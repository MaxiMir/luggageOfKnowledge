<?

###################  Bash  ###################

# Bash - стандартный командный интерпретатор линукс

pwd	// где сейчас находимся
ls	// список текущих директорий и файлов
ls projects/	// просмотр директории. Нажать tab для автокомплита названия дирекории. Опция -a, показать все файлы, включая скрытые (имена которых начинаются с точки). Опция '-l' - более подробная информация о файлах(права на файл, имя владельца, время последнего изменения файла и его размер). Опция -d' - выводить только директории. '-R' - выводит информацию о файлах находящихся в директории рекурсивно.


cd projects/  //  cd - change directory - смена директории (на projects)
cd ..  // переместиться на директорию выше
cd /  // корневая директория. все директории в системе организованы в древовидную структуру и '/' это её начало (или корень)
cd // домашняя директория. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/
cd ~/projects/  // '~' - домашняя директория
cd ~/ + 2 раза Tab	// все директории и файлы внутри текущего места 


// Если быть до конца точными, то философия *nix систем это "все есть файл". То есть папка это тоже файл, а так же файлом является любое устройство. Выражается это на программном уровне в том, что мы можем работать с любой сущностью как с файлом. То есть писать в нее или читать через унифицированный интерфейс, read и write.


// Абсолютные пути:
/dev
/usr/bin

// Относительные пути:
local/bin
../share




#  Управление файловой структурой

cp readme Desktop/	// создается копия файла на рабочем столе
cp /home/irina/tux.png /mnt/D/pingvin.png // копируется файл из домашнего каталога пользователя irina в каталог D, используются абсолютные адреса, имя копии изменяется.


mkdir test 	// создание директории test
mkdir tic tac toe // создание нескольких директорий
mkdir -p test2/test3 	// рекурсивное создание директорий
touch file1 	// создание файла


rm file1	// удаление файла
rm -r test 	// удаление директории
/test3$ rm -r *		// удаление содержимого в директории test3
rm -r test3/* 	// удаление содержимого в директории test3 */
rm -rf 	/ // опасная компанда, удяляет все не спрашивая. Здесь удалить всю


tree test // показывает внутреннюю структуру директории
// Программа tree из видео по умолчанию отсутствует в большинстве операционных систем. Ее необходимо устанавливать отдельно.


mv test test3	// переименование директории test в test3
mv test2/* test3	// перемещение файлов test2 в test3 */

./myprog	// рабочая директория ".",  используется для запуска исполняемых файлов (здесь myprog), находящихся в текущей директории.


// Каждый объект файловой системы (файл, директория...) имеет свой уникальный номер, называемый инодом (inode number)

/*
Создайте следующую файловую структуру внутри папки fs:

fs
├── example1
│   ├── file
│   └── subexample
│       ├── file
│       └── folder
|           └── another_file
└── example2
    └── another_file

Подсказка

    В названии файлов всегда присутствует слово file, все остальное — это директории.
*/

mkdir -p fs/example1/subexample/folder 
mkdir -p fs/example2

cd fs/example1/
touch file

cd subexample/
touch file

cd folder/
touch another_file

cd ~/
cd fs/example2/
touch another_file



# Просмотр содержимого файлов

cat system.log 	// вывести содержимое файла
head system.log 	// вывести первые 10 строк
tail system.log 	// вывести последние 10 строк
tail -f system.log  // описание ниже. Ctrl+C - выход 

/*
По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:

    -c — выводить указанное количество байт с конца файла;
    -f — обновлять информацию по мере появления новых строк в файле;
    -n — выводить указанное количество строк из конца файла;
    —pid — используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
    -q — не выводить имена файлов;
    —retry — повторять попытки открыть файл, если он недоступен;
    -v — выводить подробную информацию о файле;

В качестве значения параметра -c можно использовать число с приставкой b, kB, K, MB, M, GB, G T, P, E, Z, Y. Еще есть одно замечание по поводу имен файлов. По умолчанию утилита не отслеживает изменение имен, но вы можете указать что нужно отслеживать файл по дескриптору, подробнее в примерах.
*/
tail /var/log/syslog /var/log/Xorg.0.log // открыть несколько файлов одновременно

grep 'Apr 27'	// поиск файлов или строки в файле по шаблону



# Пейджеры

// программа, используемая для просмотра (но не изменения) содержимого текстовых файлов двигаясь вниз файла на одну строку или экран за раз. 

less system.log //
q // выход
h // справка

ctrl+f // следующее окно
ctrl+w // предыдущее окно

shift+g // переместиться в конец файла
g // переместиться в вверх файла

/kernel	// поиск по слову. Перемещение ctrl+f и ctrl+w
more system.log // альтернатива less, но менее функциональная



# Документация

man man
man mkdir // =>
// MKDIR(1) BSD General Commands Manual 		
// где (1) - категория, 1 категория - програмные оболочки, 2 - системные вызовы 
// ...

man -f mkdir // поиск упоминания mkdir во всех категориях
man 2 mkdir // поиск упоминания mkdir в категории 2



#  Переменные окружения

which ls /* где лежит запускаемая программа. ls не встроенная в bash программа =>
/bin/ls
*/

VAR=3
echo $VAR // распечатка переменной => 3

env /* просмотр переменных окружения в текущей сессии =>
USER=max 	// текущий пользователь
...
PWD=/var/tmp 	// текущая директория
...
HOME=/Users/max 	// домашняя директория пользователя
...
PATH 	// список директорий, в которых ищется исполняемый файл
*/

./printer 	// запуск скрипта => MYVAR:

cat printer // вывод содержимого скрипта => echo "MYVAR: $MYVAR"

MYVAR=5 // переменная будет доступна только в рамках текущей сессии. При запуске программы запускается другая сесиия она не будет там доступна.

./printer 	// запуск скрипта, ничего не измениться => MYVAR:

//	НО! При этом:

echo $MYVAR 	// => 5

MYVAR=3 ./printer // так переменная будет доступна внутри программы => MYVAR: 3

export MYVAR=10 // так переменная будет доступна для всех программ. Переменная так же будет в списке при запуске 'env'

./printer // => => MYVAR: 10


cd ..
PATH=/var/tmp:$PATH
printer // => 10

unset PATH // удаление переменной
mkdir // => mkdir: No such file or directory
ls // => mkdir: No such file or directory

MyVar MYVAR // переменные регистрозависимые



#  Перенаправления и Потоки

// STDOUT - стандартный поток вывода
ls > output	// выводим поток не на экран а записываем в файл
cat outout // распечатываем outout => ...

{
  echo 'записывается первая строчка'
  echo 'записывается вторая строчка'
  echo 'записывается третья строчка'
} > file.txt

cat unsorted /* =>
Pumpkin
Melo
Orange
Pumpkin
*/

sort < unsorted /* STDIN => сортируем и выводим содержимое unsorted
Melo
Orange
Pumpkin
Pumpkin
*/

sort < unsorted > sorted 	// STDIN => сортируем и выводим содержимое unsorted и записываем в sorted 



cat unsorted | sort | uniq	/* Конвейер - перенаправляет STDOUT одного процесса в STDIN другого + позволяет строить цепочки из программ
Melo
Orange
Pumpkin
*/

ls | grep test  /* 
test.rb
test.rkt
*/

ls | grep test | grep rkt /*
test.rkt
*/

ls | wc 	// Количество строк, слов и букв в выводе команды => 23	23 283

/*
Выведите на экран количество уникальных животных, в названии которых присутствует подстрока American. Список животных лежит в файле source.

Запишите получившуюся команду в файл solution.sh.

Подсказки:
 * Для подсчета количества строк используйте wc -l.
 * uniq убирает дубли только если они идут подряд, а не в разброс. Чтобы этого добиться, можно использовать sort.
*/

cat source | grep American | sort | uniq | wc -l


#  История

cat ~/.bach_history	// история команд
history // выводит всю историю
!525 // выполнение команды под номером 525
!! // запуск последней запущенной команды
!cat // выполниться команда из истории начинающаяся на cat 'cat system.info'
ctrl+r history // инкрементальный поиск по всей истории. Листать повторное нажатие ctrl+r


# Псевдонимы

alias	/*  выводит список алиасов установленных в системе =>
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias l='ls -CF'
*/

alias ll='ls -alF' // установка алиаса
ll 	// запуск
unalias ll 	// удаление алиаса
type l 	// описание алиаса => l is aliased to `ls -CF`


/*
В этом задании вам необходимо создать псевдоним с именем mkdir для команды mkdir -p
Добавьте команду создания этого псевдонима в файл solution.sh (влкадка solution.sh в окне онлайн-редактора)
*/
alias mkdir="mkdir -p"




