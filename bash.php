<?

###################  Bash  ###################

/*
Bash - стандартный командный интерпретатор линукс
GUI (графический интерфейс)
CLI (интерфейс командной строки)

В Windows и MacOS имя файла может быть набрано в разных регистрах, и это всегда один и тот же файл, то есть имена регистронезависимы. В *nix системах регистр имеет значение. 

В *nix системах отсутствует понятие "расширение файла". Точка — полноправная часть имени, а все файлы и директории, начинающиеся с точки, считаются скрытыми.

Кроме регулярных файлов, в *nix существует ряд других:
 * Hard Link — дополнительное имя для уже существующего файла.
 * Symbolic link — символическая ссылка, такой файл похож на ярлык в Windows. Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
 * Socket — специальный файл через который происходит взаимодействие между разными процессами операционной системы. Программисты постоянно сталкиваются с сокетами в реальной жизни.
*/

pwd	// print working directory - текущая директория
ls	// список текущих директорий и файлов
ls -l projects	/* просмотр определенной директории. Нажать tab для автокомплита названия дирекории. 
  Опция -a - показать все файлы, включая скрытые (имена которых начинаются с точки).
  Опция -l - более подробная информация о файлах(права на файл, имя владельца, время последнего изменения файла и его размер).
  Опция -d - выводить только директории. 
  Опция -R - выводит информацию о файлах находящихся в директории рекурсивно.
  Опция -i может использоваться для отображения числа инодов для объектов в списке файловой системы =>
  Опции можно комбинировать ls -a -l <-> ls -al <-> ls -la.	
/*
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
*/

ls -dl /usr /usr/bin /usr/X11R6/bin ../share // => посмотреть директорию -dl =>
/*
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
*/

// Каждый объект файловой системы (файл, директория...) имеет свой уникальный номер, называемый инодом (inode number)
ls -id /usr/local // у директории /usr/local номер инода равен 5120 => 5120 /usr/local 

ls -id /usr/local/bin/.. //  директория /usr/local/bin/.. имеет такой же номер, как у /usr/local. Директория — это инод с номером 5120, и мы нашли, по меньшей мере, два элемента (называемых «жесткими ссылками»), которые указывают на данный инод. И /usr/local, и /usr/local/bin/.. — ссылки на 5120-ый инод. Хотя этот инод и существует только в одном месте на диске, тем не менее на него может быть множество ссылок. => // 5120 /usr/local/bin/..

ls -dl /usr/local /* увидеть общее количество ссылок ведущих на 5120 инод => drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local

В моей системе на этот инод ведут следующие пути:

/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
*/

// Новые жесткие ссылки можно создать воспользовавшись командой ln:

cd /tmp
touch firstlink
ln firstlink secondlink
ls -i firstlink secondlink // =>  15782 firstlink    15782 secondlink


// Симлинки — это файлы особого типа, которые ссылаются на другие файлы по имени, а не прямо по номеру инода. Они не спасают файлы от удаления; если файл, на который указывает ссылка, исчезает, то симлинк перестает работать, ломается. Символические ссылки можно создать передав для ln опцию -s.

ln -s secondlink thirdlink
ls -l firstlink secondlink thirdlink // =>
/*
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink
*/

// В выводе ls -l символьные ссылки можно отличить тремя способами. Во-первых, обратите внимание на символ l в первой колонке. Во-вторых, размер символической ссылки равен количеству символов в ней (secondlink в нашем случае). В-третьих, последняя колонка в выводе показывает куда ведет ссылка с помощью интуитивного обозначения "->".


// Символические ссылки в целом более гибкие, чем жесткие. Вы можете создавать символьные ссылки на любой объект файловой системы, включая директории. И благодаря тому, что их реализация основана на путях (не инодах), можно совершенно свободно создать символьную ссылку указывающую на объект другой файловой системы. Однако, сей факт также делает их сложными в понимании. Предположим, что мы хотим создать ссылку в /tmp, которая указывает на /usr/local/bin. Нам следует набрать:

ln -s /usr/local/bin bin1
ls -l bin1 // => lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin

// Либо, альтернативный вариант:

ln -s ../usr/local/bin bin2
ls -l bin2 // => lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin


// Как вы видите, обе символические ссылки указывают на одну директорию. Однако, если наша вторая символьная ссылка когда-нибудь будет перемещена в другую директорию, то она может «поломаться» из-за относительности пути:

ls -l bin2 // => lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin

mkdir mynewdir
mv bin2 mynewdir
cd mynewdir
cd bin2 // =>  bash: cd: bin2: No such file or directory

// Потому, что директории /tmp/usr/local/bin не существует, мы больше не можем переместиться в bin2; другими словами, bin2 сейчас сломана. По этой причине, избегать создания ссылок с относительной информацией о пути, иногда будет хорошей идеей. Тем не менее, существует множество случаев, где относительные символические ссылки крайне удобны. Рассмотрим пример в котором мы хотим создать альтернативное имя для программы в /usr/bin:

ls -l /usr/bin/keychain // => l-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain

// От имени суперпользователя мы хотим короткий синоним для keychain, такой, как kc. В этом примере у нас есть root-доступ, о чем свидетельствует измененное на "#" приветствие bash. Нам нужен root-доступ потому, что обычные пользователи не имеют прав создавать файлы в /usr/bin. От имени суперпользователя мы можем создать альтернативное имя для keychain следующим образом:

cd /usr/bin
ln -s /usr/bin/keychain kc
ls -l keychain // => -rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain

ls -l kc // => -kclrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain

// В этом примере мы создали символьную ссылку под названием kc, которая указывает на файл /usr/bin/keychain. Пока это решение будет работать, но создаст проблему, если мы решим переместить оба файла, /usr/bin/keychain и /usr/bin/kc в /usr/local/bin:


mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
ls -l /usr/local/bin/keychain // => -rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain

ls -l /usr/local/bin/kc // => lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain


// Поскольку мы использовали абсолютный путь для символической ссылки kc, то она все еще ссылается на /usr/bin/keychain, которого не существует с тех пор как мы переместили /usr/bin/keychain в /usr/local/bin. Это привело к тому, что симлинк kc сейчас не работает. Как относительные, так и абсолютные пути в символьных ссылках имеют свои достоинства, и, в зависимости от вашей задачи, нужно использовать соответствующий тип пути. Часто, и относительный, и абсолютный путь, будут работать одинаково хорошо. Пример ниже будет работать, даже после перемещения обоих файлов:


cd /usr/bin
ln -s keychain kc
ls -l kc // => lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain


mv keychain kc /usr/local/bin
ls -l /usr/local/bin/keychain // => -rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain

ls -l /usr/local/bin/kc // => lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain


// Теперь, мы можем запустить программу keychain набрав /usr/local/bin/kc. /usr/local/bin/kc указывает на программу keychain в той же директории, где находится kc.

cd projects/  //  cd - change directory - смена директории (на projects)
cd // без аргументов перебрасывает в домашную директорию текущего пользователя
cd ..  // переместиться на директорию выше
cd /  // корневая директория. все директории в системе организованы в древовидную структуру и '/' это её начало (или корень)
cd // домашняя директория. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/
cd ~/myfile.txt  // '~' - сокращенная запись домашней директории <-> /home/maxim/myfile.txt
cd ~/ + 2 раза Tab	// все директории и файлы внутри текущего места 
./myprog ~fred/fredsfile.txt // сослаться на файл под названием fredsfile.txt в домашней директории пользователя fred


// Если быть до конца точными, то философия *nix систем это "все есть файл". То есть папка это тоже файл, а так же файлом является любое устройство. Выражается это на программном уровне в том, что мы можем работать с любой сущностью как с файлом. То есть писать в нее или читать через унифицированный интерфейс, read и write.


// Абсолютные пути:
/dev
/usr/bin

// Относительные пути:
local/bin
../share

/**
В директории /opt создано множество директорий и поддиректорий. И только в одной из них лежит файл (в остальных директориях либо пусто либо другие каталоги). Вам необходимо найти этот файл и записать его имя в файл solution.
Подсказки
В файл — в отличие от директории — нельзя войти.
**/

find /opt -type f



/**
У программы ls есть флаг, который сортирует вывод по размеру файлов. Найдите название этого флага в документации и выполните команду, которая делает подробный (-l) вывод файлов в директории /var, отсортированный по размеру.

Примечания
Добавьте к команде ls опцию --time-style со значением 'long-iso'. Это позволит выводить время в полном унифицированном формате: "год-месяц-день часы:минуты". Например, 2018-08-21 21:12.
**/
ls -lS --time-style='long-iso' /var


>>>>>  Управление файловой структурой <<<<<<<

cp readme Desktop/	// создается копия файла на рабочем столе
cp /home/irina/tux.png /mnt/D/pingvin.png // копируется файл из домашнего каталога пользователя irina в каталог D, используются абсолютные адреса, имя копии изменяется.


mkdir test 	// создание директории test
mkdir tic tac toe // создание нескольких директорий
mkdir -p test2/test3 	// рекурсивное создание директорий
touch file1 	// обновляет «mtime» (время последней модификации) файла, если тот существует. Если файл не существует, то новый, пустой файл будет создан.

rm file1	// удаление файла
rm -i file1 file2 // удаление файла в интерактивном режиме
rm -r test 	// удаление директории
/test3$ rm -r *		// удаление содержимого в директории test3
rm -r test3/* 	// удаление содержимого в директории test3 */
rm -rf mydir // опасная компанда, удяляет все не спрашивая. Здесь удалить указанную директорию,а также и объекты содержащиеся внутри


tree test // показывает внутреннюю структуру директории
// Программа tree из видео по умолчанию отсутствует в большинстве операционных систем. Ее необходимо устанавливать отдельно.


mv test test3	// переименование директории test в test3
mv test2/* test3	// перемещение файлов test2 в test3 */
mv /var/tmp/myfile1.txt /var/tmp/myarticle3.txt /home/drobbins // перемещение нескольких файлов
./myprog	// рабочая директория ".",  используется для запуска исполняемых файлов (здесь myprog), находящихся в текущей директории.


/**
Создайте следующую файловую структуру внутри папки fs:

fs
├── example1
│   ├── file
│   └── subexample
│       ├── file
│       └── folder
|           └── another_file
└── example2
    └── another_file

Подсказка

    В названии файлов всегда присутствует слово file, все остальное — это директории.
**/

mkdir -p fs/example1/subexample/folder 
mkdir -p fs/example2

touch fs/example1/file
touch fs/example1/subexample/file
touch fs/example1/subexample/folder/another_file
touch fs/example2/another_file


// информация о любом файле или директории:
stat .bashrc /* =>
File: '.bashrc'
Size: 3771        Blocks: 8          IO Block: 4096   regular file
Device: ca01h/51713d    Inode: 259234      Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1002/kirill.m)   Gid: ( 1002/kirill.m)
Access: 2018-08-27 17:24:11.237498138 +0000
Modify: 2015-08-31 23:27:45.000000000 +0000
Change: 2018-01-22 08:13:27.611966864 +0000
Birth: 
*/



>>>>>  Просмотр содержимого файлов <<<<<<< 

cat system.log 	// вывести содержимое файла
head system.log 	// вывести первые 10 строк
tail system.log 	// вывести последние 10 строк
tail -f system.log  // описание ниже. Ctrl+C - выход 
/*
По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:

    -c — выводить указанное количество байт с конца файла;
    -f — обновлять информацию по мере появления новых строк в файле;
    -n — выводить указанное количество строк из конца файла;
    —pid — используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
    -q — не выводить имена файлов;
    —retry — повторять попытки открыть файл, если он недоступен;
    -v — выводить подробную информацию о файле;

В качестве значения параметра -c можно использовать число с приставкой b, kB, K, MB, M, GB, G T, P, E, Z, Y. Еще есть одно замечание по поводу имен файлов. По умолчанию утилита не отслеживает изменение имен, но вы можете указать что нужно отслеживать файл по дескриптору, подробнее в примерах.
*/
tail /var/log/syslog /var/log/Xorg.0.log // открыть несколько файлов одновременно

grep 'Apr 27'	// поиск файлов или строки в файле по шаблону



>>>>>  Пейджеры <<<<<<<  

// программа, используемая для просмотра (но не изменения) содержимого текстовых файлов двигаясь вниз файла на одну строку или экран за раз. 

less system.log //
q // выход
h // справка

ctrl+f // следующее окно
ctrl+w // предыдущее окно

shift+g // переместиться в конец файла
g // переместиться в вверх файла

/kernel	// поиск текста. Перемещение ctrl+f и ctrl+w
more system.log // альтернатива less, но менее функциональная



>>>>>  Документация <<<<<<<

man man
man mkdir // =>
// MKDIR(1) BSD General Commands Manual 		
// где (1) - категория, 1 категория - програмные оболочки, 2 - системные вызовы 
// ...

man -f mkdir // поиск упоминания mkdir во всех категориях
man 2 mkdir // поиск упоминания mkdir в категории 2

// q - выход из режима просмотра, просмотр вперёд f (forward), назад — b (backward).



>>>>>  Переменные окружения <<<<<<<  

which ls // где лежит запускаемая программа. ls не встроенная в bash программа => /bin/ls 

VAR=3
echo $VAR // распечатка переменной => 3
echo "firstfile" > copyme; // записывать вывод echo в файл по имени copyme. Этот файл будет создан, если не существовал, или перезаписан, если существует. 

env /* просмотр переменных окружения в текущей сессии =>
USER=max 	// текущий пользователь
...
PWD=/var/tmp 	// текущая директория
...
HOME=/Users/max 	// домашняя директория пользователя
...
PATH 	// список директорий, в которых ищется исполняемый файл
*/

./printer 	// запуск скрипта => MYVAR:

cat printer // вывод содержимого скрипта => echo "MYVAR: $MYVAR"

MYVAR=5 // переменная будет доступна только в рамках текущей сессии. При запуске программы запускается другая сесиия она не будет там доступна.

./printer 	// запуск скрипта, ничего не измениться => MYVAR:

//	НО! При этом:

echo $MYVAR 	// => 5

MYVAR=3 ./printer // так переменная будет доступна внутри программы => MYVAR: 3

export MYVAR=10 // так переменная будет доступна для всех программ. Переменная так же будет в списке при запуске 'env'

./printer // => => MYVAR: 10


cd ..
PATH=/var/tmp:$PATH
printer // => 10

unset PATH // удаление переменной
mkdir // => mkdir: No such file or directory
ls // => mkdir: No such file or directory

MyVar MYVAR // переменные регистрозависимые


>>>>>  Перенаправления и Потоки <<<<<<<   

// STDOUT - стандартный поток вывода
ls > output	// выводим поток не на экран а записываем в файл
cat outout // распечатываем outout => ...

{
  echo 'записывается первая строчка'
  echo 'записывается вторая строчка'
  echo 'записывается третья строчка'
} > file.txt

cat unsorted /* =>
Pumpkin
Melo
Orange
Pumpkin
*/

sort < unsorted /* STDIN => сортируем и выводим содержимое unsorted
Melo
Orange
Pumpkin
Pumpkin
*/

sort < unsorted > sorted 	// STDIN => сортируем и выводим содержимое unsorted и записываем в sorted 

sort <<END // Bash и другие шелы поддерживают концепцию «herefile»
apple
cranberry
banana
END
// =>
/*
apple
banana
cranberry
*/

echo there. >> myfile // в отличие от > не перезаписывает, а добавляет вывод в файл



cat unsorted | sort | uniq	/* Конвейер (pipeline) - перенаправляет STDOUT одного процесса в STDIN другого + позволяет строить цепочки из программ
Melo
Orange
Pumpkin
*/

ls | grep test  /* 
test.rb
test.rkt
*/

ls | grep test | grep rkt /*
test.rkt
*/

ls | wc 	// Количество строк, слов и букв в выводе команды => 23	23 283

cd lala 2&> output // перенаправление STDERR в STDOUT (STDERR остался привязан к экрану, а внутри файла output — пустота). К >, слева добавилось 2&. 2 - в данном случае обозначает номер потока. В POSIX, за каждым потоком закреплен определенный номер, который является файловым дескриптором если быть точным: STDIN - 0, STDOUT - 1, STDERR - 2.


/**
Выведите на экран количество уникальных животных, в названии которых присутствует подстрока American. Список животных лежит в файле source.

Запишите получившуюся команду в файл solution.sh.

Подсказки:
 * Для подсчета количества строк используйте wc -l.
 * uniq убирает дубли только если они идут подряд, а не в разброс. Чтобы этого добиться, можно использовать sort.
**/

cat source | grep American | sort | uniq | wc -l



/**
Посредством конвейера отсортируйте содержимое файла languages, выберите две первых строчки и запишите их в файл solution.
**/

cat languages | sort | sed -n '1p;2p' > solution



>>>>>  История <<<<<<<  

cat ~/.bach_history	// история команд
history // выводит всю историю
!525 // выполнение команды под номером 525
!! // запуск последней запущенной команды
!cat // выполниться команда из истории начинающаяся на cat 'cat system.info'
ctrl+r history // инкрементальный поиск по всей истории. Листать повторное нажатие ctrl+r



>>>>>  Псевдонимы <<<<<<< 

alias	/*  выводит список алиасов установленных в системе =>
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias l='ls -CF'
*/

alias ll='ls -alF' // установка алиаса
ll 	// запуск
unalias ll 	// удаление алиаса
type l 	// описание алиаса => l is aliased to `ls -CF`


/** В этом задании вам необходимо создать псевдоним с именем mkdir для команды mkdir -p **/
alias mkdir="mkdir -p"



>>>>>  Использование джокеров <<<<<<<

// примеры использования шаблона «дикой конкатенации»:
rm file[1-8] // <=> $ rm file1 file2 file3 file4 file5 file6 file7 file8
rm file* // удалить все файлы с именами начинающимися с file, включая сам файл по имени file
ls -d /etc/g*1 // перечислить все объекты файловой системы в /etc, начинающиеся с «g», и заканчивающиеся на «1»

/*
 * — совпадает с нулевым или большим количеством символов. Это значит: «тут может быть все что угодно, включая и ничего»
 ? — равен любому одному символу. Примеры: myfile? совпадает с любым файлом, чье имя составляет myfile и следующим за этим какой-либо один символ;
*/

// Синтаксис джокера: []


// Этот джокер похож на ?, но более точен. Чтобы его использовать, поместите любые символы, какие вам нужны, внутрь []. Полученное выражение будет удовлетворять любому одному из этих символов. Вы также можете воспользоваться "-", для указания диапазона, и даже комбинации диапазонов. Примеры:

myfile[12] // совпадет с myfile1 и myfile2. Джокер сработает если хотя бы один из этих файлов существует в текущей директории;
   
// [Cc]hange[Ll]og совпадет с Changelog, ChangeLog, changeLog и changelog. Как можете заметить, использование скобочных джокеров очень удобно для указания вариантов с заглавными буквами;

ls /etc/[0-9]* // покажет все файлы в /etc, начинающиеся с десятичной цифры;
ls /tmp/[A-Za-z]* // отобразит все файлы в /tmp, которые начинаются с большой или маленькой латинской буквы.

// Конструкция [!] эквивалентна конструкции [], за исключением того, что вместо совпадения с символами внутри скобок, она удовлетворяет любому символу, который НЕ перечислен между [! и ]. Пример:

rm myfile[!9] // удалит все файлы с названием myfile плюс один символ, кроме myfile9.

echo '[fo]*' > /tmp/mynewfile.txt // записать "[fo]*" в mynewfile
echo \[fo\]\* > /tmp/mynewfile.txt // альтернативный вариант

# Регулярные выражения
grep aliases .bashrc // Поиск всех строк в файле .bashrc, в которых встречается слово aliases

/*
Найденные строчки выводятся на экран в том же порядке, в котором они встречаются в исходном файле. В некоторых ситуациях бывает важно увидеть не только саму строку, содержащую подстроку, но и то, что находится вокруг неё. Количество выводимых соседних строк регулируется опциями -B, -A и -C. Первая определяет количество отображаемых строк до искомой (-B, --before-context), вторая — после (-A, --after-context), а третья — до и после одновременно (C, --context).
*/
grep -C 1 aliases .bashrc

/*
Иногда мы не знаем, в каком файле то, что мы ищем, но знаем директорию, в которой лежит этот файл. В такой ситуации нужно сделать два изменения:

Добавить опцию -R, которая говорит о том, что надо искать внутри директории (рекурсивно, то есть включая все поддиректории).
Указать путь до директории, а не файла.
*/
grep -R bashrc . // Если добавить опцию n (-Rn), то дополнительно отобразится номер строки.

grep bash /etc/passwd // «grep» сканирует содержимое файла согласно заданному регулярному выражению и выводит каждую строчку, которая совпадает с регулярным выражением, игнорируя остальные =>
/*
operator:x:11:0:operator:/root:/bin/bash
root:x:0:0::/root:/bin/bash
ftp:x:40:1::/home/ftp:/bin/bash 

/tmp (поиск строки /tmp)
"\[box\]" (поиск строки [box])
"\*funny\*" (поиск строки *funny*)
«ld\.so» (поиск строки ld.so)
*/

grep dev.sda /etc/fstab // метасимвол "." - совпадает с любым единичным символом => /dev/sda2       swap            swap            sw 0 0

grep dev.sda[12] /etc/fstab //  указать подмножество символов для сопоставления => /dev/sda2       swap            swap            sw 0 0

grep dev.hda[^12] /etc/fstab // соответствуют любому символу который НЕ перечислен внутри [] => /dev/hda3       /               reiserfs        noatime,ro 1 1

grep dev[.]sda /etc/fstab // совпадение с "."  <=> grep "dev\.sda" /etc/fstab 


/*
ab*c совпадает с «abbbbc», но не с «abqc» (в случае glob-подстановки, обе строчки будут удовлетворять шаблону.)
ab*c совпадает с «abc», но не с «abbqbbc» (при glob-подстановке, шаблон сопоставим с обоими строчками)
ab*c совпадает с «ac», но не с «cba» (в случае глоббинга, ни «ac», ни «cba» не удовлетворяют шаблону)
b[cq]*e совпадает с «bqe» и с «be» (glob-подстановке удовлетворяет «bqe», но не «be»)
b[cq]*e совпадает с «bccqqe», но не с «bccc» (при глоббинге шаблон точно так же совпадет с первым, но не со вторым)
b[cq]*e совпадает с «bqqcce», но не с «cqe» (так же и при glob-подстановке)
b[cq]*e удовлетворяет «bbbeee» (но не в случае глоббинга)
.* сопоставим с любой строкой (glob-подстановке удовлетворяют только строки начинающиеся с ".")
foo.* совпадет с любой подстрокой начинающийся с «foo» (в случае glob-подстановки этот шаблон будет совпадать со строками, начинающимися с четырех символов «foo.»)

Итак, повторим для закрепления: строчка «ac» подходит под регулярное выражение «ab*c» потому, что звездочка также позволяет повторение предшествующего выражения (b) ноль раз. И опять, ценно отметить для себя, что метасимвол * в регулярках интерпретируется совершенно иначе, нежели символ * в glob-подстновках.
*/

grep ^# /etc/fstab // ^ в начале «прикрепляет» ваш шаблон к началу строки => # /etc/fstab: static file system information.
 grep '^#.*\.$' /etc/fstab // => регулярка будет соответсвовать строкам начинающимся с символа #, а заканчивающимся символом "." => # /etc/fstab: static file system information.

/*
FHS определяет следующее дерево директорий (взято непосредственно из спецификации):

    / (корневая директория)
    /boot (статичные файлы загрузчика)
    /dev (файлы устройств)
    /etc (специфические для хоста конфигурационные файлы)
    /lib (основные разделяемые библиотеки и модули ядра)
    /mnt (точка монтирования для временных нужд)
    /opt (дополнительные пакеты ПО)
    /sbin (основные системные программы)
    /tmp (временные файлы)
    /usr (вторичная иерархия)
    /var (изменяемые данные)

Разделяемые данные могут распределятся на несколько хостов; неразделяемые специфичны для конкретного хоста (как, например, конфигурационные файлы). Изменяемые данные могут изменяться; статичные не изменяются (за исключением установки и обслуживания системы).

+------------+-----------------+---------------+
|            | разделяемые     | неразделяемые |
+------------+-----------------+---------------+
| статичные  | /usr            | /etc          |
|            | /opt            | /boot         |
+------------+-----------------+---------------+
| изменяемые | /var/mail       | /var/run      |
|            | /var/spool/news | /var/lock     |
+------------+-----------------+---------------+
*/



>>>>>  PATH <<<<<<< 

/*
Когда вы запускаете программу из командной строки, bash начинает просматривать список директорий в поисках программы которую вы указали. Например, когда вы вводите ls, bash в действительности не знает, что программа ls находится в /usr/bin. Вместо этого, он ссылается на переменную окружения называемую PATH, которая содержит список директорий разделенных двоеточием. Мы можем проверить значение PATH:
*/
echo $PATH // => /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin.

// С таким значением PATH (у вас оно может быть другим) bash сначала проверит директорию /usr/local/bin, затем /usr/bin в поисках программы ls. Скорее всего, ls находится в /usr/bin, тогда на этой директории bash прекратит поиск.


# Изменение PATH

// Вы можете расширять переменную PATH, присваивая ей новое значение в командой строке:

PATH=$PATH:~/bin
echo $PATH // => /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin:/home/agriffis/bin

// Вы также можете удалять элементы из PATH, хотя это не так просто, поскольку вы не можете ссылаться в команде на существующий $PATH. Лучший вариант — это просто заново указать в PATH то, что вам нужно:

PATH=/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:~/bin
echo $PATH // => /usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/agriffis/bin

// Чтобы сделать ваши изменения PATH доступными для процессов, которые будут запускаться в командной оболочке, необходимо «экспортировать» их используя команду export:

export PATH


# О команде «which»

which ls // проверить, есть ли конкретная программа в PATH => /usr/bin/ls
which -a ls // показать все экземпляры программы в PATH => /usr/bin/ls    /bin/ls
whereis ls // показать более подробную информацию о программе => ls: /bin/ls /usr/bin/ls /usr/share/man/man1/ls.1.gz      <- полследнее документация для man ls



>>>>>  find <<<<<<< 
# Wiki: https://ru.wikipedia.org/wiki/Find

// Используя find вы не ограничены лишь поиском программ; вы можете искать любые типы файлов, используя различные критерии поиска. 

find /usr/share/doc -name README // ищем в директории /usr/share/doc, файл README: =>
/*
/usr/share/doc/ion-20010523/README
/usr/share/doc/bind-9.1.3-r6/dhcp-dynamic-dns-examples/README
/usr/share/doc/sane-1.0.5/README


Можно использовать glob-шаблоны для аргументов -name, при условии что вы экранируете их кавычками или обратным слешем (таким образом они будут переданы команде в нетронутом виде, иначе они сначала будут развернуты bash'ем и уже после переданы команде)
*/

find /usr/share/doc -name README\* // ищем все файлы README с расширением =>
/*
/usr/share/doc/iproute2-2.4.7/README.gz
/usr/share/doc/iproute2-2.4.7/README.iproute2+tc.gz
/usr/share/doc/iproute2-2.4.7/README.decnet.gz
*/

find /usr/share/doc -iname readme\* //  поиска без учета регистра



# find и регулярные выражения

find /etc -iregex '.*xt.*' // игнорировать регистр в шаблоне. find требует чтобы регулярное выражение указывалось для всего пути, а не только его части. По этой причине, стоит в начале и конце шаблона ставить .*; простого использования xt в качестве шаблона будет недостаточно. =>
/*
/etc/X11/xkb/types/extra
/etc/X11/xkb/semantics/xtest
/etc/X11/xkb/compat/xtest/etc/X11/xkb/types/extra
/etc/X11/xkb/semantics/xtest
/etc/X11/xkb/compat/xtest
*/



# find и типы файлов

// Опция -type позволяет искать в файловой системе файлы определенного типа. Возможные аргументы для -type это: b (блочное устройство), c (символьное устройство), d (директория), p (именованый канал), f (обычный файл), l (символическая ссылка), и s (сокет). Например, поиск символической ссылки в /usr/bin, которая содержит в своем имени строку vim:

find /usr/bin -name '*vim*' -type l // =>
/*
/usr/bin/rvim
/usr/bin/vimdiff
*/


# find и mtimes

// Опция -mtime позволяет вам искать файлы основываясь на дате их последней модификации. Аргументом mtime является количество 24-часовых периодов, и наиболее полезным будет указывать перед аргументом плюс (означает «после») или минус (означает «перед»). Например, рассмотрим следующий сценарий:


ls -l ?
/*
-rw-------    1 root     root            0 Jan  7 18:00 a
-rw-------    1 root     root            0 Jan  6 18:00 b
-rw-------    1 root     root            0 Jan  5 18:00 c
-rw-------    1 root     root            0 Jan  4 18:00 d
*/

date // => Tue Jan 7 18:14:52 EST 2003

// Вы можете найти файлы, которые были модифицированы за последние 24 часа:

find . -name \? -mtime -1 // => ./a

// Или файлы которые были изменены до текущего 24-часового периода:

find . -name \? -mtime +0 // =>
/*
./b
./c
./d
*/


# Опция -size
/*
Опция -size позваляет искать файлы по их размеру. По-умолчанию, аргумент -size это количество 512-байтных блоков, но добавляя к опции суффикс, можно сделать вывод более понятным. Доступные суффиксы: b (512-байтные блоки), c (байт), k (килобайт), и w (2-байтные слова). Дополнительно, перед аргументом можно указать плюс («больше чем») или минус («меньше чем»).

Например, для поиска обычного файла в /usr/bin размер которого меньше 50 байт:
*/

find /usr/bin -type f -size -50c


>>>>>  Работа с найдеными файлами <<<<<<< 

// find может производить любые действия над файлами используя опцию -exec. Эта опция принимает строку команд для выполнения, которая оканчивается на ;, и заменяет все вхождения {} именем файла. Это проще всего понять на примере:


find /usr/bin -type f -size -50c -exec ls -l '{}' ';'
/*
-rwxr-xr-x    1 root     root           27 Oct 28 07:13 /usr/bin/krdb
-rwxr-xr-x    1 root     root           35 Nov 28 18:26 /usr/bin/run-nautilus
-rwxr-xr-x    1 root     root           25 Oct 21 17:51 /usr/bin/sgmlwhich
-rwxr-xr-x    1 root     root           26 Sep 26 08:00 /usr/bin/muttbug
*/

// Как видите, find это очень мощная команда. Она «выросла» за годы разработки UNIX и Linux. У find существует много других полезных опций. Вы можете прочитать о них в man-страничке.



>>>>>  locate <<<<<<< 

// Выполнение find может занять некоторое время, т.к. ей необходимо прочитать каждую директорию в которой выполняется поиск. Оказывается, что команда locate может ускорить процесс использую внешнюю базу данных, генерируемую updatedb.

// Команда locate ищет совпадения любой части пути, а не только самого файла. Пример:


locate bin/ls // =>
/*
/var/ftp/bin/ls
/bin/ls
/sbin/lsmod
/sbin/lspci
/usr/bin/lsattr
/usr/bin/lspgpot
/usr/sbin/lsof
*/


locate netscape // найти файл с именем "netscape" для поиска, начиная с корневого каталога "/"


>>>>>  Использование updatedb <<<<<<<  

// Во многих Linux системах есть «cron job» для периодического обновления базы. В случае если вызов locate вернул нижеописанную ошибку, вам необходимо запустить updatedb от root'а для генерации поисковой базы:

locate bin/ls // => locate: /var/spool/locate/locatedb: No such file or directory
su -

Password:
# updatedb

// Работа программы updatedb может занять некоторое время. Если у вас шумный жесткий диск, вы услышите как он шуршит индексируя файловую систему. :)


slocate

// Во многих Linux дистрибутивах, утилита locate была заменена на slocate. Как правило существует также ссылка на locate, так что вам не нужно запоминать, что именно имеется в системе. slocate означает «безопасный locate» (от англ. secure locate — прим. пер.). Он сохраняет информацию о правах доступа в поисковой базе, так что, обычные пользователи не смогут увидеть директории, которые они и так не смогли бы видеть. Используется slocate точно также как locate, но вывод программы может быть различными в зависимости от пользователя ее запустившего.


https://habr.com/post/107981/ Модули ядра


>>>>>  Сделать файл исполняемым <<<<<<<  

chmod a+x my_file // выполнить как администратор или собственник этого файла. Сделает файл "my_file" исполняемым для всех пользователей.
// Заметим, что в Linux (или UNIX) не существует расширений файлов (например, .exe или .com или .bat), которое делает файл исполняемым.


>>>>>  Шебанг <<<<<<<  

/*
Шебанг  - последовательность из двух символов: решётки и восклицательного знака ("#!") в начале файла скрипта. 
Когда скрипт с шебангом выполняется как программа в Unix-подобных операционных системах, загрузчик программ рассматривает остаток строки после шебанга как имя файла программы-интерпретатора. Загрузчик запускает эту программу и передаёт ей в качестве параметра имя файла скрипта с шебангом.

  #!/bin/sh — Выполнить файл с помощью sh (Bourne shell), или другой совместимой оболочки;
  #!/bin/csh -f — Выполнить файл с помощью csh (C shell), или другой совместимой оболочки, с отключением выполнения .cshrc файла пользователя;
  #!/usr/bin/perl -T — Выполнить файл при помощи Perl в режиме Taint checking;
  #!/usr/bin/env python2 — Выполнить файл как программу на Python, используя переменную среды для получения пути к файлу интерпретатора.

Подробнее: https://ru.wikipedia.org/wiki/Шебанг_(Unix)
*/



>>>>>  Пользователи и Группы <<<<<<<
whoami // позволяет выяснить, кто же я такой
ps aux // информация какой процесс и под каким пользователем запущен

/*
# Левый столбец имя пользователя
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: kirill.m@pts/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: alexander.v@pts/1,pts/2
*/

$ ls -la // домашняя директория, .. - родительская директория, ее владельцем является root
/*
total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
-rw------- 1 kirill.m kirill.m   55 Aug 28 18:49 .lesshst
drwxrwxr-x 2 kirill.m kirill.m 4096 Aug 29 08:35 .nano
-rw-r--r-- 1 kirill.m kirill.m  655 May 16  2017 .profile
-rw-rw-r-- 1 kirill.m kirill.m    0 Aug 29 11:27 renamed-file
drwx------ 2 kirill.m kirill.m 4096 Jan 22  2018 .ssh
-rw------- 1 kirill.m kirill.m  513 Aug 29 08:06 .viminfo
*/

$ sudo -u nobody mkdir /tmp/test // Файл создан от nobody
/*
Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:
*/
$ sudo -i
$ id
uid=0(root) gid=0(root) groups=0(root)
/*
Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit. https://habr.com/post/44783/

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение. Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — тех, кто не попал в предыдущие две.

*/
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc // rw- означает, что владелец этого файла может как читать (r) этот файл, так и писать (w) в него. Последний прочерк означает, что этот файл нельзя исполнять. Запись r-- говорит о наличии доступа только для чтения, а изменение запрещено. 

/*
В литературе (статьях, книгах, мануалах) иногда используется другой способ описания прав доступа: 775. Это не одно число, а три числа, каждое из которых представляет собой группу rwx для наших типов пользователя в том же порядке: для владельца, входящих в группу и всех остальных. 0 — означает, что нет никаких прав для данного типа пользователей.

A B C D
1 # Permission  rwx Binary
2 7 read, write and execute rwx 111
3 6 read and write  rw- 110
4 5 read and execute  r-x 101
5 4 read only r-- 100
6 3 write and execute -wx 011
7 2 write only  -w- 010
8 1 execute only  --x 001
drwxr-xr-x в числовой форме соответствует 755, а -rw-r--r-- — 644.
Однако пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — рут может всё.
*/