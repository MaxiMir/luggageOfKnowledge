<?
	 
	 ####################### ORM #######################

	# >>>>>>>>>>>> Ввдедение <<<<<<<<<<< #

/**
	 В основе любой программы, лежит какая-то определенная предметная область. Например графический редактор имеет дело с геометрическими примитивами, такими как отрезки, круги или квадраты, а сервисы доставки еды занимаются логистикой.
	 
	 Предметная область включает в себя набор сущностей, которые взаимодействуют друг с другом, а так же правила их взаимодействия, называемые бизнес-логикой. Правила работающие в конкретной предметной области, никак не связаны ни с языком ни с фреймворком на которых пишется программа. Более того, они вообще не имеют никакого отношения к программированию и существуют независимо.
	 
	 Возьмем для примера Хекслет. Этот проект построенный вокруг обучения. Его предметная область включает множество сущностей, часть из которых используется в проекте. К ним относятся понятия: Профессия, Курс, Проект, Урок, Практика, Квиз. Это лишь малая часть понятий из того что реализовано. Всего на Хекслете более 300 таких сущностей. Все они подчиняются определенным бизнес-правилам, которые реализованы в коде. Например пользователь не может одновременно вступать сразу в несколько профессий и должен иметь оплаченную подписку для доступа к профессиональным курсам. Таких правил в проектах сотни и тысячи. Во многом именно они определяют сложность кода.
	 
	 Для упрощения описания предметной области и хранению ее данных в приложениях отвечают ORM. Это специализированные фреймворки, которые определяют способ создания сущностей и их связывания. Вторая большая задача этих фреймворков – обеспечивать хранение данных, создаваемых в процессе работы.
	 
	 Этот курс посвящен посвящен изучению основных концепций ORM. К ним относятся:
	 > Миграции и Схема
	 > Модели и связи
	 > Работа с формами
	 > Динамические запросы и их построение
	 > Обработка коллекций
	 > Историчность
	 > Мягкое удаление
 
	# Дополнительные материалы
	Eloquent https://laravel.com/docs/5.8/eloquent
 */
	 
	 
	 

	 # >>>>>>>>>>>> Настройка ORM <<<<<<<<<<< #
	 
/**
	Этот курс состоит из двух видов практик. Одна выполняется в редакторе Хекслета, другая на собственном компьютере. Для работы последней, нужно настроить Composer и подключить ORM. Этот процесс достаточно сложен даже для опытного разработчика, поэтому мы пойдем простым путем. Вам будет необходимо склонировать к себе готовый репозиторий и проверить его работоспособность:

	 $ git clone https://github.com/hexlet-components/php-eloquent-blog
	 $ cd php-eloquent-blog
	 $ make setup # установка зависимостей
	 $ make test # запуск тестов
	 # тут побегут SQL запросы
	 OK (2 tests, 2 assertions)
	 
	 Если на этом этапе вы увидите ошибки, то с большой вероятносью у вас не установлена поддержка sqlite в php. Чтобы ее включить, вам нужно найти пакет, обходимый для вашей версии операционной системы и php. Для этого попробуйте набрать в гугл: "php install sqlite <тут название вашей операционной системы>"
	 
	 В качестве базы данных, в этом проекте, используется SQLite. Такой выбор никак не влияет на работу с ORM, но значительно упрощает настройку и запуск кода на выполнение. SQLite в отличие от больших СУБД, хранится в одном файле и работает напрямую из кода. Под нее не поднимается отдельное приложение в системе.
 */
	 
	 #@ Основные части репозитория
	 
/**
	  src/ – Здесь лежат модели и фабрики. Это основные элементы ORM. Подробнее о них дальше по курсу.
	  
	  tests/ – Все сценарии работы с ORM описаны в виде тестов.
	  
	  composer.json – Содержит библиотеки, необходимые для работы Eloquent.

	  src/config/loaders.php – В этом файле находится вся конфигурация. Функция bootstrap() создает файл для базы данных и инициализирует Eloquent. После выполнения этого метода, ORM готова к использованию.
	 
	  db-prepare.php – Файл, запускаемый во время настройки сетапа. Он пересоздает базу данных и загружает туда тестовые данные.
	  
	  src/config/scheme.php – Содержит схему базы данных.
	  
	  tests/BaseTest.php – базовый класс для тестов. Внутри него происходит настройка приложения.
*/
	 
	 


	 # >>>>>>>>>>>> Основные концепции <<<<<<<<<<< #

/**
	 Это обзорный урок, который показывает общие концепции присущие ORM. Каждая из этих концепций рассматривается дальше в курсе
	 
	 ORM (Object-Relation Mapping) – общее название для фреймворков, позволяющих автоматически связать базу данных с кодом. Они стараются скрыть существование базы данных настолько насколько это возможно. Взамен, программисту дают возможность оперировать данными в базе через специальный интерфейс. Вместо построения SQL запросов, программист вызывает простые методы, а всю остальную работу берет на себя ORM.
*/
	 
	 $user = new App\User();
	 $user->name = 'Petr';
	 $user->save(); // сохранение пользователя в базу

/**
	 Несмотря на общую цель, ORM бывают очень разными. Eloquent относится к наиболее распространенному и простому типу ORM, реализующему шаблон проектирования ActiveRecord. Этот шаблон базируется на идее, что каждой таблице в приложении соответствует один класс (модель). Этот класс отвечает как за реализацию бизнес логики, так и за взаимодействие с базой данных. Последнее обычно появляется в модели за счет наследования от базового класса ORM.
*/

	#@ Модель
	 
	 namespace App;
	 use Illuminate\Database\Eloquent\Model;

	 class Post extends Model
	 {
		  // Благодаря метапрограммированию, модель требует минимум движений для связи с таблицей
		  // Даже пустая модель работоспособна. У нее появляются свойства, ее можно загружать из базы и сохранять
	 }
	 
/**
	 Каждый объект данного класса соответствует одной записи из этой таблицы. За преобразования данных в объекты и обратно, отвечает ORM. Программисту лишь нужно использовать правильные методы для извлечения объектов и их модификации.
 */

	 // Поиск пользователя по идентификатору
	 $user = App\User::find(1);

	// Обновление пользователя
	 $user->nickname = 'cooler';
	 
	// Сохранение в базу
	 $user->save();

	// Удаление записи в базе данных
	 $user->destroy();

	// Общее число пользователей
	// SELECT COUNT(*) FROM users;
	 User::count();
	 
	 
	 
	 #@ Выборки

/**
	Важная часть любой ORM это Query Builder (построитель запросов). Это абстракция поверх SQL, которая упрощает генерацию запросов. Она, обычно, выглядит как цепочка функций, каждая из которых отвечает за конкретную часть SQL, например: ORDER, SELECT или WHERE.
 */
	
	 $users = User::where('state', 'active')
		 ->orderBy('name', 'desc')
		 ->take(10)
		 ->get();
	 
	 // Такой запрос нужно делать через билдер, но для демонстрации можно и так
	 $users = DB::select('select * from users where active = ?', [1]);
	 
	 
	 #@ Схема

/**
	 Еще одна обязанность ORM – изменение схемы базы данных: добавление, удаление и модификация таблиц. Делается это, как правило не на чистом SQL, а с помощью специального языка. Это позволяет работать с ORM не отвлекаясь на особенности конкретных баз данных. ORM сама создает правильный SQL подходящий под конкретную базу данных:
 */
	
	 Capsule::schema()->create('users', function ($table) {
		  $table->bigIncrements('id');
		  $table->string('email')->unique();
		  $table->string('first_name');
		  $table->string('password');
		  $table->string('last_name');
		  $table->timestamps(); // Добавляет два поля updated_at и created_at, которые ORM устанавливает автоматически.
	 });
	 
/**
	В Eloquent используется подход "база первая". Это значит, что для создания новых моделей или изменения поведения старых, нужно сначала изменить базу данных.
 */

	#@ Миграции

/**
	Любая база данных в процессе жизни приложения изменяется. В нее добавляются новые таблицы, удаляются старые, какие-то меняются. Этот процесс никогда не заканчивается. Изменения в базе данных выполняются с помощью механизма миграций. Миграция это, обычно, файл, который содержит SQL, меняющий текущую схему базы данных.
*/
	
	
	 use Illuminate\Support\Facades\Schema;
	 use Illuminate\Database\Schema\Blueprint;
	 use Illuminate\Database\Migrations\Migration;
	
	 class CreateArticlesTable extends Migration
	 {
		  // Выполнится при накатывании
		  public function up()
		  {
				Schema::create('articles', function (Blueprint $table) {
					 $table->bigIncrements('id');
					 $table->string('name');
					 $table->text('body');
					 $table->timestamps();
				});
		  }
		 
		  // Выполнится при откатывании
		  public function down()
		  {
				Schema::dropIfExists('articles');
		  }
	 }
	
	
	 /**
	Когда этот файл создан, то происходит процесс, который называют "накаткой миграций" (обычно говорят "я накатил миграции"). Он выполняется с помощью утилиты командной строки. В Laravel это выглядит так:
	
	$ php artisan migrate
	
	В процессе накатки, автоматически выполняется проверка того, какие миграции были выполнены, а какие нет. Применяются только те миграции, которые еще не выполнены на текущей базе данных.
 */
	 
	 
	 
	 
	 # >>>>>>>>>>>> Схема <<<<<<<<<<< #

/**
	Для изменения структуры базы данных, Eloquent использует специальный язык, который абстрагирует нас от специфики конкретной СУБД. Он позволяет создавать и менять таблицы, не опираясь на SQL синтаксис конкретной базы данных.

	Для создании таблицы, используется метод create($name, $fn), где первый параметр это имя таблицы, второй – функция, внутри которой определяется ее структура.
 */
	
	 Capsule::schema()->create('users', function (Blueprint $table) {
		  $table->bigIncrements('id');
		  $table->string('email')->unique();
		  $table->string('first_name');
		  $table->string('password');
		  $table->string('last_name');
		  $table->timestamps();
	 });

	 
/**
	В Eloquent используется соглашение, что имя таблицы, это имя сущности записанное строчными буквами во множественном числе. Только в таком случае Eloquent сможет автоматически связать класс с таблицей. Вот некоторые примеры:
	 
	 Класс			Таблица
	 User				users
	 Article			articles
	 ArticleLike	article_likes
	 
	Из последнего примера видно, что имя класса состоящие из нескольких слов меняет свой формат с CamelCase на snake_case.

	Структура таблицы описывается в анонимной функции, в которую передается объект $table. Этот объект содержит множество методов, каждый из которых его меняет. Затем, Eloquent использует этот объект для генерации правильного SQL-запроса.
	 
	 
	 
	 Метод						Описание
	 bigIncrements($name)	Автоинкрементируемый первичный ключ типа эквивалентного UNSIGNED BIGINT
	 
	 bigInteger($userId)		Эквивалент BIGINT
	 
	 boolean($name)			Эквивалент BOOLEAN
	 
	 string($name, $length)	Эквивалент VARCHAR соответствующей длины
	 
	 По умолчанию поля создаются как not null.
	 
	 
	 Здесь приведена лишь малая часть того, что умеет делать Eloquent. За описанием остальных методов, лучше обратиться к официальной документации https://laravel.com/docs/5.8/migrations#columns.
	 
	 В дополнение к типам колонок перечисленным выше, Eloquent предоставляет методы-модификаторы, которые можно использовать во время создания таблиц. Например модификатор nullable(), убирает ограничение not null.
*/
	
	 Schema::table('users', function (Blueprint $table) {
		  $table->string('email')->nullable();
		  $table->integer('friends_count')->default(0);
	 });


/**

	Метод					Описание
	nullable				Позволяет использовать NULL как значение
	default($value)	Задает значение по умолчанию
	useCurrent			Для колонок типа TIMESTAMP устанавливает дефолтное значение равным CURRENT_TIMESTAMP

	Еще из полезного, это создание индексов. Самый распространенный случай – добавление уникального индекса на такие поля как email:
*/
	
	 Schema::table('users', function (Blueprint $table) {
		  $table->string('email')->unique();
	 });

/**
	#Самостоятельная работа
	Откройте и изучите файл src/config/schema.php. Обратите внимание на проверку hasTable, она нужна для обеспечения идемпотентности.
*/
	 
	 
	 
	 # >>>>>>>>>>>> Модель <<<<<<<<<<< #
	 
/**
	Модель это воплощение понятия предметной области в коде приложения. В Eloquent каждая модель представлена классом в коде и таблицей в базе данных:
*/
	 
	 namespace App;
	 
	 use \Illuminate\Database\Eloquent\Model;
	 
	 class User extends Model
	 {
	 }

/**
	1. Модель = Класс только в классовых языках. Чисто технически она может быть чем угодно, это зависит от языка.
	2. Связь Модель-Таблица это особенность паттерна ActiveRecord. В другом подходе, называемом DataMapper, все может быть по другому.

	Единственное, что нужно для работы модели – создать таблицу в базе данных. В веб-фреймворках это делается через миграции, которые создаются автоматически при генерации модели из командной строки:

	# Laravel
	$ php artisan make:model User

	В нашем же случае, используется файл src/schema.php, в котором есть определение таблицы:
*/
	 Capsule::schema()->create('users', function ($table) {
		  $table->bigIncrements('id');
		  $table->string('email')->unique(); // уникальный индекс
		  $table->string('first_name')->nullable(); // может быть пустым
		  $table->string('last_name')->nullable(); // может быть пустым
		  $table->string('password')->nullable();
		  $table->timestamps();
	 });
	 
// Этого описания достаточно для начала работы. Теперь можно создавать сущности, сохранять их в базу и обновлять:
	
	 $user = new \App\User();
	 // Кажется что это свойство, но на самом деле это магический метод __set
	 $user->email = 'user@email.com';
	 // Такое именование не соответствует стандарту PSR12, но таковы стандарты Eloquent
	 $user->first_name = 'Pedro';
	 $user->last_name = 'Rodriges';
	 // Пароли нельзя хранить в открытом виде
	 $user->password = password_hash('rasmuslerdorf', PASSWORD_DEFAULT);
	
	 $user->save(); // INSERT (добавление новой записи)
	
	 $user->email = 'pedro@hotmail.com';
	 $user->save(); // UPDATE (обновление существующей записи)

		
	// Выводит содержимое объекта
	 print_r($user->toArray());
	 // [
	 //    "email" => "pedro@hotmail.com",
	 //    "first_name" => "Pedro",
	 //    "last_name" => "Rodriges",
	 //    "password" => "$2y$10$jpJD6FlPp0bQFXF3rxFUTu6p.wxnbuxRE803cTdfeqAsqEtJbikp.",
	 //    "updated_at" => "2019-08-23 02:33:50",
	 //    "created_at" => "2019-08-23 02:33:34",
	 //    "id" => 1,
	 //  ]
	
	 $user->delete(); // удаление пользователя
	 
	 
/**
	 Этот код работает благодаря подходу называемому "соглашения вместо конфигурации" (Convention Over Configuration). Нам не пришлось явно указывать имя таблицы с которой связана модель. Eloquent автоматически получил это имя, выполнив приведение имени класса к нижнему регистру и сделав его во множественном числе.
	 
	 Кроме того, Eloquent проанализировала структуру этой таблицы для определния первичного ключа, полей и их типов. Эта информация используется внутри модели для сохранения, обновления и загрузки данных в код. Из примера выше видно, что при создании или обновлении сущности, используется метод save(), а Eloquent сама распознает что сейчас происходит: создание или обновление.
	 
	 После того как сущность сохранена в базу, ее можно извлечь. Самый простой способ сделать это, воспользоваться статическим методом find($id). Он выполняет поиск по первичному ключу.
*/
	 // предположим что запись с таким идентификатором есть в базе данных
	 $user = \App\User::find(1);

	 // Если записи не существует, то вернется null
	 \App\User::find(100);
	 
/**
	 # Самостоятельная работа
	 Зайдите в REPL набрав make console.
	 Создайте нескольких пользователей, обновите их.
	 Переоткройте REPL и извлеките сущности из базы данных.
	 Удалить часть сущностей.
	 
	 
	 Как соотносятся между собой модель и таблица в базе данных?
	 > Каждый объект соответствует одной строке в таблице базы данных
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Массовое присвоение <<<<<<<<<<< #

	// В предыдущем уроке, мы устанавливали свойства модели через сеттеры:
	
	 $user = new \App\User();
	 $user->email = 'user@email.com';
	 $user->first_name = 'Pedro';

/**
	Но это не единственный способ установки свойств. Как правило, в веб-разработке, модели создаются после заполнения формы пользователем сайта. Данные этих форм приходят на сервер в виде ассоциативного массива. Eloquent, как и большинство ORM, позволяет сразу передать этот массив в конструктор, вместо индивидуальной установки каждого свойства. Такой подход называется "mass-assignment":
*/


	 // Обычно это данные пришедшие из формы
	 $params = ['email' => 'user@email.com', 'first_name' => 'Pedro'];
	 $user = new \App\User($params);
	 $user->save();

/**
	 Но если выполнить такой подход в лоб, то он завершится с ошибкой: Add [email] to fillable property to allow mass assignment on [App/User]. Чтобы понять почему так происходит, надо немного поговорить о безопасности.
	 
	 Формы никогда не содержат всех полей. В каждой модели обязательно есть, по крайней мере, одно поле (id), которое нельзя давать менять. Обычно их больше, например различные поля определяющие состояние, количество денег, какие-то внутренние характеристики, которые можно менять только изнутри системы.
	 
	 Но достаточно ли просто не указывать их в форме? Будет ли это безопасно? Не будет. Веб это HTTP, а значит любой человек, всегда может послать форму в нужный обработчик добавив туда все что угодно. Это автоматически означает, что передача данных пачкой в конструктор может привести к очень нежелательным эффектам. Например к изменению уровня доступа в систему:
*/
	
	 // Предположим что в базе есть поле admin, установив которое, можно получить доступ к административной части приложения.
	 $params = ['email' => 'user@email.com', 'first_name' => 'Pedro', 'admin' => true];
	 $user = new \App\User($params);
	 $user->save();

/**
	Во избежания подобных ситуаций, Eloquent контролирует то, что идет на вход при массовом присвоении. Делается это с помощью свойства $fillable внутри модели:
*/
	 
	 namespace App;
	 
	 use \Illuminate\Database\Eloquent\Model;
	 
	 class User extends Model
	 {
		  // Белый список. Здесь описываются допустимые поля.
		  protected $fillable = ['email', 'first_name', 'last_name'];
	 }
	
	 // Теперь указанные поля могут использоваться в конструкторе:
		
	 $params = ['email' => 'user@email.com', 'first_name' => 'Pedro', 'last_name' => 'Alexandro'];
	 $user = new \App\User($params);
	 $user->save(); // Все пройдет успешно
	 
/**
	Массовое присвоение немного отличается если мы говорим про обновление сущности. Конструктор использовать не получится, сущность уже создана. Для массового обновления полей создан метод fill:
*/
	
	 $user = \App\User::find($id);
	 // Только обновление, без сохранения
	 // Этот метод так же ориентируется на свойство $fillable
	 $user->fill(['first_name' => 'Mike', 'email' => 'lala@email.com']);
	 $user->save();
	 
/**
	 Откровенно говоря, контроль входных данных это не уровень моделей. Об этом должен заботиться тот слой, который использует модели. Но жизнь сложная штука. Подобные решения принимаются разработчиками фреймворков, в угоду упрощения работы. Иначе повышается порог входа. С другой стороны, подобные вещи выходят боком для опытных разработчиков. Что если нам нужно иметь разные наборы полей для разных форм? Eloquent ничего не сможет сделать, потому что набор полей зашивается жестко внутри модели
	 
	 # Самостоятельная работа
	 Заполните $fillable у User если оно не заполнено.
	 Создайте пользователя используя mass-assignment.
	 Обновите любого пользователя используя mass-assignment.
	 https://laravel.com/docs/5.8/eloquent#mass-assignment
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Построение запросов (Query Builder) <<<<<<<<<<< #


	 // Одна из задач, которую берут на себя ORM – это построение произвольных SQL запросов в базу данных. Вот как это делается с помощью Eloquent:


	 // SELECT * FROM users WHERE name = "John" ORDER BY name DESC LIMIT 10
	 $users = User::where('name', 'John') // WHERE
	 ->orderBy('name', 'desc') // ORDER BY
	 ->take(10) // LIMIT
	 ->get();
	
	 foreach ($users as $user) {
		  echo $user->first_name;
	 }

/**
	Такая цепочка вызовов поэтапно конструирует необходимый запрос. Метод get() указывает на окончание запроса и выполняет его в базе данных. Eloquent автоматически конвертирует вернувшиеся данные в объекты модели и возвращает их наружу. Если нужно вернуть только одну запись, то вместо get() можно использовать first():
*/

	 // SELECT * FROM users WHERE name = "John" LIMIT 1
	 $user = User::where('name', 'John')->first();
	 
	 // Порядок вызовов функций не важен. Сначала можно сортировать, а потом фильтровать:
	 $users = User::orderBy('name', 'desc')
		 ->where('name', 'John')
		 ->get();
	 // SELECT * FROM users WHERE name = "John" ORDER BY name DESC
	 
/**
	Eloquent самостоятельно расставит все части в правильном порядке. Несмотря на такую заботу, все же рекомендуется там где это возможно соблюдать ожидаемый порядок вызовов. Это упростит чтение кода.

	Многие вызовы могут накапливаться. Цепочка из where породит в SQL-запросе одну часть WHERE, где все условия объеденены с помощью оператора AND.
*/
	
	 User::where('name', 'John')->where('age', 34)->where('city', 'Moscow')->get();
	 // WHERE name = "John" AND age = 34 AND city = "Moscow"

/**
	Обратите внимание на то, что первый вызов всегда идет через статический метод самой модели. Все дальнейшие вызовы выполнятся из объекта, который возвращает первый вызов. Это касается любого метода и зависит от порядка вызовов:
*/
	
	 // Статический метод orderBy
	 User::orderBy('name', 'desc')->where('name', 'John');

	 // Статический метод where
	 User::where('name', 'John')->orderBy('name', 'desc');

/*
	Каждая такая цепочка вызовов порождает новый объект и не мутирует старый. С одной стороны это безопасно, можно строить цепочку и использовать ее для построения других цепочек не боясь что одна повлияет на другую. С другой стороны, нужно не забывать сохранять вызовы, иначе они потеряются:
*/
	
	 $scope = User::orderBy('name', 'desc');
	 $scope->where('name', 'John'); // этот вызов не изменяет $scope, он возвращает новый объект, который не используется
	 print_r($scope->toSQL()); // SELECT * FROM users ORDER BY name DESC
	 
	 $scope = $scope->where('name', 'John');
	 print_r($scope->toSQL()); // SELECT * FROM users WHERE name = "John" ORDER BY name DESC

/**
	В языке запросов Eloquent, есть по методу на каждую часть SQL. Некоторые из них в таблице ниже:

	 метод		sql
	 where		WHERE
	 orderBy		ORDER
	 take			LIMIT
	 select		SELECT
	 skip			OFFSET
	 groupBy		GROUP
*/
	
	 // Where – наиболее часто используемая часть при построении запросов. Ниже примеры кода и описание:
	
	 // WHERE votes = 100
	 // Равносильно User::where('votes', 100);
	 User::where('votes', '=', 100);

	 // WHERE votes >= 100
	 // Кроме >= можно использовать все что поддерживается базой данных.
	 User::where('votes', '>=', 100);
	
	 // У метода Where много специализированных версий:
	
	 // orWhere – соединяется с другими вызовами "where" через оператор OR
	 $users = User::where('votes', '>', 100)->orWhere('name', 'John')->get();

	 // WHERE id IN (1, 2, 3)
	 $users = User::whereIn('id', [1, 2, 3])->get();

	 // Проверка по дате
	 $users = User::whereDate('created_at', '2016-12-31')->get();
	
	 
	 #@ Зачем?
	 
	 // Для чего нужен такой язык, почему недостаточно SQL? На это есть несколько разных причин:
	 
/**
	* Универсальность. Eloquent способна генерировать SQL подходящий под конкретную базу данных. Построение запросов же не привязано к базе данных. Хотя это не отменяет ситуаций, в которых приходится выполнять "сырые" запросы в базу данных.
	* Безопасность. Такой способ построения запросов автоматчески квотирует все подставляемые значения.
	* Автоматическая конвертация. Если делать запросы руками, то придется руками же описывать как выбранные данные должны лечь на свойства конкретной модели. Это довольно серьезная работа, которую лучше поручить ORM (во многом она для этого и создавалась).
	* Динамические запросы. SQL очень плохо подходит для динамических запросов, когда они конструируются по условиям. Такое часто встречается в фильтрах.
*/
	
	
	 
	 # >>>>>>>>>>>> Связи <<<<<<<<<<< #

/**
	Сущности предметной области существуют не сами по себе. Они часто зависят друг от друга. На уровне базы данных, такие связи задаются через внешние ключи или даже промежуточные таблицы, как в случае связи "многие ко многим". ORM, в свою очередь, используют эти ключи, для работы со связями. Добавляет множество полезных методов, которые упрощают работу с зависимыми сущностями: выборкой, добавлением, модификацией и удалением.

	Так как в этом курсе мы делаем блог, нам понадобится сущность Post. Пользователи связаны с постами "один ко многим":

	> Один пользователь может быть автором многих постов
	> У одного поста всегда один автор
*/

	#@ Структура
	 
	 // Для поддержки такой связи, при создании таблицы постов, нужно добавить внешний ключ на таблицу пользователей:
		
	 Capsule::schema()->create('posts', function ($table) {
		  $table->bigIncrements('id');
		  $table->string('state')->nullable();
		  $table->string('title');
		  $table->text('body');
		  // Поле которое будет внешним ключем
		  $table->bigInteger('creator_id');
		  // Добавление внешнего ключа (констрейна)
		  $table->foreign('creator_id')->references('id')->on('users');
		  $table->timestamps();
	 });
	 
/**
	По умолчанию, Eloquent не воспринимает внешние ключи как что-то особенное. Она требует (как и большинство ORM) явного указания связи на уровне моделей. Для этого, в каждой из моделей определяется специальный метод, через который, будет происходить все взаимодействие между связанными сущностями. Имя этого метода произвольно и выбирается так, чтобы лучше отражать суть связи: У поста есть автор, у каждого автора есть посты. Каждый такой метод должен вернуть вызов другого метода, отвечающего за связь. В примере ниже это belongsTo и hasMany.
*/
	 
	 // Post.php
	 namespace App;
	 
	 use \Illuminate\Database\Eloquent\Model;
	 
	 class Post extends Model
	 {
		  public function creator()
		  {
				// Принадлежит пользователю
				// belongsTo определяется у модели содержащей внешний ключ
				return $this->belongsTo('App\User');
		  }
	 }
	 
	 
/**
	Вторым параметром метод belongsTo ожидает имя внешнего ключа, по которой строится связь: $this->belongsTo('App\User', 'creator_id'). Имя ключа можно (и желательно не указывать). В таком случае, Eloquent определяет его самостоятельно используя имя метода связи и добавляя к нему суффикс _id.
*/


	 // User.php
	 namespace App;
	 
	 use \Illuminate\Database\Eloquent\Model;
	 
	 class User extends Model
	 {
		  // во множественном числе потому что это коллекция
		  public function posts()
		  {
				// У каждого пользователя много постов
				// hasMany определяется у модели имеющей внешние ключи в других таблицах
				return $this->hasMany('App\Post', 'creator_id');
		  }
	 }

/**
Метод hasMany так же поддерживает соглашение для определения имени внешнего ключа. Только здесь оно определяется не по имени метода, а по имени модели в которой описывается связь. Для модели User это будет creator_id. В нашем случае такая логика не работает, поэтому имя свойства указано явно.
*/


	 #@ CRUD
		
	 // Теперь Eloquent знает о связях и дает работать с ними напрямую:
	 $user = App\User::find(1);
	 $posts = $user->posts(); // вызывается как метод
	 // SELECT * FROM posts WHERE creator_id = 1
	 foreach($posts as $post) {
		  echo $post;
	 }

/**
	Обращение к коллекции зависимых сущностей возвращает специальный объект, который может использоваться как массив. Кроме этого, он содержит множество методов, полезных при манипуляциях зависимостями:
*/
	
	 $post = new App\Post();
	 $post->title = 'title';
	 $post->body = 'body';
	 // Метод save автоматически делает установку пользователя внутрь поста.
	 $user->posts()->save($post);
	 $user->posts(); // [['id' => 1, 'title' => 'title', 'body' => 'body', 'creator_id' => 1, ...]]
	
	 $post2 = $user->posts()->find(1);
	
	 $post == $post2; // true

	 // Удаление всех постов одним запросом
	 $user->posts()->delete();

	 // Немного по другому устроена работа с другой стороны связи. Вместо обращения к методу creator(), нужно работать со свойством creator:
	
	 $post = App\Post::find(1);
	 $post->creator->first_name;

	 // Установка пользователя
	 $post->creator = $user;
	 $post->save();
	 
/**
	При работе со связями, важно переключиться от мышления через таблицы и ключи, к сущностям и связям (почему) https://www.youtube.com/watch?v=Hk_uSvADUIo&lc=z230srdblqqmgx5duacdp4343lyj51wh5whk2z05cy1w03c010c. Технически, это значит, что код опирается на сами сущности, а не их идентификаторы:
*/

	 // Плохо
	 $post->user_id = $user->id;

	 // Хорошо
	 $post->user = $user;

	 
	#@ Выборки
	
	// Все типы связей в Eloquent поддерживают построение запросов на выборку:
	
	 // в запрос будет включено условие по user_id равным текущему пользователю
	 // SELECT * FROM posts WHERE user_id = 1 AND state = 'active'
	 $user->posts()->where('state', 'active')->get();
	
	 
/**
	 # Самостоятельная работа
	 Заполните $fillable у Post.
	 Изучите связи внутри Post.
	 Откройте REPL и создайте несколько постов.
	 
 	 # Дополнительные материалы
	Один ко Многим https://laravel.com/docs/5.8/eloquent-relationships#one-to-many
*/




	# >>>>>>>>>>>> Коллекции <<<<<<<<<<< #
	

/**
	Любая выборка построенная с помощью языка запросов или связей, это объект, который позволяет получить выбранные данные через метод get(). Сами данные при этом, ведут себя как массив объектов, но, в реальности, не являются массивом:


	>>> $users = \App\User::where('id', '>', 1)->get()
	=> Illuminate\Database\Eloquent\Collection {#2399}

	>>> $posts = \App\User::find(1)->posts()->get();
	=> Illuminate\Database\Eloquent\Collection {#2396}

	Вместо массива Eloquent возвращает инстанс Illuminate\Database\Eloquent\Collection. Это класс, расширяющий другой класс, Collection, созданный для упрощения обработки наборов данных. Он содержит внутри себя десятки удобных методов, с помощью которых данные можно фильтровать, сортировать, агрегировать и так далее.
*/
	
	 // Сразу возвращает Collection
	 $users = App\User::all();

	 // Такую операцию правильно делать напрямую в базе данных
	 // Здесь она только для демонстрации
	 $names = $users->filter(function ($user) { // фильтруем
		  return $user->active === true;
	 })
	 ->map(function ($user) { // отображаем
	 	 return $user->name;
	 });

/**
	В результате работы этого кода, внутри $names останутся имена активных пользователей.

	Ниже посмотрим на некоторые полезные методы, которые могут пригодиться в повседневной работе:
*/
	
	
	 $users = \App\User::all();

	 // contains – проверяет содержит ли коллекция объект с указанным идентификатором (id)
	 $users->contains(1); // true
	 $users->contains(3); // false

	 // unique – возвращает уникальные объекты
	 $users = $users->unique();

	 // modelKeys – возвращает список первичных ключей
	 $users->modelKeys();

	 // intersect – возвращает пересечение между двумя коллекциями
	 $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());

	 // diff – возвращает разницу между двумя коллекциями
	 $users = $users->diff(User::whereIn('id', [1, 2, 3])->get());

/**
	Это только верхушка айсберга. Более подробно нужно смотреть в официальной документации https://laravel.com/docs/5.8/collections. Библиотека Collections относится к такому тиму библиотек. В которые нужно постоянно заглядывать и изучать ее возможности. В любом случае, ее использование, значительно сокращает количество кода и делает код качественее. Но будьте осторожны. Те операции которые можно выполнять в базе, нужно выполнять в базе. Работа с большими коллекциями в памяти жестко бьет по производительности и ест ресурсы.
*/
	
	
	
	
	 # >>>>>>>>>>>> Скоупы <<<<<<<<<<< #
	 

/**
	Чем больше становится проект и чем сложнее его логика, тем чаще возникает потребность в построении запросов с условиями, группировками и сортировками. В коде проекта все чаще начнет возникать подобный код:
*/
	
	 $posts = \App\Post::where('state', 'active')
		 ->whereIn('user_id', $users)
		 ->where('votes_count', '>', 100)
		 ->orderBy('id', 'desc');
	 
/**
	В целом, такие запросы могут встречаться прямо в обработчиках запросов. С другой стороны, они позволяют очень легко пройти границу, за которой происходит снижение качества кода.
	
	 Проблем здесь несколько. Не все условия могут быть очевидны. Например что такое 100 в примере выше? Почему именно 100? Магическое число. Кроме того, если это число имеет какое-то особое значение, то вероятно оно будет встречаться и в других обработчиках точно в таком же запросе. Это значит что произойдет дублирование.
	 
	 Кроме того, некоторые части запроса могут иметь значение только тогда, когда они встречаются вместе и их нужно указывать всегда. Например выше мы выбираем только активные посты у которых больше 100 просмотров. Можно предположить что эти два условия связаны между собой, возможно в этом запросе подразумевается поиск "популярных постов". Это значит что в любом месте где нам понадобятся популярные посты, нужно не забыть скопировать эти два условия.
	 
	 Для решения этих проблем нужно повышать уровень абстракции – создавать функции, которые прячат в себя эти детали. Их можно сделать самостоятельно, но Eloquent уже имеет встроенный механизм называемый скоупами (Scope).
	 
	 Его принцип работы крайне прост. Каждое условие или набор условий, которые мы бы хотели как то обозначить функцией, можно задать в виде скоупа. Скоуп в терминах ORM и есть функция, которая определяется прямо в модели и используется фреймворком при построении запросов:
*/
	 
	 namespace App;
	 
	 use Illuminate\Database\Eloquent\Model;
	 
	 class User extends Model
	 {
		  public function scopeActive($query)
		  {
				return $query->where('state', 'active');
		  }
		  
		  public function scopePopular($query)
		  {
				return $query->where('votes_count', '>', 100);
		  }
	 }

/**
	Каждый скоуп это обычный метод, который начинается с префикса scope. Именно по префиксу Eloquent понимает что это скоуп. Внутрь скоупа передается запрос, на который можно навешивать дополнительные условия. Результатом работы любого скоупа должен быть скоуп.

	Далее они становятся доступны как и любые другие методы языка запросов:
 */
	
	 // И как статический метод и как обычный метод
	 $users = \App\User::popular()->active()->orderBy('created_at')->get();
	
/**
Скоупы можно вызывать из скоупов. Это помогает снизить уровень дублирования при построении более сложных запросов. Например если мы считаем что популярность оценивается только среди активных постов. То это легко поправить изменив соответствующий скоуп:
*/

	 public function scopePopular($query)
	 {
		  return $query->active()->where('votes_count', '>', 100);
	 }
	 
	 
	 #@ Динамические скоупы

/**
	Некоторые скоупы зависят от параметров, передающихся в процессе составления запроса. Для этого, достаточно описать эти параметры внутри скоупа после параметра $query:
 */
	 
	 namespace App;
	 
	 use Illuminate\Database\Eloquent\Model;
	 
	 class User extends Model
	 {
		  public function scopeOfType($query, $type)
		  {
				return $query->where('type', $type);
		  }
	 }
	 
	 // Использование:
	
	 $users = App\User::ofType('admin')->get();
	 
/**
	# Дополнительные материалы
	Локальные скоупы https://laravel.com/docs/5.8/eloquent#local-scopes
*/