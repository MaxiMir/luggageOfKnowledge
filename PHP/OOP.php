<?/*
	 
	 ############### ООП ###############
	 
	 
	 #1 Онтология
	 Описание объектов рассматриваемой области и связей между ними называется онтологией предметной области. Эту онтологию хорошо знают эксперты соответствующей области (в бухгалтерии — бухгалтер, в обучении — преподаватель), но в отличие от программистов, они часто представляют ее на интуитивном уровне, неформально. На практике, программисты (или бизнес-аналитики и менеджеры) общаются с заказчиками, которые могут сами выступать в роли экспертов и строят вместе с ними формальную онтологию (этот процесс происходит постоянно в процессе развития проекта и не выделяется в отдельный этап проектирования). То есть выделяют конкретные термины, договариваются о том что они означают и как связаны друг с другом. Затем, используя ER-модель (https://ru.wikipedia.org/wiki/ER-модель), программист формирует необходимую модель данных. ER-модель — используется при высокоуровневом (концептуальном) проектировании баз данных. На этом этапе уже проявляются зачатки архитектуры будущего приложения.
	 
	 Кстати, далеко не всегда можно однозначно сказать какая связь существует между двумя сущностями. Иногда программисты думают наперед и сразу формируют более сложные связи, например m2m, а не o2m, что сказывается на сложности кода. Чем сложнее связь, тем больше кода и выше стоимость ее создания и поддержки. Сложность связей можно описать так (правее — сложнее): o2o, o2m, m2m. Иногда программисты ошибаются при выборе той или иной связи, что обычно говорит о недостаточно хорошем понимании предметной области. Приведу интересный пример. Предположим, что в системе нужно реализовать пользователя и заграничный паспорт. Интуитивно кажется, что между этими понятиями связь один к одному, ведь один пользователь может иметь один заграничный паспорт. Так? Не совсем, паспорт может поменяться, если он был утерян или закончился срок действия. К тому же, в некоторых странах (в России недавно приняли такой закон) разрешено владение одновременно несколькими заграничными паспортами.
	 
	 С другой стороны, реальный мир всегда сложнее и полнее чем любая модель и задача программиста состоит не в том, чтобы создать универсальную и всеобъемлющую модель некоторой области, а в том, чтобы понять потребности конкретного бизнеса, выделить для них только значимые части рассматриваемой предметной области и перенести ее в код.
	 
	 В зависимости от языка меняется способ представления сущностей в коде. В некоторых определяются типы (используя АТД, интерфейсы или классы), в других структуры. Третьи вообще не предоставляют никаких вариантов, кроме словарей (ассоциативных массивов). То самое понятие ООП имеет непосредственное отношение к рассматриваемой теме.
	 
	 Проблемно-ориентированное проектирование:
	 https://ru.wikipedia.org/wiki/
	 
	 Ментальное программирование:
	 https://www.youtube.com/watch?v=EEq1wdM2M2w
	 https://www.youtube.com/watch?v=Hk_uSvADUIo
	 
	 Simple Made Easy:
	 https://www.infoq.com/presentations/Simple-Made-Easy
	 
	 
	 
	 #2 data hiding
	 Функция makeDecartPoint называется конструктором, потому что она создает новый примитив, функции getX и getY — селекторами (selector), от слова "select", что в переводе означает "извлекать" или "выбирать".
	 
	 data hiding - Скрытие структуры данных за счет взаимодействия с ней только посредством функций:
	 */
	 
	 $point = makeDecartPoint(3, 4);
	 $symmetricalPoint = makeDecartPoint(-getX($point), getY($point));
	 
	 function makeDecartPoint($x, $y)
	 {
		  return [
				'x' => $x,
				'y' => $y
		  ];
	 }
	 
	 function getX($point)
	 {
		  return $point['x'];
	 }
	 
	 function getY($point)
	 {
		  return $point['y'];
	 }
	 
	 // или полярная система координат:
	 
	 function makeDecartPoint($x, $y)
	 {
			// конвертация
			return [
				 'angle' => atan2($y, $x),
				 'radius' => sqrt($x ** 2 + $y ** 2)
			];
	 }
	 
	 /*
	 #3 Интерфейс
	 Интерфейсом называют набор функций (имена и их сигнатуры, то есть количество и типы входящих параметров, а также возвращаемое значение), не зависящих от конкретной реализации. Такое определение один в один совпадает с понятием абстрактного типа данных. Например, для точек интерфейсными являются все функции, которые мы реализовывали в практике, и которые описывались в теории. Но функции бывают не только интерфейсные, но и вспомогательные, которые не предназначены для вызывающего кода и используются исключительно внутри абстракции.
	 */
	 
	 function makeUser($name, $birthday)
	 {
		  return [
				'name' => $name,
				'birthday' => $birthday
		  ];
	 }
	 
	 function getAge($user)
	 {
		  return calculateAge($user['birthday']);
	 }
	 
	 function isAdult($user)
	 {
		  return getAge($user) >= 18;
	 }
	 
	 // Внутренняя функция не являющаяся частью интерфейса абстракции User
	 function calculateAge($birthday)
	 {
		  $secondsInYear = 31556926;
		  return floor((time() - strtotime($birthday)) / $secondsInYear);
	 }
	 
	 /*
	 PHP существует конструкция имеющая имя Interface. Она используется для явного описания интерфейсов, а также выполняет ряд дополнительных функций.
	 
	 #4:
	 
	 Рациональные числа в PHP не поддерживаются, поэтому построить абстракцию для них придется самостоятельно. Как обычно, нам понадобятся конструктор и селекторы:
	 */
	 $num = makeRational(1, 2); // одна вторая
	 $numer = getNumer($num); // => 1
	 $denom = getDenom($num); // => 2
	 
	 
	 function makeRational($numer, $denom)
	 {
		  return "{$numer}/{$denom}";
	 }
	 
	 function getNumer($rational)
	 {
		  return explode('/', $rational)[0];
	 }
	 
	 function getDenom($rational)
	 {
		  return explode('/', $rational)[1];
	 }
	 
	 print_r(makeRational(10, 3)); // => 10/3
	 
	 
	 function mul($rational1, $rational2) // **
	 {
		  return makeRational(
				getNumer($rational1) * getNumer($rational2),
				getDenom($rational1) * getDenom($rational2)
		  );
	 }
	 
	 /* **
	 С точки зрения вызывающего кода все нормально, абстракция сохранена. На вход в mul подаются рациональные числа, на выходе — рациональное число. А вот внутри никакой абстракции нет, обращение с рациональными числами строится на основе знания их устройства. Любое изменение внутренней реализации рациональных чисел потребует переписывания всех операций, работающих с рациональными числами напрямую, без селекторов и конструкторов. Данный код нарушает принцип одного уровня абстракции (single layer abstraction).
	 
	 При разработке сложных систем используется подход — уровневое проектирование. Он заключается в том, что системе придается структура при помощи последовательных уровней. Каждый из уровней строится путем комбинации частей, которые на данном уровне рассматриваются как элементарные. Части, которые строятся на каждом уровне, работают как элементарные на следующем уровне.
	 
	 Уровневое проектирование пронизывает всю технику построения сложных систем. Например, при проектировании компьютеров резисторы и транзисторы сочетаются (и описываются при помощи языка аналоговых схем), и из них строятся и-, или- элементы и им подобные, служащие основой языка цифровых схем. Из этих элементов строятся процессоры, шины и системы памяти, которые в свою очередь служат элементами в построении компьютеров при помощи языков, подходящих для описания компьютерной архитектуры. Компьютеры, сочетаясь, дают распределенные системы, которые описываются при помощи языков описания сетевых взаимодействий, и так далее. (c) SICP
	 
	 
	 
	 # Инварианты
	 
	 Абстракция, благодаря data hiding, позволяет нам не думать о деталях реализации и сосредоточиться на ее использовании. Более того, при необходимости реализацию абстракции можно всегда переписать, не боясь сломать использующий ее код (почти). Но есть еще одна важная причина, по которой нужно использовать абстракцию — соблюдение инвариантов.
	 
	 Инвариант в программировании — логическое выражение, определяющее непротиворечивость состояния (набора данных).
	 */
	 $num = makeRational($numer, $denom);
	 $denom == getDenom($num); // => true
	 $numer == getNumer($num); // => true
	 
	 /*
	 Другими словами, мы ожидаем, что, передав в конструктор числитель и знаменатель, мы получим их (те же числа), если применим селекторы к этому рациональному числу. Именно так определяется корректность работы данной абстракции. Практически этот код является тестами.
	 
	 Инварианты существуют относительно любой операции, и иногда довольно хитрые. Например, рациональные числа можно сравнивать между собой, но не прямым способом, потому, что одни и те же дроби можно представлять разными способами: 1/2 и 2/4. Код который не учитывает этого факта, работает некорректно.
	 */
	 
	 $num1 = makeRational(2, 4);
	 $num2 = makeRational(8, 16);
	 
	 print_r($num1 == $num2); // => false
	 
	 /*
	 Задача приведения дроби к нормальной форме называется нормализацией. Реализовать ее можно разными способами. Самый очевидный — выполнять нормализацию во время создания дроби, внутри функции makeRational. Другой — выполнять нормализацию уже при обращении через функции getDenom и getNumer. Последний способ обладает недостатком — вычисление нормальной формы происходит на каждый вызов. Избежать этого можно, используя технику мемоизации (https://ru.wikipedia.org/wiki/Мемоизация).
	 
	 Учитывая новые вводные, становится понятно, что инвариант, связывающий конструктор и селекторы, нуждается в модификации. Функции getDenom и getNumer должны вернуть не переданные значения, а значения после нормализации (если дробь уже нормализована, то это будут те же самые значения).
	 */
	 
	 $num = makeRational(10, 20);
	 getDenom($num); // => 1
	 getNumer($num); // => 2
	 
	 /*
	 Как бы там ни было, становится понятно, что абстракция не только прячет от нас реализацию, но и отвечает за соблюдение инвариантов. Любая работа в обход абстракции чревата тем, что не будут учтены внутренние преобразования. Многие языки в своем арсенале имеют средства для data hiding. Эти механизмы защищают данные от прямого доступа. В PHP за это отвечают модификаторы доступа к свойствам объектов public, protected и private.
	 
	 Data hiding можно организовать и без специальных средств, только за счет функций высшего порядка. Данный способ основан на создании абстракций только с помощью анонимных функций, замыканий и передачи сообщений (подробнее в SICP).
	 
	 Хочу сразу предостеречь вас от следования культу карго. Несмотря на то, что идея с data hiding выглядит очень здраво, в реальности подобные механизмы крайне легко обходятся с помощью Reflection API и даже без них, просто за счет ссылочных данных. Поэтому подобная защита — она больше "от дурака". Второй момент связан с тем, что в мире немало языков (пример - JavaScript), в которых все нормально с абстракциями, но нет механизмов для data hiding и ничего страшного не произошло. Другими словами, на практике, при использовании абстракций, никто особо и не пытается их нарушать специально. И я склоняюсь к мысли, что значение принудительного data hiding сильно преувеличено.
	 
	 
	 # Структуры
	 
	 Самый лучший способ по настоящему понять ООП — изучить и прорешать вторую главу в SICP/
	 
	 В предыдущих уроках мы познакомились с универсальным способом реализовывать абстракции — ассоциативным массивом. Он не требует написания никакого дополнительного кода, его можно брать и заполнять так, как нам вздумается в зависимости от ситуации. С другой стороны, он не обеспечивает типобезопасности. Так как любая сущность представляется этим массивом, то по ошибке можно вызывать функцию, предназначенную для одной абстракции, например, точки, на другой абстракции, например, сегменте.
	 */
	 
	 $num1 = makeRational(10, 20);
	 // Этот код выполнится, но в $num2 окажется что-то странное:
	 $num2 = makeRational($num1, 20);
	 
	 /*
	 Что при этом произойдет - непонятно и зависит от того, насколько удачно совпали структуры. И если такое произошло, то функция внезапно может отработать без ошибок и даже что-то вернуть. В итоге программа продолжит работать некорректно, вместо того, чтобы завершиться с ошибкой. Кроме того, не существует универсального способа проверить тип данных, так как все есть массив. Описанные проблемы далеко не всегда являются проблемами. То есть нет движения за отказ от ассоциативных массивов. Но есть ситуации, где действительно лучше использовать специализированные средства.
	 
	 Отдельного внимание заслуживают языки со статической типизацией. В этих языках нельзя просто так взять и начать использовать ассоциативный массив как в динамических языках. Любые составные данные должны быть типизированы и описаны, причем до начала использования. По этой причине в таких языках для работы с составными данными используются, например, записи, структуры или классы.
	 
	 Перед тем как переходить непосредственно к объектам, посмотрим на структуры языка СИ, так вы лучше поймете происходящее. К счастью, их синтаксис достаточно прост и нагляден.
	 
	 Примеры несколько упрощены, так как использование указателей, в данном случае, помешает нам понять суть.
	 */
	 
	 // Описание структуры Точка
	 typedef struct
	 {
		  int x;
		  int y;
	 } point;
	 
	 /*
	 Здесь typedef и struct ключевые слова языка, а point — название, которое я выбрал самостоятельно для именования структуры. x и y — элементы (члены) структуры.
	 
	 Структура всегда имеет название, которое может являться ее типом как в примере выше (благодаря typedef). В теле структуры (все что между {}) описываются элементы структуры, имена и их типы.
	 */
	 
	 int main()
	 {
		  // Создание переменной p1 типа point.
		  point p1 = { .x = 0, .y = 1 };
	 
		  // Печать на экран. Доступ к частям структуры происходит через точку p1.x и p1.y
		  printf("%d", p1.x); // => 0
		  printf("%d", p1.y); // => 1
	 
		  // Изменение значения в структуре
		  p1.x = 20;
		  p1.y = -10;
	 }
	 
	 /*
	 Доступ к элементам структуры происходит через точку. Например, если в программе присутствует переменная p1, являющаяся структурой point, то для чтения x нужно написать p1.x, а для чтения y — p1.y. Практически то же самое и в случае присваивания - для изменения x нужно написать p1.x = 5.
	 
	 Структура, как и ассоциативный массив, не дает data hiding. Создание функций для конструирования, извлечения и модификации структуры — целиком и полностью ответственность программиста. И, также, как и ассоциативный массив, тип "структура" в СИ — рекурсивная (древовидная) структура данных. Другими словами, элементом структуры может быть другая структура.
	 */
	 
	 typedef struct
	 {
		  point center; // point это структура
		  int radius;
	 } circle;
	 
	 int main()
	 {
		  // При создании круга одновременно создается точка
		  circle c1 = { .center = { .x = 3, .y = 3 }, .radius = 10 };
	 
		  // Доступ к вложенным членам происходит через дополнительные точки
		  printf("%d", c1.center.x); // => 3
		  printf("%d", c1.radius); // => 10
	 
		  // изменение значения в структуре
		  c1.center.y = 20;
		  c1.radius = -10;
	 }
	 
	 /*
	 С помощью структур в СИ описывают практически любые композитные (составные) данные. Посмотрев на определения структур, можно сказать, с чем работает данная программа, какие сущности в ней выделены и как они связаны между собой.
	 
	 
	 # Классы
	 
	 Аналогом структур из СИ в PHP являются классы (как вы увидите позже, классы устроены намного сложнее). По крайней мере, в первом приближении.
	 Обратите внимание на стиль - где ставятся открывающие и закрывающие скобки:
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 }
	 
	 /*
	 Определение класса подозрительно похоже на определение структуры. За ключевым словом class следует имя класса, затем в фигурных скобках перечисляются элементы класса. Если в структурах их элементы назывались членами, то в PHP их принято называть свойствами. Такое именование характерно для большинства классовых языков. В PHP классы должны начинаться с заглавной буквы.
	 
	 Одно из отличий классов от структур связано с наличием встроенного механизма data hiding. Ключевое слово public делает свойства публичными, то есть доступными снаружи для чтения и модификации. Это поведение аналогично тому, как ведут себя элементы структур. Кроме public есть и другие варианты, но мы их рассмотрим позже, когда поговорим об инкапсуляции и методах.
	 
	 Определив класс, можно начать создавать объекты или, как их еще называют, экземпляры (instance) класса. На текущий момент достаточно рассматривать объект как конкретную структуру данных с конкретными данными.
	 */
	 
	 // Создаем объект типа Point
	 $point = new Point();
	 
	 // По умолчанию значения равны null
	 print_r($point->x); // => null
	 print_r($point->y); // => null
	 
	 // Обратите внимание на синтаксис. Такой вызов неверный: $point->$x.
	 $point->x = 5;
	 $point->y = 10;
	 
	 print_r($point->x); // => 5
	 print_r($point->y); // => 10
	 
	 
	 /*
	 Создание объекта выглядит как вызов функции, к которому добавили ключевое слово new, и, как вы увидите позже, это так и есть. В остальном все работает как и в структурах, только для разделения используется не точка, а стрелка. При обращении к свойствам, знак $ перед именем свойства не ставится.
	 
	 Если распечатать объект на экран print_r($point), то можно увидеть его структуру и значения всех свойств.
	 
	 Point Object
	 (
		  [x] => 5
		  [y] => 10
	 )
	 
	 Классы как рекурсивная структура данных
	 
	 Как и в случае со структурами, значением свойства объекта может быть другой объект. Ограничений на вложенность никаких нет: объекты, содержащие объекты, которые содержат объекты — это нормально.
	 */
	 
	 class Circle
	 {
		  public $center;
		  public $radius;
	 }
	 
	 $circle = new Circle();
	 $circle->radius = 3;
	 $circle->center = new Point();
	 $circle->center->x = 5;
	 $circle->center->y = 10;
	 
	 print_r($circle->center->x); // => 5
	 print_r($circle->radius); // => 3
	 
	 /*
	 Типы данных
	 
	 В PHP около 10 встроенных типов данных, с большинством которых мы уже знакомы, например со строками или массивами. Объекты в этом списке представлены типом object.
	 */
	 gettype($circle); // object
	 gettype($point); // object
	 
	 /*
	 С другой стороны, каждый класс может рассматриваться как пользовательский тип данных, а его объекты-значения (инстансы) - как данные этого типа. Далее в процессе обучения я использую понятие "тип" как синоним понятия "класс". На синтаксическом уровне классы, наравне с обычными типами, могут использоваться для описания входных и выходного типов данных функций.
	 */
	 
	 function showUser(User $user) {
		  // ...
	 }
	 
	 /*
	 Такое определение вызовет ошибку при передачи в функцию любых посторонних данных.
	 
	 
	 
	 # Namespace
	 
	 Неймспейс задается с помощью ключевого слова namespace, за которым следует имя неймспейса. По стандарту, один файл должен соответствовать одному неймспейсу. В случае когда внутри неймспейса определяются только функции (а не классы) имя неймспейса должно соответстовать имени файла с учетом регистра, то есть для нашего примера имя файла math.php, следовательно имя неймспейса math. Теперь посмотрим на то, как использовать функции определенные в неймспейсе:
	 */
	 // FILE: math.php:
	 
	 namespace math;
	 
	 function sum($a, $b)
	 {
		  return $a + $b;
	 }
	 
	 // FILE: index.php:
	 
	 require_once('math.php');
	 
	 \math\sum(5, 8); // 13
	 
	 
	 /*
	 Файловая структура практически любого проекта на PHP выглядит так:
	 
	 src/
		  Formatters/
				 Pretty.php
			 Generator.php
	 
	 tests/
	 composer.json
	 composer.lock
	 .git
	 README.md
	 
	 Если взять файл Pretty.php, то его неймспейс следовало бы назвать FormattersPretty что отражает вложенность Formatters/Pretty. Но можно сделать еще лучше - использовать вложенные неймспейсы:
	 */
	 namespace Formatters\Pretty;
	 
	 function render($data)
	 {
		  // some code
	 }
	 
	 // Или
	 
	 namespace Generator;
	 
	 function generate($data)
	 {
		  return \Formatters\Pretty\render($data);
	 }
	 
	 /*
	 Каждый проект или пакет принято помещать в одно общее пространство и не загрязнять глобальное пространство множеством неймспейсов. Это название выбирается на основе названия самого проекта, той директории внутри которой лежит src. В нашей структуре директорий это my-site. Это значит, что общим пространством для всех файлов внутри src будет MySite:
	 */
	 
	 // FILE: src/Formatters/Pretty.php
	 
	 namespace MySite\Formatters\Pretty;
	 
	 // some code
	 
	 // C помошью механизма импорта функцию можно импортировать в текущий неймспейс так, как будто она определена прямо здесь:
	 
	 namespace Generator;
	 
	 use function Formatters\Pretty\render;
	 
	 function generate($data)
	 {
		  return render($data);
	 }
	 
	 
	 // Изредка случаются ситуации, когда хочется импортировать функцию, но в текущем пространстве либо уже определена функция с таким именем, либо функция с таким именем была импортирована ранее из другого неймспейса. Сделать это можно через алиасы (псевдонимы), механизм позволяющий переименовывать импортируемые функции:
	 
	 namespace Generator;
	 
	 use function Formatters\Pretty\render;
	 use function Formatters\Simple\render as simpleRender;
	 
	 function generate($data)
	 {
		  return simpleRender($data);
	 }
	 
	 
	 # Автозагрузка классов
	 
	 /*
	 Принято определять ровно один класс на файл. Более того, в этом файле больше не может быть никаких инструкций, не считая определения неймспейса. Чисто технически, язык не запрещает нарушать это правило, но лучше следовать стандартам кодирования (https://www.php-fig.org/psr/psr-2/#4-classes-properties-and-methods)
	 
	 Классы немного по-другому работают с неймспейсами. Если неймспейс содержит только функции, то его определение обычно оканчивается именем файла (без расширения). Во всех наших упражнениях именно такая структура.
	 
	 FILE: src/solution.php
	 */
	 namespace App\solution;
	 
	 function ...
	 
	 /*
	 В случае с классами неймспейс не содержит имени файла. Его роль выполняет само название класса. Причем файл должен называться в точности как класс и с учетом регистра.
	 
	 FILE: src/Point.php
	 */
	 
	 namespace App;
	 
	 class Point
	 {
	 
	 }
	 
	 // Использовать этот класс в другом неймспейсе можно так:
	 
	 namespace AnotherApp;
	 
	 use App\Point;
	 
	 $point = new Point();
	 
	 // либо так:
	 
	 namespace AnotherApp;
	 
	 $point = new \App\Point();
	 
	 /*
	 Полное описание требований к тому, как правильно стилистически именовать классы и как соотносить их с файловой структурой, приведено в стандарте PSR4. Этот стандарт важно соблюдать по двум причинам. Первая связана с единым подходом к именованию и формированию структуры, что позволяет легко ориентироваться в проектах. Но есть и другая, не менее важная причина — автозагрузка классов.
	 
	 Если определенный неймспейс в PHP содержит только функции, то для его загрузки используется специальная секция autoload/files в файле composer.json.
	 */
	 
	 "autoload": {
		"files": [
		  "src/Points.php",
		  "src/Segments.php"
		]
	 }
	 
	 /*
	 Эту секцию вы могли видеть практически в каждой практике на Хекслете. Composer требует перечисления всех таких файлов, и только в этом случае он загрузит их автоматически. Причем произойдет это в любом случае, не важно, используются функции этих неймспейсов или нет.
	 */
	 
	 // Эта строчка приводит к загрузке всех файлов, указанных в секции files
	 require __DIR__ . '/vendor/autoload.php';
	 
	 /*
	 С классами ситуация другая. PHP содержит специальный механизм (http://php.net/manual/ru/function.spl-autoload-register.php) автозагрузки классов. Этот механизм работает так: если интерпретатор наталкивается на использование класса, то он проверяет, определили ли вы автозагрузчик классов, и, если определили, то вызывает его (пример https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md). Composer определяет такой загрузчик автоматически. Его можно конфигурировать с помощью файла composer.json. Если структура классов в вашем приложении соответствует PSR4, то конфигурация минимальна. Стандарт PSR4 задает стиль именования, позволяющий однозначно определять полное имя класса (включая неймспейсы) на основании пути до файла (относительно корня проекта) и наоборот.
	 */
	 
	 FULLY QUALIFIED CLASS NAME   | NAMESPACE PREFIX| BASE DIRECTORY         | RESULTING FILE PATH
	 \Acme\Log\Writer\File_Writer | Acme\Log\Writer | ./acme-log-writer/lib/ | ./acme-log-writer/lib/File_Writer.php
	 \Zend\Acl 					 | Zend            | /usr/includes/Zend/    | /usr/includes/Zend/Acl.php
	 \Symfony\Core\Request        | Symfony\Core    | ./vendor/Symfony/Core/ | ./vendor/Symfony/Core/Request.php
	 
	 {
		  "autoload": {
				"psr-4": {"App\\": "src/"}
		  }
	 }
	 
	 /*
	 В данном примере указано, что в папке src относительно расположения файла composer.json находится неймспейс App, соответствующий стандарту PSR4. В этом случае Composer только регистрирует автозагрузчик, который подключает файлы с классами по необходимости, только во время их использования.
	 
	 Все примеры на Хекслете используют автозагрузку классов. Рекомендую подглядывать в файл composer.json каждой практики и анализировать содержимое. Кроме того, понимать автозагрузку лучше всего не через внимательное чтение документации, а через эксперименты. Попробуйте самостоятельно собрать простой php пакет и создайте внутри него классы. Не забывайте, что всегда можно подглядывать в наш шаблон (https://github.com/hexlet-boilerplates/php-package).
	 
	 Документация: http://php.net/manual/ru/language.oop5.autoload.php
	 
	 # Свойства
	 
	 Свойства класса иногда называют аттрибутами или полями класса, но общепринятым все же является термин "свойства". Объявление свойств по умолчанию устанавливает в них значение null.
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 }
	 
	 $p = new Point();
	 var_dump($p);
	 // class Point#1 (2) {
	 //   public $x =>
	 //   NULL
	 //   public $y =>
	 //   NULL
	 // }
	 
	 class User
	 {
		  public $children = [];
		  public $status = 'approved';
	 }
	 
	 $user = new User();
	 print_r($user->children); // => []
	 
	 /*
	 По историческим причинам свойства в PHP можно определять с помощью ключевого слова "var", но делать этого не нужно. По своему действию "var" аналогичен "public" и существует в языке только для обратной совместимости (с версиями языка < 5).
	 
	 Свойства классов хоть и описываются в классе, но не принадлежат ему. То есть каждый объект при создании получает свою собственную копию свойств. В этом смысле поведение абсолютно аналогично структурам.
	 */
	 
	 $user1 = new User();
	 $user1->status = 'declined';
	 $user2 = new User();
	 print_r($user2->status); // approved
	 
	 /*
	 Динамическое обращение к свойствам
	 
	 В некоторых ситуациях имя свойства, к которому нужно обратиться, задается динамически и хранится в переменной. В такой ситауции можно использовать специальный синтаксис обращения к свойству:
	 */
	 $propertyName = 'key'ж
	 $obj->$propertyName = 'value';
	 $obj->$propertyName; // value
	 $obj->key; // value
	 
	 /*
	 Документация: http://php.net/manual/ru/language.oop5.properties.php
	 
	 # Указатели
	 
	 Мы привыкли к тому, что данные в PHP всегда передаются по значению. Так происходит и при присваивании, и при передаче данных в функции.
	 */
	 
	 $a = 5;
	 $b = $a;
	 
	 $a = 4;
	 print_r($b); // => 5
	 
	 // Это правило применимо ко всем данным без исключения. Если мы хотим сделать передачу по ссылке, то нужно использовать &.
	 
	 $a = 5;
	 $b =& $a;
	 
	 $a = 4;
	 print_r($b); // => 4
	 
	 /*
	 Но объекты ведут себя подобно передаче по ссылке даже без &.
	 
	 По этой причине многие считают, что передача объектов всегда происходит по ссылке. Это не верно. Тот механизм, который используется для передачи объектов, внешне ведет себя точно так же, как и передача по ссылке, но это другой механизм.
	 */
	 
	 $p1 = new Point();
	 $p1->x = 3;
	 $p1->y = 5;
	 $p2 = $p1;
	 
	 $p2->x = 100;
	 print_r($p1->x); // => 100
	 
	 /*
	 Когда создается объект, в переменную записывается не он сам, а указатель (pointer) на него. Указатель можно воспринимать как идентификатор (номер) объекта, находящегося где-то в памяти. Когда мы присваиваем переменной объект $p2 = $p1, то происходит копирование этого идентификатора, но сам он не меняется. Другими словами, идентификатор всегда указывает на тот же самый объект. Поэтому создается впечатление, что объекты передаются по ссылке как при присваивании, так и при передаче объектов в функции.
	 */
	 
	 function setX($point, $x)
	 {
		  $point->x = $x;
	 }
	 
	 $point = new Point();
	 $point->x = 3;
	 $point->y = 4;
	 setX($point, 8);
	 print_r($point->x); // => 8
	 
	 /*
	 По этой причине, работа с объектами резко отличается от того, что мы изучали раньше, например, функции, меняющие объекты, редко что-то возвращают наружу. И эти же функции почти никогда не бывают чистыми, ведь, меняя объекты, они влияют на внешнее окружение. Популярные языки программирования строят работу с объектами на основе императивной парадигмы, что, в общем случае, не обязательно. С другой стороны, есть ряд задач, в которых удобнее работать с объектами в декларативном стиле, например, при обработке коллекций.
	 
	 Документация: http://php.net/manual/ru/language.oop5.references.php
	 
	 
	 
	 Реализуйте функцию dup, которая клонирует переданную точку. Под клонированием подразумевается процесс создания нового объекта, с такими же данными как и у старого.
	 */
	 namespace App\PointFunctions;
	 
	 function dup($point)
	 {
		  $clonedPoint = new \App\Point();
		  $clonedPoint->x = $point->x;
		  $clonedPoint->y = $point->y;
	 
		  return $clonedPoint;
	 } // <-> clone($point);
	 
	 // В другом файле:
	 
	 use function App\PointFunctions\dup;
	 
	 $point1 = new \App\Point();
	 $point2 = dup($point1);
	 
	 $point1 == $point2; // true
	 $point1 === $point2; // false
	 
	 /*
	 # Сравнение объектов
	 
	 Сравнение объектов обладает некоторыми особенностями, о которых надо знать. Главное правило сравнения состоит в том, что объекты разных типов никогда не равны. Здесь никаких сюрпризов.
	 */
	 $p = new Point();
	 $s = new Segment();
	 
	 $s == $p;  // => false
	 $s === $p; // => false
	 
	 /*
	 Если же тип один и тот же, то возникает две ситуации: одна для оператора нестрогого сравнения и другая — для строгого.
	 
	 Нестрогое сравнение (==)
	 Два объекта считаются равными, если они имеют одинаковые свойства и их значения совпадают.
	 */
	 $p1 = new Point(3, 9);
	 $p2 = new Point(3, 9);
	 
	 $p1 == $p2; // => true
	 
	 // Но что будет, если значением свойства объекта является другой объект?
	 
	 $s1 = new Segment(new Point(1, 3), new Point(8, 5));
	 $s2 = new Segment(new Point(1, 3), new Point(8, 5));
	 
	 $s1 == $s2; // => true
	 
	 /*
	 Если вложенные объекты совпадают по правилу описанному выше, то исходные объекты также считаются равными. Другими словами, правило — рекурсивно, и проверка идет по всем вложенным объектам.
	 
	 Строгое сравнение (===)
	 Строгое сравнение, напротив, проверяет только совпадение значения указателей. Объекты равны строго, только если это один и тот же объект.
	 */
	 
	 $p1 = new Point(3, 9);
	 $p2 = new Point(3, 9);
	 
	 $p1 === $p2; // => false
	 
	 $p3 = $p1;
	 $p3 === $p1; // => true
	 
	 /*
	 Свое сравнение
	 На практике, все же, объекты устроены сложнее и сравнивать их стандартными средствами не получается. Например, сравнение может происходить на основании идентификаторов, взятых из базы данных. В таких случаях остается только один способ — написать свою собственную функцию (или метод) сравнения.
	 
	 
	 # Конструктор
	 
	 Структура в СИ может быть инициализирована значениями прямо при создании.
	 */
	 int main()
	 {
		  // Создание переменной p1 типа point.
		  point p1 = {.x = 0, .y = 1 };
	 }
	 
	 /*
	 Объекты в PHP тоже могут быть инициализированы при создании, но для этого придется внести изменения в класс — написать функцию-конструктор. Конструктор класса похож на тот конструктор, который мы реализовывали, знакомясь с абстракциями. Разница только в том, что в случае классов конструктор находится внутри класса, а не описывается как обычная функция снаружи.
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 
		  public function __construct($x, $y)
		  {
				$this->x = $x;
				$this->y = $y;
		  }
	 }
	 
	 $point = new Point(1, 10);
	 $point->x; // => 1
	 $point->y; // => 10
	 
	 /*
	 Конструктор класса — функция с именем __construct. Эту функцию невозможно вызвать напрямую. Она вызывается автоматически во время создания объекта new Point(5, 3), а параметры, переданные в этот вызов, сразу попадают в конструктор. Это значит, что, если в классе определен конструктор с двумя обязательными параметрами, то создание объекта всегда потребует два обязательных параметра. Сам по себе конструктор подчиняется тем же правилам, что и обычные функции, например, при необходимости можно указать значения по умолчанию. PHP, в силу динамической природы, допускает создание ровно одного конструктора на класс.
	 
	 Конструктор не может и не должен ничего возвращать (технически вы можете написать return, но этот возврат никем не используется).
	 
	 Самое интересное происходит внутри конструктора. Во-первых, конструктор вызывается тогда, когда объект уже создан. Этот объект доступен внутри конструктора как переменная $this. Такое поведение может показаться странным, ведь, глядя на эту конструкцию $point = new Point(1, 10), видно, что правая часть выполняется раньше присваивания, а значит и конструктор вызывается раньше. Ответ кроется в том, какая логика скрывается за оператором new. Процесс создания объекта внутри PHP выглядит следующим образом:
	 
	 1. Создается объект без вызова чего-либо. Технически, внутри интерпретатора создается та самая структура из языка СИ (PHP написан на СИ).
	 2. Вызывается конструктор, в который передается объект. Синтаксически этой передачи не видно, но она есть. Можно сказать, что объект попадает внутрь конструктора как нулевой параметр, то есть внутри PHP для нашего класса, определенного выше, сигнатура конструктора выглядит так: __construct($this, $x, $y).
	 3. Объект $this наполняется в соответствии с кодом, находящимся в теле функции __construct. Так как объект всегда передается по указателю, то возврат из конструктора не нужен.
	 4. Объект возвращается наружу. В этот момент отрабатывает присваивание.
	 Основная задача конструктора — заполнить свойства объекта переданными параметрами. Этот способ сложнее, чем тот, который мы рассматривали в структурах (где ничего не надо определять, а можно заполнять при конструировании), и вот почему:
	 
	 1. Свойства могут быть защищены от прямого изменения или чтения. Этот вопрос рассматривается позже.
	 2. Свойства могут требовать дополнительных расчетов, как, например, в ситуации с рациональными числами, которую мы рассматривали ранее, где происходило преобразование входных координат в другой способ представления.
	 3. В конструкторе можно выполнять различные побочные эффекты, например, читать файлы или выполнять сетевые вызовы (открыть соединение с базой данных). С этой возможностью нужно быть очень осторожным. Побочные эффекты резко усложняют код и затрудняют тестирование.
	 
	 Документация: http://php.net/manual/ru/language.oop5.decon.php
	 
	 
	 
	 /**@@
	 Реализуйте класс App\Segment с двумя публичными свойствами beginPoint и endPoint. Определите в классе конструктор.
	 Примеры
	 */
	 $segment = new Segment(new Point(1, 1), new Point(10, 11));
	 
	 /*
	 src/SegmentFunctions.php
	 Реализуйте функцию reverse, которая принимает на вход сегмент и возвращает новый сегмент с точками, добавленными в обратном порядке (begin меняется местами с end).
	 
	 Примечания
	 Точки в результирующем сегменте должны быть копиями (по значению) соответствующих точек исходного массива. То есть они не должны быть ссылкой на один и тот же объект, так как это разные объекты (пускай и с одинаковыми координатами).
	 
	 Примеры
	 */
	 
	 use function App\SegmentFunctions\reverse;
	 
	 $segment = new \App\Segment(new Point(1, 10), new Point(11, -3));
	 $reversedSegment = reverse($segment);
	 
	 $reversedSegment->beginPoint; // => (11, -3)
	 $reversedSegment->endPoint; // => (1, 10)
	 
	 
	 // FILE: src/Segment.php
	 class Segment
	 {
		  public $beginPoint;
		  public $endPoint;
	 
		  public function __construct($beginPoint, $endPoint)
		  {
				$this->beginPoint = $beginPoint;
				$this->endPoint = $endPoint;
		  }
	 }
	 
	 // FILE: src/SegmentFunctions.php
	 function reverse($segment)
	 {
		  $startP = $segment->beginPoint;
		  $finishP = $segment->endPoint;
		  $endPoint = new Point($startP->x, $startP->y);
		  $beginPoint = new Point($finishP->x, $finishP->y);
	 
		  return new \App\Segment($beginPoint, $endPoint);
	 }
	 
	 
	 
	 # Инкапсуляция
	 
	 // В первой части этого курса мы строили абстракции, используя обычные функции с применением подхода data hiding.
	 
	 $point = makeDecartPoint(3, 4);
	 getX($point); // => 3
	 getY($point); // => 4
	 
	 /*
	 В Объектно-ориентированном подходе, функции объединяются с данными и описываются вместе внутри класса (в классово-ориентированных языках). Инкапсуляция - механизм, позволяющий описывать данные и функции, оперирующие ими, в рамках одной языковой конструкции. В случае PHP, такой конструкцией является класс.
	 
	 Мы уже начали так делать, когда знакомились с конструктором. Такие функции принято именовать методами, так как они связаны с объектом, на котором вызываются. Визуально вызов метода выглядит как обращение к свойству и его вызов.
	 */
	 
	 $point = new Point(3, 4);
	 $point->getX(); // => 3
	 $point->getY(); // => 4
	 
	 /*
	 Вызов метода не требует передачи объекта в аргументах, потому что метод вызывается на объекте и имеет к нему доступ через переменную $this.
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 
		  public function __construct($x, $y)
		  {
				$this->x = $x;
				$this->y = $y;
		  }
	 
		  public function getX()
		  {
				return $this->x;
		  }
	 
		  public function getY()
		  {
				return $this->y;
		  }
	 }
	 
	 /*
	 Методы, которые извлекают составные части объекта, принято называть геттерами (getters), а методы, изменяющие составные части — сеттерами (setters). Как правило, геттеры и сеттеры один в один отображаются на конкретные свойства внутри объекта. Технически, методы — обычные функции, за исключением доступа к $this и способа вызова.
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 
		  public function __construct($x, $y)
		  {
				$this->x = $x;
				$this->y = $y;
		  }
	 
		  public function getX()
		  {
				return $this->x;
		  }
	 
		  public function getY()
		  {
				return $this->y;
		  }
	 
		  public function setX($x)
		  {
				$this->x = $x;
		  }
	 
		  public function setY($y)
		  {
				$this->y = $y;
		  }
	 }
	 
	 $point = new Point(5, 10);
	 $point->setX(100);
	 print_r($point->getX()); // => 100
	 
	 
	 /*
	 Сеттеры в примере выше показаны только для демонстрации. В реальном коде точка почти наверняка будет неизменяемым объектом.
	 
	 Но геттеры и сеттеры - не единственные типы функций, которые позволяет описывать класс. В принципе, все, что мы описывали работая без классов, с таким же успехом описывается и с классами.
	 
	 Реализация без классов:
	 */
	 
	 function distanceTo($point1, $point2)
	 {
	 
		  $squareOfX = (getX($point1) - getX($point2)) ** 2;
		  $squareOfY = (getY($point1) - getY($point2)) ** 2;
	 
		  return sqrt($squareOfY + $squareOfX);
	 }
	 
	 // Реализация в классе:
	 
	 class Point
	 {
		  ...
	 
		  /*
			* Рассчет по теореме пифагора связи между
			* сторонами прямоугольного треугольника с^2 = a^2 + b^2
		  */
		  public function distanceTo($point)
		  {
	 
				$squareOfX = ($this->getX() - $point->getX()) ** 2;
				$squareOfY = ($this->getY() - $point->getY()) ** 2;
	 
				return sqrt($squareOfY + $squareOfX);
		  }
	 }
	 
	 $point1 = new Point(0, 0);
	 $point2 = new Point(3, 4);
	 print_r($point1->distanceTo($point2)); // => 5
	 print_r($point2->distanceTo($point1)); // => 5
	 
	 /*
	 Данная операция обладает свойством коммутативности. Результат вычисления не зависит от того, в каком порядке идут аргументы. Соответственно, при использовании методов, можно вызывать distanceTo как на одном объекте, так и на другом.
	 
	 Нередко методы выполняют не только вычисления, но и возвращают новые объекты. Например, так произойдет при вычислении симметричной точки.
	 */
	 
	 class Point
	 {
		  ...
	 
		  public function getSymmetricalPoint()
		  {
				// Можно выполнять промежуточное создание переменной, а можно возвращать сразу
				return new Point(-$this->getX(), -$this->getY());
		  }
	 }
	 
	 $point = new Point(3, 8);
	 $point->getSymmetricalPoint(); // => (-3, -8)
	 
	 /*
	 Выше мы рассмотрели техническую сторону вопроса, оставив за кадром описание преимуществ и недостатков такого похода, а также связанные темы, например, data hiding или полиморфизм. Их описание довольно обширно и практически бесполезно без хотя бы минимального опыта использования. О том, что дает или забирает инкапсуляция, я расскажу на протяжении ближайших уроков. Отдельного обсуждения заслуживает вопрос о способе хранения методов - где они находятся физически (внутри объекта или нет?). С ним мы разберемся в уроках, посвященных полиморфизму и динамической диспетчеризации.
	 
	 Документация: http://php.net/manual/ru/language.oop5.visibility.php
	 
	 
	 /**@@
	 Реализуйте класс для работы с рациональными числами, включающую в себя следующие методы:
	 
	 Конструктор — принимает на вход числитель и знаменатель.
	 Метод getNumer — возвращает числитель
	 Метод getDenom — возвращает знаменатель
	 Сложение add — складывает переданные дроби
	 Вычитание sub — находит разность между двумя дробями
	 **/
	 $rat1 = new Rational(3, 9);
	 $rat1->getNumer(); // => 3
	 $rat1->getDenom(); // => 9
	 
	 $rat2 = new Rational(10, 3);
	 
	 $rat3 = $rat1->add($rat2); // => Абстракция для рационального числа 99/27
	 $rat3->getNumer();         // => 99
	 $rat3->getDenom();         // => 27
	 
	 $rat4 = $rat1->sub($rat2); // => Абстракция для рационального числа -81/27
	 $rat4->getNumer();         // => -81
	 $rat4->getDenom();         // => 27
	 
	 class Rational
	 {
		  public $numer;
		  public $denom;
	 
		  public function __construct($numer, $denom)
		  {
				$this->numer = $numer;
				$this->denom = $denom;
		  }
	 
		  public function getNumer()
		  {
				return $this->numer;
		  }
	 
		  public function getDenom()
		  {
				return $this->denom;
		  }
	 
		  public function add($rational)
		  {
				$numer = $rational->getNumer() * $this->getDenom() + $this->getNumer() * $rational->getDenom();
				$denom = $rational->getDenom() * $this->getDenom();
				return new Rational($numer, $denom);
		  }
	 
		  public function sub($rational)
		  {
				$numer = $this->getNumer() * $rational->getDenom() - $rational->getNumer() * $this->getDenom();
				$denom = $rational->getDenom() * $this->getDenom();
				return new Rational($numer, $denom);
		  }
	 }
	 
	 
	 
	 # Data Hiding (Data Protection)
	 
	 /*
	 Как я уже упоминал, в терминологии ООП творится довольно серьезная путаница. Она возникает, в первую очередь, из-за того, что многие программируют либо на одном языке, либо если и на разных, то часто схожих по структуре языках. Соответственно, происходит профессиональная деформация, когда программист видит мир сквозь призму одного языка. Одна из таких историй происходит вокруг инкапсуляции и data hiding. Напомню, что data hiding - подход, при котором нельзя изменить данные напрямую, в обход интерфейса, тем самым нарушив инварианты (такое происходит не всегда). Есть языки, в которых присутствует data hiding, например, haskell, но нет инкапсуляции. В ООП data hiding появляется благодаря двум возможностям:
	 
	 - инкапсуляции
	 - области видимости свойств
	 
	 Однако учтите что в литературе часто отождествляют термины инкапсуляция и защита данных. Поэтому не пугайтесь если многие вокруг вас будут утверждать что инкапсуляция это про защиту данных, но даже не вспомнят про объединение функций и данных в рамках одной структуры
	 
	 Достаточно изменить слово public на private у любого свойства, как пропадет возможность обращаться к нему напрямую снаружи объекта.
	 */
	 class Point
	 {
		  private $x;
		  private $y;
	 
		  public function __construct($x, $y)
		  {
				// Внутри по прежнему доступ есть
				$this->x = $x;
				$this->y = $y;
		  }
	 
		  public function getX()
		  {
				return $this->x;
		  }
	 
		  public function getY()
		  {
				return $this->y;
		  }
	 }
	 
	 $point = new Point(10, 8);
	 print_r($point->getX()); // => 10
	 $point->x; // PHP Fatal error:  Uncaught Error: Cannot access private property Point::$x<Paste>
	 
	 /*
	 Подчеркну, что речь идет именно о доступе снаружи. Внутри он должен остаться, иначе как мы сможем оперировать этим свойством?
	 
	 Data hiding считается важным аттрибутом любой абстракции, независимо от того, работаем мы в ООП стиле, или нет. Именно по этой причине существуют геттеры. В ООП, построенном на классах, вообще не принято обращаться к свойствам напрямую. Геттеры - первое, что реализуется при описании любого нового класса. Кстати, в языке Ruby нельзя (один способ есть, но он выходит за рамки обсуждаемой темы) обратиться к свойству объекта без геттера, но описываются они там значительно проще и компактнее, чем в таких языках, как PHP или Java, и выглядят как обращения к свойствам (в ruby можно не ставить скобки при вызове функций). Тоже самое касается и сеттеров. Свойства напрямую не редактируют, так как потенциально можно нарушить инварианты.
	 
	 # Изменяемость
	 
	 Сеттеры (setters) служат для изменения внутреннего состояния объекта. Как и геттеры, они именуются особым образом. К сеттерам обычно добавляется префикс set, если этот сеттер что-то устанавливает и add - если добавляет.
	 */
	 $point1 = new Point(10, 11);
	 $point2 = new Point(-3, 3);
	 $segment = new Segment($point1, $point2);
	 
	 $segment->getStartPoint(); // (10, 11)
	 $segment->setStartPoint(new Point(3, 8)); // Допустимо, потому что new Point(3, 8) - выражение
	 $segment->getStartPoint(); // (3, 8)
	 
	 /*
	 На практике изменения объектов происходят почти всегда с помощью сеттеров, и крайне редко - через изменение свойства напрямую. Причем объекты (впрочем, как и любая абстракция) иногда хранят внутри себя свойства, которые нельзя изменять снаружи (например, соединение с базой данных), и для них не делают сеттеров.
	 
	 Вообще говоря, с сеттерами связано много головной боли. Несмотря на data hiding, встроенный в объекты, как я уже говорил ранее, можно легко создать ситуацию, в которой из одного объекта извлекается другой объект и меняется. Естественно, исходный объект об этих изменениях ничего не знает. Проблема обостряется тогда, когда один объект используется по всему приложению. В такой ситуации он ведет себя как глобальная переменная (в худшем ее проявлении). Изменения, сделанные в одном месте, коснутся всего.
	 
	 Например, ранее вы создали класс для работы с рациональными числами. Если бы методы add и sub изменяли объект, на котором вызываются, то получить неверные рассчеты стало бы крайне просто. Достаточно использовать одно рациональное число в нескольких местах, и любое его изменение повлияет на всех, кто использует это число. Абсолютно такая же ситуация и с графическими примитивами на плоскости.
	 */
	 
	 $point1 = new Point(10, 11);
	 $point2 = new Point(-3, 3);
	 $segment1 = new Segment($point1, $point2);
	 $segment2 = new Segment($point1, $point2);
	 
	 // Функция moveUp перемещает весь отрезок на три значения вверх. Она не возвращает новый сегмент, а мутирует сам объект.
	 $segment1->moveUp(3);
	 print_r($segment1); // => [(10, 14), (-3, 6)]
	 
	 /*
	 Если внутри moveUp происходит изменение точек (вместо создания новых), то такое изменение повлияет и на segment2, хотя мы и не собирались его перемещать.
	 Другой яркий пример - Маркдаун (https://guides.hexlet.io/markdown/#что-это-значит).
	 Для генерации маркдауна, вообще говоря, достаточно обычной функции:
	 */
	 
	 $html = generateHtml($markdown);
	 
	 // Иногда поведение генератора надо менять, а у него довольно много разных опций, например, нужно ли вырезать опасные теги и вообще - разрешать ли использовать теги:
	 
	 $html = generateHtml($markdown, ['sanitaize' => 'true']);
	 
	 // По-прежнему используется функция, и с кодом все хорошо. Но, если опций много и они одинаковые по всему приложению (во всех местах, где происходит генерация), то появляется много дублирования с передачей этих опций на каждый вызов. Эту задачу можно решить двумя способами. Один основан на генерации функции, которая замыкает внутри себя опции (такое решение популярно в js). Второй - можно использовать объект как способ хранить состояние.
	 
	 $markdown = new Markdown($options);
	 $html = $markdown->render($text);
	 
	 // Теперь достаточно прокинуть в нужную часть приложения объект $markdown, вызвать метод render - и больше не беспокоиться об опциях. Но обязательно найдется место, в котором понадобится особое поведение. И некоторые создатели подобных библиотек пытаются решить возникшую проблему, добавив сеттер на изменение опций, заложенных в объект.
	 
	 $markdown->setOptions(['sanitize' => false]);
	 $html = $markdown->render($text);
	 
	 /*
	 Такой код создает потенциальную огромную дыру, которую очень сложно отловить. Так как сеттер меняет состояние объекта, а объект - общий для разных частей программы, то все вызовы метода render после вызова setOptions будут основываться на новых опциях, хотя изначально мы хотели поменять поведение только для одного места.
	 
	 Существует ли способ сделать все красиво? Нет, фундаментальная проблема "изменяемое состояние" может быть убрана только отказом от изменения и созданием нового на основе старого вместо мутаций. Последний прием подходит не всегда, но мы уже использовали его на практике, например, в рациональных числах.
	 
	 # Магические методы (__toString)
	 
	 Некоторые методы в классах имеют специальное предназначение и часто называются "магическими". Их легко отличить от других методов наличием двух подчеркиваний в начале имени метода. К таким методам относится и конструктор. Другим полезным и часто используемым методом является __toString. Его "магичность" заключается в том, что он вызывается автоматически, в тех ситуациях, когда объект используется как строка. К таким ситуациям относится интерполяция или конкатенация. Результат вызова этого метода используется как строковое представление объекта.
	 */
	 
	 class Point
	 {
		  public $x;
		  public $y;
	 
		  public function __construct($x, $y)
		  {
				$this->x = $x;
				$this->y = $y;
		  }
	 
		  public function getX()
		  {
				return $this->x;
		  }
	 
		  public function getY()
		  {
				return $this->y;
		  }
	 
		  public function __toString()
		  {
				return "({$this->x}, {$this->y})";
		  }
	 }
	 
	 $point = new Point(1, 10);
	 
	 // Автоматически вызывается __toString
	 echo $point; // => (1, 10)
	 
	 // и тут
	 $message = 'hello, ' + $point;
	 
	 // и тут
	 $message2 = "hi, {$point}";
	 
	 /*
	 Но этот же метод не вызовется если передать объект в print_r. Эта функция всегда пытается отобразить внутреннее представление того, что ей передали.
	 
	 __toString должен вернуть строку, иначе произойдет ошибка. Ошибка возникнет и в том случае, когда у объекта нет метода toString.
	 */
	 
	 echo $o; // PHP Catchable fatal error:  Object of class stdClass could not be converted to string
	 
	 // Документация: http://php.net/manual/ru/language.oop5.magic.php#object.tostring
	 
	 class Connection
	 {
		  protected $link;
		  private $dsn, $username, $password;
		  
		  public function __construct($dsn, $username, $password)
		  {
				$this->dsn = $dsn;
				$this->username = $username;
				$this->password = $password;
				$this->connect();
		  }
		  
		  private function connect()
		  {
				$this->link = new PDO($this->dsn, $this->username, $this->password);
		  }
		  
		  public function __sleep() // вызывается перед сериализацией ($connData = serialize($obj); unset($obj); $connData = unserialize($connData)). Должен возвращать массив с именами свойств для сериализации.
		  {
				return array('dsn', 'username', 'password');
		  }
		  
		  public function __wakeup() // вызывается после сериализации. Метод __construct не вызывается!
		  {
				$this->connect();
		  }
	 
		 public function __call($name, $args) // запускается при вызове недоступных методов в контексте объекта.
		 {
			 echo "Call method '{$name}' with arguments:" . implode(', ', $args);
		 }
	 
		 public function __callStatic($name, $args) // запускается при вызове недоступных статических методов в контексте объекта.
		 {
			 echo "Call static method '{$name}' with arguments:" . implode(', ', $args);
		 }
		 
		 public function __invoke($num, $action) // вызывается при обращении к объекту как к функции
		 {
			 // some code...
		 }
	 }
	 
	 
	 
	 
	 /*
	 #  Константы классов
	 
	 Напомню, что в PHP есть такая конструкция как константа. Она используется для хранения каких-то постоянных данных, которые, как правило, глобальные. Например, константа PHP_VERSION содержит версию PHP, в которой был запущен код (а его можно запустить на разных версиях интерпретатора). Эта константа относится к предопределенным (предоставляется интерпретатором). PHP позволяет создавать свои собственные константы, используя конструкцию const SEC_PER_DAY = 86400;. Эти константы принадлежат неймспейсу и могут быть импортированы из него, используя конструкцию use const App\Times\SEC_PER_DAY;.
	 
	 Класс встроен в язык http://php.net/manual/ru/class.datetime.php
	 */
	 class DateTime
	 {
		  const RSS = 'D, d M Y H:i:s O';
		  const RFC822 = 'D, d M y H:i:s O';
	 }
	 
	 // Внутри классов константы определяются точно таким же способом, как и снаружи. Основное отличие проявляется в способе доступа.
	 
	 print_r(DateTime::RSS); // => D, d M Y H:i:s O
	 
	 /*
	 Синтаксически обращение происходит с использованием двух двоеточий после имени класса, за которыми, в свою очередь, идет имя константы. Обратите внимание на отсутствие знака $. Для констант классов нет особого синтаксиса импорта. Он не нужен по очень простой причине - импортируется в другие неймспейсы всегда класс, а константа извлекается уже из него.
	 
	 Внутри класса к константе можно обратиться ровно таким же образом, но есть и другой способ:
	 */
	 class DateTime
	 {
		  /* ... */
	 
		  public function getRssFormat()
		  {
				return self::RSS;
		  }
	 }
	 
	 /*
	 В этом способе вместо имени класса слева стоит ключевое слово self. Его удобство заключается в отсутствии дублирования имени класса. Эта проблема особенно актуальна при активном использовании констант внутри самого класса.
	 
	 Предопределенные константы
	 Внутри класса определено несколько магических констант:
	 
	 __CLASS__ - текущее имя класса
	 __METHOD__ - текущее имя метода
	 В отличии от обычных констант, магические не требуют префикса self:: и доступны только внутри класса.
	 */
	 
	 class Example
	 {
		  public function printMethodName()
		  {
				print_r(__METHOD__);
		  }
	 }
	 
	 
	 // Кроме магических, в классах есть одна специальная константа class. Она возвращает полное имя класса и может вызываться только через класс.
	 
	 namespace App;
	 
	 class User
	 {
	 
	 }
	 
	 User::class; // => App\User
	 
	 /*
	 Эта константа возвращает полное имя класса относительно неймспейса, в котором происходит ее вызов.
	 
	 
	 
	 # Модификаторы доступа
	 
	 С версии PHP 7.1 константы обрели возможность иметь модификатор доступа. По умолчанию константы публичные, но если очень хочется, можно их сделать приватными.
	 */
	 
	 class DateTime
	 {
		  private const RSS = 'D, d M Y H:i:s O';
		  public const RFC822 = 'D, d M y H:i:s O';
	 }
	 
	 
	 namespace App;
	 
	 class Example
	 {
			 public function printMe()
			 {
				  print_r(self::class);
			 }
	 }
	 
	 $obj = new Example();
	 $obj->printMe(); // =>  App\Example
	 
	 /*
	 Документация: http://php.net/manual/ru/language.oop5.constants.php
	 
	 
	 Реализуйте недостающие части класса Timer, который описывает собой таймер обратного отсчета. Необходимо дописать конструктор принимающий на вход три параметра: секунды, минуты (необязательный) и часы (необязательный). Конструктор должен подсчитать общее количество секунд для переданного времени и записать его в свойство secondsCount.
	 
	 Воспользуйтесь константой SEC_PER_MIN для перевода минут в секунды (через умножение)
	 Реализуйте дополнительную константу SEC_PER_HOUR и воспользуйтесь ей для перевода часов в секунды
	 */
	 
	 $timer = new Timer(10);
	 $this->assertEquals(10, $timer->getLeftSeconds());
	 
	 
	 namespace App;
	 
	 class Timer
	 {
		  const SEC_PER_MIN = 60;
		  const SEC_PER_HOUR = 60 * self::SEC_PER_MIN;
		  private $secondsCount;
	 
		  public function __construct($sec, $min = 0, $hour = 0)
		  {
				$this->secondsCount = $sec + $min * self::SEC_PER_MIN + $hour * self::SEC_PER_HOUR;
		  }
	 
		  public function getLeftSeconds()
		  {
				return $this->secondsCount;
		  }
	 
		  public function tick()
		  {
				$this->secondsCount--;
		  }
	 }
	 
	 
	 
	 # Статические свойства
	 /*
	 Статическое свойство, в отличие от обычного свойства, принадлежит классу, а не инстансу. С точки зрения синтаксиса отличие только лишь в дополнительном ключевом слове static.
	 */
	 
	 namespace App;
	 
	 class User
	 {
		  public static $table = 'users';
	 }
	 
	 // Если попробовать обратиться к нему через объект, используя ->, то возникнет ошибка.
	 
	 $user = new User();
	 $user->table; // PHP Notice: Accessing static property App\User::$table as non static
	 
	 /*
	 Статическое свойство не часть объекта, то есть не часть его состояния. Основной способ обращения к статическому свойству похож на то, как мы обращались к константам. Статические свойства, подобно обычным свойствам, имеют область видимости. Их всегда можно сделать приватными.
	 */
	 print_r(User::$table); // => users
	 
	 /*
	 В отличии от констант, свойства требуют наличия знака $. Только не перепутайте: $table — это не имя переменной, а имя статического свойства.
	 
	 К свойствам все же можно обращаться, используя объекты, но это лишь синтаксический сахар. Объект в таком вызове используется только как способ понять, что это за тип.
	 */
	 
	 $user = new User();
	 $user::$table; // в реальности вместо $user подставляется класс
	 
	 /*
	 Такая возможность открывает доступ к полиморфизму, о котором мы еще будем разговаривать.
	 
	 К статическим свойствам можно обращаться не только снаружи, но и внутри объектов этого же типа. Как и в случае констант, есть два способа. Первый показан выше, когда мы указываем полное имя класса, второй способ использует уже знакомый нам self:
	 */
	 
	 class User
	 {
		  public static $table = 'users';
	 
		  public function getTable()
		  {
				return self::$table;
		  }
	 }
	 
	 $user = new User();
	 $user->getTable(); // users
	 
	 /*
	 Зачем?
	 Основная цель статических свойств — хранить информацию о типе в целом, безотносительно его экземпляров. Таким приемом часто пользуются для связи сущностей предметной области с базой данных. Например, в статическом свойстве удобно (но не всегда правильно) хранить имя соответствующей таблицы в базе данных. В случае с User выше, таблица называется users. Подобная возможность активно используется в ORM (фреймворк для отображения сущностей предметной области из базы в код и обратно).
	 
	 В идеале статические свойства класса должны инициализироваться при старте программы и никогда не меняться. Ведь статическое свойство по своим характеристикам является глобальной переменной. Если сохранять туда временные данные и менять их, то очень просто создать трудноподдерживаемый код с большим числом ошибок.
	 
	 По этой причине статические свойства часто делают приватными, а доступ снаружи оставляют через статические методы.
	 
	 Документация: http://php.net/manual/ru/language.oop5.static.php
	 
	 # Статические методы
	 */
	 
	 class User
	 {
		  private static $table = 'users';
	 
		  public static function getTable()
		  {
				return self::$table;
		  }
	 }
	 
	 User::getTable(); // users
	 
	 /*
	 Статические методы, как и свойства, не принадлежат экземплярам, они — часть типа. Следовательно, из статического метода невозможно получить доступ к объекту (ведь нет никакого объекта) через $this. $this внутри него просто не существует. Статические методы могут обращаться к другим статическим методам или статическим свойствам, используя self.
	 
	 Как я уже упоминал в предыдущем уроке, статические методы часто используют для доступа к приватным статическим свойствам. Причем, как геттеры, так и сеттеры, которые нужны редко, но все же бывают нужны.
	 
	 Но есть еще один способ использования статических методов, не связанный со статическими свойствами. Их используют как способ создать объект вместо прямого вызова конструктора через оператор new.
	 
	 Как вы помните, PHP (как, впрочем, и любой динамический язык) позволяет иметь ровно один конструктор для класса. В случае таких данных, как время, это - серьезное ограничение, потому, что нельзя одним конструктором описать все возможные способы создания дат, которые используются в коде.
	 */
	 
	 $date = new DateTime('2000-01-01');
	 
	 /*
	 В стандартной библиотеке PHP есть класс DateTime, который принимает на вход строчку определенного формата и возвращает соответствующий объект. А что, если в нашей программе формат времени другой? А если у нас вообще нет строчки, а есть отдельные числа? Естественным желанием было бы иметь разные конструкторы под разные задачи. Их у нас нет, но зато есть статические методы, которых можно создать столько, сколько нужно.
	 */
	 
	 // Специальная библиотека для работы с датами будет рассматриваться в следующем курсе
	 $vancouverTimeRightNow = Carbon::now('America/Vancouver');  //implicit __toString()
	 $noonTodayLondonTime = Carbon::createFromTime(12, 0, 0, 'Europe/London');
	 $internetWillBlowUpOn = Carbon::create(2038, 01, 19, 3, 14, 7, 'GMT');
	 
	 // Как видно из кода выше, статические методы имеют разные сигнатуры, но внутри они, так или иначе, вызывают конструктор, передвая туда уже подготовленные параметры. Конструктор можно вызывать двумя способами: первый — использовать полное имя класса, второй — черезself. Второй способ предпочтительнее просто потому, что позволяет не дублировать имя класса.
	 
	 class Carbon
	 {
		  public static function now($timezone = '')
		  {
				return new self(date("Y-m-d H:i:s"), $timezone);
		  }
	 }
	 
	 /*
	 Подводя итог, можно сказать, что статические методы используют как фабрику объектов в случаях, когда создание объекта достаточно сложное и требует некоторых манипуляций.
	 
	 Еще есть третий способ использования статических методов — глобальные функции неймспейса. Такой способ особенно популярен в языках типа Java, где физически невозможно создать функцию вне класса. В PHP очень похожая модель, и, хотя создавать функции можно в обычных неймспейсах, по факту делают так редко. Одна из причин связана с наличием автозагрузки классов, такой способ банально удобнее с точки зрения лени. С точки зрения "правильности" такой код скорее "неправильный". Если статическая функция не порождает объектов данного типа, или хотя бы не использует статические свойства, то непонятно, почему она вообще оказалась в этом классе. Но это в теории. На практике есть устоявшиеся нормы и традиции. В своей практике, работая в проектах, построенных на классовой модели (не все проекты в PHP разрабатываются именно так), вы будете встречать код, который почти всегда принадлежит тому или иному классу.
	 
	 Документация: http://php.net/manual/ru/language.oop5.static.php
	 
	 
	 Добавьте в класс Time статический метод fromString, который позволяет создавать инстансы Time на основе времени переданного строкой формата часы:минуты.
	 */
	 
	 $time = Time::fromString('10:23');
	 $this->assertEquals('10:23', $time->toString());
	 
	 
	 namespace App;
	 
	 class Time
	 {
		  private $h;
		  private $m;
	 
		  public static function fromString($time)
		  {
				[$h, $m] = explode(':', $time);
				
				return new self($h, $m);
		  }
	 
		  public function __construct($h, $m)
		  {
				$this->h = $h;
				$this->m = $m;
		  }
	 
		  public function toString()
		  {
				return "{$this->h}:{$this->m}";
		  }
	 }
	 
	 
	 
	 
	 # Интерфейсы (Конструкция языка `interface`)
	 /*
	 Интерфейс в PHP — конструкция языка, описывающая абстрактный типы данных (АТД). Напомню, что АТД (https://ru.wikipedia.org/wiki/Абстрактный_тип_данных) определяет набор операций (функций), независимых от конкретной реализации типа (в нашем случае класса) для манипулирования его значениями. На практике интерфейсы содержат определения функций (то есть описание их сигнатур) без их реализации.
	 
	 
	 Хотя данная конструкция для нас в новинку, само понятие интерфейса используется на протяжении всего курса. В первую очередь это касается рассуждений о рассматриваемом типе. Для оперирования точками на плоскости нам не нужна "реализация" точек. Достаточно того, что мы представляем их визуально и знаем операции, выполняемые над ними. То же самое касается и более базовых концепций, например, чисел и любых арифметических операций. Задумывались ли вы над тем, как на самом деле выполняются арифметические операции? Ответ на этот вопрос гораздо сложнее, чем может показаться на первый взгляд, и он зависит не только от языка, но и от конкретного аппаратного обеспечения (железа). Однако незнание ответа не мешает нам пользоваться числами, строками и массивами, не зная их устройства.
	 */
	 // FILE: DecartPointInterface.php
	 
	 namespace App;
	 
	 // Интерфейсы, по аналогии с классами, хранятся в своих собственных файлах
	 // и загружаются автоматически при следовании стандарту PSR4.
	 
	 // Имя интерфейса может быть любым, главное - соответствие PSR4.
	 
	 interface DecartPointInterface
	 {
		  public function __construct($x, $y);
		  public function getX();
		  public function getY();
	 }
	 
	 /*
	 То, что раньше мы описывали словами и держали в голове, теперь явно записано в виде кода. Декартова точка — это АТД с тремя операциями:
	 
	 - Создание точки из двух значений
	 - Извлечение координаты X
	 - Извлечение координаты Y
	 
	 По сути, прикладному коду больше ничего знать о точках и не нужно. Естественно, если нам понадобятся новые операции, то мы всегда можем их добавить, тем самым расширив интерфейс. Свои собственные АТД можно менять как угодно и когда угодно, только учтите, что изменение интерфейса влечет за собой исправления кода, использующего этот интерфейс.
	 
	 Сама по себе конструкция Interface никак не влияет на остальной код. Недостаточно просто создать интерфейс, в этом нет смысла. Интерфейс должен быть реализован, и тогда он начнет приносить пользу.
	 */
	 
	 namespace AnotherApp;
	 
	 // Импорт интерфейса
	 use App\DecartPointInterface;
	 
	 class DecartPoint implements DecartPointInterface
	 {
		  private $x;
		  private $y;
	 
		  // Интерфейсные функции
		  public function __construct($x, $y)
		  {
				$this->x = $x;
				$this->y = $y;
		  }
	 
		  public function getX()
		  {
				return $this->x;
		  }
	 
		  public function getY()
		  {
				return $this->y;
		  }
	 
		  // Не интерфейсные функции
	 
		  public function __toString()
		  {
				return "({$this->getX()}, {$this->getY()})";
		  }
	 }
	 
	 /*
	 Реализация интерфейса происходит за счет ключевого слова implements, за которым идет название интерфейса. Интерпретатор проверяет, чтобы в классе были описаны все функции интерфейса и их сигнатуры совпадали, а если это не так, то возникает ошибка. Реализация интерфейса никак не ограничивает возможности по наполнению класса, другими словами, вы можете определять и добавлять в класс все, что хотите, помимо интерфейсных функций.
	 
	 Сами по себе интерфейсы мало полезны. Например, можно в любой программе открыть все файлы с классами и удалить часть определения класса, которая описывает реализацию интерфейсов (слово implements и то что идет за ним). После этого не изменится ровным счетом ничего - программа продолжит выполняться так же, как и выполнялась. Но ситуация меняется, если использовать интерфейс в сигнатурах функций и методов вместо классов.
	 */
	 
	 function compare(DecartPointInterface $point1, DecartPointInterface $point2)
	 {
		  // ...
	 }
	 
	 /*
	 Во время выполнения программы PHP проверяет, реализует ли класс соответствующий интерфейс, и если нет, то возникает ошибка. Причем проверка идет именно на наличие записи implements в определении класса, а не на факт того, что методы определены (проверка реализации интерфейса гарантирует это).
	 
	 Такая запись позволяет коду завязываться не на конкретную реализацию точек, а на их интерфейс. Это - ключевая мысль, которую имеет смысл обсуждать подробнее вместе с полиморфизмом.
	 
	 Countable
	 В PHP встроен интерфейс Countable, а функция count умеет работать с любым объектом, реализующим этот интерфейс.
	 */
	 
	 class Collection implements Countable
	 {
		  private $items;
		  
		  public function __construct($items = [])
		  {
				$this->items = $items;
		  }
		  
		  public function count()
		  {
				return sizeof($this->items);
		  }
	 }
	 
	 $coll = new Collection([3, 2, 5]);
	 print_r(count($coll));
	 
	 /*
	 Документация:
	 Интерфейсы: http://php.net/manual/ru/language.oop5.interfaces.php
	 Утиная типизация: https://ru.wikipedia.org/Утиная_типизация
	 Принцип инверсии зависимостей: https://ru.wikipedia.org/wiki/Принцип_инверсии_зависимостей
	 
	 /**
	 Реализуйте класс User, который создает пользователей. Конструктор класса принимает на вход два параметра: идентификатор и имя.
	 
	 Реализуйте интерфейс Comparable для класса User. Сравнение пользователей происходит на основе их идентификатора.
	 **/
	 $user1 = new User(4, 'tolya');
	 $user2 = new User(1, 'petya');
	 
	 $user1->compareTo($user2); // false
	 
	 // FILE: Comparable.php
	 
	 interface Comparable
	 {
		  public function compareTo($obj);
	 }
	 
	 
	 
	 // FILE: User.php
	 
	 class User implements Comparable
	 {
		  private $id;
		  private $name;
	 
		  public function __construct($id, $name)
		  {
				$this->id = $id;
				$this->name = $name;
		  }
	 
		  public function getId()
		  {
				return $this->id;
		  }
	 
		  public function compareTo($user)
		  {
				return $this->getId() === $user->getId();
		  }
	 }
	 
	 /*
	 #  Плюсы и минусы разных способов организации абстракций
	 
	 
	 Теперь, после того, как мы немного поработали с объектами, давайте попытаемся ответить на вопрос: "какую такую задачу они решают, которую не решают абстракции на основе обычных функций + ассоциативный массив как структура"?
	 
	 Изложенные ниже тезисы могут показаться вам совсем чуждыми и непонятными в силу отсутствия опыта. В этом нет ничего страшного, главное - увидеть направления, а отработкой мы займемся в следующих курсах.
	 
	 Перед тем как начать уходить глубже в тему объектов, хочу вас предостеречь. ООП в современном мире воспринимается большим числом программистов (особенно начинающими), как серебряная пуля, как средство от всех болезней. Учитывая, что в PHP это основной способ строить абстракции, у вас может сложиться такое же впечатление. Но это не так. Во-первых, под ООП понимают две абсолютно разные концепции. Та, которую мы обсуждаем, является мейнстримом, и встроена во многие языки настолько глубоко, что писать в другом стиле либо невозможно, либо очень тяжело. Но есть и другая, созданная Аланом Кеем. Что интересно, именно Алан является создателем термина ООП, но его ООП не имеет почти ничего общего с тем, что сейчас называется ООП.
	 
	 ООП для меня это сообщения, локальное удержание и защита, скрытие состояния и позднее связывание всего. Это можно сделать в Smalltalk и в LISP. Alan Key
	 
	 Во-вторых, существуют другие способы получить поведение, похожее на то, которое вы будете наблюдать в ООП-коде. Более того, многие из них значительно мощнее в возможностях (и некоторые появились задолго до ООП-языков). Например, мультиметоды в языке Clojure дают большую свободу (мультидиспетчеризацию) и позволяют строить полиморфизм на специализированных функциях.
	 
	 В общем и целом, чем больше разных по структуре языков и парадигм вы знаете, тем лучше понимаете, что происходит. Рекомендую: clojure, haskell, elixir, kotlin и js (последний стандарт).
	 
	 Преимущества
	 1. Пожалуй, основное преимущество связано с полиморфизмом подтипов. Подробно эта тема освещается позже. Сейчас лишь скажу, что если мы вызываем функцию, то это всегда некоторая конкретная функция, импортированная из конкретного неймспейса. А вот если мы вызываем метод, то появляются варианты. Когда интерпретатор доходит до кода с вызовом метода $obj->methodCall(), он не может сразу сказать, где определен данный метод, потому что ответ на этот вопрос зависит от того, какой тип у $obj. Отсюда следует, что, если разные объекты содержат методы с одинаковым именем (и сигнатурой), то их можно прозрачно (для вызывающего кода) подменять. На практике такая возможность местами упрощает код (становится меньше условных конструкций), но главное — делает его расширение проще.
	 
	 2. Работа с абстракцией, основанной на ассоциативном массиве, таит в себе один сюрприз. Так как любая сущность представляется этим массивом, то можно по ошибке вызывать функцию, предназначенную для одной абстракции (например, точки), на другой абстракции (например, сегменте). Что при этом произойдет — непонятно, и зависит от того, насколько удачно совпали структуры. И если такое произошло, то функция внезапно может отработать без ошибок и даже что-то вернуть. В итоге программа продолжит работать некорректно, вместо того, чтобы завершиться с ошибкой. Инкапсуляция исключает подобную ситуацию. Вызываемый метод всегда принадлежит тому объекту, на котором он вызывается. Если метода нет, то будет ошибка, если есть — то он отработает так, как и должен отработать. Но это преимущество является преимуществом только при сравнении с абстракциями, построенными на общих структурах данных (и в динамических языках), такими, как ассоциативные массивы. В языках с развитой системой типов (но без ООП), например, в haskell, подобной проблемы также нет.
	 */
	 
	 $segment = makeSegment(makePoint(1, 3), makePoint(10, 11));
	 // Функция отработает, хотя в нее передали сегмент, а не точку
	 getX($segment); // getX - функция, предназначенная для работы с точками
	 
	 /*
	 3. Это преимущество немного неожиданно. Возможность вызывать методы у объектов открывает дорогу к автокомплиту в редакторах. Да-да! Именно благодаря такому способу вызова редактор может подсказать список методов, которые есть у данного объекта. Если вы сначала пишите функцию, а затем передаете туда данные, то вы должны знать про существование функции заранее. Но тут нужно оговориться. Вызов функции после данных не является прерогативой ООП. В некоторых современных языках (Nim, D, Rust) поддерживается Unified Function Call, который позволяет проделывать такой же трюк с обычными функциями. Ниже пример на языке Nim (https://nim-lang.org/).
	 */
	 
	 # Создается тип Vector, представляющий из себя кортеж из двух элементов
	 type Vector = tuple[x, y: int]
	 
	 # Определяется функция, принимающая на вход два вектора и возвращающая новый вектор,
	 # полученный сложением исходных векторов
	 proc add(a, b: Vector): Vector =
		(a.x + b.x, a.y + b.y)
	 
	 let
		# Создается переменная v1, содержащая вектор
		v1 = (x: -1, y: 4)
		# Создается переменная v2, содержащая вектор
		v2 = (x: 5, y: -2)
	 
		# Обычный вызов функции
		v3 = add(v1, v2)
	 
		# Вызов через точку: v1 передается в функцию add первым параметром
		v4 = v1.add(v2)
	 
		# Цепочка вызовов. Результат предыдущего вычисления всегда передается первым параметром в следующий
		v5 = v1.add(v2).add(v1)
	 
	 /*
	 4. Реализация ООП в PHP содержит конструкции для обеспечения data hiding. Справедливости ради скажу, что, несмотря на это, их всегда можно обойти (например, используя Reflection API). Причем не только в PHP, но и в других языках с похожей моделью, например, в Java. С другой стороны, практика показывает, что отсутствие таких механизмов не создает больших проблем при работе. К таким языкам относится JavaScript.
	 
	 Недостатки
	 1. Инкапсуляция. Как и всегда в инженерной деятельности, за возможности нужно платить. Инкапсуляция, при всех своих плюсах, создает огромную проблему. Расширяемость поведения объекта падает до нуля. Если мы работаем с обычными функциями, то достаточно написать новую функцию, чтобы можно было продолжать работать. Когда речь заходит про инкапсуляцию, то все не так. Дело в том, что методы описываются в классах. В PHP класс можно описать ровно один раз. И большая часть этих классов приходит в проекты из сторонних библиотек. Как только понадобится расширить поведение любого стороннего класса, мы сразу сталкиваемся с проблемами. Любой код из библиотек поставляется как есть, и мы не можем открыть исходный код любой библиотеки и внести необходимые нам правки. По этой причине расширяемость поведения объектов в ООП языках — головная боль. Как правило, создатели класса пытаются заботиться об этом сами, давая возможность расширять свое поведение снаружи (если это возможно). Существуют языки, в которых эту проблему пытаются решать, позволяя "дописывать" определение класса по ходу работы программы, - например, в Ruby. В js то же самое достигается за счет механизма прототипов. Языки, в которых функции и данные разделены не имеют подобного недостатка, и код на них пишется, как ни странно, легче и проще (хотя местами многословнее). Сюда же можно отнести проблему, называемую антипаттерном (плохой реализацией) god object.
	 
	 Если вы уже немного знакомы с ООП, то можете подумать, что наследование спасает от этой проблемы. Так вот, наследование не просто не спасает, но и само по себе является проблемой. Об этом я расскажу в соответствующем курсе, когда мы разберем суть наследования как отношения между типами, и ограничениями, без которых наследование невозможно.
	 
	 2. Представление любой мало-мальской сущности в языке с помощью пользовательского типа сильно раздувает программу. А сущности часто создают только по той причине, что не нашлось подходящего под нее типа (в котором логично было бы описать ее). Существует миф о том, что программы, написанные в ООП-стиле (на самом деле имеется ввиду та самая модель ООП, которая используется в языках типа PHP или Java), при больших размерах оказываются относительно компактными по объему кода. В реальности все с точностью до наоборот. Программы на языке Clojure компактнее аналогов на PHP во много раз. И чем больше кода, тем больше разрыв. Эта тема настолько животрепещущая, что кто-то не поленился и создал проект-шутку FizzBuzzEnterpriseEdition. К тому же, появляются проблемы с ответственностями. Собака должна есть еду ($dog->eat($food)), или же еда съедается собакой ($food->eatBy($dog))? Несмотря на кажущуюся абсурдность, подобная проблема реальна и проявляется очень часто.
	 
	 3. Думаю, что влияние этого пункта вы уже ощутили на себе, хотя мы только начали. Слишком много языковых сущностей (Бритва Оккама). В PHP постоянно добавляют новые возможности по реализации ООП. Вот лишь некоторые из них: абстрактные классы, анонимные классы, интерфейсы, статические методы, видимость методов, видимость свойств, видимость констант, трейты, магические методы, наследование. И это только ключевые слова. А все эти механизмы могут взаимодействовать друг с другом, порождая неведомые комбинации, у каждой из которых есть свое особенное поведение и ограничения. В итоге одно и то же поведение можно реализовать десятком разных способов. Приходится знать тысячи нюансов и постоянно решать споры о том, какой подход лучше.
	 
	 Видео: Изоморфизм Рича Хикки https://www.youtube.com/watch?v=b-Eq4YV4uwc
	 
	 
	 
	 Реализуйте класс Url который описывает переданный в конструктор HTTP адрес и позволяет извлекать из него части:
	 */
	 
	 $url = new Url('http://yandex.ru?key=value&key2=value2');
	 $url->getScheme(); // http
	 $url->getHost(); // yandex.ru
	 $url->getQueryParams();
	 // [
	 //     'key' => 'value',
	 //     'key2' => 'value2'
	 // ];
	 $url->getQueryParam('key'); // value
	 // второй параметр - значение по умолчанию
	 $url->getQueryParam('key2', 'lala'); // value2
	 $url->getQueryParam('new', 'ehu'); // ehu
	 
	 
	 // FILE: UrlInterface.php:
	 namespace App;
	 
	 interface UrlInterface
	 {
		  public function getScheme();
		  public function getQueryParams();
		  public function getQueryParam($key, $defaultValue = null);
		  public function getHost();
		  public function getQuery();
	 }
	 
	 namespace App;
	 
	 // FILE: UrlInterface.php
	 
	 class Url implements UrlInterface
	 {
		 private $url;
		  private $scheme;
		  private $host;
		  private $queryParams;
	 
		  public function __construct($url)
		  {
				$data = parse_url($url);
	 
				$this->scheme = $data['scheme'];
				$this->host = $data['host'];
				$this->query = $data['query'];
				$this->queryParams = $this->parseQuery($data['query']);
		  }
	 
		  public function getScheme()
		  {
				return $this->scheme;
		  }
	 
		  public function getQueryParams()
		  {
				return $this->queryParams;
		  }
	 
		  public function getQueryParam($key, $defaultValue = null)
		  {
				return $this->queryParams[$key] ?? $defaultValue;
		  }
	 
		  public function getHost()
		  {
				return $this->host;
		  }
	 
		  public function getQuery()
		  {
				return $this->query;
		  }
	 
		  private function parseQuery($query)
		  {
				$parts = explode('&', $query);
				
				return array_reduce($parts, function ($acc, $item) {
					 [$key, $value] = explode('=', $item);
					 $acc[$key] = $value;
					 return $acc;
				}, []);
		  }
	 }
	 
	 
	 /*
	 #  Плюсы и минусы разных способов организации абстракций
	 
	 В PHP есть функция, которая называется strpos($text, $substr). Она ищет подстроку $substr внутри текста $text и возвращает индекс начала этой подстроки в тексте. Что произойдет если подстрока не была найдена? Является ли это поведение ошибкой? Нет. Это штатное поведение функции. От того что подстрока не была найдена, ничего страшного не случилось. Представьте себе любой редактор текста и механизм поиска внутри него. Ситуация когда ничего не было найдено, возникает постоянно и это не ломает работу программы.
	 
	 Кстати, посмотрите в документацию этой функции, каким образом она говорит о том что подстрока не была найдена?
	 
	 Другая ситуация. В тех же редакторах есть функция "открыть файл". Представьте что во время открытия файла, что-то пошло не так, например его удалили. А это ошибка или нет? Да, в этой ситуации произошла ошибка, но это не ошибка программирования. Подобная ошибка может возникуть всегда, независимо от желания программиста. Он не может избежать ее появления. Единственное что он может, правильно реализовать ее обработку.
	 
	 Еще один интересный вопрос, насколько это критичная ошибка? Должно ли оно приводить к остановке всего приложения или нет? В плохо написанных приложениях, там где неправильно реализована обработка ошибок, такая ситуация приведет к краху всего приложения и оно завершится. В хорошо написанном приложении не произойдет ничего страшного. Пользователь увидит предупреждение о том что, файл не читается и сможет выбрать дальнейшие действия, например, попытаться прочитать его снова или выполнить другое действие.
	 
	 Сказанное выше имеет очень серьезные следствия. Одна и та же ситуация, на разных уровнях может как являться ошибкой, так и быть вполне штатной ситуацией. Например если задача функции читать файл, а она не смогла этого сделать, то, с точки зрения этой функции, произошла ошибка. Должна ли она приводить к остановке всего приложения? Как мы выяснили выше – не должна. О том насколько критична данная ситуация, может решать приложение которое использует эту функцию, но не сама функция.
	 
	 Коды возврата
	 В языках появившихся до 1990 года (примерно), обработка ошибок выполнялась через механизм возврата специального значения функцией. Например в СИ, если функция не может выполнить свою задачу, то она должна вернуть специальное значение, либо NULL либо отрицательное число. Значение этого числа, говорит о том какая ошибка произошла. Например:
	 */
	 int write_log()
	 {
		  int ret = 0; // return value 0 if success
		  FILE *f = fopen("logfile.txt", "w+");
	 
		  // Проверяем, получилось ли открыть файл
		  if (!f)
				return -1;
	 
		  // Проверяем, что не достигли конца файла
		  if (fputs("hello logfile!", f) != EOF) {
				// continue using the file resource
		  } else {
				// Файл закончился
				ret = -2;
		  }
	 
		  // Не получилось закрыть файл
		  if (fclose(f) == EOF)
				ret = -3;
	 
		  return ret;
	 }
	 
	 /*
	 Обратите внимание на условные конструкции и постоянное присваивание переменной ret. Фактически каждая потенциально опасная операция, должна проверяться на успешность выполнения. Если что-то пошло не так, то функция возвращает специальный код.
	 
	 И вот тут начинаются проблемы. Как показывает жизнь, в большинстве ситуаций, ошибка обрабатывается не там где она возникла и даже не уровнем выше. Предположим, что есть функция A, которая вызывает код, потенциально приводящий к ошибке, и она его должна уметь правильно обработать и сообщить пользователю о проблеме. При этом сама ошибка происходит внутри функции E, которая вызывается внутри A не напрямую, а через цепочку функций: A => B => C => D => E. Подумайте, к чему приводит такая схема? Все функции в этой цепочке, даже не смотря на то что они не обрабатывают ошибку, обязаны знать про нее, отлавливать ее и так же возвращать наружу код этой ошибки. В результате, количество кода, который занимается ошибками, становится так много, что за ним теряется код, выполняющий исходную задачу.
	 
	 Стоит сказать, что существуют схемы обработки ошибок, которые не обладают такими недостатками, но работают по принципу возврата. Например монада Either.
	 
	 
	 # Исключения
	 
	 Именно на этом фоне и возник механизм исключений. Его главная цель, передать ошибку из того места где она возникла, в место где ее можно обработать минуя все промежуточные уровни. Другими словами, механизм исключений раскручивает стек вызовов самостоятельно.
	 
	 С исключениями нужно запомнить две вещи: Код в котором произошла ошибка – бросает исключение, код, в котором ошибка обрабатывается – ловит.
	 */
	 
	 // Функция которая может бросить исключение
	 function fileread($filepath) {
		  if (!is_readable($filepath)) {
				throw new \Exception("'{$filepath}' is not readble");
		  }
		  // ...
	 }
	 
	 // Где-то в другом месте программы
	 
	 function run()
	 {
		  try {
				// Функция, которая вызывает filepath. Возможно не напрямую, а через другие функции.
				// Для механизма исключений это не важно.
				openFile($filepath);
		  } catch (\Exception $e) {
				// Этот блок выполняется только в одном случае, если в блоке try было "возбуждено" (выброшено) исключение
				showErrorToUser($e);
		  }
		  // Если тут будет код, он продолжит выполняться
	 }
	 
	 /*
	 Сами исключения это объекты класса \Exception и его наследников (о наследовании в одном из следующих курсов). Этот объект содержит внутри себя сообщение переданное в конструктор, бектрейс и другие полезные данные:
	 */
	 Exception implements Throwable {
		  protected string $message;
		  protected int $code;
		  protected string $file;
		  protected int $line;
	 
		  public __construct ([ string $message = "" [, int $code = 0 [, Throwable $previous = NULL ]]] )
		  final public getMessage ( void ) : string
		  final public getPrevious ( void ) : Throwable
		  final public getCode ( void ) : mixed
		  final public getFile ( void ) : string
		  final public getLine ( void ) : int
		  final public getTrace ( void ) : array
		  final public getTraceAsString ( void ) : string
		  public __toString ( void ) : string
	 }
	 
	 // Бросить исключение проще простого, достаточно использовать инструкцию throw:
	 
	 $e = new \Exception('Тут любой текст');
	 throw $e; // исключение можно создать отдельно, а можно сразу же там где используется throw
	 
	 /*
	 throw прерывает дальнейшее выполнение кода. В этом смысле оно подобно return, но в отличии от него, прерывает выполнение не только текущей функции, но и всего кода, вплоть до ближайщего в стеке вызовов блока catch.
	 
	 Блок try/catch обычно ставится на самом верхнем уровне программы, но это не обязательно. Вполне вероятно, что есть несколько промежуточных блоков, которые могут отлавливать ошибки и снова их возбуждать. Эта тема достаточно сложная и требует некоторого опыта работы.
	 
	 PHP
	 Когда PHP только появился, то в нем не был реализован механизм исключений. Поэтому многие функции либо возвращают какие-то значения указывающие на ошибку, либо об ошибке можно узнать с помощью специальных ухищрений. Эти подходы пришли прямиком из си и в современных языках больше нигде не встречаются. Все еще ухудшается наличием альтернативного механизма: Notice, Warning, Fatal. К счастью в новых версиях PHP эти ошибки заменяют на исключения, но вряд ли когда-нибудь произойдет полный переход. Написано слишком много кода и язык должен сохранять обратную совместимость.
	 
	 Например обработка ошибок парсинга json в PHP, реализована крайне странно, по современным меркам. Чтобы узнать об ошибке, нужно вызвать функцию json_last_error() сразу после парсинга. А текст ошибки получается функцией json_last_error_msg().
	 
	 Библиотека safe https://github.com/thecodingmachine/safe
	 */
	 
	 
	 /**@@
	 Реализуйте функцию json_decode, которая работает почти как встроенная, но вместо возврата ошибки, выбрасывает исключение \Exception.
	 */
	 
	 use App\Safe;
	 
	 // Второй параметр, соответствует второму параметру во встроенной функции json_encode
	 // Его нужно передать как есть во внутренний вызов встроенной функции json_decode
	 $data = Safe\json_decode('{ "key": "value" }', true);
	 // ['key' => 'value']
	 
	 /*
	 Подсказки
	 Проверить наличие ошибок парсинга можно так: json_last_error() !== JSON_ERROR_NONE. Здесь используются специальная функция и константа, определенные в PHP.
	 */
	 
	 
	 // FILE: Safe.php
	 namespace App\Safe;
	 
	 function json_decode($json, $assoc = false)
	 {
		  $data = \json_decode($json, $assoc);
		  
		  if (json_last_error() !== JSON_ERROR_NONE) {
				throw new \Exception(json_last_error_msg());
		  }
		  
		  return $data;
	 }
	 
	 
	 
	 
	 ################################### Объектно-ориентированный дизайн  ###################################
	 
	 /*
	 Fluent Interface
	 stdClass - встроенный в PHP класс, который автоматически используется при преобразовании типов
	 Структуры данных - ОО-версии популярных структур данных.
	 PHPUnit - фреймворк для тестирования в PHP
	 Collect - библиотека для работы с коллекциями в ОО-стиле
	 Carbon - библиотека для работы с датами в ОО-стиле
	 Stringy - библиотека для работы со строками в ОО-стиле
	 
	 
	 Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. (Wiki)
	 
	 Простым языком, определение звучит так: типовое решение для типовой задачи. Термин пришел в программирование из архитектуры. В 1970-е годы архитектор Кристофер Александр составил набор шаблонов проектирования, типовых решений для различных архитектурных задач. Спустя полтора десятка лет эта идея была заимствована и адаптирована применительно к разработке графических оболочек языка SmallTalk. Сейчас паттерны встречаются повсеместно, постоянно изобретаются и переизобретаются. Некоторые из них описывают задачи, связанные с небольшим участком кода, другие определяют, например, способы работы в распределенных системах. Причем последние отвязаны от языка программирования. Интересный факт: некоторые шаблоны в языках появились вследствие ограничений самих языков и пытаются обойти их.
	 
	 Как минимум один паттерн проектирования мы уже знаем по уроку "статические методы". Его называют Фабрика. Фабрика - функция, порождающая объекты, создание которых сложнее, чем просто передача данных в конструктор.
	 */
	 class Carbon
	 {
		  public static function now($timezone = '')
		  {
				return new self(date("Y-m-d H:i:s"), $timezone);
		  }
	 }
	 
	 /*
	 Паттерн фабрика никак не завязан ни на статические методы, ни на объектно-ориентированное программирование, ни на конкретный язык. Ключевое в этом шаблоне - "функция порождает данные"; чем являются данные (хоть объекты, хоть функции - те самые объекты первого рода) или функция - не важно. В статических языках подобные паттерны определяются строже из-за необходимости согласования типов.
	 
	 Возможно, вы удивитесь, что для такой примитивной задачи придуман целый паттерн, и будете правы. Паттерн - не обязательно что-то сложное и доступное только избранным. Паттерном называют любую задачу, которая повторяется безотносительно оценки сложности решения. Поэтому, хотите вы того или нет, в вашем коде уже встречаются шаблоны проектирования, даже если вы об этом не знаете. Правда, до некоторых типовых решений самостоятельно дойти крайне сложно.
	 
	 Насколько важно изучать шаблоны проектирования? Не отрицая полезность, предупрежу, что большинство описаний шаблонов в интернете завязано на конкретную книгу (https://ru.wikipedia.org/wiki/Design_Patterns). Далеко не все паттерны, описанные в ней полезны и встречаются в обычной жизни. Многие из них специфицированы под конкретные языки и не применимы в том же виде в других языках. Еще больше паттернов (на порядки) в этой книге не описано.
	 
	 Как только появились паттерны, то не могли не появиться и антипаттерны. Антипаттерн - такое же типовое решение (потому что им часто пользуются), но создающее больше проблем, чем приносящее пользы. Обычно такие решения возникают из-за непонимания причинно-следственных связей в коде.
	 
	 Дополнительные материалы:
	 Антипаттерн: https://ru.wikipedia.org/wiki/Антипаттерн
	 Паттерны без привязки к языку: https://github.com/Hexlet/patterns/tree/master/content
	 
	 # Конфигурация
	 
	 Markdown - упрощенный язык разметки, который удобен при работе с текстом (в отличие от HTML). Браузеры не умеют отображать markdown напрямую, поэтому он транслируется в HTML и уже затем показывается. Трансляция markdown в HTML описывается чистой функцией. Она не зависит от внешнего окружения, детерминирована и не порождает побочных эффектов.
	 */
	 
	 $html = markdownToHtml($markdown);
	 
	 // На входе текст (в формате markdown), на выходе - тоже текст (в формате html). Если нужно изменить поведение трансляции, то достаточно передать вторым параметром массив опций.
	 
	 $html = markdownToHtml($markdown, ['sanitize' => false]);
	 
	 /*
	 Теперь давайте вообразим объектно-ориентированную версию этого кода. Перед тем, как двигаться дальше, попробуйте отвлечься от чтения и подумайте над следующими вопросами:
	 
	 Что мы вообще хотим получить такого от ООП, чего не дает нам чистая функция?
	 Как будет выглядеть получившийся интерфейс?
	 Как вы помните, ключевая идея ООП - абстракция данных. Можно ли сказать, что в процессе преобразования markdown в HTML есть абстракция? Нет. Абстракция подразумевает наличие некоторого понятия (типа), значения которого обладают временем жизни. Это значит, что она создается и затем многократно и по-разному используется. Например, невозможно представить работу с пользователем в виде одной функции. Если говорить о markdown, то конкретный текст этого формата не интересует нас сам по себе, мы не определяем над ним некоторый набор операций и не собираемся им активно пользоваться. Все, что мы хотим, прямо здесь и сейчас (в том коде) - получить HTML и забыть про markdown.
	 
	 Если бы мы хотели построить вокруг текста абстракцию, то код выглядел бы так:
	 */
	 
	 $md = new Markdown($markdown);
	 $html = $md->render();
	 
	 /*
	 В примере выше тип Markdown представляет собой абстракцию над текстом в формате markdown. Смысла в таком коде мало, а вот проблем он доставит. Эти две строчки начнут неразрывно встречаться в каждом месте, в котором требуется получить HTML. Объект $md становится сразу не нужен, как только получен HTML, у него нет времени жизни. Такой антипаттерн особенно часто встречается у новичков. Загвоздка здесь именно в том, чтобы разобраться, где у нас абстракция данных, а где нет.
	 */
	 
	 $md1 = new Markdown($markdown1);
	 $html1 = $md->render();
	 
	 $md2 = new Markdown($markdown2);
	 $html2 = $md2->render();
	 
	 /*
	 Существует формальное правило, позволяющее это определить. Если создание объекта и вызов метода можно заменить на обычную функцию, то ни о какой абстракции речи не идет, и правильный подход, в данной ситуации, сводится к переносу данных из конструктора в сам метод.
	 */
	 
	 $md = new Markdown();
	 // очень важно, чтобы render оставался чистой функцией и не сохранял $markdown внутри объекта
	 $html1 = $md->render($markdown1);
	 $html2 = $md->render($markdown2);
	 
	 /*
	 В этом коде Markdown - тип, относящийся к транслятору, а не к тексту. У такого объекта жизненный цикл шире, чем ожидание однократного вызова функции render (как в предыдущем случае). Он может (и должен) переиспользоваться столько раз, сколько потребуется. Для этого важно оставить функцию render чистой и не менять состояние объекта между вызовами.
	 
	 Тогда становится непонятно, зачем здесь вообще объект. И на это есть 3 причины.
	 
	 Идиоматика. В PHP, как и в Java, принято практически все оформлять в виде классов. К тому же для них работает автозагрузка.
	 Полиморфизм подтипов. Разберем в последущих курсах.
	 Третья и главная причина (для данного случая) - Конфигурация.
	 Разберем последний пункт подробнее. Представьте что маркдаун на проекте используется повсеместно (на Хекслете очень часто) и код генерации HTML выглядит так:
	 */
	 
	 // В одном месте
	 $html1 = markdownToHtml($markdown1, ['sanitaize' => true]);
	 
	 // Где-то в другом месте
	 $html2 = markdownToHtml($markdown2, ['sanitaize' => true]);
	 
	 /*
	 Чем больше возникает таких мест, тем больше дублируется передача опций. Изменение поведения потребует переписывания всех мест вызова этой функции. Логичным шагом было бы задать опции в одном месте и затем их переиспользовать.
	 */
	 
	 // В одном месте
	 $html1 = markdownToHtml($markdown1, $options);
	 
	 // Где-то в другом месте
	 $html2 = markdownToHtml($markdown2, $options);
	 
	 /*
	 Использование объекта позволяет убрать явную передачу (про которую легко забыть). Суть этого паттерна заключается в конфигурировании. То есть объект в данном случае выступает в роли контейнера, содержащего опции для markdown, которые применяются при рендеринге, что позволяет их не передавать каждый раз.
	 */
	 
	 $md = new Markdown(['sanitize' => true]);
	 $html1 = $md->render($markdown1);
	 $html2 = $md->render($markdown2);
	 
	 /*
	 Под конфигурированием, всегда понимается передача опций (различных настроек необходимых данной библиотеке) в конструктор во время создания объекта. Особенно полезным такая конфигурация становится тогда, когда объект создается в одном месте программы (на этапе инициализации приложения), а используется в других местах. Возможность конфигурации не навязывает саму конфигурацию, как правило, подобные объекты можно создавать и без указания чего либо, тогда поведение остается "дефолтным", но смысл от этого не меняется.
	 */
	 
	 $md = new Markdown();
	 $html = $md->render($markdown);
	 
	 /*
	 Популярная библиотека для HTTP запросов построена по такому же принципу. Перед выполнением запроса необходимо создать объект. Конструктор соответствующего класса позволяет задать базовую конфигурацию, но через него нельзя указать запрашиваемый адрес, ведь это не часть конфигурации, а часть самого запроса.
	 
	 Попробуйте проверить себя. Выполнение HTTP запроса это абстракция данных или нет?
	 */
	 
	 $client = new \GuzzleHttp\Client();
	 $res = $client->get('https://api.github.com/repos/guzzle/guzzle');
	 echo $res->getStatusCode();
	 
	 /*
	 Данный прием не является прерогативой классов и объектов. В функциональных языках (и в js) он крайне просто реализуется через замыкание
	 
	 Какой дизайн кода правильный (при условии что решено использовать класс) для библиотеки определяющей местоположение по IP адресу?
	 */
	 
	 $ipgeo = new IpGeo();
	 $result = $ipgeo->resolve($ip);
	 print_r($result->city());
	 print_r($result->country());
	 
	 /*
	 Валидация - процесс проверки корректности данных. В вебе происходит всегда при отправке форм, например, регистрация на многих сайтах проверяет корректность введенного емейла, его уникальности (что такого пользователя уже нет).
	 
	 Каждый тип валидации в таких системах (на PHP) обычно представлен классом-валидатором, который принимает на вход опции и предоставляет интерфейс в виде функции validate. Эта функция принимает на вход то что проверяется (валидируется) и возвращает массив с ошибками. Если массив пустой, значит ошибок нет.
	 
	 Реализуйте класс PassworValidator ориентируясь на тесты.
	 
	 Этот валидатор поддерживает следующие опции:
	 minLength (по-умолчанию 8) - минимальная длина пароля
	 containNumbers (по-умолчанию false) - требование содержать хотя бы одну цифру
	 
	 Массив ошибок в ключах содержит название опции, а в значении текст указывающий на ошибку (тексты можно подсмотреть в тестах)
	 */
	 
	 namespace App;
	 
	 class PasswordValidator
	 {
		  const OPTIONS = [
				'minLength' => 8,
				'containNumbers' => false
		  ];
	 
		  private $options = [];
	 
		  public function __construct(array $options = [])
		  {
				$this->options = array_merge(self::OPTIONS, $options);
		  }
	 
		  public function validate(string $password): array
		  {
				$errors = [];
				if (mb_strlen($password) < $this->options['minLength']) {
					 $errors['minLength'] = 'too small';
				}
	 
				if ($this->options['containNumbers']) {
					 if (!$this->hasNumber($password)) {
						  $errors['containNumbers'] = 'should contain at least one number';
					 }
				}
	 
				return $errors;
		  }
	 
		  private function hasNumber($subject)
		  {
				return strpbrk($subject, '1234567890') !== false;
		  }
	 }
	 
	 /*
	 # Изменяемая конфигурация
	 
	 Как мы выяснили в предыдущем уроке, многие объекты в ООП не являются абстракцией данных, а используются как способ сохранить конфигурацию для выполнения повторяющихся действий, таких как генерация HTML из Markdown или определение города по IP. Конфигурация осуществляется через передачу опций в конструктор объекта, а сами опции, хранятся внутри и используются для всех последующих вызовов.
	 */
	 
	 // timeout устанавливает ограничение в одну секунду на длительность запроса
	 $ipgeo = new IpGeo(['timeout' => 1000]);
	 $ipgeo->resolve('123.4.3.2');
	 
	 /*
	 Но что если для конкретного запроса, нужно временно установить опции отличные от тех что были переданы в конструктор? Для выхода из этой ситуации есть три возможных решения
	 
	 Создание нового объекта
	 
	 Самое простое решение сводится к созданию нового объекта в том месте где нам нужно. Это решение хоть и простое, но обладает рядом недостатков. Главный недостаток связан с невозможностью подмены реализации (тот самый полиморфизм о котором мы будем говорить в будущем), так как объект создается не на этапе конфигурирования системы, а в том месте где происходит вызов. Это, в свою очередь, ведет к тому что придется дублировать общие опции, а тестирование станет затруднительным (если не невозможным).
	 */
	 $ipgeo = new IpGeo(['timeout' => 10]);
	 $ipgeo->resolve('123.4.3.2');
	 
	 /*
	 Сеттеры
	 Самый страшный вариант связан с использованием сеттеров.
	 */
	 $ipgeo = new IpGeo(['timeout' => 1000]);
	 
	 // В одной части программы
	 $ipgeo->resolve('123.4.3.2');
	 
	 // В другой части программы
	 $ipgeo->setOption('timeout', 10);
	 $ipgeo->resolve('123.4.3.2');
	 
	 /*
	 Изменяемое состояние, самое сложное что есть в программировании. Его наличие приводит практически ко всем сложностям с которыми мы встречаемся и создает трудноотловимые и опасные баги. Догадайтесь, что пойдет не так после выполнения последних двух строк? Наш объект $ipgeo используется совместно всеми частями системы из этого следует что его изменение в одном месте повлияет на все последующие вызовы. В случае работы с Markdown все может быть еще страшнее, так как неправильный вывод порождает дыры в безопасности, а конкретно возможность провести XSS:
	 */
	 $md = new Markdown(['sanitaize' => true]);
	 
	 // В одной части программы
	 $md->render($markdown);
	 
	 // В другой части программы отключаем санитайз
	 $md->setOption('sanitize', false);
	 $md->render($markdown2);
	 
	 /*
	 sanitaize, флаг отвечающий за включение безопасного рендеринга. Если его выключить, то теги script вставленные в markdown отобразятся как есть. Такое иногда нужно и допустимо для своего собственного текста (например на Хекслете это уроки), но недопустимо для текста который вводят пользователи. Мутация объекта md создает дыру в безопасности. Избежать ее можно не забыв вернуть опцию обратно:
	 */
	 $md = new Markdown(['sanitaize' => true]);
	 
	 // В одной части программы
	 $md->render($markdown);
	 
	 // В другой части программы отключаем санитайз
	 $md->setOption('sanitize', false);
	 $md->render($markdown2);
	 $md->setOption('sanitize', true);
	 
	 /*
	 Как вы понимаете, в силу человеческого фактора, программист обязательно забудет это сделать. Такой код, в котором сначала что-то меняется в одну сторону, а потом восстанавливается обратно, почти всегда говорит о проблемах архитектуры и его можно написать безопасно.
	 
	 Новые опции на время запроса
	 Правильный способ решает все проблемы указанные выше. Его использование основано на передаче дополнительного параметра в метод. Этот параметр содержит временные опции, которые применяются только для данного запроса.
	 */
	 
	 $md = new Markdown(['sanitaize' => true]);
	 
	 // В одной части программы
	 $md->render($markdown);
	 
	 // В другой части программы отключаем санитайз на время выполнения запроса
	 $md->render($markdown2, ['sanitaize' => false]);
	 $md->render($markdown3); // sanitaize по прежнему равен true
	 
	 // Теперь все в порядке. Sanitize включен глобально, но в конкретном запросе он был переопределен $md->render($markdown, ['sanitaize' => false]) и это никак не отражается на последующих вызовах метода render.
	 
	 
	 
	 /*
	 Для работы с текстом в вебе бывает полезна функция truncate, которая обрезает слишком длинный текст и ставит в конце, например, троеточие:
	 truncate('long text', ['length' => 3]); // => lon...
	 */
	 
	 namespace App;
	 
	 class Truncater
	 {
		  const OPTIONS = [
				'separator' => '...',
				'length' => 200,
		  ];
	 
		  private $options = [];
	 
		  public function __construct(array $options = [])
		  {
				$this->options = array_merge(self::OPTIONS, $options);
		  }
	 
		  public function truncate(string $text, array $options = []): string
		  {
				$options = array_merge($this->options, $options);
				
				if (mb_strlen($text) <= $options['length']) {
					 return $text;
				}
				
				return substr_replace($text, $options['separator'], $options['length']);
		  }
	 }
	 
	 namespace App\Tests;
	 
	 use App\Truncater;
	 use PHPUnit\Framework\TestCase;
	 
	 class TruncaterTest extends TestCase
	 {
		  public function testTruncate()
		  {
				$truncater = new Truncater();
				$actual = $truncater->truncate('one two');
				$this->assertEquals('one two', $actual);
				$actual = $truncater->truncate('one two', ['length' => 6]);
				$this->assertEquals('one tw...', $actual);
				$actual = $truncater->truncate('one two', ['separator' => '.']);
				$actual = $truncater->truncate('one two', ['length' => '3']);
				$this->assertEquals('one...', $actual);
	 
				$truncater = new Truncater(['length' => 3]);
				$actual = $truncater->truncate('one two');
				$this->assertEquals('one...', $actual);
				$actual = $truncater->truncate('one two', ['separator' => '!']);
				$this->assertEquals('one!', $actual);
				$actual = $truncater->truncate('one two');
				$this->assertEquals('one...', $actual);
		  }
	 }
	 
	 /*
	 # stdClass
	 
	 PHP поставляется с небольшим набором предопределенных классов, в который входит stdClass. Этот класс имеет особое значение для языка и используется в некоторых ситуациях автоматически.
	 
	 Первое, что бросается в глаза: stdClass нарушает стандарт именования и начинается с маленькой буквы. Вторая особеность проявляется при работе с ним - в stdClass нет предопределенных свойств и методов, но объекты этого класса могут наполняться любыми свойствами в процессе работы.
	 */
	 
	 $obj = new stdClass();
	 $obj->key = 'value';
	 
	 var_dump($obj);
	 // class stdClass#1 (1) {
	 //   public $key =>
	 //   string(5) "value"
	 // }
	 
	 /*
	 В обычной ситуации, попытка записать значение в неопределенное свойство приводит к ошибке. В случае с stdClass ошибки не возникает. Такого эффекта можно добиться с помощью специальных магических методов __get и __set. Эти методы вызываются автоматически при обращении к неопределенным свойствам и позволяют создавать их на лету.
	 */
	 
	 class MyStdClass
	 {
		  private $properties = [];
	 
		  public function __set($name, $value)
		  {
				$this->properties[$name] = $value;
		  }
	 
		  public function __get($name)
		  {
				return $this->properties[$name];
		  }
	 
		  // Для полноты полезно реализовать метод __isset
		  // http://php.net/manual/ru/language.oop5.overloading.php#object.isset
	 }
	 
	 $obj = new MyStdClass();
	 $obj->key = 'value'; // __set($name, $value) где $name = 'key', а $value = 'value'
	 $obj->key; // __get($name) где $name = 'key'
	 
	 print_r($obj);
	 // MyStdClass Object
	 // (
	 //     [properties:Tmp\MyStdClass:private] => Array
	 //         (
	 //             [key] => value
	 //         )
	 //
	 // )
	 
	 /*
	 Такие объекты очень похожи на ассоциативные массивы, но с объектным синтаксисом. Более того, в JavaScript встроен тип данных object, который ведет себя одновременно и как ассоциативный массив, и как объект из примера выше. В зависимости от желания, к нему можно обращаться и так, и так.
	 */
	 const obj = {};
	 obj.key = 'value';
	 obj.key; // value
	 obj['key']; // value
	 
	 obj['key'] = 'value2';
	 obj.key; // value2
	 
	 /*
	 Преобразование типов
	 Преобразование ассоциативного массива в объект приводит к созданию объекта класса stdClass;
	 */
	 
	 $userAsArray = [
		'name' => 'George',
		'age' => 18
	 ];
	 
	 $userAsObject = (object) $userAsArray;
	 
	 var_dump($userAsObject);
	 // class stdClass#2 (2) {
	 //   public $name =>
	 //   string(6) "George"
	 //   public $age =>
	 //   int(18)
	 // }
	 
	 /*
	 Парсинг JSON
	 В PHP не разделяются понятия массив и ассоциативный массив, что резко отличается от всех остальных языков и форматов. Например, в JSON это два разных типа данных.
	 */
	 
	 {
		"files": ["src/Countable.php", "src/Moment.php"],
		"require": {
		  "phpunit": "*",
		  "http-client": "*"
		}
	 }
	 
	 /*
	 В JSON files содержит массив, а require - ассоциативный массив. Именно в таких ситуациях и подходит stdClass (хотя, откровенно говоря, это - костыль из-за отсутствия нормальных массивов). Функция json_decode парсит переданный ей JSON и формирует либо массив, либо объект stdClass, в зависимости от того, чем были данные внутри JSON.
	 
	 stdClass Object
	 (
		  [files] => Array
				(
					 [0] => src/Countable.php
					 [1] => src/Moment.php
				)
	 
		  [require] => stdClass Object
				(
					 [phpunit] => *
					 [http-client] => *
				)
	 
	 )
	 
	 Конфигурация
	 Многие фреймворки используют stdClass для хранения конфигурации, так как она динамическая (то есть состав ключей меняется в зависимости от потребностей разработчика).
	 
	 Реализуйте функцию toStd, которая п ринимает на вход ассоциативнвый массив и ввозвращает объект типа stdClass такой же структуры. Выполните задачу проставляя ключи и значения вручную без использования преобразования типа.
	 */
	 
	 $data = [
		  'key' => 'value',
		  'key2' => 'value2',
	 ];
	 $config = toStd($data);
	 
	 $config->key; // value
	 $config->key2; // value2
	 
	 /*
	 # PHPUnit
	 Практика на хекслете проверяется автоматическими тестами, к которым вы уже немного привыкли, если смогли добраться до текущего урока. Для тестирования PHP-кода мы используем фреймворк PHPUnit, который, хоть и не единственный, но до сих пор - самый популярный. Имея некоторое представление об ООП, мы можем поговорить о его устройстве.
	 */
	 
	 namespace App\Tests;
	 
	 use function App\Math\average;
	 use PHPUnit\Framework\TestCase;
	 
	 /*
	 Единственная незнакомая синтаксическая конструкция в этом тесте - `extends TestCase`.
	 С ее помощью реализуется наследование. О наследовании пойдет разговор в следующих курсах, а сейчас достаточно знать, что все методы, которые мы вызываем внутри нашего теста, определены в классе `TestCase` и именно наследование позволяет их использовать.
	 */
	 
	 class MathTest extends TestCase
	 {
		  public function testAverage()
		  {
				$this->assertEquals(0, average(0));
				$this->assertEquals(5, average(0, 10));
		  }
	 }
	 
	 /*
	 Не имеет значения предмет тестирования; любой тест PHPUnit всегда описывается в классе с именем ЧтотоTest внутри директории tests. Если тестируется какой-то конкретный класс с именем Foo, то, по соглашению, его тесты располагаются в классе FooTest. Точно такое же правило с неймспейсами без классов. Как правило, структура папок внутри tests совпадает со структурой исходных файлов - так проще ориентироваться, и некоторые редакторы позволяют автоматически переключаться между тестом и исходным файлом при такой структуре и именовании.
	 
	 src/                                tests/
	 `-- Money/Currency.php              `-- Money/CurrencyTest.php
	 `-- IntlFormatter.php               `-- IntlFormatterTest.php
	 `-- Money.php                       `-- MoneyTest.php
	 
	 Каждый тестовый класс состоит из тестовых методов. Тестовые методы всегда начинаются с префикса test, например, testAverage - только тогда PHPUnit понимает, что это тестовый метод и выполняет его автоматически при прогоне тестов. Тестовые методы пишутся программистом. Нет никаких правил в том, сколько их должно быть и какова должна быть их структура. Если нужно написать десять разных тестов на одну функцию, то так и нужно делать.
	 
	 Главная задача любого тестового метода - выполнить ту проверку, ради которой задумывался соответствующий тест. В примере выше тестируется функция average, находящая среднее арифметическое всех переданных в эту функцию чисел. Average - чистая функция, а значит, ее легко тестировать. Достаточно передать в функцию несколько чисел и проверить возвращаемое значение.
	 
	 Проверки в PHPUnit выполняются с помощью специальных функций - утверждений. Этих функций довольно много, но среди них есть несколько наиболее используемых. Метод assertEquals принимает на вход два значения:
	 
	 Expected. Ожидаемый результат - то, что должна вернуть функция.
	 Actual. Результат, который на самом деле вернула функция.
	 Порядок важен. На его основе PHPUnit формирует вывод, в котором указывает, что ожидалось, а что пришло на самом деле.
	 
	 Другое популярное утверждение assertTrue (и assertFalse), оно принимает только один аргумент и отлично подходит для тестирования предикатов.
	 
	 Анализ дизайн
	 Дизайн тестов на основе классов, теряет свою популярность, а во многих языках уже давно не используется. Современный подход растет из BDD (https://en.wikipedia.org/wiki/Behavior-driven_development) процесса. Синтаксически такие тесты часто полагаются на функции высшего порядка describe и it.
	 */
	 describe('Example', function () {
		  $object = new stdClass();
		  $object->name = 'pho';
	 
		  context('name', function () use ($object) {
				it('is set to pho', function()  use ($object) {
					 expect($object->name)->toBe('pho');
				});
		  });
	 });
	 
	 /* Замечу, что в PHP такой стиль выглядит немного тяжелым из-за обилия синтаксических конструкций.
	 
	 Дополнительные материалы:
	 Официальная документация https://phpunit.de/manual/6.5/en/writing-tests-for-phpunit.html
	 Behat (BDD Framework) http://behat.org/en/latest/quick_start.html
	 Codeception (Браузерные тесты) https://codeception.com/
	 Начинаем писать тесты (Правильно) https://ru.hexlet.io/blog/posts/how-to-test-code
	 
	 
	 
	 /**@@
	 Реализуйте тест CourseTest, проверяющий работоспособность метода getName класса Course.
	 **/
	 
	 // FILE: App/Course.php
	 namespace App;
	 
	 class Course
	 {
		  private $name;
	 
		  public function __construct($name)
		  {
				$this->name = $name;
		  }
	 
		  public function getName()
		  {
				return $this->name;
		  }
	 }
	 
	 // tests/CourseTest.php:
	 
	 namespace App\Tests;
	 
	 use PHPUnit\Framework\TestCase;
	 
	 class CourseTest extends TestCase
	 {
		  public function testGetName()
		  {
				$name = 'my super course';
				$course = new \App\Course($name);
				
				$this->assertEquals($name, $course->getName());
		  }
	 }
	 
	 
	 
	 # DS
		
	 /*
	 PHP поставляется с библиотекой, называемой SPL (Standard PHP Library http://php.net/manual/en/book.spl.php).
	 Кроме прочего, она содержит набор классов, реализующих популярные структуры данных, таких, как стек или очередь.
	 */
	 
	 $q = new SplStack();
	 $q->push(3);
	 $q->push(10);
	 $q->pop(); // 10
	 $q->pop(); // 3
	 
	 /*
	 Несмотря на то, что SPL встроен в язык, конкретно к Datastructures есть множество претензий со стороны комьюнити как по производительности, так и по интерфейсам классов. Все это вылилось в создание расширения php-ds (DS). Подробнее о нем читайте в статье https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd. php-ds можно установить как обычный пакет https://github.com/php-ds/polyfill. Вся документация доступна здесь: http://docs.php.net/manual/ru/book.ds.php.
	 
	 DS включает в себя Vector, Deque, Map, Set, Stack, Queue, PriorityQueue, Pair. Эти структуры, в жизни обычного веб-разработчика нужны не каждый день, но все же такое случается. Если вы с ними не знакомы, то рекомендую пробежаться по вики.
	 
	 # Stack
	 Стек - это коллекция типа "Последний вошел, первый вышел" (Last In, First Out или LIFO), которая позволяет работать только с самым верхним (последним) значением. Итерация происходит от конца к началу с удалением взятого элемента.
	 */
	 
	 $stack = new Ds\Stack();
	 $stack->push(3);
	 $stack->push(10);
	 $stack->pop(); // 10
	 $stack->pop(); // 3
	 print_r($stack->toArray());
	 
	 /*
	 Методы pop и push составляют основной интерфейс класса. push добавляет элемент (или элементы) на стек, pop - снимает со стека.
	 
	 Перепишем с использованием этого стека функцию, которая разбиралась в курсе "PHP: массивы". Напомню задачу:
	 
	 Необходимо реализовать функцию, которая проверяет, что парные символы сбалансированы. То есть каждый открывающий символ имеет закрывающий, и они не перекрываются, например, так: [{]}. К таким символам в нашем случае относятся <>, {}, () []. Входом в функцию может быть ()<>{}. Такой пример проходит проверку, а вот этот уже нет: [({)}]. Здесь происходит перекрытие фигурных и круглых скобок.
	 */
	 
	 function checkIfBalanced(string $expression): boolean
	 {
		  // инициализируем стек
		  $stack = new Ds\Stack();
		  // инициализируем список открывающих элементов
		  $startSymbols = ['{', '(', '<', '['];
		  // инициализируем список пар
		  $pairs = ['{}', '()', '<>', '[]'];
	 
		  // Проходим по строке от первого до последнего символа
		  for ($i = 0; $i < strlen($expression); $i++) {
				$curr = $expression[$i];
				// Если текущий символ находится в списке открывающих символов, то заносим его в стек
				if (in_array($curr, $startSymbols)) {
					 $stack->push($curr);
				} else { // Если элемент не входит в список открывающих, то считаем, что это закрывающий символ
					 $prev = $stack->pop();
					 // Составляем из этих символов пару
					 $pair = "{$prev}{$curr}";
					 // Проверяем, что она входит в список $pairs. Если входит, то все правильно, двигаемся дальше; если нет,
					 // то это автоматически означает, что символы не сбалансированы
					 if (!in_array($pair, $pairs)) {
						  return false;
					 }
				};
		  }
	 
		  // Если стек оказался пустым после обхода строки, то значит все хорошо
		  return sizeof($stack) == 0;
	 }
	 
	 /*
	 По большому счету, ничего не поменялось. Кода не стало меньше, он не стал проще. С другой стороны, такой подход более канонический для PHP.
	 
	 /**@@
	 Реализуйте функцию compare, которая сравнивает две строчки набранные в редакторе. Если они равны то возвращает true, иначе - false. Особенность строчек в том они могут содержать символ #, который означает нажатие клавиши Backspace. То есть перед самим сравнением, нужно вычислить реальную строчку отображенную в редакторе.
	 **/
	 
	 compare('ab#c', 'ab#c'); // true
	 compare('ab##', 'c#d#'); // true
	 compare('a#c', 'b'); // false
	 
	 
	 function compare($str1, $str2)
	 {
		  $getRealString = function ($str) {
				$stack = new \Ds\Stack();
	 
				for ($i = 0; $i < strlen($str); $i++) {
					 $sign = $str[$i];
					 
					 if ($sign == '#') {
						  $stack->pop();
					 } else {
						  $stack->push($sign);
					 }
				}
				
				return implode('', $stack->toArray());
		  };
		  
		  return $getRealString($str1) == $getRealString($str2);
	 }
	 
	 #2:
	 
	 function compare($text1, $text2)
	 {
		  $evaluatedText1 = evaluate($text1);
		  $evaluatedText2 = evaluate($text2);
	 
		  return $evaluatedText1 === $evaluatedText2;
	 }
	 
	 function evaluate($text)
	 {
		  $stack = new \Ds\Stack();
		  
		  for ($i = 0; $i < mb_strlen($text); $i++) {
				$current = $text[$i];
				
				if ($current == '#') {
					 $stack->pop();
				} else {
					 $stack->push($current);
				}
		  }
	 
		  return implode('', $stack->toArray());
	 }
	 
	 
	 
	 # Collect
	 
	 /*
	 В курсе по работе с массивами я упоминал библиотку Collect, позволяющую манипулировать в объектном стиле. Она содержит более 100 операций, решающих большинство распростаненных задач по манипулированию коллекциями. Крайне рекомендую использовать ее во всех ваших проектах как одну из базовых зависимостей.
	 
	 Пример ниже показывает, как выполнить flatten, используя Collect. Напомню, что flatten распрямляет массивы, вытаскивая элементы из вложенных на верхний уровень.
	 */
	 
	 $collection = collect(['name' => 'taylor', 'languages' => ['php', 'javascript']]);
	 $flattened = $collection->flatten();
	 
	 // Извлечение массива
	 $flattened->all(); // => ['taylor', 'php', 'javascript'];
	 
	 /*
	 Всего три строчки, но очень много смысла. Попробуем разобраться. В первой строчке создается объект типа Collection. Создается необычным способом - вместо new Collection мы видим обычную функцию. Такой трюк служит одной единственной цели - сделать код компактнее. Это наглядный пример использования паттерна Фабрика.
	 
	 Объект, который возвращает функция collect, содержит исходную коллекцию внутри себя и предоставляет свой собственный интерфейс для ее изменения. Создав объект, мы можем начать пользоваться самой библиотекой. В примере выше выполняется метод flatten, который возвращает новую коллекцию. Причем под коллекцией понимается не массив, а именно объект типа Collection, что позволяет продолжить обработку без необходимости повторного оборачивания в collect. Кроме того, каждый метод в Collection всегда возвращает новую коллекцию и никогда не модифицирует исходную. Такой подход позволяет переиспользовать промежуточные результаты, не боясь случайно сломать код. В примере выше это означает, что сама $collection не изменилась (и не изменится никогда). А значит, мы можем ее использовать повторно уже для других вычислений.
	 */
	 
	 $collection = collect(['name' => 'taylor', 'languages' => ['php', 'javascript']]);
	 $excepted = $collection->except(['name']); // исключаем ключи
	 $flattened = $collection->flatten();
	 $collection->all(); // => ['name' => 'taylor', 'languages' => ['php', 'javascript']]
	 $excepted->all(); // => ['languages' => ['php', 'javascript']]
	 $flattened->all(); // => ['taylor', 'php', 'javascript']
	 
	 /*
	 В последней строчке $flattened->all() из объекта извлекается результирующий массив. Подобный код нужен почти всегда, когда нативная (встроенная в язык) структура оборачивается в объект. Когда все операции выполнены, тогда обычно нам требуется готовый массив для продолжения работы.
	 
	 Collect содержит внутри себя все те функции высшего порядка, с которыми мы познакомились ранее, это map, filter и reduce.
	 */
	 
	 // Map
	 
	 $collection = collect([1, 2, 3, 4, 5]);
	 
	 $multiplied = $collection->map(function ($item, $key) {
		  return $item * 2;
	 });
	 
	 $multiplied->all(); // [2, 4, 6, 8, 10]
	 
	 // Filter
	 
	 $collection = collect([1, 2, 3, 4]);
	 
	 $filtered = $collection->filter(function ($value, $key) {
		  return $value > 2;
	 });
	 
	 $filtered->all(); // [3, 4]
	 
	 // Reduce
	 
	 $collection = collect([1, 2, 3]);
	 
	 $total = $collection->reduce(function ($carry, $item) {
		  return $carry + $item;
	 }); // 6
	 
	 /*
	 Fluent Interface
	 Посмотрите на то, как организована цепочка вызовов в коде ниже.
	 */
	 
	 $result = collect(['taylor', 'abigail', null])
		  ->map(function ($name) {
				// переводим в верхний регистр
				return strtoupper($name);
		  })
		  ->reject(function ($name) {
				// отфильтровываем пустые
				return empty($name);
		  });
	 
	 // выводим коллекцию на экран
	 $result->dump(); // => ['TAYLOR', 'ABIGAIL']
	 
	 /*
	 Схематично цепочка выглядит так: $collection->map(...)->reject(...). Мы уже рассматривали подобный код, когда один объект возвращает другой, но тогда речь шла про то, что объект одного типа возвращает объект другого типа, у которого есть свои методы. В данном же примере методы возвращают объект того же типа (возникает ощущение что возвращается сам объект, но в измененной форме). В теории такой подход дает возможность строить цепочки неограниченной длины: $collection->map(...)->map(...)->map(...). Такую цепочку вызовов принято называть fluent interface (текучий интерфейс).
	 
	 Кстати в том же JavaScript такие цепочки - основной способ строить вычисления на коллекциях.
	 */
	 
	 [0, -2, 4].map(n => n ** 2).filter(n => n > 3); // [4, 16]
	 
	 /*
	 Query Builder
	 Query Builder - широко распространенный паттерн проектирования, позволяющий собирать сложные запросы по частям. Чаще всего он встречается при работе с базами данных для сбора sql, либо для коллекций, как в примерах данного урока. Этот паттерн в ОО-языках реализуется с помощью fluent interface.
	 */
	 
	 // laravel query builder
	 $price = DB::table('orders')
						  ->where('finalized', 1)
						  ->avg('price');
	 /*
	 Его удобство проявляется особенно сильно в тех местах, где логика построения запросов условная. Например, фильтрация товаров в интернет-магазине. Без Query Builder такую выборку реализовать крайне трудно.
	 
	 # Fluent Interface
	 
	 Fluent Interface удобен для создания DSL. Domain Specific Language (Предметно-ориентированный язык) — язык, специализированный под конкретную область применения. Структура такого языка отражает специфику решаемых с его помощью задач. Яркий пример подобного языка — библиотека Jquery, с которой знакомо большинство программистов (или хотя бы слышали о ней).
	 */
	 $('#test').css('color', '#333').height(200);
	 /*
	 На техническом уровне есть ровно два способа создать такой интерфейс.
	 
	 This
	 Первый способ основан на возврате $this из методов, которые участвуют в построении цепочек. $this — ссылка на тот объект, в контексте которого вызывается метод, а, следовательно, его можно возвращать как обычное значение.
	 */
	 class Coll
	 {
		  private $coll;
	 
		  public function __construct(array $coll)
		  {
				$this->coll = $coll;
		  }
	 
		  public function map(callable $fn)
		  {
			 $this->coll = array_map($fn, $this->coll);
	 
			 return $this;
		  }
	 
		  public function filter(callable $fn)
		  {
			 $this->coll = array_filter($this->coll, $fn);
	 
			 return $this;
		  }
	 
		  // Возвращает саму коллекцию, а не this. Этот метод всегда последний в цепочке вызовов Coll.
		  public function all()
		  {
				return $this->coll;
		  }
	 }
	 
	 $cars = new Coll([
		['model' => 'rapid', 'year' => 2016],
		['model' => 'rio', 'year' => 2013],
		['model' => 'mondeo', 'year' => 2011],
		['model' => 'octavia', 'year' => 2014]
	 ]);
	 
	 $cars->filter(function ($car) { return $car['year'] > 2013; })
			->map(function ($car) { return $car['model']; });
	 $cars->all(); // [rapid, octavia]
	 
	 /*
	 У этого способа есть один серьезный недостаток — объект изменяется. Это значит, что нельзя взять и просто так переиспользовать объект-коллекцию для разных выборок, потому что они начнут накладываться друг на друга.
	 
	 На практике часто используется другой подход, с которым мы уже познакомились в прошлом курсе. Все, что нужно сделать — добавить немного функциональности в ооп, то есть возвращать не $this, а создавать новый объект того же типа с обновленной коллекцией.
	 */
	 
	 class Coll
	 {
		  private $coll;
	 
		  public function __construct(array $coll)
		  {
				$this->coll = $coll;
		  }
	 
		  public function map(callable $fn)
		  {
			 $coll = array_map($fn, $this->coll);
	 
			 return new Coll($coll);
		  }
	 
		  public function filter(callable $fn)
		  {
			 $coll = array_filter($this->coll, $fn);
	 
			 return new Coll($coll);
		  }
	 
		  // Возвращает саму коллекцию, а не this. Этот метод всегда последний в цепочке вызовов Coll.
		  public function all()
		  {
				return $this->coll;
		  }
	 }
	 
	 $cars = new Coll([
		['model' => 'rapid', 'year' => 2016],
		['model' => 'rio', 'year' => 2013],
		['model' => 'mondeo', 'year' => 2011],
		['model' => 'octavia', 'year' => 2014]
	 ]);
	 
	 $filteredCars = $cars->filter(function ($car) { return $car['year'] > 2013; });
	 $mappedCars = $filteredCars->map(function ($car) { return $car['model']; });
	 $mappedCars->all(); // [rapid, octavia]
	 $cars->all();
	 // [
	 //   ['model' => 'rapid', 'year' => 2016],
	 //   ['model' => 'rio', 'year' => 2013],
	 //   ['model' => 'mondeo', 'year' => 2011],
	 //   ['model' => 'octavia', 'year' => 2014]
	 // ]
	 
	 /*
	 Теперь каждый вызов возвращает новый объект. Такой код значительно безопаснее в использовании и позволяет без проблем переиспользовать новые коллекции. Изменение одной, не приведет к автоматическому изменению всех остальных.
	 */
	 
	 class Coll
	 {
		  // ...
	 
		  public function map(callable $fn)
		  {
			 $coll = array_map($fn, $this->coll);
	 
			 return new Coll($coll);
		  }
	 
		  // ...
	 }
	 
	 /*
	 В каждом методе, который участвует в построении Fluent Interface, последняя строчка всегда содержит один и тот же вызов: new Coll($coll). Ее можно записать проще, не дублируя названия класса. Помните как в прыдудщем курсе использовался self для работы со статическими членами класса? Так вот self работает и с обычными методами, вызов new self($coll) идентичен вызову new Coll($coll), другими словами вместо self подставляется текущий класс. У такого вызова есть еще одно преимущество, о котором мы поговорим в следующем ООП курсе, в теме наследования. В двух словах self реализуется посредством позднего связывания и при наследовании раскрывается в тот класс, с которым прямо сейчас идет работа.
	 
	 Текучий интерфейс: https://ru.wikipedia.org/wiki/Fluent_interface
	 
	 
	 # Carbon
	 
	 Для работы с датами в PHP есть три пути.
	 
	 Использовать обычные функции http://php.net/manual/en/ref.datetime.php
	 Использовать встроенные классы, например, http://php.net/manual/en/class.datetimeimmutable.php
	 Воспользоваться сторонней библиотекой
	 Первый вариант подходит только для примитивных рассчетов. Не потому, что функции плохи, а потому, что в PHP их мало и ими неудобно пользоваться (интерфейс для машин, а не для людей). Встроенные классы тоже не сильно облегчают задачу. Они работают на низком уровне и простые операции в стиле "получить дату, которая была неделю назад" становятся целым приключением.
	 
	 В этом уроке мы рассмотрим третий вариант. Самым популярным сторонним решением для работы с датами в PHP является библиотека Carbon (http://carbon.nesbot.com/).
	 */
	 
	 use Carbon\Carbon;
	 
	 // выдало текущую дату на момент написания урока
	 printf("Now: %s", Carbon::now()); // Now: 2018-04-21 13:31:56
	 
	 
	 /*
	 В целом принцип работы этой библиотеки совпадает с принципом работы Collect. Создавая объект, мы как бы "оборачиваем" дату, делая ее внутренним состоянием объекта. Затем выполняем необходимые операции, используя соответствующие методы. Когда нам снова понадобится дата, то мы сможем ее извлечь.
	 
	 Библиотека Carbon обширна и включает в себя невероятно большое количество методов. Мы рассмотрим буквально несколько, а за остальными добро пожаловать в официальную документацию.
	 
	 Определение выходного дня:
	 */
	 if (Carbon::now()->isWeekend()) {
		  echo 'Party!';
	 }
	 
	 // Без Carbon
	 // if (date('D') == 'Sat' || date('D') == 'Sun') {
	 //    echo "Today is Saturday or Sunday.";
	 // }
	 
	 // Вывод
	 Carbon::create(2001, 4, 21, 12)->diffForHumans(); // 1 month ago
	 
	 # Манипулирование датами
	 $nextSummerOlympics = Carbon::createFromDate(2016)->addYears(4);
	 // date("F j Y", mktime(0, 0, 0, 1, 1, 2016 + 4));
	 
	 
	 # Fluent Setters
	 /*
	 Carbon предоставляет Fluent интерфейс для генерации дат, причем даже несколько видов таких интерфейсов. Его полезность проявляется в местах, где построение дат - динамическое.
	 */
	 
	 $dt = Carbon::now();
	 
	 $dt->year(1975)->month(5)->day(21)->hour(22)->minute(32)->second(5)->toDateTimeString();
	 $dt->setDate(1975, 5, 21)->setTime(22, 32, 5)->toDateTimeString();
	 $dt->setDate(1975, 5, 21)->setTimeFromTimeString('22:32:05')->toDateTimeString();
	 $dt->setDateTime(1975, 5, 21, 22, 32, 5)->toDateTimeString();
	 
	 $dt->timestamp(169957925)->timezone('Europe/London');
	 
	 
	 # Сравнение дат
	 /*
	 Отдельного внимания заслуживает сравнение дат, которое учитывает часовые пояса.
	 */
	 echo Carbon::now()->tzName;                        // America/Toronto
	 $first = Carbon::create(2012, 9, 5, 23, 26, 11);
	 $second = Carbon::create(2012, 9, 5, 20, 26, 11, 'America/Vancouver');
	 
	 echo $first->toDateTimeString();                   // 2012-09-05 23:26:11
	 echo $first->tzName;                               // America/Toronto
	 echo $second->toDateTimeString();                  // 2012-09-05 20:26:11
	 echo $second->tzName;                              // America/Vancouver
	 
	 var_dump($first->eq($second));                     // bool(true)
	 var_dump($first->ne($second));                     // bool(false)
	 var_dump($first->gt($second));                     // bool(false)
	 var_dump($first->gte($second));                    // bool(true)
	 var_dump($first->lt($second));                     // bool(false)
	 var_dump($first->lte($second));                    // bool(true)
	 
	 
	 // Благодаря наличию Spaceship Operator (https://wiki.php.net/rfc/combined-comparison-operator) в PHP версий старше 7.1, код выше можно переписать, используя обычные операции сравнения.
	 
	 var_dump($first == $second);                       // bool(false)
	 var_dump($first != $second);                       // bool(true)
	 var_dump($first > $second);                        // bool(false)
	 var_dump($first >= $second);                       // bool(false)
	 var_dump($first < $second);                        // bool(true)
	 var_dump($first <= $second);                       // bool(true)
	 
	 /*
	 Дополнительные материалы:
	 Carbon Docs: https://carbon.nesbot.com/docs/
	 
	 
	 # Stringy
	 
	 PHP долгое время не работал с многобайтовыми кодировками, такими как utf-8.
	 */
	 strlen('привет'); // 12
	 
	 /*
	 Даже если попробовать выполнить любую операцию над строкой, включающей не ASCII-символы, станет видно, что функции по-прежнему не умеют обрабатывать такие строки. Дело в том, что в целях соблюдения обратной совместимости, в PHP было создано отдельное подмножество функций, имеющих аналогичные названия, но с префиксом mb_.
	 */
	 mb_strlen('привет'); // 6
	 /*
	 Такая ситуация очень неприятна и из популярных языков присутствует, пожалуй, только в PHP. В остальных языках есть ровно один набор функций, работающий со всеми кодировками. Минимизировать проблему можно использованием только функций с префиксом mb_, так как они прекрасно работают и для английского алфавита, и вообще для любых строк.
	 
	 Вторая проблема, уже типичная - функций довольно мало и они низкоуровневые. Например, проверить то, что строка начинается с определенной подстроки можно только с помощью функции strpos.
	 */
	 
	 // Обязательно проверять строго на равенство нулю
	 strpos('start', 'st') === 0; // true
		
	 // Такой код, мало того, что сложен (не очевидно, что он делает), так еще и является постоянным источником ошибок из-за неявного приведения типов.
	 
	 
		
	 # Stringy
	 /*
	 Библиотека Stringy предоставляет унифицированный объектно-ориентированный интерфейс для работы со строчками. Она работает как типичный builder, например, Collect.
	 */
	 
	 use function Stringy\create as s;
	 
	 s('fòôbàř')->toUpperCase(); // 'FÒÔBÀŘ'
	 //  Применение методов к обернутой строке всегда возвращает обернутую строку. Такое поведение добавляет много полезных возможностей.
	 
		
	 // Цепочки
	 s('fòô     bàř')->collapseWhitespace()->swapCase(); // FÒÔ BÀŘ
	 
	 
	 // Итерацию с помощью foreach
	 $stringy = s('fòôbàř');
	 foreach ($stringy as $char) {
		echo $char;
	 }
	 // => fòôbàř
	 
	 
	 // Функция count
	 $stringy = s('fòô');
	 count($stringy);  // 3
	 
	 /*
	 Кроме того, объект, возвращаемый функцией s, реализует магический метод toString, а это значит, что не придется заниматься преобразованием типов, как в случае с Collect. Каждый раз, когда объект используется как строка, на его месте оказывается строка.
	 
	 Всего в библиотеке около 100 функций https://github.com/danielstjules/Stringy.
	 
	 
	 
	 # Пишем код правильно
	 
	 В PHP считается, что набор принципов SOLID, это ответ на вопрос о том как правильно писать код.
	 Но жизнь показывает, что знание этих принципов слабо помогает хорошей организации кода.
	 
	 Возьмем принцип SRP (принцип единственной ответственности. S из SOLID). Он говорит следующее:
	 
	 Должна быть ровно одна причина для изменения класса. Роберт Мартин.
	 
	 Есть и другие формулировки, но это самая лаконичная. Что не так с этим принципом? Он очень общий. Звучит примерно как: нормально делай – нормально будет. Он не дает никаких формальных критериев, по которым можно понять что в классе есть проблема. В статьях посвященных этому принципу, всегда все кажется логичным. Но только потому что автор уже предложил разделение ответственностей. В реальной жизни все было бы по другому. Когда разных людей спрашиваешь об одних и тех же ситуациях, они дают совершенно разные, иногда противоположные ответы. По факту, все сводится к некоторому внутреннему чутью конкретного программиста.
	 
	 Возьмем для примера библиотеку выполнения HTTP запросов. С чего нужно начать ее проектирование?
	 
	 Правильно начинать с вариантов использования. Представить себе как-будто библиотека уже написана и мы пробуем ей воспользоваться (TDD толкает именно к этому, поэтому оно так мощно работает). Перед тем как я покажу код, попробуйте ответить на вопрос, так ли нужны классы и ооп для реализации этой библиотеки?
	 
	 HTTP-сессия это операция, у которой есть конец и начало. Нужны ли объекты для ее выражения? Нет, конечно. Для операций достаточно функций. Поэтому наша библиотека, в самом простом случае, может выглядеть так:
	 */
	 use function HTTP\get;
	 use function HTTP\post;
	 
	 $response = get('https://ru.hexlet.io/blog');
	 echo $response['body'];
	 
	 $response = post('https://ru.hexlet.io/users', ['name' => 'tolya', 'email' => 'tolya@example.com']);
	 echo $response['statusCode'];
	 
	 /*
	 Теперь, когда готов интерфейс библиотеки, можно приступать к ее реализации. Насколько важно как она выполнена внутри? Откровенно говоря не важно. Внутренности останутся внутренностями и никто про них не узнает, а их размер никогда не станет слишком большим (это всего лишь http библиотека). Это значит, что мы в любой момент можем их переписать. И делать это лучше не до, а после, когда накопится опыт поддержки и опыт использования. Только в этом случае, появится настоящее понимание разделения.
	 
	 Генеральная идея звучит так: грамотная абстракция – ключ к успеху. Обозначьте границы, рассмотрите варианты использования и реализуйте как-нибудь.
	 
	 Если бы мы работали в JavaScript, то пример выше и стал бы реальной HTTP-библиотекой, вы можете убедиться сами, что самая популярная http-библиотека axios, это, действительно, набор функций:
	 */
	 import axios from 'axios';
	 
	 await axios.get('/user?ID=12345');
	 
	 await axios.post('/user', {
		firstName: 'Fred',
		lastName: 'Flintstone',
	 });
	 
	 /*
	 Но в PHP принято создавать классы. Во многом из-за автозагрузки и принятой модели работы. Поэтому перепишем наш интерфейс выше на объектный.
	 */
	 
	 use HTTP;
	 
	 // Сразу возникает вопрос, куда должен передаваться адрес запроса, в конструктор или в метод?
	 // Ответ на этот вопрос давался в курсе ранее. Класс в данном случае выступает конфигурацией.
	 // http://docs.guzzlephp.org/en/stable/
	 $client = new HTTP\Client();
	 $response = $client->get('https://api.github.com/user');
	 echo $response->getBody();
	 
	 $response = $client->post('/user', [
		  firstName: 'Fred',
		  lastName: 'Flintstone',
	 ]);
	 
	 echo $response->getStatusCode();
	 
	 /*
	 Какими принципами нужно руководствоваться, чтобы понять внутреннюю архитектуру и количество классов? Для старта достаточно здравого смысла. У нас есть сам клиент, который представлен объектом (но его состояние это конфигурация, а не запросы и ответы) и есть результат http-запроса. Результат представлен объектом, который возвращается после выполнения запроса. Внутри него хранится вся информация по взаимодействию с сервером, например отправленные и принятые заголовки, код и тело ответа.
	 
	 Дальнейшее разбиение не нужно. Возможно это не понадобится никогда. А если и понадобится, то сначала нужно почувствовать такую необходимость, а затем уже реализовывать ее, когда появится боль. Причем главное основание для такого разделения, это не абстрактная единая ответственность, а выделение чистого кода, который не связан с побочными эффектами.
	 
	 Внутри нашей библиотеки есть код, который выполняет сетевые запросы, а есть код, который работает с данными, приводит их в нормальный вид, чистит и как-то структурирует. В первую очередь, нужно отслеживать такой код и отделять его на уровне функций или методов. Любая операция, которая может быть чисто вычислительной, потенциальный кандидат на вынесение.
	 
	 Еще один пример где анализ побочных эффектов позволяет понять как поступить правильно. В материалах по ООП часто говорят про класс, который отвечает за генерацию отчета. Предположим что он работает так:
	 */
	 // Делать ли Reporter абстракцией данных (то есть объектом описывающим конкретный отчет)
	 // или нет, это большой вопрос
	 // По умолчанию так делать не стоит, иначе весь код превратится
	 // в бесполезное (new Reporter('path/to/file'))->generate()
	 $reporter = new Reporter();
	 $report = $reporter->generate('/path/to/report');
	 
	 /*
	 На что стоит обратить внимание в первую очередь? На то, что этот класс одновременно выполняет грязную работу (с побочными эффектами): читает файл с диска, так и чистую: обрабатывает данные для формирования отчета. Это не значит что надо кидаться переписывать код, но это то, на что надо обращать внимание в первую очередь. Код выше, сложнее в тестировании и отладке, чем код с разделенными операциями по побочным эффектам. Кроме того, если вынести чтение файла наружу, то репортер станет значительно более универсальным. Он сможет работать с данными, которые лежат не только на диске, но и были загружены каким-то другим способом, например, по http через форму. После несложных манипуляций, получаем такой код:
	 */
	 
	 $reporter = new Reporter();
	 $data = file_get_contents('/path/to/report');
	 $report = $reporter->generate($data);
	 $report = $reporter->generate(file_get_contents('https://ru.hexlet.io/reporters/3'));
	 
	 // https://ru.hexlet.io/blog/posts/arhitektura-i-oop
	 
	 
	 
	 
	 
	 /**@@@
	 Реализуйте класс Circle для описания кругов. У круга есть только одно свойство - его радиус. Реализуйте методы getArea и getCircumference, которые возвращают площадь и периметр круга соответственно.
	 **/
	 $circle = new Circle(10);
	 
	 class Circle
	 {
		  private $radius;
	 
		  public function __construct($radius)
		  {
				$this->radius = $radius;
		  }
	 
		  public function getArea()
		  {
				return pi() * ($this->radius ** 2);
		  }
	 
		  public function getCircumference()
		  {
			  return 2 * pi() * $this->radius;
		  }
	 
	 }
	 
	 
	 /**@@
	 Реализуйте генератор рандомных чисел, представленный классом Random. Интерфейс объекта включает в себя три функции:
	 
	 Конструктор. Принимает на вход seed, начальное число генератора псевдослучайных чисел
	 getNext — метод, возврающающий новое случайное число
	 reset — метод, сбрасывающий генератор на начальное значение
	 Простейший способ реализовать случайные числа — линейный конгруэнтный метод https://ru.wikipedia.org/wiki/Линейный_конгруэнтный_метод.
	 **/
	 
	 $seq = new Random(100);
	 $result1 = $seq->getNext();
	 $result2 = $seq->getNext();
	 
	 $result1 != $result2; // => true
	 
	 $seq->reset();
	 
	 $result21 = $seq->getNext();
	 $result22 = $seq->getNext();
	 
	 $result1 == $result21; // => true
	 $result2 == $result22; // => true
	 
	 
	 class Random
	 {
		  protected $seed;
		  protected $init;
	 
		  public function __construct($seed)
		  {
				$this->seed = $seed;
				$this->init = $seed;
		  }
	 
		  public function reset()
		  {
				$this->seed = $this->init;
		  }
	 
		  public function getNext()
		  {
				$a = 45 + $this->init;
				$c = 21 + $this->init;
				$m = 67 + $this->init;
	 
				$this->seed = ($a * $this->seed + $c) % $m;
	 
				return $this->seed;
		  }
	 }
	 
	 
	 /**@@
	 Реализуйте класс Square для описания квадратов. У квадрата есть только одно свойство — сторона. Реализуйте метод getSide, возвращающий значение стороны.
	 **/
	 
	 $square = new Square(10);
	 $square->getSide(); // 10
	 
	 /**
	 Реализуйте класс SquaresGenerator со статическим методом generate, принимающим два параметра: сторону и количество экземпляров квадрата, которые нужно создать. Функция должна вернуть массив из квадратов.
	 **/
	 
	 $squares = SquaresGenerator::generate(3, 2); // [new Square(3), new Square(3)];
	 
	 
	 class Square
	 {
		  private $side;
	 
		  public function __construct($side)
		  {
				$this->side = $side;
		  }
	 
		  public function getSide()
		  {
				return $this->side;
		  }
	 }
	 
	 
	 class SquaresGenerator
	 {
		  public static function generate($side, $count = 5)
		  {
				$squares = [];
				
				for ($i = 0; $i < $count; $i++) {
					 $squares[] = new Square($side);
				}
	 
				return $squares;
		  }
	 }
	 
	 
	 
	 # http://php.net/manual/ru/language.oop5.phps
	 get_class($obj); // возращает класс объекта
	 
	 # 1:
	 // file theory/Guest.php
	 
	 namespace Theory;
	 
	 final class Guest implements UserInterface // final - предотвратить переопределение класса в дочерних классах (не может быть унаследован)
	 {
		  public function isGuest()
		  {
				return true;
		  }
	 
		  final public function getFullName() // предотвратить переопределение метода в дочерних классах
		  {
				return 'Guest';
		  }
	  }
	 
	 
	 // file theory/UserInterface.php
	 namespace Theory;
	 
	 interface UserInterface
	 {
		 public function isGuest();
		 public function getFullName();
	 }
	 
	 
	 // file theory/UserInterface.php
	 namespace Theory;
	 
	 interface MemberInterface
	 {
		  public function __construct($id, $firstName, $lastName);
		  public function getId();
		  public function canScanUserList();
	 }
	 
	 
	 
	 // file theory/User.php
	 namespace Theory;
	 
	 class User implements UserInterface, MemberInterface
	 {
		  private $id;
		  protected $firstName;
		  protected $lastName;
	 
		  public function __construct($id, $firstName, $lastName)
		  {
				$this->id = $id;
				$this->firstName = $firstName;
				$this->lastName = $lastName;
		  }
	 
		  final public function isGuest() // метод переопределить нельзя
		  {
				return false;
		  }
	 
		  final public function getId() // метод переопределить нельзя
		  {
				return $this->id;
		  }
	 
		  public function getFullName()
		  {
				return $this->firstName . " " . $this->lastName;
		  }
	 
		  public function canScanUserList()
		  {
				return false;
		  }
	 }
	 
	 
	 // file theory/Teacher.php
	 namespace Theory;
	 
	 class Teacher extends UserInterface
	 {
		  public function getCourses()
		  {
				return [];
		  }
	 
		  public function getFullName()
		  {
				return 'Teacher: ' . parent::getFullName(); // for __construct - parent::__construct()
		  }
	 }
	 
	 
	 // file theory/HrManager.php
	 namespace Theory;
	 
	 class HrManager extends User
	 {
		  public function getCandidates()
		  {
				return [];
		  }
	 
		  public function canScanUserList()
		  {
				return true;
		  }
	 
		  public function getFullName()
		  {
				return "{$this->lastName} {$this->firstName}";
		  }
	 }
	 
	 
	 # 2
	 /*
	 Абстрактный класс может не содержать абстрактных методов
	 Абстрактный класс может наследоваться от абстрактного класса
	 
	 С абстрактными классами в php есть одна интересная особенность.
	 Если этот класс реализует (не полностью) интерфейс, то определения методов из интерфейса становятся абстрактными методами в этом классе.
	 */
	 
	 // file theory/CasheInterface.php
	 namespace Theory;
	 
	 interface CasheInterface
	 {
		 public function __construct($options);
		 public function get($key);
		 public function set($key, $value);
	 }
	 
	 // Пример:
	 // $cashe = new DbCashe($options);
	 // $cashe->set('user', 3);
	 // 3 == $cashe->get('user');
	 
	 
	 // file theory/Cashe.php
	 namespace Theory;
	 
	 abstract class Cashe implements CasheInterface
	 {
		  protected $options;
	 
		  public function __construct($options)
		  {
				$this->options = $options;
				$this->connect();
		  }
	 
		  abstract protected function connect();
	 }
	 
	 
	 // file theory/DbCashe.php
	 namespace Theory;
	 
	 class DbCashe extends Cache
	 {
		  public function get($key)
		  {
				return $this->connection->get($key);
		  }
	 
		  public function set($key, $value)
		  {
				return $this->connection->set($key, $value);
		  }
	 
		  protected function connect()
		  {
				// ...
		  }
	 }
	 
	 
	 # 3
	 // file theory/index.php
	 namespace Theory;
	 
	 require_once 'Enumarable.php';
	 require_once 'Router.php';
	 
	 $router = new Router();
	 $router->addRouter('root', '/');
	 $router->addRouter('users', '/users');
	 $router->addRouter('new-user', '/users/new');
	 $router->addRouter('new-photos', '/users/{id}/photos');
	 $router->addRouter('new-user-photo', '/users/{id}/photos/new');
	 
	 echo "Routes count: {$router->count()\n}"; // количество маршрутов
	 echo "Is `/users a member? : {$router->isMember('/users')\n}"; // => 1
	 echo "Is `/photos a member? : {$router->isMember('/photos')\n}"; // =>
	 
	 
	 // file theory/Router.php
	 namespace Theory;
	 
	 class Router
	 {
		  use Enumarable; // используем трейт. Можно использовать несколько, перечислив через ','
	 
		  private $options;
		  private $routes = [];
	 
		  public function __construct($options = [])
		  {
				$this->options = $options;
		  }
	 
		  public function addRoute($name, $url)
		  {
				$this->routes[$name] = $url;
		  }
	 
		  public function each($lambda)
		  {
				foreach ($this->routes as $value) {
					 $lambda($value);
				}
		  }
	 }
	 
	 
	 // file theory/Router.php
	 namespace Theory;
	 
	 trait Enumarable
	 {
		  function count()
		  {
				$count = 0;
				
				$this->each(function ($element) use (&$count) {
					 $count++;
				});
				
				return $count;
		  }
		  
		  function isMember($obj)
		  {
				$isMember = false;
				
				$this->each(function ($element) use ($obj, &$isMember) {
					 if ($element == $obj) {
						  $isMember = true;
					 }
				});
				
				return $isMember;
		  }
	 }
	 
	 
	 // Разрешение конфликтов имен в трейтах:
	 trait Hello
	 {
		 private function sayHello()
		 {
			 return 'Hello';
		 }
	 }
	 
	 trait User
	 {
		 public function sayHello($name)
		 {
			 return $name;
		 }
	 }
	 
	 class Welcome
	 {
		 use User, Hello {
			 Hello::sayHello as public word; // изменяем модификатор доступа + даем пседвоним `word`
			 User::sayHello insteadof Hello; // для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.
		 }
	 }
	 
	 $obj = new Welcome();
	 echo $obj->word(), ', ', $obj->sayHello('Jorn'), ', ';
	 
	 
	 #4
	 /*
	 Полезно использовать статические свойства и методы:
	 Когда у класса есть мета информация используемая его объектами
	 Если создание объектов комплексная операция (нужно произвести какие-то вычисления)
	 */
	 
	 function Parser
	 {
		  public static $formats = ['xml', 'html', 'json'];
		  
		  public static function factory($options)
		  {
				$parser = new self($options);
				
				return $parser;
		  }
		  
		  public static function getStaticValue()
		  {
				return self::$formats;
		  }
		  
		  public function callStaticFunction()
		  {
				return self::getStaticValueFromStatic();
		  }
	 }
	 
	 print_r(Parser::$formats);
	 print_r(Parser::getStaticValueFromStatic());
	 
	 $parser = new Parset();
	 print_r($parser->getStaticValue());
	 print_r($parser->callStaticFunction());
	 
	 
	 #5
	 function foo($arg)
	 {
		  if (is_string($arg)) {
				return -1;
		  }
		  
		  return;
	 }
	 
	 function bar($arg)
	 {
		  if (-1 == foo($arg)) {
				return -1;
		  }
		  
		  return;
	 }
	 
	 echo bar('foo'); // => -1
	 
	 
	 namespace Theory;
	 
	 function myReadFile($filepath)
	 {
		  if (!file_exists($filepath)) {
				throw new \Exception("file '{$filepath}' doesn`t exist");
		  }
	 }
	 
	 function readFolder($folderPath)
	 {
		  //NOTE: write logic here
		  return [myReadFile($folderPath)];
	 }
	 
	 function tryReadFile()
	 {
		  try {
				$bodies = readFolder("path/to/Folder");
				return $bodies;
		  } catch (\Exception $e) { // наи
				echo $e->getMessage();
				return [];
		  }
	 }
	 
	 $result = tryReadFile();
	 print_r($result);
	 
	 
	 
	 namespace Thery;
	 
	 $handle = fopen($filepath, "r");
	 
	 try {
		  $data = fread($handle, filesize($filepath));
	 } finally { // Выполняется в любом случае, независимо от того было исключение или нет. Отсюда можно бросать исключение
		  fclose($handle);
	 }
	 
	 
	 # 6 Динамическое создание свойств
	 namespace Theory;
	 
	 class DynamicProps
	 {
		  private $data = [];
	 
		  public $declared = 1;
		  private $hidden = 2;
	 
		  public function __set($name, $value)
		  {
				$this->data[$name] = $value;
		  }
	 
		  public function __get($name)
		  {
				return $this->data[$name];
		  }
	 
		  public function getHidden()
		  {
				return $this->hidden;
		  }
	 
		  public function __isset() {} // проверяет существование свойства
		  public function __unset() {} // удаляет свойтсво
	 }
	 
	 $obj = new DynamicProps();
	 $obj->customKey = 'value2';
	 echo $obj->customKey;
	 isset($obj->customKey); // если реализован магический метод __isset
	 unset($obj->customKey); // если реализован магический метод __unset
	 
	 
	 
	 /**@@
	 Реализуйте функцию compare, которая сравнивает переданных пользователей на основе их идентификаторов. При этом функция должна убедиться, что переданные объекты - пользователи.
	 **/
	 
	 use function App\UserFunctions\compare;
	 
	 $user1 = new User();
	 $user1->id = 1;
	 
	 $user2 = new User();
	 $user2->id = 1;
	 
	 compare($user1, $user2); // => true
	 
	 $cat = new Cat();
	 $user2->id = 1;
	 
	 compare($user1, $cat); // => false
	 
	 
	 function compare(User $user1, User $user2)
	 {
		  return $user1->id === $user2->id;
	 }
	 
	 /**@@
	 Реализуйте функцию toStd, которая принимает на вход ассоциативнвый массив и ввозвращает объект типа stdClass такой же структуры. Выполните задачу проставляя ключи и значения вручную без использования преобразования типа.
	 **/
	 
	 $data = [
		  'key' => 'value',
		  'key2' => 'value2',
	 ];
	 
	 $config = toStd($data);
	 
	 $config->key; // value
	 $config->key2; // value2
	 
	 
	 function toStd($data)
	 {
		  $std = new \stdClass();
		  
		  foreach ($data as $key => $value) {
				$std->$key = $value;
		  }
	 
		  return $std;
	 }
	 
	 
	 # 7 Переопределение методов
	 namespace Theory;
	 
	 /*
	 Вызовы через __call работают медленнее обычных вызовов
	 Код с использованием __call сложнее в отладке (реального метода не существует)
	 __call($name, $args);
	 preg_match("/findBy(.*)/", $finder, $outputArray);
	 */
	 
	 $repository = new repository('users');
	 $repository ->findByEmail('admin@exapmple.com');
	 $repository->findByEmail('John');
	 $repository->findByNameAndAge('John', 18);
	 
	 #8
	 namespace Theory;
	 
	 class Base
	 {
		  public static function who()
		  {
				echo __CLASS__ . "\n";
		  }
	 
		  public static function test()
		  {
				self::who(); // привязывает к текущему классу
				static::who(); // ! позднее статическое связывание
		  }
	 }
	 
	 class Child extends Base
	 {
		  // public static function who()
		  // {
		  //  echo __CLASS__ . "\n";
		  // }
	 }
	 
	 echo Child::who(); // Theory\Base - 2 раза;
	 echo Child::who(); /* => если раскоменторовать =>
	 Theory\Base
	 Theory\Child
	 */
	 
	 
	 #9
	 /*
	 http://php.net/manual/ru/function.spl-autoload.php
	 http://php.net/manual/ru/language.oop5.autoload.php
	 */
	 
	 namespace Theory;
	 
	 
	 __autoload(); // DEPRECATED!
	 
	 // #1
	 spl_autoload_extensions(".php");
	 spl_autoload_register(); // если namespace соответствует папке
	 
	 // #2
	 spl_autoload_register(function($class) {
		  $path = dirname(__FILE__) . "/" .strtolower(str_replace("\\", "/", $class));
		  spl_autoload($path); // загрузка класса
	 });
	 
	 
	 
	 $app = new \ns\Application();
	 var_dump($app);
	 
	 
	 
	 /**@@
	 Реализуйте функцию buildRange, которая переводит входные данные в удобный для построения графика формат.
	 
	 На вход эта функция принимает массив данных. Каждая запись массива представляет из себя объект типа [ 'value' => 14, 'date' => '02.08.2018' ]. Например:
	 */
	 
	 $data = [
		[ 'value' => 14, 'date' => '02.08.2018' ],
		[ 'value' => 43, 'date' => '03.08.2018' ],
		[ 'value' => 38, 'date' => '05.08.2018' ],
	 ];
	 
	 
	 /*
	 Вторым и третьим параметрами функция принимает даты (в форме строк типа 'YYYY-MM-DD') начала и конца периода:
	 
	 $begin = '2018-08-01';
	 $end = '2018-08-06';
	 Диапазон дат задаёт размер выходного массива, который должна сгенерить реализуемая функция. Правила формирования итогового массива:
	 
	 он заполняется записями по всем дням из диапазона begin - end
	 в него включаются только те записи из входного массива, даты которых попадают в диапазон
	 если во входном массиве нет данных для какого-то дня из диапазона, то в свойство value записи этого дня установить значение 0
	 <?php
	 
	 $result = buildRange(data, beginDate, endDate);
	 
	 // OUTPUT
	 // [ [ 'value' => 0, 'date' => '01.08.2018' ],
	 //   [ 'value' => 14, 'date' => '02.08.2018' ],
	 //   [ 'value' => 43, date => '03.08.2018' ],
	 //   [ 'value' => 0, 'date' => '04.08.2018' ],
	 //   [ 'value' => 38, 'date' => '05.08.2018' ],
	 //   [ 'value' => 0, 'date' => '06.08.2018' ] ]
	 
	 Подсказки:
	 Функции из библиотеки Collect, которые могут пригодиться: keyBy.
	 Функции из библиотеки Carbon, которые могут пригодиться: \Carbon\CarbonPeriod::create.
	 */
	 
	 namespace App\Dates;
	 
	 // BEGIN (write your solution here)
	 
	 // END
	 
	 
	 
	 namespace App\Tests;
	 
	 use function App\Dates\buildRange;
	 use PHPUnit\Framework\TestCase;
	 
	 class DatesTest extends TestCase
	 {
		  public function testGetRange()
		  {
				$dates = [
				  [ 'value' => 14, 'date' => '02.08.2018' ],
				  [ 'value' => 43, 'date' => '03.08.2018' ],
				  [ 'value' => 38, 'date' => '05.08.2018' ],
				];
				$beginDate = '2018-08-01';
				$endDate = '2018-08-10';
				$expected = [
				  [ 'value' => 0, 'date' => '01.08.2018' ],
				  [ 'value' => 14, 'date' => '02.08.2018' ],
				  [ 'value' => 43, 'date' => '03.08.2018' ],
				  [ 'value' => 0, 'date' => '04.08.2018' ],
				  [ 'value' => 38, 'date' => '05.08.2018' ],
				  [ 'value' => 0, 'date' => '06.08.2018' ],
				  [ 'value' => 0, 'date' => '07.08.2018' ],
				  [ 'value' => 0, 'date' => '08.08.2018' ],
				  [ 'value' => 0, 'date' => '09.08.2018' ],
				  [ 'value' => 0, 'date' => '10.08.2018' ],
				];
	 
				$actual = buildRange($dates, $beginDate, $endDate);
				$this->assertEquals($expected, $actual);
		  }
	 }
	 
	 
	 #2
	 /*
	 В этой задаче необходимо реализовать ленивую коллекцию https://ru.wikipedia.org/wiki/Отложенная_инициализация
	 
	 src/Enumerable.php
	 Реализуйте класс Enumerable, который работает похожим образом, что и Collect, но предназначен для обработки коллекций ассоциативных массивов. Основная особенность работы данного класса заключается в том, что он использует lazy вариант обработки.
	 */
	 
	 $elements = [
		  ['key' => 'value', 'year' => 1932],
		  ['key' => '', 'year' => 1100],
		  ['key' => 'value', 'year' => 32]
	 ];
	 
	 $coll = Enumerable::wrap($elements);
	 $newColl = $coll->where('key', 'value')->where('year', 1932);
	 $newCall->all(); // ['key' => 'value', 'year' => 1932]
	 
	 /*
	 Подсказки
	 Функции, которые нужно реализовать, описаны в интерфейсе EnumerableInterface
	 Усложнённый вариант: добавьте мемоизацию https://ru.wikipedia.org/wiki/Мемоизация
	 */
	 
	 // FILE: app/src/EnumerableInterface.php
	 
	 namespace App;
	 
	 interface EnumerableInterface
	 {
		  public static function wrap($elements);
		  public function where($key, $value);
		  public function all();
	 }
	 
	 
	 // FILE: app/src/Enumerable.php
	 
	 namespace App;
	 
	 // BEGIN (write your solution here)
	 
	 // END
	 
	 
	 
	 // FILE: app/tests/EnumerableTest.php
	 
	 namespace App\Tests;
	 
	 use App\Enumerable;
	 use PHPUnit\Framework\TestCase;
	 
	 class EnumerableTest extends TestCase
	 {
		  public function testWhere()
		  {
				$coll = Enumerable::wrap([]);
				$this->assertEquals([], $coll->all());
	 
				$elements = [
					 ['key' => 'value'],
					 ['key' => '']
				];
				$coll = Enumerable::wrap($elements);
				$result = $coll->where('key', 'value');
				$expected = [
					 ['key' => 'value']
				];
				$this->assertEquals($expected, $result->all());
				$this->assertEquals($elements, $coll->all());
		  }
	 }
	 
	 
	 
	 /**@@
	 Пьяница — карточная игра, в которой побеждает тот игрок, который собирает все карты. В нашей задаче используется модификация игры с двумя игроками. Игрокам раздаётся равное количество карт. Игроки не смотрят в свои карты, а кладут их в стопку рядом с собой. Затем каждый игрок снимает верхнюю карту и показывает её сопернику. Тот игрок, чья карта оказалась большего номинала, берёт обе карты и кладёт их к себе в колоду снизу (так что своя карта идёт первой). Если карты имеют одинаковый номинал, то они выкидываются из игры. В игре возможны три исхода:
	 
	 У обоих игроков не осталось карт
	 Игра не может закончиться
	 Победил один из игроков
	 src/Drunkard.php
	 Реализуйте класс Drunkard с функцией run, которая принимает на вход два списка чисел, которые представляют собой карты для первого и второго игроков.
	 
	 Если выиграл первый игрок, то метод должен вернуть First player. Round: <номер раунда>.
	 Если выиграл второй игрок, то метод должен вернуть Second player. Round: <номер раунда>.
	 Если у игроков не осталось карт, то метод должен вернуть Botva!
	 Если за 100 раундов не удалось выявить победителя то также возвращается Botva!
	 Реальные примеры смотрите в тестах.
	 
	 Подсказки
	 Воспользуйтесь классом \Ds\Deque для работы с колодами
	 **/
	 
	 // FILE: app/src/Drunkard.php
	 
	 namespace App;
	 
	 use Ds\Deque;
	 
	 // BEGIN (write your solution here)
	 
	 // END
	 
	 
	 // FILE: app/tests/DrunkardTest.php
	 
	 namespace App\Tests;
	 
	 use App\Drunkard;
	 use PHPUnit\Framework\TestCase;
	 
	 class DrunkardTest extends TestCase
	 {
		  public function testRun()
		  {
				$game = new Drunkard();
				$result = $game->run([1], [2]);
				$this->assertEquals('Second player. Round: 1', $result);
	 
				$result = $game->run([2], [1]);
				$this->assertEquals('First player. Round: 1', $result);
	 
				$result = $game->run([1], [1]);
				$this->assertEquals('Botva!', $result);
	 
				$result = $game->run([1, 2], [3, 2]);
				$this->assertEquals('Second player. Round: 2', $result);
	 
				$result = $game->run([1, 3], [2, 1]);
				$this->assertEquals('First player. Round: 4', $result);
		  }
	 }
	 
	 
	 
	 /**@@
	 Реализуйте функцию getQuestions, которая принимает на вход текст (полученный из редактора) и возвращает список вопросов извлеченных из этого текста разделенных переводом строки.
	 
	 Входящий текст разбит на строки и может содержать любые пробельные символы. Некоторые из этих строк являются вопросами. Они определяются по последнему символу, который должен равняться знаку ?.
	 **/
	 
	 $text = <<<HEREDOC
	 lala\r\nr
	 ehu?
	 \n \t
	 i see you
	 /r \n
	 one two?\r\n\n
HEREDOC;
	 
	 getQuestions($text);
	 // ehu?
	 // one two?
	 
	 
	 // FILE: app/src/Normalizer.php
	 namespace App\Normalizer;
	 
	 use function Stringy\create as s;
	 
	 function getQuestions(string $text)
	 {
		  $lines = s($text)->lines();
		  $filteredLines = collect($lines)->filter(function ($line) {
				return $line->endsWith('?');
		  });
		  return implode("\n", $filteredLines->all());
	 }
	 
	 
	 // FILE: app/tests/NormalizerTest.php
	 namespace App\Tests;
	 
	 use function App\Normalizer\getQuestions;
	 use PHPUnit\Framework\TestCase;
	 
	 class NormalizerTest extends TestCase
	 {
		  public function testGetQuestions()
		  {
				$text1 = <<<HEREDOC
	 lala\r\nr
	 ehu?
	 \n \t
	 i see you
	 /r \n
	 one two?\r\n\n
HEREDOC;
				$actual1 = getQuestions($text1);
	 
				$expected1 = "ehu?\none two?";
				$this->assertEquals($expected1, $actual1);
		  }
	 }
	 
		
	 
	 
	 
	 /**@@
	 Booking — процесс бронирования чего-либо. В интернете существует множество сайтов, предлагающих бронирование машин, квартир, домов, самолётов и многого другого. Несмотря на то, что такие сайты предлагают разные услуги, букинг везде работает почти идентично. Выбираются нужные даты и, если они свободны, производится бронирование.
	 
	 src/Booking.php
	 Реализуйте класс Booking, который позволяет бронировать номер отеля на определённые даты. Единственный интерфейс класса — функция book, которая принимает на вход две даты в текстовом формате. Если бронирование возможно, то метод возвращает true и выполняет бронирование (даты записываются во внутреннее состояние объекта).
	 
	 Подсказки
	 По обычаям гостиничного сервиса время заселения в номер — после полудня первого дня, а время выселения — до полудня последнего дня. Конкретные часы варьируются в разных отелях. Но в данной практике это не важно, главное понять принцип, по которому указываются даты:
	 **/
	 
	 $booking = new Booking();
	 
	 // забронировать номер на два дня
	 $booking->book('10-11-2008', '12-11-2008');
	 
	 // бронь невозможна, 11-го числа номер будет занят
	 $booking->book('11-11-2008', '15-11-2008');
	 
	 // бронь возможна, потому что 12-го числа номер освободится
	 $booking->book('12-11-2008', '13-11-2008');
	 
	 // бронь невозможна, съём, сроком менее одного дня, обычно не практикуется
	 $booking->book('17-11-2008', '17-11-2008');
	 
	 // бронь возможна, съём номера на один день
	 $booking->book('17-11-2008', '18-11-2008');
	 
	 $booking = new Booking();
	 $booking->book('11-11-2008', '13-11-2008'); // true
	 $booking->book('12-11-2008', '12-11-2008'); // false
	 $booking->book('10-11-2008', '12-11-2008'); // false
	 $booking->book('12-11-2008', '14-11-2008'); // false
	 $booking->book('10-11-2008', '11-11-2008'); // true
	 $booking->book('13-11-2008', '14-11-2008'); // true
	 
	 
	 // FILE: app/src/Booking.php
	 
	 namespace App;
	 
	 use Carbon\Carbon;
	 
	 class Booking
	 {
		  public $dates = [];
	 
		  public function book($begin, $end)
		  {
				$carbonNewBegin = new Carbon($begin);
				$carbonNewEnd = new Carbon($end);
				if ($this->canBook($carbonNewBegin, $carbonNewEnd)) {
					 $this->dates[] = [$carbonNewBegin, $carbonNewEnd];
					 return true;
				}
	 
				return false;
		  }
	 
		  public function canBook($begin, $end)
		  {
				if ($begin >= $end) {
					 return false;
				}
	 
				foreach ($this->dates as [$bookedBegin, $bookedEnd]) {
					 $isStartedAfter = $begin < $bookedEnd;
					 $isEndedBefore = $end > $bookedBegin;
					 if ($isStartedAfter && $isEndedBefore) {
						  return false;
					 }
				}
				return true;
		  }
	 }
	 
	 
	 
	 // FILE: app/tests/BookingTest.php
	 namespace App\Tests;
	 
	 use PHPUnit\Framework\TestCase;
	 use App\Booking;
	 
	 class BookingTest extends TestCase
	 {
		  public function testBook()
		  {
				$booking = new Booking();
				$result1 = $booking->book('11-11-2008', '13-11-2008');
				$this->assertTrue($result1);
	 
				$result2 = $booking->book('12-11-2008', '12-11-2008');
				$this->assertFalse($result2);
	 
				$result3 = $booking->book('10-11-2008', '12-11-2008');
				$this->assertFalse($result3);
	 
				$result4 = $booking->book('12-11-2008', '14-11-2008');
				$this->assertFalse($result4);
	 
				$result5 = $booking->book('10-11-2008', '11-11-2008');
				$this->assertTrue($result5);
	 
				$result6 = $booking->book('13-11-2008', '13-11-2008');
				$this->assertFalse($result6);
	 
				$result7 = $booking->book('13-11-2008', '14-11-2008');
				$this->assertTrue($result7);
		  }
	 }
	 

	 
	 /**@@
	 Дисклеймер - эту задачу можно решить огромным числом способов. Почти наверняка ваш способ будет не такой как решение учителя.
	 
	 Для отработки fluent interface в задаче используется библиотека Collect. Мы не даем никаких подсказок насчет того, какие функции нужно использовать. Как минимум вы знаете главную тройку map, filter и reduce. Их вполне достаточно, но можно и лучше если внимательно поизучать функции в документации Collect.
	 
	 src/Normalizer.php
	 Реализуйте функцию normalize которая принимает на вход список городов, производит внутри некоторые преобразования и возвращает структуру определенного формата.
	 
	 Входные данные
	 **/
	 
	 $raw = [
		  [
				'name' => 'istambul',
				'country' => 'turkey'
		  ],
		  [
				'name' => 'Moscow ',
				'country' => ' Russia'
		  ],
		  [
				'name' => 'iStambul',
				'country' => 'tUrkey'
		  ],
		  [
				'name' => 'antalia',
				'country' => 'turkeY '
		  ],
		  [
				'name' => 'samarA',
				'country' => '  ruSsiA'
		  ],
	 ];
	 
	 /*
	 Входная структура представляет из себя список городов, где каждый город это ассоциативный массив с ключами name и country. Значения в этих ключах не нормализованы. Они могут быть в любом регистре и содержать начальные и концевые пробелы. Сами города могут дублироваться в рамках одной страны.
	 
	 Результат
	 */
	 
	 $actual = normalize($raw);
	 // $expected = [
	 //     'russia' => [
	 //         'moscow', 'samara'
	 //     ],
	 //     'turkey' => [
	 //         'antalia', 'istambul'
	 //     ]
	 // ];
	 
	 /*
	 Конечная структура - ассоциативный массив, в котором ключ это страна, а значение - список имен городов отсортированный по именам. Сама структура отсортирована по городам. Дублей городов в выходной структуре быть не должно, а сами страны и города должны быть записаны в нижнем регистре без ведущих и концевых пробелов.
	 */
	 
	 // FILE: app/src/Normalizer.php
	 
	 namespace App\Normalizer;
	 
	 
	 function normalize($raw)
	 {
		  return collect($raw)
				->map(function ($value) {
					 return array_map('mb_strtolower', $value);
				})
				->map(function ($value) {
					 return array_map('trim', $value);
				})
				->unique('name')
				->mapToGroups(function ($item, $key) {
					 return [$item['country'] => $item['name']];
				})
				->map(function ($cities) {
					 return $cities->sort()->values();
				})
				->sortKeys()
				->toArray();
	 }
	 
	 
	 
	 // FILE: app/tests/NormalizerTest.php
	 namespace App\Tests;
	 
	 use function App\Normalizer\normalize;
	 use PHPUnit\Framework\TestCase;
	 
	 class NormalizeTest extends TestCase
	 {
		  public function testNormalize()
		  {
				$raw = [
					 [
						  'name' => 'istambul',
						  'country' => 'turkey'
					 ],
					 [
						  'name' => 'Moscow ',
						  'country' => ' Russia'
					 ],
					 [
						  'name' => 'iStambul',
						  'country' => 'tUrkey'
					 ],
					 [
						  'name' => 'antalia',
						  'country' => 'turkeY '
					 ],
					 [
						  'name' => 'samarA',
						  'country' => '  ruSsiA'
					 ],
				];
	 
				$actual = normalize($raw);
				$expected = [
					 'russia' => [
						  'moscow', 'samara'
					 ],
					 'turkey' => [
						  'antalia', 'istambul'
					 ]
				];
				$this->assertEquals($expected, $actual);
		  }
	 
		  public function testNormalize2()
		  {
				$raw = [
					 [
						  'name' => 'pariS ',
						  'country' => ' france'
					 ],
					 [
						  'name' => ' madrid',
						  'country' => ' sPain'
					 ],
					 [
						  'name' => 'valencia',
						  'country' => 'spain'
					 ],
					 [
						  'name' => 'marcel',
						  'country' => 'france'
					 ],
					 [
						  'name' => ' madrid',
						  'country' => ' sPain'
					 ],
				];
	 
				$actual = normalize($raw);
				$expected = [
					 'france' => [
						  'marcel', 'paris'
					 ],
					 'spain' => [
						  'madrid', 'valencia'
					 ]
				];
				$this->assertEquals($expected, $actual);
		  }
	 }
	 
	 
	 
	 
	 /**@@
	 Реализуйте класс DeckOfCards, который описывает колоду карт и умеет её мешать.
	 
	 Конструктор класса принимает на вход массив, в котором перечислены номиналы карт в единственном экземпляре, например, [6, 7, 8, 9, 10, 'king'].
	 
	 Реализуйте публичный метод getShuffled, с помощью которого можно получить полную колоду в виде отсортированного случайным образом массива.
	 
	 Примечания
	 В "полной" колоде каждая карта встречается 4 раза — для простоты не учитываем масть.
	 Примеры
	 **/
	 
	 $deck = new DeckOfCards([2, 3]);
	 $deck->getShuffled(); // [2, 3, 3, 3, 2, 3, 2, 2]
	 $deck->getShuffled(); // [3, 3, 2, 2, 2, 3, 3, 2]
	 
	 /*
	 Подсказки
	 Используйте функцию collect для оборачивания массивов
	 Документация по доступным функциям https://laravel.com/docs/5.6/collections
	 */
	 
	 // FILE: app/src/DeckOfCards.php
	 
	 namespace App;
	 
	 class DeckOfCards
	 {
		  private $cards;
	 
		  public function __construct(array $types)
		  {
				$this->cards = collect($types)
					  ->map(function ($card) {
							return array_fill(0, 4, $card);
					  })
					  ->flatten();
		  }
	 
		  public function getShuffled(): array
		  {
				return $this->cards->shuffle()->all();
		  }
	 }
	 
	 
	 
	 
	 // FILE: app/tests/DeckOfCardsTest.php
	 namespace App\Tests;
	 
	 use App\DeckOfCards;
	 use PHPUnit\Framework\TestCase;
	 
	 class DeckOfCardsTest extends TestCase
	 {
		  public function testGetShuffled1()
		  {
				$expected = [2, 2, 2, 2, 3, 3, 3, 3];
				$deck = new DeckOfCards([2, 3]);
				$result1 = $deck->getShuffled();
				$result2 = $deck->getShuffled();
				$this->assertNotEquals($result1, $result2);
	 
				sort($result1);
				$this->assertEquals($expected, $result1);
	 
				sort($result2);
				$this->assertEquals($expected, $result2);
		  }
	 
		  public function testGetShuffled2()
		  {
				$expected = [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9];
				$deck = new DeckOfCards([8, 9, 7]);
				$result1 = $deck->getShuffled();
				$result2 = $deck->getShuffled();
				$this->assertNotEquals($result1, $result2);
	 
				sort($result1);
				$this->assertEquals($expected, $result1);
	 
				sort($result2);
				$this->assertEquals($expected, $result2);
		  }
	 }
	 
	 
	 
	 
	 
	 function foo (callable $x) // ожидается callback функция
	 {
		 // some code
	 }
	 
	 echo foo($obj, "func"); // функция должна принимать метод Класса
	 echo foo(['MyClass', 'staticFunc']); // функция должна принимать статический метод Класса `MyClass`
	 echo foo($obj); // Функция может принимать объект, если у него описан магический метод __invoke
	 
	 // http://php.net/manual/ru/ref.classobj.php
	 
	 
	 
		
	 ###############  PHP: Полиморфизм ###############
	 
	 #>>>>>> Параметрический полиморфизм <<<<<<#
	 
	 /*
	 Слово "полиморфизм", в зависимости от контекста, может означать разные вещи. Когда о полиморфизме говорят программисты на императивных языках, они, как правило, подразумевают "полиморфизм подтипов". В тоже время, программисты на функциональных языках имеют ввиду "параметрический полиморфизм". О последнем и поговорим.
	 
	 В PHP встроена функция array_merge(), которая объединяет переданные ей массивы:
	 */
	 array_merge([1], [2, 3, 1]); // [1, 2, 3, 1]
	 array_merge(['one'], ['two', 'three']); // ['one', 'two', 'three']
	 array_merge([true], [false, false, true]); // [true, false, false, true]
	 
	 // Эта функция объединяет любые массивы, независимо от типа данных, содержащихся внутри. Попробуем реализовать её самостоятельно.
	 
	 // Это немного урезанная версия функции array_merge, она работает только с двумя аргументами
	 // Функция создаёт новый массив, затем обходит по очереди переданные массивы и добавляет их значения
	 // во вновь созданный массив. Затем он возвращается наружу.
	 
	 function myArrayMerge(array $first, array $last)
	 {
		  $result = [];
	 
		  foreach ($first as $value) {
				$result[] = $value;
		  }
	 
		  foreach ($last as $value) {
				$result[] = $value;
		  }
	 
		  return $result;
	 }
	 
	 
	 /*
	 Посмотрите внимательно на этот код. Выполняются ли в нём какие-либо операции над данными внутри массива? Ответ: нет. Эти данные перекладываются из одного массива в другой, но над ними не происходит никаких действий. Наша новая функция myArrayMerge(), также как и исходная array_merge() может работать с массивами, содержащими любые типы данных.
	 
	 Для разработчиков, которые писали только на динамических языках, такое поведение кажется естественным, но в статических языках не всё так просто. Ниже пример определения массивов в Java:
	 */
	 int numbers[] = {3, 1, 2, 5, 4};
	 String words[] = {"one", "two", "three"};
	 
	 /*
	 В глаза бросается необходимость указывать тип. Для первого массива это int, для второго String. Нельзя создать массив без указания типа его значений. Тоже самое касается функций обрабатывающих массивы:
	 */
	 
	 class Main {
		  public static void main(String[] args) {
			 int[] a = {1, 2, 3, 4};
			 int[] b = {4, 16, 1, 2, 3, 22};
			 myArrayMerge(a, b);
		  }
	 
		  public static int[] myArrayMerge(int[] first, int[] last) {
				int[] result = new int[first.length + last.length];
				int count = 0;
	 
				for (int i = 0; i < first.length; i++) {
					result[i] = first[i];
					count++;
				}
	 
				for (int j = 0; j < last.length; j++) {
					result[count] = last[j];
					count++;
				}
	 
				return result;
		  }
	 }
	 
	 
	 /*
	 Обратите внимание на сигнатуру метода myArrayMerge(): int[] myArrayMerge(int[] first, int[] last). В отличие от варианта на PHP, здесь указано что входными параметрами являются массивы чисел. То есть для массива строк эта функция работать не будет. Не будет она работать и для всех остальных типов данных.
	 
	 Что это означает на практике? Очень простую и печальную вещь. Нам придётся реализовывать подобную функцию для каждого типа, при том что алгоритм внутри абсолютно идентичен.
	 
	 Именно тут нам пригодится параметрический полиморфизм. Статическим языкам приходится вводить в язык специальные конструкции, которые позволяют описывать подобные алгоритмы безотносительно типа.
	 В некоторых языках их называют шаблонами (c++) или дженериками (java, c#):
	 */
	 
	 class Main {
		public static void main(String[] args) {
		  Integer[] a = {1, 2, 3, 4};
		  Integer[] b = {4, 16, 1, 2, 3, 22};
		  myArrayMerge(a, b);
		}
	 
		public static<T> T[] myArrayMerge(T[] first, T[] last) {
			 T[] result = (T[]) new Object[first.length + last.length];
			 int count = 0;
	 
			 for (int i = 0; i < first.length; i++) {
				 result[i] = first[i];
				 count++;
			 }
	 
			 for (int j = 0; j < last.length;j++) {
				 result[count] = last[j];
				 count++;
			 }
	 
			 return result;
		}
	 }
	 
	 /*
	 В этом коде появляется тип T, что как раз и означает возможность использования с любым типом внутри массива. Теперь функция myArrayMerge работает подобно аналогу из PHP.
	 
	 Параметрический полиморфизм дает возможность писать обобщённые алгоритмы для составных типов, что, в некоторых случаях, значительно сокращает количество кода. Иногда, за это приходится платить сложностью решения, но, для большинства типичных операций сложность растёт не сильно. Это видно и по коду выше.
	 
	 В динамических языках, для реализации обобщённых алгоритмов, параметрический полиморфизм не нужен. Любая коллекция может содержать любые типы данных в любой момент времени. Благодаря этому не требуется вводить дополнительных языковых конструкций и изучать новые концепции.
	 
	 В литературе использование параметрического полиморфизма часто называется обобщённым программированием.
	 */
	 
	 
	 /**@@
	 В этой практике вам предстоит поработать с односвязным списком. Для лучшего понимания задачи, прочитайте литературу данную в подсказках и изучите исходники файла src/Node.php, внутри которого находится реализация односвязного списка. И посмотрите тесты, там видно как список создается и используется.
	 
	 src/LinkedList.php
	 Реализуйте функцию reverse($list), которая принимает на вход односвязный список и переворачивает его.
	 https://ru.wikipedia.org/wiki/Связный_список#Односвязный_список_(однонаправленный_связный_список)
	 */
	 $numbers = new Node(1, new Node(2, new Node(3)));
	 $reversedNumbers = reverse($numbers); // (3, 2, 1)
	 
	 
	 // FILE /app/src/LinkedList.php:
	 use App\Node;
	 use function App\LinkedList\reverse;
	 
	 function reverse(\App\Node $list)
	 {
		  $newHead = null;
		  $current = $list;
	 
		  while ($current) {
				$newHead = new Node($current->getValue(), $newHead);
				$current = $current->getNext();
		  }
	 
		  return $newHead;
	 }
	 
	 // FILE /app/src/Node.php:
	 namespace App;
	 
	 class Node
	 {
		  public function __construct($value, Node $node = null)
		  {
				$this->next = $node;
				$this->value = $value;
		  }
	 
		  public function getNext()
		  {
				return $this->next;
		  }
	 
		  public function getValue()
		  {
				return $this->value;
		  }
	 }
	 
	 
	 
	 #>>>>>> Диспетчеризация по ключу (данные) <<<<<<<#
	 
	 /*
	 В связке с полиморфизмом постоянно возникает выражение "динамическая диспетчеризация". С самим понятием мы познакомимся позже, а сейчас поговорим про диспетчеризацию в принципе.
	 
	 Диспетчеризация (от английского dispatch - отсылать, отправлять) - процесс координации каких-либо действий. Например диспетчер в аэропорту разводит самолеты, диспетчер в службе такси связывает доступного водителя и клиента.
	 
	 Рассмотрим условный код, в котором выбор ветки исполнения идёт по конкретному значению переменной:
	 */
	 
	 if ($env === 'development') {
		  $databaseConfiguration = [
				'adapter' => 'sqlite',
		  ];
	 } else if ($env === 'production') {
		  $databaseConfiguration = [
				'adapter' => 'postgresql',
		  ];
	 }
	 
	 /*
	 Во всех проектах существует понятие "среда", это то окружение в котором происходит запуск проекта. Во время разработки код запускают в среде разработчика, её традиционно называют development. Среда, в которой приложение работает по-настоящему, называется production. В зависимости от среды, приложения по разному стартуют, конфигурируются и даже работают, например в разных средах могут использоваться разные базы данных.
	 
	 Код выше как раз типичный пример того, как меняется конфигурация в зависимости от среды. Процесс выбора можно назвать процессом диспетчеризации.
	 
	 Статичная условная конструкция, в которой диспетчеризация идёт по строкам, легко заменяется на свитч. Так код становится понятнее и проще:
	 */
	 
	 switch ($env) {
		  case 'development':
				$databaseConfiguration = [
					 'adapter' => 'sqlite',
				];
				break;
		  case 'production':
				$databaseConfiguration = [
					 'adapter' => 'postgresql',
				];
				break;
	 }
	 
	 /*
	 Хотя кода и стало чуть больше, switch сам по себе более явно описывает процесс диспетчеризации. Но можно пойти ещё дальше и сделать диспетчеризацию по ключу ассоциативного массива:
	 */
	 
	 $databaseSettingsByEnv = [
		  'development' => [
				'adapter' => 'sqlite',
		  ],
		  'production' => [
				'adapter' => 'postgresql',
		  ],
	 ];
	 
	 $databaseConfiguration = $databaseSettingsByEnv[$env];
	 
	 // Значение по умолчанию легко добавить через оператор ??:
	 $databaseConfiguration = $databaseSettingsByEnv[$env] ?? [ 'adapter' => 'memory' ];
	 
	 
	 /*
	 Этот вариант лучше предыдущих двух сразу по нескольким причинам. Во-первых он короче, во-вторых он гибче. Условные конструкции это статичный код, который нельзя поменять без переписывания самой программы в отличие от последнего варианта. А вот данные это совсем другое дело. Для удобства их часто кладут в файлы конфигурации, которые используют формат json или yaml, например:
	 development:
		adapter: sqlite
	 
	 production:
		adapter: sqlite
	 
	 При таком подходе, легко добавить новое поведение без изменения самого кода приложения. Его мощь особенно чувствуется в ситуациях, когда обработкой занимается не наш код, а код библиотеки или фреймворка. Ведь мы не можем просто взять, открыть исходники и поправить их.
	 */
	 
	 /**@@
	 src/HTML.php
	 Реализуйте функцию getLinks($tags), которая принимает на вход список тегов, находит среди них теги a, link и img, а затем извлекает ссылки и возвращает список ссылок. Теги подаются на вход в виде массива, где каждый элемент это тег. Тег имеет следующую структуру:
	 
	 name - имя тега.
	 href или src - аттрибуты. Атрибуты зависят от тега: img - src, a - href, link - href.
	 */
	 
	 use function App\HTML\getLinks;
	 
	 $tags = [
		  ['name' => 'img', 'src' => 'hexlet.io/assets/logo.png'],
		  ['name' => 'div'],
		  ['name' => 'link', 'href' => 'hexlet.io/assets/style.css'],
		  ['name' => 'h1']
	 ];
	 
	 $links = getLinks($tags);
	 // [
	 //     'hexlet.io/assets/logo.png',
	 //     'hexlet.io/assets/style.css'
	 // ];
	 
	 // FILE: /app/src/HTML.php
	 namespace App\HTML;
	 
	 function getLinks($tags)
	 {
		  $mapping = [
				'a' => 'href',
				'img' => 'src',
				'link' => 'href'
		  ];
	 
		  $filteredTags = array_filter($tags, function ($tag) use ($mapping) {
				return in_array($tag['name'], array_keys($mapping));
		  });
	 
		  $paths = array_map(function ($tag) use ($mapping) {
				$attributeName = $mapping[$tag['name']];
	 
				return $tag[$attributeName];
		  }, $filteredTags);
		  
		  return array_values($paths);
	 }
	 
	 
	 
	 #>>>>>> Диспетчеризация по ключу (функции) <<<<<<<#
	 
	 /*
	 Диспетчеризация по ключу ассоциативного массива мощнее чем кажется на первый взгляд. Далеко не всегда достаточно выбирать разные данные, иногда приходится выполнять другой код.
	 
	 Предположим что нам надо сформировать массив, с фамилиями наших пользователей. Главное условие – для девушек берётся девичья фамилия.
	 
	 Реализуем эту задачу используя старый добрый if:
	 */
	 
	 $lastNames = array_map($users, function ($user) {
		  if ($user->gender == 'female') {
				return $user->maidenName;
		  }
		  
		  return $user->lastName;
	 });
	 
	 
	 // Теперь решим эту задачу используя диспетчеризацию по ключам объекта, но в отличие от предыдущего урока, в значениях у нас будут функции:
	 
	 
	 // Определяем key-value, где ключ это пол, а значение это функция, возвращающая нужное значение для пола
	 $mapping = [
		  'female' => function ($user) {
				return $user->maidenName;
		  },
		  'male' => function ($user) {
				return $user->lastName;
		  },
	 ];
	 
	 $lastNames = array_map($users, function ($user) use ($mapping) {
		// Выбираем нужную функцию по названию пола и вызываем её
		// Внутрь функции передается пользователь
		return $mapping[$user->gender]($user);
	 });
	 
	 /*
	 Кода стало больше, но хочу подчеркнуть, что во многом "виноват" сам PHP. У него очень многословный синтаксис определения анонимных функций. Тот же код в JavaScript, будет практически идентичен по размерам первоначальному варианту
	 
	 В некоторых ситуациях такой вариант решения задачи лучше. В нём явно прослеживаются зависимости, особенно если их становится много. Кроме того, конфигурация данными позволяет вынести их в другое место и расширять поведение без переписывания кода, который использует эти данные.
	 
	 Ещё один пример – парсинг данных в зависимости от их типа:
	 */
	 
	 use Symfony\Component\Yaml\Yaml;
	 
	 function parse($type, $data)
	 {
		  $mapping = [
				'yml' => function ($rawData) {
					 return Yaml::parse($rawData);
				},
				'json' => function ($rawData) {
					 return json_decode($rawData);
				}
		  ];
	 
		  return $mapping[$type]($data);
	 }
	 
	 /**@@
	 src/HTML.php
	 Реализуйте функцию stringify($tag), которая принимает на вход тег и возвращает его текстовое представление. Например:
	 */
	 
	 use function App\HTML\stringify;
	 
	 $tag = ['name' => 'hr', 'class' => 'px-3', 'id' => 'myid', 'tagType' => 'single'];
	 $html = stringify($tag);
	 // <hr class="px-3" id="myid">
	 
	 
	 $tag = ['name' => 'div', 'tagType' => 'pair', 'body' => 'text2', 'id' => 'wow'];
	 $html = stringify($tag);
	 // <div id="wow">text2</div>
	 
	 /*
	 Внутри структуры тега есть три специальных ключа:
	 
	 name - имя тега
	 tagType - тип тега, определяет его парность (pair) или одиночность (single)
	 body - тело тега, используется для парных тегов
	 
	 Все остальное становится атрибутами тега и не зависит от того парный он или нет.
	 
	 Подсказки
	 В этой задаче хорошо работает Collect https://laravel.com/docs/5.8/collections
	 */
	 
	 // FILE: /app/src/HTML.php
	 
	 namespace App\HTML;
	 
	 function buildAttrs(array $tag)
	 {
		  return collect($tag)
				->except(['name', 'tagType', 'body'])
				->map(function ($value, $key) {
					 return " {$key}=\"{$value}\"";
				})->join('');
	 }
	 
	 function stringify($tag)
	 {
		  $mapping = [
				'single' => function ($tag) {
					 $attrs = buildAttrs($tag);
	 
					 return "<{$tag['name']}{$attrs}>";
				},
				'pair' => function ($tag) {
					 $attrs = buildAttrs($tag);
	 
					 return "<{$tag['name']}{$attrs}>{$tag['body']}</{$tag['name']}>";
				}
		  ];
	 
		  $build = $mapping[$tag['tagType']];
		  return $build($tag);
	 }
	 
	 
	 
	 #>>>>>> Диспетчеризация по имени файла <<<<<<#
	 
	 /*
	 Ещё один интересный приём – диспетчеризация по имени файла.
	 
	 В некоторых системах принято иметь не один файл с разными ключами для конфигурации, а разные файлы относящиеся к разным средам. Например:
	 
	 configs/
		database.development.json
		database.production.json
		database.test.json
	 
	 Где-то в исходниках должен быть код, который выбирает какой файл загружать. Ниже код используя диспетчеризацию по ключу:
	 */
	 
	 $configFileNamesByEnv = [
		  'development' => 'database.development.json',
		  'production' => 'database.production.json',
		  'test' => 'database.test.json'
	 ];
	 
	 $filename = $configFileNamesByEnv[$env];
	 $raw = file_get_contents($filename);
	 $config = json_decode($raw);
	 
	 // Нетрудно заметить, что имея название среды запуска, можно составить подходящее имя файла. Так и сделаем:
	 $filename = "database.{$env}.json";
	 $raw = file_get_contents($filename);
	 $config = json_decode($raw);
	 
	 
	 // Код стал намного короче и больше не требует изменения при расширении.
	 
	 /**@@
	 src/DatabaseConfigLoader.php
	 Реализуйте класс DatabaseConfigLoader, который отвечает за загрузку конфигурации для базы данных. У класса следующий интерфейс:
	 
	 Конструктор - принимает на вход путь, по которому нужно искать конфигурацию
	 load($env) - метод, который грузит конфигурацию для конкретной среды окружения. Она загружает файл database.{$env}.json, парсит его и возвращает результат наружу.
	 */
	 
	 $loader = new DatabaseConfigLoader(__DIR__ . '/fixtures');
	 $config = $loader->load('production'); // loading database.production.json
	 // [
	 //     'host' => 'google.com',
	 //     'username' => 'postgres'
	 // ];
	 
	 /*
	 В этом классе и конфигурации реализована поддержка расширения. Если в загружаемом конфиге есть ключ extend, то нужно загрузить конфигурацию с этим именем (он соответствует $env). Далее конфигурации мержатся между собой так, что приоритет имеет загруженный раньше. Более подробный пример посмотрите в тестах.
	 */
	 
	 // FILE: /app/src/
	 
	 namespace App;
	 
	 class DatabaseConfigLoader
	 {
		  private $path;
	 
		  public function __construct($path)
		  {
				$this->path = $path;
		  }
	 
		  public function load($name)
		  {
				$filename = "database.{$name}.json";
	 
				$raw = file_get_contents($this->path . '/' . $filename);
				$config = json_decode($raw, true);
	 
				if (!isset($config['extend'])) {
					 return $config;
				}
	 
				$newName = $config['extend'];
				unset($config['extend']);
	 
				return array_merge($this->load($newName), $config);
		  }
	 }
	 
	 
	 
	 #>>>>>> Полиморфизм (утиная типизация) <<<<<<#
	 
	 /*
	 Начнём знакомство с полиморфизмом подтипов с задачки. Представьте себе функцию, которая проверяет есть ли комментарии у статьи или топика (вопросы пользователей Хекслета под уроками и проектами).
	 */
	 
	 function hasComments($commentable)
	 {
		  // Если это статья
		  if ($commentable instanceof Article) {
				return count($commentable->getArticleComments()) > 0;
		  // Если это топик
		  } elseif ($commentable instanceof Topic) {
				return count($commentable->getTopicComments()) > 0;
		  }
	 }
	 
	 class Article
	 {
		  // some code
		  public function getArticleComments()
		  {
				return $this->comments;
		  }
	 }
	 
	 
	 class Topic
	 {
		  // some code
		  public function getTopicsComments()
		  {
				return $this->comments;
		  }
	 }
	 
	 // Article::first() - статический метод, который возвращает первую статью из базы данных
	 $article = Article::first();
	 hasComments($article);
	 
	 /*
	 С таким кодом мы уже сталкивались ранее. Каждый новый тип, потребует от нас добавления кода в эту условную конструкцию. Его можно заменить на диспетчеризацию по ключу, но особенно лучше не станет. Всё равно придётся описывать поведение для каждого класса в дополнении к тому, что поведение и так описано внутри каждого класса. Но можно сделать кое-что лучше. Достаточно согласовать интерфейс всех типов и договориться о том, что метод для извлечения комментариев будет называться getComments(). Тогда код станет таким:
	 */
	 
	 function hasComments($commentable)
	 {
		  return count($commentable->getComments()) > 0;
	 }
	 
	 $article = Article::first();
	 hasComments($article);
	 
	 $topic = Topic::first();
	 hasComments($topic);
	 
	 /*
	 Теперь, функцию hasComments($commentable) можно вызывать с любым объектом, имеющим метод getComments(), с необходимой сигнатурой. Эта функция не поменяется даже при добавлении нового класса, содержащего такой же метод.
	 
	 Способность функции, обрабатывать объекты разных типов одинаковым образом, называется полиморфизмом подтипов (почему подтипов, мы разберёмся в следующих уроках, но это не про наследование), а сама функция – полиморфной функцией.
	 
	 Как видно из кода выше, для реализации такого полиморфизма, в PHP не нужно наследование и интерфейсы. В миру такой подход называют "утиной типизацией". Если что-то ходит как утка и крякает как утка, то это утка. Позже мы рассмотрим полиморфизм подтипов вместе с интерфейсами
	 
	 Технически, самое простое и понятное что делает полиморфизм подтипов (для клиентского кода) – убирает условные конструкции. Любую условную конструкцию можно заменить полиморфизмом и любую полиморфную функцию можно заменить ифами. Другими словами, полиморфизм подтипов не является неотъемлемой частью разработки, код можно писать и без него. С другой стороны, иногда встречаются ситуации, в которых он здорово помогает, но не сказать что это происходит постоянно.
	 
	 В чем разница между параметрическим и полиморфизмом подтипов? В первом случае, реализуется общий алгоритм для контейнера (например массива), который, содержит значение или значения типа T. Этот алгоритм не зависит от T и для любых T выполняется идентично. Во втором, алгоритм построен вокруг самого объекта и использует его методы. В полиморфизме подтипов, полиморфная функция работает только с теми объектами, которые имеют необходимые для реализации алгоритма методы.
	 */
	 
	 
	 
	 /**@@
	 В программировании, для некоторых задач, распространены key-value базы данных. Внешне они работают по принципу ассоциативных массивов, но живут как отдельные программы и умеют много полезных штук, например сохранять данные на диск, переносить данные между машинами в сети и тому подобное.
	 
	 В этой задаче реализована подобная база данных в виде класса FileKV, который сохраняет свои данные на диске в указанном файле. Она имеет следующий интерфейс:
	 */
	 
	 $map = new FileKV('/path/to/dbfile');

	 // Получение значения по ключу
	 $map->get('key'); // key
	 $map->get('unkonwnkey'); // null

	 // Получение значения и дефолт
	 $map->get('unkonwnkey', 'default value'); // default value

	 // Установка и обновление ключа
	 $map->set('key2', 'value2');
	 $map->get('key2'); // value2

	 // Удаление ключа
	 $map->unset('key2'); // value2
	 $map->get('key2'); // null
	 $map->set('key', 'value'); // null

	 // Возврат всех данных из базы
	 $map->toArray(); // ['key' => 'value']
	 
	 /*
	 В целях тестирования, бывает полезно иметь реализацию такой базы данных, которая хранит данные в памяти, а не во внешнем хранилище. Это позволяет легко сбрасывать состояние между тестами и не замедлять их.
	 
	 src/InMemoryKV.php
	 
	 Реализуйте класс InMemoryKV, который представляет собой in-memory key-value хранилище. Данные внутри него хранятся в обычном ассоциативном массиве. Интерфейс этого класса совпадает с FileKV за исключением конструктора. Конструктор InMemoryKV принимает на вход массив, который становится начальным значением базы данных.
	 */
	 
	 use App\InMemoryKV;
	 
	 $map = new InMemoryKV(['key' => 10]);
	 $map->get('key'); // 10
	 
	 /**@@
	 src/KeyValueFunctions.php
	 
	 Реализуйте функцию swapKeyValue, которая принимает на вход объект базы данных и меняет в нем ключи и значения местами.
	 
	 swapKeyValue – полиморфная функция, она может работать с любой реализацией key-value имеющую такой же интерфейс
	 */
	 
	 $map = new \App\InMemoryKV(['key' => 10]);
	 $map->set('key2', 'value2');
	 swapKeyValue($map);
	 $map->get('key'); // null
	 $map->get(10); // key
	 $map->get('value2'); // key2
	 
	 
	 // FILE: /app/src/FileKV.php:
	 namespace App;
	 
	 class FileKV
	 {
		  private $dbfilepath;
	 
		  public function __construct($dbfilepath, $initial = [])
		  {
				$this->dbfilepath = $dbfilepath;
	 
				foreach ($initial as $key => $value) {
					 $this->set($key, $value);
				};
		  }
	 
		  public function set($key, $value)
		  {
				$content = file_get_contents($this->dbfilepath);
				$data = unserialize($content);
				$data[$key] = $value;
				file_put_contents(serialize($data));
		  }
	 
		  public function unset($key)
		  {
				$content = file_get_contents($this->dbfilepath);
				$data = unserialize($content);
				unset($data[$key]);
				file_put_contents(serialize($data));
		  }
	 
		  public function get($key, $default = null)
		  {
				$content = file_get_contents($this->dbfilepath);
				$data = unserialize($content);
	 
				return $data[$key] ?? $default;
		  }
	 
		  public function toArray()
		  {
				$content = file_get_contents($this->dbfilepath);
				$data = unserialize($content);
				return $data;
		  }
	 }
	 
	 // FILE: /app/src/KeyValueFunctions.php:
	 namespace App\KeyValueFunctions;
	 
	 use App\InMemoryKV;
	 
	 function swapKeyValue($map)
	 {
		  $data = $map->toArray();
		  
		  foreach ($data as $key => $value) {
				$map->unset($key);
				$map->set($value, $key);
		  }
	 
		  return $map;
	 }
	 
	 
	 
	 // FILE: /app/src/InMemoryKV.php:
	 namespace App;
	 
	 class InMemoryKV
	 {
		  private $map;
	 
		  public function __construct($initial = [])
		  {
				$this->map = $initial;
		  }
	 
		  public function set($key, $value)
		  {
				$this->map[$key] = $value;
		  }
	 
		  public function unset($key)
		  {
				unset($this->map[$key]);
		  }
	 
		  public function get($key, $default = null)
		  {
				return $this->map[$key] ?? $default;
		  }
	 
		  public function toArray()
		  {
				return $this->map;
		  }
	 }
	 
	 
	 
	 /**@@
	 file: Repository.php
	 Реализуйте динамические методы findAllBy<FieldName>.
	 Название MyFieldNameId должно преобразовываться в my_field_name_id.
	 Методы должны возвращать sql запрос. Используйте метод where, уже написанный для Repository.
	 Бросайте исключение WrongFinderNameException, если название метода не соответствует шаблону /findAllBy([A-Z].*)/.
	 */
	 
	 namespace App;
	 
	 require_once "RepositoryInterface.php";
	 require_once "WrongFinderNameException.php";
	 
	 class Repository implements RepositoryInterface
	 {
		  
		  private $tableName;
	 
		  public function __construct($tableName)
		  {
				$this->tableName = $tableName;
		  }
	 
		  public function __call($finder, $arguments)
		  {
				preg_match("/findAllBy([A-Z].*)/", $finder, $outputArray);
	 
				if (!$outputArray) {
					 throw new WrongFinderNameException();
				}
	 
				$fieldUpperName = $outputArray[1];
				preg_match_all("/([A-Z][^A-Z]+)/", $fieldUpperName, $matches);
				$fieldName = implode('_', array_map(function ($part) {
					 return mb_strtolower($part);
				}, $matches[0]));
	 
				return $this->where($fieldName, $arguments[0]);
		  }
		  
	 
		  public function where($fieldName, $value)
		  {
				$format = "select * from %s where %s = '%s'";
				return sprintf(
					 $format,
					 $this->_escape($this->tableName),
					 $this->_escape($fieldName),
					 $this->_escape($value)
				);
		  }
	 
		  private function _escape($value)
		  {
				// NOTE: we must to implement escape logic over here in real world
				return $value;
		  }
	 }
	 
	 
	 
	 
	 #>>>>>> Null Object Pattern <<<<<<#
	 
	 /*
	 На сайтах, у которых есть аутентификация, внутри присутствует понятие "текущий пользователь". Это тот пользователь который аутентифицировался через форму (или вошел через социальную сеть). Текущий пользователь активно используется для вывода различных блоков информации, например отображении блока этого пользователя. Подобный код обычно выглядит так:
	 
	 -- где-то в воображаемом шаблоне articles/index.phtml
	 -- $this - предоставляется фреймворком, это объект View внутри которого лежат данные и полезные методы
	 
	 <? if ($this->userSignedIn() && $this->currentUser->hasArticles()): ?>
		  <? foreach ($this->currentUser->getArticles() as $article): ?>
				<!-- тут выводим статьи -->
		  <? endforeach ?>
	 <? endif ?>
	 */
	 
	 if ($this->userSignedIn() && $this->currentUser->hasArticles()): ?>
		  <? foreach ($this->currentUser->getArticles() as $article): ?>
				<!-- тут выводим статьи -->
		  <? endforeach ?>
	 <? endif ?>
	 
	 <?
	 /*
	 Обратите внимание на проверку существования пользователя. Если её не сделать, то код упадет с ошибкой, потому что вызывается метод hasArticles() у null. Когда этих проверок одна-две, то ничего страшного, но если их десятки и больше, то код быстро захламляется. Кроме того, такую проверку очень легко забыть вставить.
	 
	 Можно ли решить эту задачу каким-то другим способом? Оказывается можно. Достаточно использовать полиморфизм подтипов. Для этого создаётся класс описывающий пользователя не прошедшего аутентификацию, например, Guest. Затем в него добавляются все необходимые методы, для которых мы хотим получить полиморфное поведение.
	 */
	 
	 class Guest
	 {
		  public function hasArticles()
		  {
				return false;
		  }
	 
		  public function getArticles()
		  {
				return [];
		  }
	 }
	 
	 /*
	 Большинство этих методов возвращает false либо пустые списки, так как у этого пользователя ничего нет. Зачем тогда он нужен? Всё очень просто, теперь клиентский код, всегда рассчитывает на существование пользователя, ему больше не нужно проверять аутентификацию:
	 
	 -- может быть гостем, а может быть реальным пользователем
	 */
	 
	 if ($this->currentUser->hasArticles()): ?>
		  <? foreach ($this->currentUser->getArticles() as $article): ?>
				<!-- тут выводим статьи -->
		  <? endforeach ?>
	 <? endif ?>
	 
	 
	 <?
	 /*
	 Условные конструкции уйдут по всем шаблонам, но остаётся вопрос. А где и как происходит сам процесс создания нашего пользователя? И вот здесь останется тот единственный if, благодаря которому произойдет создание правильного объекта. Это происходит на этапе обработки входящего запроса, и конкретное место зависит от используемого фреймворка. Код в этом месте выглядит примерно так:
	 */
	 
	 function fetchCurrentUser()
	 {
		  $userId = $_SESSION['user_id'] ?? null;
		  // Если id есть в сессии, то выбираем пользователя из базы, иначе возвращаем гостя
		  return $userId ? User::find($userId) : new Guest();
	 }
	 
	 /*
	 У такого способа использования полиморфизма есть особое название: шаблон проектирования "null object". Он часто используется внутри фреймворков и иногда встречается в прикладном коде. На Хекслете таких мест как минимум 3. Например в классе Guest у нас десятки методов.
	 */
	 
	 
	 
	 /**@@
	 На Хекслете доступ к курсам оформляется через подписку. Подписка, это отдельная сущность, которая хранит в себе информацию о самой подписке, когда она началась, сколько продолжается, оплачена ли и так далее. Типичная проверка на наличие подписки (а значит доступ к платному контенту) выглядит так:
	 */
	 
	 // Эти примеры сильно упрощены, к тому же Хекслет написан на Rails
	 // но для демонстрации идеи такая реализация подойдет
	 $user->getCurrentSubscription()->hasPremiumAccess();
	 $user->getCurrentSubscription()->hasProfessionalAccess();
	 
	 // Но не у всех пользователей есть подписка, на Хекслете есть и большая бесплатная часть. Так как подписка может отсутствовать, в коде придется делать так:
	 
	 if ($user->getCurrentSubscription() && $user->getCurrentSubscription()->hasPremiumAccess()) {
		 // есть преимум доступ, показываем что-то особенное
	 }
	 
	 // Чтобы избежать постоянных проверок на существование подписки, мы внедрили Null Object. Теперь подписка есть всегда и достаточно написать:
	 
	 if ($user->getCurrentSubscription()->hasProfessionalAccess()) {
		 // есть профессиональный доступ, показываем что-то особенное
	 }
	 
	 /*
	 src/FakeSubscription.php
	 
	 Реализуйте класс FakeSubscription, который повторяет интерфейс класса Subscription за исключением конструктора. В конструктор FakeSubscription принимает пользователя. Если пользователь администратор $user->isAdmin(), то все доступы разрешены, если нет – то запрещены.
	 
	 src/User.php
	 Допишите конструктор пользователя, так, чтобы внутри устанавливась реальная подписка если она передана снаружи и создавалась фейковая в ином случае.
	 */
	 
	 use App\Subscription;
	 use App\User;
	 
	 $user = new User('vasya@email.com', new Subscription('premium'));
	 $user->getCurrentSubscription()->hasPremiumAccess(); // true
	 $user->getCurrentSubscription()->hasProfessionalAccess(); // false
	 
	 $user = new User('vasya@email.com', new Subscription('professional'));
	 $user->getCurrentSubscription()->hasPremiumAccess(); // false
	 $user->getCurrentSubscription()->hasProfessionalAccess(); // true
	 
	 // Внутри создается фейковая, потому что подписка не передается
	 $user = new User('vasya@email.com');
	 $user->getCurrentSubscription()->hasPremiumAccess(); // false
	 $user->getCurrentSubscription()->hasProfessionalAccess(); // false
	 
	 $user = new User('rakhim@hexlet.io'); // администратор, проверяется по емейлу
	 $user->getCurrentSubscription()->hasPremiumAccess(); // true
	 $user->getCurrentSubscription()->hasProfessionalAccess(); // true
	 
	 
	 // FILE: /app/src/FakeSubscription.php
	 namespace App;
	 
	 class FakeSubscription
	 {
		  private $user;
	 
		  public function __construct($user)
		  {
				$this->user = $user;
		  }
	 
		  public function hasProfessionalAccess()
		  {
				return $this->user->isAdmin();
		  }
	 
		  public function hasPremiumAccess()
		  {
				return $this->user->isAdmin();
		  }
	 }
	 
	 
	 // FILE: /app/src/User.php
	 namespace App;
	 
	 class User
	 {
		  private $currentSubscription;
		  private $email;
	 
		  public function __construct($email, $currentSubscription = null)
		  {
				$this->email = $email;
	 
				$this->currentSubscription = $currentSubscription ?? new FakeSubscription($this);
		  }
	 
		  public function getCurrentSubscription()
		  {
				return $this->currentSubscription;
		  }
	 
		  public function isAdmin()
		  {
				return $this->email === 'rakhim@hexlet.io';
		  }
	 }
	 
	 
	 // FILE: /app/src/Subscription.php
	 namespace App;
	 
	 class Subscription
	 {
		  private $subscriptionPlanName;
	 
		  public function __construct($subscriptionPlanName)
		  {
				$this->subscriptionPlanName = $subscriptionPlanName;
		  }
		  
		  public function hasProfessionalAccess()
		  {
				return $this->subscriptionPlanName === 'professional';
		  }
	 
		  public function hasPremiumAccess()
		  {
				return $this->subscriptionPlanName === 'premium';
		  }
	 }
	 
	 
	 
	 
	 #>>>>>> Код, который убивает полиморфизм <<<<<<#
	 
	 /*
	 # Формирование объектов
	 
	 Посмотрите на функцию ниже и скажите, является ли она полиморфной?
	 */
	 
	 function sayHiByEmail($user)
	 {
		  $sender = new EmailSender();
		  // Отправляем email пользователю
		  $sender->send($user->getEmail(), 'hi!');
	 }
	 
	 /*
	 С одной стороны да, пользователь передается снаружи и у нас есть возможность его подменить, передав туда объект другого класса. С другой стороны, внутри функции явно используется класс EmailSender и его подменить не получится без переписывания самого кода.
	 
	 Этот код демонстрирует простую, но важную идею. Полиморфизм подтипов возможен тогда, когда объект попадает в функцию снаружи, а не конструируется прямо внутри неё.
	 
	 Честно говоря, объект можно создавать и внутри функции, но в таком случае имя класса должно формироваться (или получаться) динамически. Этот приём мы рассмотрим позже, в уроке про метапрограммирование
	 
	 # Проверка типов
	 
	 Ещё один пример с подвохом. Есть ли полиморфизм в коде ниже?
	 */
	 
	 function sayHi($user)
	 {
		  if ($user instanceof User) {
			 print_r("Hello, {$user}!");
		  } elseif ($user instanceof Guest) {
			 print_r('Hello, guest!');
		  } else {
			 print_r('Who you are?');
		  }
	 }
	 
	 /*
	 В данном примере, вроде бы, всё нормально, объект передается снаружи, но есть одна загвоздка. Внутри функции явно проверяется тип, а это значит, что поведение определяется не типом, а сама функция решает как себя вести. Более того, функция жестко связана с теми типами, которые определены внутри неё и её придётся переписывать при их изменении. И как результат – отсутствие полиморфизма подтипов.
	 
	 Проверка типа иногда встречается и её можно использовать к месту, чтобы не усложнять код, но чаще, она говорит о плохом дизайне. Такой код, можно сказать, не соответствует ООП в современном его понимании.
	 
	 Для решения задачи выше, есть несколько подходов:
	 - Перенос логики внутрь самих классов. Тогда код функции превратится в такой: $user->sayHi(). С этим подходом нужно быть осторожным, так как легко получить божественный объект. Гораздо чаще нужно применять другой подход.
	 - Понадобится добавить новый интерфейс в виде методов isUser и isGuest.
	 */
	 
	 function sayHi($user)
	 {
		  if ($user->isUser()) {
			 print_r("Hello, {$user}!");
		  } elseif ($user->isGuest()) {
			 print_r('Hello, guest!');
		  } else {
			 print_r('Who you are?');
		  }
	 }
	 
	 // И хотя кода меньше не стало, всё же это полиморфизм подтипов. Код завязан на методы, а не на типы. Изменение структуры классов не коснется этой функции если сама логика останется той же.
	 
	 
	 /**@@
	 src/Helpers.php
	 Реализуйте функцию getGreeting($user), которая возвращает приветствие для пользователя. Это приветствие показывается пользователю на сайте. Если пользователь гость, то выводится "Hello Guest!", если не гость, то "Hello, <Имя>", где "<Имя>" это имя реального пользователя.
	 
	 В этой задаче, способ решения остается на ваше усмотрение. Используйте знания полученные в этом курсе.
	 */
	 
	 $guest = new \App\Guest();
	 getGreeting($guest); // 'Hello Guest!'
	 
	 $user = new \App\User('Petr');
	 getGreeting($user); // 'Hello Petr!'
	 
	 
	 // FILE: /app/src/Guest.php:
	 namespace App;
	 
	 class Guest
	 {
		  public function getName()
		  {
				return 'Guest';
		  }
	 
		  public function getTypeName()
		  {
				return 'guest';
		  }
	 }
	 
	 // FILE: /app/src/Helpers.php:
	 namespace App\Helpers;
	 
	 function getGreeting($user)
	 {
		  $mapping = [
				'guest' => function ($guest) {
					 return 'Hello Guest!';
				},
				'user' => function ($user) {
					 return "Hello {$user->getName()}!";
				}
		  ];
	 
		  return $mapping[$user->getTypeName()]($user);
	 }
	 
	 
	 // FILE: /app/src/User.php:
	 namespace App;
	 
	 class User
	 {
		  private $name;
	 
		  public function __construct($name)
		  {
				$this->name = $name;
		  }
	 
		  public function getName()
		  {
				return $this->name;
		  }
	 
		  public function getTypeName()
		  {
				return 'user';
		  }
	 }
	 
	 
	 
	 #>>>>>> Инверсия зависимостей <<<<<<#
	 
	 /*
	 Каждый раз, когда внутри функции создаётся объект, появляется зависимость функции от класса этого объекта. Другими словами функция жестко завязана на работу в паре с конкретным классом. Есть формальный способ, позволяющий легко проверить насколько ваш код завязан в узел.
	 Возьмите любую функцию и мысленно представьте что вы переносите её в другой проект. Сколько за собой она потянет зависимостей (а те в свою очередь свои зависимости)? Если перенос функции потребует переноса большого количества кода, то говорят что в коде высокая связанность.
	 
	 Для развязки кода придуман даже специальный термин: Принцип Инверсии Зависимостей https://ru.wikipedia.org/wiki/Принцип_инверсии_зависимостей. Ещё он известен как DIP https://en.wikipedia.org/wiki/Dependency_inversion_principle из SOLID. Вот его формулировка:
	 
	 Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
	 Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
	 В зависимости от языка, в эти фразы вкладывается немного разный смысл. В общем и целом, они говорят о том, что не нужно завязываться на конкретную реализацию класса. Создание объектов в том месте где они используются, связывает нас с классом этих объектов без возможности его подменить. Правильный подход, с точки зрения этого принципа, инвертировать зависимости, то есть не работать с классами напрямую, а получать объекты нужных классов снаружи, например, через параметры функции.
	 
	 Кроме того, DIP говорит о завязке на интерфейсы вместо классов в сигнатурах функций. Об этом мы поговорим позже, когда закончим с основными понятиями
	 */
	 
	 // Было:
	 function doSomething()
	 {
		  $logger = new Logger();
		  // some code
	 }
	 
	 
	 // Стало:
	 function doSomething($logger)
	 {
		  // some code
	 }
	 
	 /*
	 В докладах на тему DIP, докладчики любят, в качестве аналогии, приводить принцип голливуда: Не надо нам звонить, мы сами вас наберем. Имеется ввиду что не пользуйтесь классами напрямую, получайте готовые объекты как внешнюю зависимость.
	 
	 Нужно ли всегда придерживаться этого принципа? Откровенно говоря, код целиком построенный в таком стиле становится излишне абстрактным и сложным для понимания. В программировании нет серебряных пуль и в каждой конкретной ситуации нужно смотреть на условия и решаемую задачу. Если подмена реализации нужна, то делаем её, если нет – то работаем напрямую.
	 
	 Почти всегда, когда речь идёт про инверсию зависимостей, рядом появляется термин "инъекция зависимостей". В то время как DIP говорит о модульности, инъекция зависимостей говорит о конкретных способах её достижения. О том каким образом можно передать зависимости в код использующий их. Всего есть три способа инъектировать зависимости:
	 */
	 
	 // Передать их как аргументы функций или методов. Именно этот способ мы использовали до сих пор.
	 $app->get('/', new Logger());
	 
	 // Через конструктор в тех ситуациях где используются объекты
	 $app = new Application(new Logger());
	 
	 // Через сеттеры. По возможности лучше этот способ не использовать. Он связан с мутацией объектов и нарушением целостности (подробнее было в курсе по объектно-ориентированному дизайну).
	 
	 $obj->setLogger(new Logger());
	 
	 /*
	 Как видите, за громким термином скрывается очень простая штука – передача параметров. С другой стороны, термины позволяют понять больше смысла без необходимости знать дополнительный контекст. Главное не увлекаться, а то можно превратиться в архитектурных астронавтов.
	 
	 # Дополнительные материалы
	 Dependency Injection https://www.youtube.com/watch?v=IKD2-MAkXyQ
	 */
	 
	 /**@@
	 Создайте полноценное консольное приложение, которое показывает текущую погоду в городе. Оно работает так:
	 */
	 $ php bin/weather.php berlin
	 
	 /*
	 Temperature in berlin: 26C
	 Это консольное приложение обращается внутри себя к сервису погоды. Сервис погоды расположен на localhost:8080. Информацию по городу можно извлечь сделав GET запрос на урл /api/v2/cities/<имя города>. Данные от сервиса возвращаются в виде json: { "name": "<имя города>", temperature: "<температура>" }.
	 
	 src/WeatherService.php
	 Реализуйте логику работы сервиса. Сделайте так, чтобы http-клиент не был зашит внутри класса, используйте инъекцию зависимостей для проброса клиента во внутрь.
	 
	 То как выполнять http-запросы через guzzle можно подсмотреть в его документации.
	 
	 bin/weather.php
	 Реализуйте код, вызывающий сервис и печатающий на экран ожидаемую строку. Для извлечения города из аргументов командной строки, воспользуйтесь массивом $argv. Первый аргумент (передаваемое имя города) находится под индексом 1.
	 
	 Подсказки
	 Попробуйте ответить на вопросы:
	 
	 Сервис погоды это абстракция данных или нет? (пересмотрите начало курса по объектно-ориентированному дизайну).
	 Кто отвечает за формирование текста, который мы ожидаем на выходе?
	 Что должен вернуть метод lookup($cityName)?
	 Может ли bin содержать определения?
	 */
	 
	 // FILE: /app/WeatherService.php:
	 namespace App;
	 
	 class WeatherService
	 {
		  const API_URL = 'http://localhost:8080/api/v2';
	 
		  private $httpClient;
	 
		  public function __construct($httpClient)
		  {
				$this->httpClient = $httpClient;
		  }
	 
		  public function lookup($cityName)
		  {
				$url = implode('/', [self::API_URL, "cities/{$cityName}"]);
				$response = $this->httpClient->get($url);
	 
				return json_decode($response->getBody(), true);
		  }
	 }
	 
	 
	 // FILE: /app/bin/weather.php:
	 
	 require '/composer/vendor/autoload.php';
	 
	 use App\WeatherService;
	 
	 $weather = new WeatherService(new \GuzzleHttp\Client());
	 $data = $weather->lookup($argv[1]);
	 echo "Temperature in {$data['name']}: {$data['temperature']}C";
	 
	 
	 
	#>>>>>> Полиморфизм подтипов <<<<<<#
	 
	 /*
	 До сих пор мы работали с, так называемой, утиной типизацией: Если что-то ходит как утка и крякает как утка, то это и есть утка. Она проявляется в том, что в сигнатуре функции не указывается ожидаемый класс или интерфейс объекта. Мы просто ждем что вызывающий код отдаст объект, имеющий необходимые методы:
	 */
	 
	 function doSomething($logger)
	 {
		  $logger->info('process starting');
	 }
	 
	 /*
	 Утиная типизация автоматически вытекает из динамической типизации. В большинстве динамических языках понятия "интерфейс" даже не существует. PHP, в этом смысле, пошел своим путём. Несмотря на его динамическую природу, классовая модель PHP взята из Java. И в PHP присутствуют почти все соответствующие атрибуты: интерфейсы, абстрактные классы и многое другое. Поэтому в PHP принято указывать интерфейсы ожидаемых объектов в сигнатурах функций.
	 */
	 
	 function doSomething(Psr\Log\LoggerInterface $logger)
	 {
		  $logger->info('process starting');
	 }
	 
	 /*
	 Теперь эта функция работает только с объектами тех классов, которые реализуют указанный интерфейс.
	 
	 Как вы помните, в сигнатуре можно указывать и класс и интерфейс. Что правильнее? Вооружившись принципом инверсии зависимостей, мы можем однозначно сказать что правильнее использовать интерфейсы и завязываться на абстракцию вместо конкретной реализации. Только в этом случае появится возможность подменить реализацию. Ниже пример реального кода из фреймворка Symfony2, в котором активно используется полиморфизм подтипов с инъекцией через конструктор:
	 */
	 
	 class Psr18Client implements ClientInterface
	 {
		  private $client;
		  private $responseFactory;
		  private $streamFactory;
	 
		  public function __construct(HttpClientInterface $client = null, ResponseFactoryInterface $responseFactory = null, StreamFactoryInterface $streamFactory = null)
		  {
				$this->client = $client ?? HttpClient::create();
				$this->responseFactory = $responseFactory;
				$this->streamFactory = $streamFactory ?? ($responseFactory instanceof StreamFactoryInterface ? $responseFactory : null);
				$psr17Factory = new Psr17Factory();
				$this->responseFactory = $this->responseFactory ?? $psr17Factory;
				$this->streamFactory = $this->streamFactory ?? $psr17Factory;
		  }
	 
		  // another methods
	 }
	 
	 
	 /*
	 В очередной раз подчеркну что не нужно возводить эту технику в абсолют. Если создавать интерфейсы на всё подряд, то код очень быстро распухнет и станет сложным. Вспомните, в ruby/pyton/js вообще нет интерфейсов и никто не умер. Попробуйте побродить по исходникам популярного микрофреймворка https://github.com/laravel/lumen-framework. Внутри него крайне тяжело найти места, где в сигнатурах методов встречаются явные указания интерфейсов
	 
	 Для лучшей переносимости кода, в PHP вводятся стандартные интерфейсы для самых частых задач. Они описываются в PSR. В примере выше используется стандартный интерфейс Psr\Log\LoggerInterface. Со временем, всё большая часть библиотек начнет его реализовывать, а это позволит безболезненно подменять логгер без необходимости менять свой код. Кроме логгера в PSR описаны множество других интерфейсов, среди них http-клиент, http-запрос, http-ответ, кеш и другое.
	 
	 Теперь мы можем ответить на вопрос, почему этот полиморфизм называется полиморфизмом подтипов. Типом в ООП языках принято называть интерфейсы (хотя это не совсем правда) и отношение подтипов определяется отношением интерфейсов.
	 
	 Интерфейсы можно расширять другими интерфейсами, для этого используется ключевое слово extends. Пример из библиотеки DS (той где описаны структуры данных на PHP в объектном синтаксисе):
	 */
	 
	 // https://github.com/php-ds/polyfill/blob/master/src/Collection.php
	 interface Collection extends \Traversable, \Countable, \JsonSerializable
	 {
		  // some code
	 }
	 
	 /*
	 Теперь, любой класс реализующий интерфейс Collection, будет обязан реализовать все интерфейсы, которые расширяет Collection. Это касается каждого интерфейса в цепочке.
	 
	 # Статические методы
	 
	 Статические методы жестко завязаны на имя класса, поэтому полиморфизм подтипов в них невозможен. Но можно схитрить и использовать вместо класса, переменную с его именем:
	 */
	 Foo::aStaticMethod();
	 $classname = 'Foo';
	 $classname::aStaticMethod(); // As of PHP 5.3.0
	 
	 /*
	 # Дополнительные материалы
	 Принцип Лисков https://en.wikipedia.org/wiki/Принцип_подстановки_Барбары_Лисков
	 Subtyping https://en.wikipedia.org/wiki/Subtyping
	 Принцип открытости/закрытости https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости
	 Принцип разделения интерфейса https://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса
	 */
	 
	 
	 /**@@
	 В этом задании используется класс InMemoryKV, с которым вы недавно работали. Теперь мы добавим ему интерфейс и дополнительно реализуем сериализацию.
	 
	 src/KeyValueStorageInterface.php
	 Реализуйте интерфейс KeyValueStorageInterface, который расширяет интерфейс \Serializable и имеет следующие методы:
	 */
	 
	 set($key, $value);
	 get($key, $default = null);
	 unset($key);
	 toArray();
	 
	 /*
	 src/InMemoryKV.php
	 Реализуйте в классе InMemoryKV интерфейс \Serializable https://www.php.net/manual/en/class.serializable.php, который встроен в PHP. Этот интерфейс позволяет применять к объектам методы serialize https://www.php.net/manual/en/function.serialize.php и unserialize https://www.php.net/manual/en/function.unserialize.php.
	 
	 Функция serialize позволяет представить объект строкой и сохранить его куда-нибудь в файловую систему или передать по сети. Функция unserialize выполняет обратную операцию и восстанавливает сериализованный объект.
	 
	 Для сериализации используйте json_encode, для десериализации json_decode.
	 */
	 
	 
	 // FILE: /app/src/KeyValueStorageInterface.php:
	 namespace App;
	 
	 interface KeyValueStorageInterface extends \Serializable
	 {
		  public function set($key, $value);
		  public function get($key, $default = null);
		  public function unset($key);
		  public function toArray();
	 }
	 
	 
	 // FILE: /app/src/InMemoryKV.php:
	 namespace App;
	 
	 class InMemoryKV implements KeyValueStorageInterface
	 {
		  private $map;
	 
		  public function __construct($initial = [])
		  {
				$this->map = $initial;
		  }
	 
		  public function set($key, $value)
		  {
				$this->map[$key] = $value;
		  }
	 
		  public function unset($key)
		  {
				unset($this->map[$key]);
		  }
	 
		  public function get($key, $default = null)
		  {
				return $this->map[$key] ?? $default;
		  }
	 
		  public function toArray()
		  {
				return $this->map;
		  }
	 
		  public function serialize()
		  {
				return json_encode($this->map);
		  }
	 
		  public function unserialize($data)
		  {
				$this->map = json_decode($data, true);
		  }
	 }
	 
	 
	 
	 
	 #>>>>>> Стратегия (Паттерн) <<<<<<#
	 
	 /*
	 Закрепим пройденную теорию на одном практическом примере, показывающем типичное применение полиморфизма подтипов.
	 
	 Представьте себе задачу расчёта стоимости туристической страховки. Эта страховка, которую желательно купить при выезде за границу, на случай внезапных болезней или травм.
	 
	 Сумма страховки зависит от большого числа факторов. Некоторые из факторов могут влиять на сам процесс подсчёта стоимости, то есть они изменяют не значения в формуле подсчёта, а саму формулу.
	 
	 Конкретно в случае страховок, скорее всего есть одна большая формула, куда подставляются значения и вычисление происходит за один заход. Для нас, сейчас, главное сама концепция, а не точное знание внутренностей страхового бизнеса
	 
	 Если решать эту задачу в лоб, то она будет выглядеть как большое месиво вычислений со множеством условных конструкций. Со временем такой код становится крайне тяжелым для восприятия из-за большого числа состояний, которые надо удерживать в голове.
	 */
	 
	 // Примеры с потолка
	 if ($age < 18) {
		$cost = $salary * $age;
	 
		if ($country === 'uganda') {
		  $cost = $cost / 2;
		}
	 } else if ($age >= 18 && $age < 24) {
		  // ...
	 }
	 
	 /*
	 Можно ли как-то сделать код понятнее и проще для восприятия? Иногда да. Из всех факторов участвующих в расчёте, нужно попытаться найти те, которые влияют на вычисление глобально. Они проявляются как глобальный if на верхнем уровне. Предположим что в случае страховки это возраст. То есть считаем что возраст определяет формулу расчёта стоимости страховки. Следующим шагом смотрим на ветки в этой условной конструкции и то какие диапазоны там указаны. Допустим такую картину:
	 
	 - До 18
	 - От 18 до 24
	 - От 24 до 65
	 - Старше 65
	 */
	 
	 interface CostInsuranceCalculation
	 {
		  public function calculate($params);
	 }
	 
	 class LessThan18 implements CostInsuranceCalculation
	 {
		  // Параметры, это те самые факторы, по которым строится вычисление
	 
		  public function calculate($params)
		  {
				// тут считаем и возвращаем результат
		  }
	 }
	 
	 // Имя конечно так себе, в реальном коде стоит придумать что-нибудь говорящее
	 class MoreThan18AndLessThan24 implements CostInsuranceCalculation
	 {
		  // Структура параметров должна 100% совпадать с остальными классами,
		  // так как только в этом случае возможен полиморфизм
		  public function calculate($params)
		  {
				// тут считаем и возвращаем результат
		  }
	 }
	 
	 // Остальные классы
	 
	 
	 /*
	 Главное что мы получили - разделили процесс вычисления на независимые блоки кода, которые проще для восприятия. Каждый такой класс называется стратегией (вычисления). Очень важно то, что стратегия не является абстракцией, объектом с состоянием и временем жизни. Поэтому данные передаются не в конструктор, а в сам метод (вспомните курс объектно-ориентированный дизайн). По сути, это обычная функция (вычисление), которое упаковано в класс только с одной целью, получить полиморфизм подтипов. Всё тоже самое можно сделать (и код будет проще) используя диспетчеризацию функций по ключам.
	 
	 Дальше возникает вопрос, а каким образом и где выбрать правильную реализацию, с которой нужно работать? Вариантов здесь несколько. Выбор реализации может быть делегирован внешнему коду, то есть если мы применяем инверсию зависимостей, то работаем уже с готовой стратегией:
	 */
	 
	 function calculateCost($strategy, $params)
	 {
		  $strategy->calculate($params);
	 }
	 
	 /*
	 Пока мы только ушли от проблемы, но не решили её. В любом случае, где-то будет код, который содержит либо условную конструкцию, либо реализует один из способов диспетчеризации, которые мы разобрали в предыдущих уроках. В самом простом случае этот код будет выглядеть так:
	 */
	 
	 function chooseCostInsuranceStrategy($user)
	 {
		  if ($user->getAge() < 18) {
				return new LessThan18();
		  } else if (/* ... */) {
				// some code
		  }
	 }
	 
	 $strategy = chooseCostInsuranceStrategy($user);
	 $strategy->calculate($params);
	 
	 
	 /*
	 Как видно по примерам выше, кода с использованием стратегии будет больше (но не так много если используется диспетчеризация функций по ключам в ассоциативном массиве). Это касается фактически всех ситуаций, в которых задействован полиморфизм подтипов в PHP. Это цена, которую придётся заплатить за разделение, упрощающее расширение кода и уменьшающее его сложность. С другой стороны, очень легко попасть в ловушку и, наоборот, сделать сложность кода выше, чем оно было до внедрения полиморфизма подтипов. Этот полиморфизм делает код многословным и излишне абстрактным если применять его налево и направо. А расширение нужно не так часто, как об этом говорят. Более того, инвертировать зависимости можно по ходу действия, когда в этом появляется необходимость.
	 
	 # Дополнительные материалы
	 Expression Problem https://en.wikipedia.org/wiki/Expression_problem
	 */
	 
	 
	 /**@@
	 TicTacToe – известная игра в крестики нолики, на поле 3x3. В этом задании, вам предстоит реализовать данную игру. Основной движок игры находится в файле TicTacToe.php. В директории strategies находится код, который отвечает за поведение AI (искуственный интелект!). В зависимости от выбранного уровня игры, включается либо Easy стратегия, либо Normal.
	 
	 Задание специально построено так, чтобы предоставить вам максимальную свободу в организации кода. Результат будет хорошей лакмусовой бумажкой, по которому можно оценить насколько архитектурная тема была понята.
	 
	 src/TicTacToe.php
	 Реализуйте класс TicTacToe, который представляет собой игру крестики-нолики. Принцип его работы описан в коде ниже:
	 */
	 
	 // По умолчанию выбран easy уровень. Его можно изменить, передав в конструктор строку 'normal'
	 $game = new TicTacToe();
	 
	 // Если переданы аргументы, то ходит игрок. Первый аргумент – строка, второй – столбец.
	 $game->go(2, 2);
	 
	 // Ход компьютера
	 $game->go();
	 $game->go(1, 2);
	 $game->go();
	 // Метод go возвращает true если текущий ход победный и false в ином случае
	 $isWinner = $game->go(3, 2); // true
	 
	 /*
	 src/strategies/Easy.php
	 Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно сверху вниз и слева направо. Как только она встречает свободное поле, то вставляет туда значение.
	 
	 src/strategies/Normal.php
	 Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно снизу вверх и слева направо. Как только она встречает свободное поле, то вставляет туда значение.
	 
	 Подсказки
	 Кто отвечает за состояние игры, и где оно должно храниться?
	 Не мудрите с проверкой победителя, реализуйте эту логику в лоб.
	 */
	 
	 
	 // FILE /app/src/TicTacToe.php:
	 namespace App;
	 
	 class TicTacToe
	 {
		  private $strategy;
	 
		  public function __construct($level = 'easy')
		  {
				switch ($level) {
					 case 'easy':
						  $this->strategy = new strategies\Easy();
						  break;
					 case 'normal':
						  $this->strategy = new strategies\Normal();
						  break;
				}
	 
				$this->map = [
					 1 => array_fill(1, 3, null),
					 2 => array_fill(1, 3, null),
					 3 => array_fill(1, 3, null)
				];
		  }
	 
		  public function getMap()
		  {
				return $this->map;
		  }
	 
		  public function go($row = null, $col = null)
		  {
				if ($row === null || $col === null) {
					 [$autoRow, $autoCol] = $this->strategy->getNextStep($this->map);
	 
					 $this->map[$autoRow][$autoCol] = 'AI';
	 
					 return $this->isWinner('AI');
				}
	 
				$this->map[$row][$col] = 'Player';
	 
				return $this->isWinner('Player');
		  }
	 
		  private function isWinner($type)
		  {
				foreach ($this->map as $row) {
					 if ($this->populatedByOnePlayer($row, $type)) {
						  return true;
					 }
				}
	 
				for ($i = 1; $i <= 3; $i++) {
					 if ($this->populatedByOnePlayer(array_column($this->map, $i), $type)) {
						  return true;
					 }
				}
	 
				$diagonal1 = [$this->map[1][1], $this->map[2][2], $this->map[3][3]];
	 
				if ($this->populatedByOnePlayer($diagonal1, $type)) {
					 return true;
				}
	 
				$diagonal2 = [$this->map[3][1], $this->map[2][2], $this->map[1][3]];
				if ($this->populatedByOnePlayer($diagonal1, $type)) {
					 return true;
				}
	 
				return false;
		  }
	 
		  private function populatedByOnePlayer($row, $type)
		  {
				foreach ($row as $value) {
					 if ($value !== $type) {
						  return false;
					 }
				}
				return true;
		  }
	 }
	 
	 
	 // FILE: /app/src/strategies/Easy.php
	 namespace App\strategies;
	 
	 class Easy
	 {
		  public function getNextStep($map)
		  {
				foreach ($map as $i => $row) {
					 foreach ($row as $j => $value) {
						  if ($value === null) {
								return [$i, $j];
						  }
					 }
				}
		  }
	 }
	 
	 
	 
	 // FILE: /app/src/strategies/Normal.php
	 namespace App\strategies;
	 
	 class Normal
	 {
		  public function getNextStep($map)
		  {
				for ($i = 3; $i >= 1; $i--) {
					 foreach ($map[$i] as $j => $value) {
						  if ($value === null) {
								return [$i, $j];
						  }
					 }
				}
		  }
	 }
	 
	 
	 
	 
	 #>>>>>> Фабрика (Паттерн) <<<<<<#
	 
	 /*
	 Применение полиморфизма подтипов не убирает условные конструкции полностью (кроме некоторых случаев диспетчеризации, например по ключу или по имени файла). Чаще, условная конструкция остаётся одна, только на уровне выбора подходящей реализации, а вот, затем, эта реализация используется внутри полиморфной функции прямым способом, без условий. В прошлом уроке мы рассмотрели пример функции, которая выбирает необходимую реализацию стратегии на основе возраста пользователя и возвращает её наружу.
	 */
	 
	 
	 function chooseCostInsuranceStrategy($user)
	 {
		  if ($user->getAge() < 18) {
				return new LessThan18();
		  } else if (/* ... */) {
				// some code
		  }
	 }
	 
	 /*
	 Функция, которая: выбирает нужный класс, создаёт объект и возвращает его наружу, называется фабрикой (более точно фабричным методом). Громкое имя для очень простой штуки. Фабрика может быть реализована любым способом включая всё что разбиралось в этом курсе.
	 
	 В общем случае фабрикой называют всё подряд, что создаёт объект или коллекции объектов. Причём не обязательно разных классов, класс может быть и один, но сам процесс создания, включает в себя какие-то предварительные вычисления. В реальных проектах фабрики могут быть огромными.
	 
	 Фабрики часто реализуются как классы с одним статическим методом – factory. Сами фабрики объектами не делают (иногда таки делают), так как это не абстракция данных, а подменять их смысла нет, иначе получится подмена подменятора.
	 
	 # Диспетчеризация класса
	 PHP позволяет создавать объекты, используя имя класса как строку:
	 */
	 
	 $className = 'stdObject';
	 $obj = new $className();
	 
	 /*
	 В большинстве других динамических языках, класс и так объект первого рода и им можно пользоваться как обычными данными
	 
	 Такой синтаксис открывает широкий простор для диспетчеризации. Например в некоторых ситуациях получится уйти от условных конструкций вообще:
	 */
	 
	 // Policy – обычно это имя используют для авторизации, то есть системы проверки прав доступа
	 function getUserPolicy($user)
	 {
		  $mapping = [
			 'manager' => 'App\Policies\Manager',
			 'worker' => 'App\Policies\Worker'
		  ];
	 
		  $className = $mapping[$user->getType()];
	 
		  return new $className();
	 }
	 
	 /*
	 В этом коде есть одна небольшая проблема. Она связана с тем, что нужно указывать полное имя класса, включая все неймспейсы, иначе этот код не заработает. От неё можно уйти если использовать специальный синтаксис извлечения полного имени класса:
	 */
	 
	 use App\Policies\Manager;
	 use App\Policies\Worker;
	 
	 $mapping = [
		'manager' => Manager::class, // App\Policies\Manager
		'worker' => Worker::class // App\Policies\Worker
	 ];
	 
	 /*
	 То есть достаточно после имени любого класса добавить ::class и получится выражение, которое возвращает полное имя класса в виде строки.
	 
	 Иногда идут ещё дальше и формируют само имя класса динамически. Это можно сделать даже с кодом выше. По нему видно, что имя класса однозначно выводится из типа пользователя. Ниже пример, в котором фабрика вообще не содержит конкретных имён классов, она выводит их на основе соглашения об именовании: type => typePolicy.
	 */
	 
	 // Policy – обычно это имя используют для авторизации, то есть системы проверки прав доступа
	 function getUserPolicy($user)
	 {
		  // При таком подходе придётся самостоятельно добавлять все неймспейсы
		  // Но зато код полностью отвязан от имён классов и их количества
		  $className = 'App\Policies\'' . ucfirst($user->getType()) . 'Policy';
	 
		  return new $className();
	 }
	 
	 /*
	 # Дополнительные материалы
	 Фабрика https://github.com/Hexlet/patterns/tree/master/content/factory
	 */
	 
	 
	 /**@@
	 src/ConfigFactory.php
	 Создайте фабрику, которая принимает на вход путь до файла конфигурации в формате либо json либо yaml и возвращает объект класса Config. Конструктор класса Config принимает на вход массив с данными, полученными из конфигурационных файлов и предоставляет к нему объектный доступ.
	 */
	 
	 $config = ConfigFactory::build(__DIR__ . '/fixtures/test.yml');
	 $config->key; // value
	 print_r(get_class($config)); // Config
	 
	 $config2 = ConfigFactory::build(__DIR__ . '/fixtures/test.json');
	 $config2->key; // value
	 
	 /*
	 src/parsers/JsonParser.php
	 Реализуйте класс, отвечающий за парсинг json. Используйте внутри json_decode, в котором второй параметр true.
	 
	 src/parsers/YamlParser.php
	 Реализуйте класс, отвечающий за парсинг yaml. Для парсинга используется сторонний компонент со следующим интерфейсом:
	 */
	 Yaml::parse($data);
	 
	 /*
	 Подсказки
	 - Получить расширение файла можно двумя способами, либо через pathinfo https://php.net/manual/ru/function.pathinfo.php, либо через SplFileInfo https://php.net/manual/ru/class.splfileinfo.php
	 - Чтение файлов делается с помощью функции file_get_contents https://www.php.net/manual/ru/function.file-get-contents.php
	 */
	 
	 
	 // FILE: /app/src/ConfigFactory.php
	 
	 namespace App;
	 
	 class ConfigFactory
	 {
		  public static function build($filepath)
		  {
				$mapping = [
					 'yaml' => parsers\YamlParser::class,
					 'yml' => parsers\YamlParser::class,
					 'json' => parsers\JsonParser::class,
				];
	 
				$fileInfo = new \SplFileInfo($filepath);
	 
				$parserClass = $mapping[$fileInfo->getExtension()];
				$parser = new $parserClass();
				$rawData = file_get_contents($fileInfo->getPathname());
				$data = $parser->parse($rawData);
	 
				return new Config($data);
		  }
	 }
	 
	 // FILE: /app/src/parsers/JsonParser.php:
	 namespace App\parsers;
	 
	 class JsonParser
	 {
		  public function parse($data)
		  {
				return json_decode($data, true);
		  }
	 }
	 
	 
	 // FILE: /app/src/parsers/YamlParser.php:
	 namespace App\parsers;
	 
	 use Symfony\Component\Yaml\Yaml;
	 
	 class YamlParser
	 {
		  public function parse($data)
		  {
				return Yaml::parse($data);
		  }
	 }
	 
	 
	 
	 
	 #>>>>>> Шаблоны проектирования (Паттерны) <<<<<<#
	 /*
	 Паттерн проектирования – подход к решению какой-то типовой задачи. Ранее мы уже рассмотрели некоторые из них, начиная от разных видов диспетчеризации, заканчивая стратегией и фабрикой. Этих паттернов очень много, каждый день придумываются новые, и даже каждый программист имеет какие-то свои паттерны для своих задач.
	 
	 Паттерны, в общем, не связаны с понятием ООП, но именно в ООП их любят структурировать и описывать. Поэтому эта тема особенно распространена в языках с классовой структурой, например Java, C# или PHP. И большинство этих паттернов сводится к тому, как правильно применять полиморфизм подтипов в разных ситуациях. Вот только некоторые из широко известных, которые опираются на полиморфизм:
	 
	 - Адаптер
	 - Стратегия
	 - Абстрактная фабрика
	 - Мост
	 - Композит
	 - Декоратор
	 - Цепочка ответственности
	 - Наблюдатель
	 - Состояние
	 - Шаблонный метод
	 - Посетитель
	 
	 Некоторые из них связаны с абстракцией и имеют внутреннее состояние, другие – обычные функции, упакованные в классы только ради полиморфизма (но могли бы быть реализованы и обычными функциями, которые диспетчеризуются разными способами).
	 
	 В мире ООП паттернов, их основным источником считается книга Приемы объектно-ориентированного проектирования https://www.ozon.ru/context/detail/id/2457392/. Паттерны проектирования. В ней действительно описано много полезных подходов, но будьте осторожны. Учтите следующие моменты:
	 
	  - Примеры в книге описаны на языке C++ и имеют более сложную реализацию, чем это нужно в динамических языках.
	  - Многие паттерны рождаются вследствие ограничений конкретного языка, например паттерн "команда". В JavaScript это естественный способ писать код и для этого не нужны классы.
	  - Не все паттерны описанные в этой книге, так уж важны для веб-разработчиков. Вероятность того, что вам придётся когда-то иметь дело с абстрактной фабрикой, крайне низка.
	  - Самих паттернов намного больше чем указано в этой книге. Паттерны это не догма, всё течет, всё развивается.
	 
	  Конкретно в PHP, популярностью пользуется книга Объекты, шаблоны и методики программирования https://www.amazon.com/Objects-Patterns-Practice-MATT-ZANDSTRA/dp/1484219953.
	 
	 
	 # Полиморфизм в паттернах или Паттерн создания Паттернов
	 
	 Большая часть паттернов, которая связана с полиморфизмом, строится по одному и тому же принципу. Зная его, вы сможете самостоятельно принимать правильные решения, даже не зная про паттерн для данной ситуации. Ключевая идея состоит в том, что берётся всё множество вариантов поведения и на каждый создаётся свой собственный класс.
	 
	 Например в стратегии, количество классов-стратегий совпадает с количеством разных способов вычисления. Если их будет пять, то придётся создать пять классов. По крайней мере в классовых языках. В языках, где предпочитают функции, будет создано пять разных функций и это всё равно будет стратегия.
	 
	 
	 # Антипаттерны
	 
	 Раз есть паттерны, значит и существуют антипаттерны, это типовые ошибки, которые совершают программисты. Многие из них имеют вполне конкретные, часто шуточные, названия: "паблик морозов" или "божественный объект". Самое удивительное, что подходы считавшиеся раньше паттернами, иногда перетекают в раздел антипаттернов. Самый яркий пример это паттерн "одиночка (singleton)" – объект который может существовать только в единственном экземпляре. Как показала жизнь, это плохо почти всегда. Кроме того, код с синглтонами крайне сложно тестировать.
	 
	 # Обучение паттернам
	 Новичков, которые начитались статей и наслушались старших товарищей, очень волнует вопрос изучения паттернов. Нужно ли их учить? Сколько их учить? По каким книгам и так далее.
	 
	 Попробуем разобраться. Как показывает практика, про паттерны все говорят, но мало кто действительно прочитал и понял их и может разумно применять. Причин этому несколько. Во-первых, крайне сложно осознать паттерн не столкнувшись с реальной проблемой, которую он решает. Во-вторых, настоящее понимание паттернов завязано на те вещи, которые мы разбирали на протяжении всей профессии: именование (оно чертовски важно), менеджмент состояния, побочные эффекты, абстракции, расширяемость, полиморфизм подтипов. Без понимания этих вещей, попытка испольовать паттерны, почти наверняка, превратится в культ карго. Причём из всего списка выше, паттерны, по эффекту оказываемому на код, находятся на последнем месте.
	 
	 Важно понимать что паттерны это не причина, а следствие. Остерегайтесь мышления в стиле "вот есть паттерн, как его натянуть на ситуацию". Сначала нужно понять ситуацию, а потом возникнет паттерн. И совершенно нормально, что первые годы разработки (а у кого-то и больше), задачи будут решаться так как получается. Обучение происходит через ошибки и неправильные решения, этого не надо бояться и избегать. Главное это последовательное улучшение, а здесь помогут книги и наставники (на работе или в сети).
	 
	 # Дополнительные материалы
	 Design Patterns (PHP The Right Way)  https://phptherightway.com/pages/Design-Patterns.html
	 Принцип единственной ответственности https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности
	 Вебинар: Что такое паттерны программирования https://www.youtube.com/watch?v=wX6BBaQZpzE
	 Паттерны (Редакция Хекслета) https://github.com/Hexlet/patterns
	 Антипаттерны https://ru.wikipedia.org/wiki/Антипаттерн
	 Архитектура корпоративных приложений https://www.ozon.ru/context/detail/id/1616782/
	 */
	 
	 
	 
	 /**@@
	 В задании описан интерфейс Tag. Каждый класс, реализующий этот интерфейс, представляет из себя тег HTML. Метод render(), позволяет получить текстовое представление тега:
	 */
	 $tag = new InputTag('submit', 'Save');
	 $tag->render(); // <input type="submit" value="Save">
	 
	 /*
	 Предположим, что эта система нужна для генерации разных кусков верстки, которая может быть очень разнообразной. Попробуйте ответить на вопрос, сколько понадобится классов для представления всех возможных комбинаций тегов?
	 
	 Если создавать по классу на каждый возможный вариант верстки, то классов будет бесконечно много и смысла в такой реализации очень мало. Но вместо этого лучше использовать композицию. Создать класс для каджого индивидуального тега (в html5 их около 100 штук), а затем путем комбинирования получить все возможные варианты верстки.
	 
	 src/LabelTag.php
	 Реализуйте класс LabelTag, который реализует интерфейс Tag и умеет оборачивать другие теги:
	 */
	 
	 
	 $inputTag = new InputTag('submit', 'Save');
	 $labelTag = new LabelTag('Press Submit', $inputTag);
	 $labelTag->render();
	 // <label>
	 //   Press Submit
	 //   <input type="submit" value="Save">
	 // </label>
	 
	 
	 /*
	 Подсказки
	  - Паттерн Декоратор https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)
	  - Паттерн Компоновщик https://ru.wikipedia.org/wiki/Компоновщик_(шаблон_проектирования)
	 */
	 
	 
	 // FILE: /app/src/html.php:
	 namespace App\html;
	 
	 function save($tag, $filename)
	 {
		  $html = $tag->render();
		  file_put_contents($filename, $html);
	 }
	 
	 
	 
	 // FILE: /app/src/InputTag.php:
	 namespace App\tags;
	 
	 class InputTag implements Tag
	 {
		  private $type;
		  private $value;
	 
		  public function __construct($type, $value)
		  {
				$this->type = $type;
				$this->value = $value;
		  }
	 
		  public function render()
		  {
				return "<input type=\"{$this->type}\" value=\"{$this->value}\">";
		  }
	 
		  public function __toString()
		  {
				return $this->render();
		  }
	 }
	 
	 
	 // FILE: /app/src/LabelTag.php:
	 namespace App\tags;
	 
	 class LabelTag implements Tag
	 {
		  private $text;
		  private $child;
	 
		  public function __construct($text, $child)
		  {
				$this->text = $text;
				$this->child = $child;
		  }
	 
		  public function render()
		  {
				return "<label>{$this->text}{$this->child}</label>";
		  }
	 
		  public function __toString()
		  {
				return $this->render();
		  }
	 }
	 
	 
	 
	 // FILE: /app/src/Tag.php:
	 namespace App\tags;
	 
	 interface Tag
	 {
		  public function render();
		  public function __toString();
	 }
	 
	 
	 
	 
	 #>>>>>> Объектная композиция <<<<<<#
	 
	 /*
	 В этом уроке, описывается система, которая помогает правильно организовывать код построенный на классах.
	 
	 В языках, где ООП построено без инкапсуляции, подобные проблемы решаются проще и возникают реже. Если хочется узнать как это бывает, попробуйте пописать код на Clojure или Elixir.
	 
	 Предположим что мы делаем сайт имеющий механизм аутентификации. После её выполнения, пользователю выводится приветствие, которое строится по разному в зависимости от возвраста пользователя. Если пользователю не исполнилось 18, то пишется одно, всем остальным другое.
	 
	 В данном случае, реализация в лоб, через if, будет лучшим решением задачи. Но в этом уроке мы отрабатываем использование полиморфизма в рамках классовой модели, поэтому пойдем другим путём. Сама задача специально упрощена, чтобы не тратить время на её анализ
	 
	 Первый порыв у многих разработчиков, ввести два типа (интерфейса и класса): Under18 и Above18. Дальше в каждом из классов, которые реализуют эти интерфейсы добавить по методу getGreetingMessage(). В итоге мы получили полиморфизм подтипов:
	 
	 -- Где-то в шаблоне
	 -- Правильный класс для пользователя выбирается на момент начала обработки http-запроса
	 <?= $user->getGreetingMessage() ?>
	 
	 
	 Это решение хоть и работает, но ведёт не по тому пути. Сегодня у нас до 18 и после, потом появится отдельное поведение для тех кто старше 65. Всё станет ещё хуже, когда кроме этих разделений, появится дополнительное разделение на девушек и парней. В таком случае мы получим большое число комбинаций, под каждую из которых придётся создать отдельный класс пользователя:
	 
	 девушки старше 18
	 девушки младше 18
	 парни старше 18
	 парни младше 18
	 ...
	 
	 В книжках по паттернам любят приводить пример с разделением средств передвижения по типам: плавающие, летающие и ездящие. А потом, внезапно оказывается, что некоторые одновременно и плавают и ездят.
	 
	 Теперь попробуем ответить на вопрос, почему эту задачу не надо решать подтипами в любом случае. Сам по себе, пользователь, это сущность взятая из нашей предметной области. Предметная область и вывод текста на экран, это совершенно разные вещи. Второе относится к логике приложения, но не бизнес-логике. Если об этом не задумываться, то в конце-концов настанет момент, когда внутри пользователя окажется вообще всё что только происходит на сайте, ведь оно всё так или иначе связано с самим пользователем. И мы получим божественный объект.
	 
	 Правильное решение основано на композиции, подходе при котором создаются классы под конкретные задачи. Начнём сначала. В нашей задаче есть две ситуации: пользователи до 18 лет и пользователи старше. Создадим интерфейс GreetingMessage с методом getGreetingMessage и реализуем его в двух классах, один GreetingForUnder18 и другой GreetingAbove18. В каждом из них, будет тот вывод, который нужен для конкретного пользователя.
	 
	 Как пользователь будет взаимодействовать с объектами этих классов? Варианта два, либо мы передаем его в конструктор, либо в сам метод getGreetingMessage. Что правильнее? Всегда пытайтесь понять, имеем ли мы дело с абстракцией данных или нет. С самим пользователем всё понятно. Пользователь это абстракция данных, у него есть уникальность (все пользователи отличаются) и время жизни. А вот вывод сообщения, это операция без состояния. Само наличие класса и объекта для него обусловлено желанием получить полиморфизм подтипов и ничем более. Поэтому в данном примере лучше передавать пользователя через метод:
	 
	 <?= $greeting->getGreetingMessage($user) ?>
	 */
	 
	 // За кадром остался вопрос выбора и создания соответствующего объекта. За это отвечает фабрика, которая вызывается где-то до формирования вывода из шаблона.
	 
	 function buildGreetingObject($user)
	 {
		  if ($user->getAge() < 18) {
				return new GreetingForUnder18();
		  } else {
				return new GreetingForAbove18();
		  }
	 }
	 
	 /*
	 Главное в этой схеме, то что пользователь остался пользователем. Он по прежнему отвечает только за логику ядра приложения. Даже если добавятся новые условия вывода сообщения и наши два класса превратятся в 10 классов (потому что 10 вариантов вывода в зависимости от разных параметров), то это никак не повлияет на пользователя.
	 
	 Что ещё более важно, при появлении новых задач, не связанных с выводом сообщения, пользователь по прежнему не будет затронут. Например, мы захотим отправлять письма разным пользователям после регистрации. В зависимости от количества видов писем, будет создано такое же количество классов реализующих интерфейс RegistrationEmailText. Принцип работы останется таким же. Фабрика, выбор нужного типа в начале процесса регистрации и полиморфное поведение при отправке письма.
	 
	 Внимательный читатель заметит, что результат подозрительно похож на стратегию. Как ни странно, это и есть стратегия.
	 
	 В итоге, в коде появляется большое количество небольших интерфейсов (типов) и множество классов их реализующих. Количество классов реализующих конкретный интерфейс, равно количеству возможных вариантов поведения. Большинство объектов этих классов не имеют своего состояния и нужны для организации полиморфного кода.
	 
	 Стоит ли так писать код? Иногда да, но чаще нет. Слепое следование ООП, делает код сложнее и тяжелее, там где подходит простая функция или условная конструкция, начинают вырастать параллельные иерархии классов. В примерах выше это хорошо прослеживается. Задача, которая может быть реализована десятью строчками, решается многими десятками строчек и четырьмя файлами (фабрика, классы и интерфейс). А программист знакомый с абстрактными классами и наследованием, наворотит ещё больше файлов.
	 
	 Обычно, получаемая сложность оправдывается расширяемостью, но это так не работает. Расширяемость нужно добавлять тогда когда нужно и только туда куда нужно. Другой вопрос, что сам способ организации кода через композицию объектов, является краеугольным камнем при организации кода построенного на классах. При этом надо чётко отслеживать, где у нас абстракция данных, а где действия без состояния, представленные объектами.
	 
	 Дополнительные материалы
	 Архитектура и ООП https://ru.hexlet.io/blog/posts/arhitektura-i-oop
	 Принцип разделения интерфейса https://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса
	 */
	 
	 
	 /**@@
	 Адаптер – популярный шаблон проектирования. Он используется тогда, когда нужно использовать код, не поддерживающий необходимый интерфейс. В такой ситуации, создается "обертка" над необходимым кодом, которая поддерживает нужный интерфейс. Это очень похоже на адаптеры электронных устройств в реальной жизни.
	 
	 В текущем задании, есть код отвечающий за генерацию паролей, он находится в классе PasswordBuilder. Для генерации паролей, этот класс использует внешний объект, класс которого реализует интерфейс PasswordGenerationInterface.
	 
	 Суть данного задания, внедрить в эту систему внешнюю библиотеку, которая не поддерживает интерфейс PasswordGenerationInterface.
	 
	 Обратите внимание на то, что задача решается не через исправление кода самой библиотеки, а за счет создания адаптера, благодаря которому соединяется код задания и код библиотеки.
	 
	 src/HackzillaPasswordGenerator.php
	 Напишите класс HackzillaPasswordGenerator, который представляет собой адаптер к пакету hackzilla/password-generator. Реализуйте внутри него интерфейс PasswordGeneratorInterface.
	 */
	 
	 // FILE: /app/src/HackzillaPasswordGenerator:
	 namespace App;
	 
	 use Hackzilla\PasswordGenerator\Generator\ComputerPasswordGenerator;
	 
	 class HackzillaPasswordGeneratorAdapter implements PasswordGeneratorInterface
	 {
		  private $options = [
				'upperCase' => ComputerPasswordGenerator::OPTION_UPPER_CASE,
				'lowerCase' => ComputerPasswordGenerator::OPTION_LOWER_CASE,
				'numbers' => ComputerPasswordGenerator::OPTION_NUMBERS,
				'symbols' => ComputerPasswordGenerator::OPTION_SYMBOLS
		  ];
	 
		  public function generatePassword($length, $options = [])
		  {
				$generator = new ComputerPasswordGenerator();
				$generator->setLength($length);
	 
				foreach ($options as $optionName) {
					 $generator->setOptionValue($this->options[$optionName], true);
				}
	 
				return $generator->generatePassword();
		  }
	 }
	 
	 // FILE: /app/src/PasswordBuilder.php:
	 namespace App;
	 
	 class PasswordBuilder
	 {
		  private $passwordGenerator;
	 
		  public function __construct(PasswordGeneratorInterface $passwordGenerator)
		  {
				$this->passwordGenerator = $passwordGenerator;
		  }
	 
		  public function buildPassword($length = 8, $options = ['numbers', 'symbols'])
		  {
				$password = $this->passwordGenerator->generatePassword($length, $options);
				$passwordDigest = sha1($password);
	 
				return ['password' => $password, 'digest' => $passwordDigest];
		  }
	 }
	 
	 // FILE: /app/src/PasswordGeneratorInterface.php:
	 namespace App;
	 
	 interface PasswordGeneratorInterface
	 {
		  public function generatePassword($length, $options = ['numbers', 'symbols']);
	 }
	 
	 
	 #>>>>>> Паттерн Состояние (State) <<<<<<#
	 
	 /*
	 Паттерн "Состояние" – яркий пример замены условных конструкций на полиморфизм подтипов. Он довольно широко используется и способен по-настоящему снизить сложность кода. Разберем его на примере будильника.
	 
	 Пусть у него имеются три кнопки. H - кнопка для увеличения часа на единицу, M - для увеличения минуты на единицу и кнопка Mode, которая переключает часы в режим настройки будильника. В этом режиме на экране отображается время срабатывания будильника, а кнопки H и M устанавливают не текущее время, а время срабатывания будильника. Повторное нажатие кнопки Mode возвращает часы в обычный режим. Кроме того, затяжное нажатие на кнопку Mode приводит к тому, что будильник активируется. Такое же нажатие ещё раз отключает будильник.
	 
	 После этого, если текущее время совпадает со временем будильника, включается звонок, который отключается либо нажатием кнопки Mode, либо самопроизвольно через минуту. Кнопки H и M в режиме звонка (когда сработал будильник) не активны.
	 
	 Поведение часов с будильником уже является сложным, поскольку одни и те же входные воздействия (нажатие одних и тех же кнопок) в зависимости от режима инициируют различные действия.
	 
	 В программных и программно-аппаратных вычислительных системах сущности со сложным поведением встречаются очень часто. Таким свойством обладают устройства управления, сетевые протоколы, диалоговые окна, персонажи компьютерных игр и многие другие объекты и системы.
	 
	 Подведём итог. У нас есть следующие действия:
	 
	  - Установка времени
	  - Установка времени срабатывания будильника
	  - Включение/Выключение будильника
	  - Отключение звонка будильника
	 
	 # Флаго-ориентированное программирование
	 */
	 
	 class AlarmClock
	 {
		  public function clickH()
		  {
				if (!$this->onBell) {
					 if ($this->mode === 'alarm') {
						  $this->alarmHours += 1;
					 } else {
						  $this->hours += 1;
					 }
				}
		  }
	 }
	 
	 $clock = new AlarmClock();
	 $clock->clickH();
	 
	 /*
	 Выше типичный пример флаго-ориентированного программирования. Примерно так выглядит код большинства программ.
	 
	 Здесь наблюдается ситуация в которую так и просится полиморфизм. Достаточно очевидно, что диспетчеризация нам нужна по состоянию, другими словами, должен выполняться разный код в зависимости от того, в каком состоянии находится наш объект. Из этого предположения может следовать только одно. Нужно каждое состояние превратить в тип данных. Так появляется на свет паттерн State.
	 
	 Выделим три управляющих состояния для наших часов:
	  - ClockState
	  - AlarmState
	  - BellState
	 
	 
	 Обратите внимание, что состояние "включен будильник" сюда не входит. Оно не является управляющим.
	 Этот параметр влияет только на то, что произойдет переход в BellState в тот момент, когда время на часах и время на будильнике будет одинаковым.
	 
	 Теперь давайте посмотрим на реализацию с использованием динамической диспетчеризации:
	 */
	 
	 class AlarmClock
	 {
		  public function __construct()
		  {
				$this->hours = 12;
				$this->alarmHours = 6;
				$this->setState(ClockState::class);
		  }
	 
		  public function setState($className)
		  {
				$this->state = new $className($this);
		  }
	 
		  public function clickH()
		  {
				// Делегирование
				$this->state->clickH();
		  }
	 }
	 
	 
	 /*
	 Код, который здесь написан, это всего лишь один из вариантов реализации паттерна State. Не принимайте как догму всё, что вы читаете в книгах "10 лучших паттернов". Главное, это концептуальная идея и решаемая задача, остальное очень сильно варьируется от большого числа параметров. В основном в книгах все примеры даны для статических языков, и эти реализации очень громоздки для такого языка как php.
	 
	 От чего точно не уйти, так это от того, что в начале наши часы инициализируются неким начальным состоянием. В нашем случае оно statefull (мы передаем туда текущий объект), но так же оно могло бы быть и stateless. А дальше все интерфейсные методы часов, поведение которых зависит от состояния, делегируют все вызовы внутрь объекта состояния. Внутри, без условных конструкций, находится код, который выполняет только то, что нужно делать в текущем состоянии. При необходимости этот код меняет сам объект часов. Это возможно благодаря тому, что мы передали внутрь состояния this.
	 
	 Если какое-то событие приводит к изменению состояния, то само состояние (в паттерне State) отвечает за то, чтобы поменять себя на другое состояние. Например, при очередном тике часов, если настало время работы будильника, то мы подставляем вместо себя состояние BellState.
	 */
	 
	 class ClockState
	 {
		  public function tick()
		  {
				if ($this->clock->isAlarmTime()) {
					 $this->clock->setState(BellState::class);
				}
		  }
	 }
	 
	 /**@@
	 Реализуйте логику работы часов из теории.
	 
	 В режиме настройки будильника (alarm), часы и минуты изменяются независимо и никак друг на друга не влияют (как и в большинстве реальных будильников). То есть если происходит увеличение минут с 59 до 60 (сброс на 00), то цифра с часами остается неизменной.
	 
	 Интерфейсными методами часов являются:
	 
	 
	 clickMode() - нажатие на кнопку Mode
	 longClickMode() - долгое нажатие на кнопку Mode
	 clickH() - нажатие на кнопку H
	 clickM() - нажатие на кнопку M
	 tick() - при вызове, увеличивает время на одну минуту. Если новое время совпало со временем на будильнике, то часы переключаются в режим срабатывания будильника (bell).
	 isAlarmOn() - показывает включен ли режим будильника
	 isAlarmTime() - возвращает true, если время на часах совпадает со временем на будильнике
	 getMinutes() - возвращает минуты, установленные на часах
	 getHours() - возвращает часы, установленные на часах
	 getAlarmMinutes() - возвращает минуты, установленные на будильнике
	 getAlarmHours() - возвращает часы, установленные на будильнике
	 getCurrentMode() - возвращает текущий режим (alarm | clock | bell)
	 
	 
	 Основной спецификацией к данной задачe нужно считать тесты.
	 
	 AlarmClock.php
	 Реализуйте интерфейсные методы и логику работы часов.
	 
	 states/AlarmState.php, states/BellState.php, states/ClockState.php
	 Реализуйте логику состояний.
	 */
	 
	 // FILE: /app/src/AlarmClock.php:
	 class AlarmClock
	 {
		  private $clockTime = ['minutes' => 0, 'hours' => 12];
		  private $alarmTime = ['minutes' => 0, 'hours' => 6];
		  private $alarmOn = false;
	 
		  public function __construct()
		  {
				$this->setNextState(states\ClockState::class);
		  }
	 
		  public function clickMode()
		  {
				$this->setNextState($this->state->getNextStateClassName());
		  }
	 
		  public function longClickMode()
		  {
				$this->alarmOn = !$this->alarmOn;
		  }
	 
		  public function clickH()
		  {
				$this->state->incrementH();
		  }
	 
		  public function clickM()
		  {
				$this->state->incrementM();
		  }
	 
		  public function tick()
		  {
				$this->incrementM('clockTime');
				if ($this->clockTime['minutes'] === 0) {
					 $this->incrementH('clockTime');
				}
				$this->state->tick();
		  }
	 
		  public function isAlarmOn()
		  {
				return $this->alarmOn;
		  }
	 
		  public function isAlarmTime()
		  {
				return $this->clockTime['minutes'] === $this->alarmTime['minutes']
					 && $this->clockTime['hours'] === $this->alarmTime['hours'];
		  }
	 
		  public function getMinutes()
		  {
				return $this->clockTime['minutes'];
		  }
	 
		  public function getHours()
		  {
				return $this->clockTime['hours'];
		  }
	 
		  public function getAlarmMinutes()
		  {
				return $this->alarmTime['minutes'];
		  }
	 
		  public function getAlarmHours()
		  {
				return $this->alarmTime['hours'];
		  }
	 
		  public function setNextState($className = null)
		  {
				$className = $className ?? $this->state->getNextStateClassName();
				$this->state = new $className($this);
		  }
	 
		  public function getCurrentMode()
		  {
				return $this->state->getModeName();
		  }
	 
		  public function incrementH($timeType)
		  {
				$hoursCount = $this->$timeType['hours'];
				$this->$timeType['hours'] = ($hoursCount + 1) % 24;
		  }
	 
		  public function incrementM($timeType)
		  {
				$minutesCount = $this->$timeType['minutes'];
				$this->$timeType['minutes'] = ($minutesCount + 1) % 60;
		  }
	 }
	 
	 // FILE: /app/src/states/AlarmState.php:
	 class AlarmState implements State
	 {
		  private $clock;
		  private $mode = 'alarm';
		  private $timeType = 'alarmTime';
		  private $nextStateClass = ClockState::class;
	 
		  public function __construct($clock)
		  {
				$this->clock = $clock;
		  }
	 
		  public function getNextStateClassName()
		  {
				return $this->nextStateClass;
		  }
	 
		  public function getModeName()
		  {
				return $this->mode;
		  }
	 
		  public function incrementH()
		  {
				$this->clock->incrementH($this->timeType);
		  }
	 
		  public function incrementM()
		  {
				$this->clock->incrementM($this->timeType);
		  }
	 
		  public function tick()
		  {
				if ($this->clock->isAlarmTime()) {
					 $this->clock->setNextState(BellState::class);
				}
		  }
	 }
	 
	 // FILE: /app/src/states/BellState.php:
	 class BellState implements State
	 {
		  private $clock;
		  private $mode = 'bell';
		  private $nextStateClass = ClockState::class;
	 
		  public function __construct($clock)
		  {
				$this->clock = $clock;
		  }
	 
		  public function getNextStateClassName()
		  {
				return $this->nextStateClass;
		  }
	 
		  public function getModeName()
		  {
				return $this->mode;
		  }
	 
		  public function tick()
		  {
				$this->clock->setNextState();
		  }
	 
		  public function incrementH()
		  {
				return false;
		  }
	 
		  public function incrementM()
		  {
				return false;
		  }
	 }
	 
	 // FILE: /app/src/states/ClockState.php:
	 class ClockState implements State
	 {
		  private $clock;
		  private $mode = 'clock';
		  private $timeType = 'clockTime';
		  private $nextStateClass = AlarmState::class;
	 
		  public function __construct($clock)
		  {
				$this->clock = $clock;
		  }
	 
		  public function getNextStateClassName()
		  {
				return $this->nextStateClass;
		  }
	 
		  public function getModeName()
		  {
				return $this->mode;
		  }
	 
		  public function incrementH()
		  {
				$this->clock->incrementH($this->timeType);
		  }
	 
		  public function incrementM()
		  {
				$this->clock->incrementM($this->timeType);
		  }
	 
		  public function tick()
		  {
				if ($this->clock->isAlarmOn() && $this->clock->isAlarmTime()) {
					 $this->clock->setNextState(BellState::class);
				}
		  }
	 }
	 
	 
	 
	 #>>>>>> Управление зависимостями <<<<<<#
	 
	 /*
	 На протяжении всего курса, мы говорили про процесс инициализации, внутри которого создаются необходимые объекты. Затем эти объекты используются в прикладном коде. К таким объектам относятся: соединение с базой данных, логгер, кеш, шаблонизатор, интеграция с внешними сервисами и многое другое.
	 
	 В простых ситуациях, там где объектов немного и мы сами управляем кодом (а не используем фреймворки, определяющие структуру), зависимости можно внедрять "руками":
	 */
	 
	 $geolocationService = new GoogleMaps();
	 $storeService = new StoreService($geolocationService);
	 $app = new App(['storeService' => $storeService]);
	 $app->run();
	 
	 /*
	 В коде, который активно использует инверсию зависимостей, инициализация кода выглядит как матрёшка из объектов. Объекты верхнего уровня принимают на вход объекты с нижних слоев, шаг за шагом собирая готовое приложение.
	 
	 С ростом числа объектов, процесс сборки усложняется и становится утомительным. Появляются ситуации, в которых объекты нужны в самой глубине кода, но прокинуть их можно только пройдя множество уровней. В популярных фреймворках, инициализация может включать в себя создание и внедрение сотен объектов. Страшно даже представить, что придётся писать этот код вручную.
	 
	 Для решения данной задачи, используется два подхода (шаблона проектирования). Ниже поговорим про каждый из них
	 
	 
	 # Локатор (Service Locator)
	 
	 Самый простой способ внедрять зависимости в таких системах - сервис локатор. Это объект, который содержит внутри себя все зависимости.
	 Любой объект, которому нужен какой-либо сервис, обращается за ним к сервис локатору.
	 
	 Возьмём для примера микрофреймворк Slim. У него есть расширение PHP-View, которое добавляет шаблонизатор во фреймворк. Попробуем внедрить это расширение через Service Locator:
	 */
	 
	 use Slim\Views\PhpRenderer;
	 
	 include 'vendor/autoload.php';
	 
	 $app = new Slim\App();
	 
	 // Для простоты локатор реализован как обычный массив
	 // Но, в общем случае, он может быть чем угодно
	 $locator = [
		'renderer' => new PhpRenderer('./templates')
	 ];
	 
	 $app->get('/hello/{name}', function ($request, $response, $args) use ($locator) {
		  // Прикладной код _знает_ про локатор и пользуется им для извлечения зависимостей
		  return $locator['renderer']->render($response, 'hello.php', $args);
	 });
	 
	 $app->run();
	 
	 /* Вот такой нехитрый подход для внедрения зависимостей. По нему написаны сотни статей со всевозможными вариациями его создания и использования. В большинстве из них локатор рассматривается как антипаттерн. Так как прикладной код знает про его существование.
	 
	 # Контейнер (DI-container)
	 
	 Вершиной эволюции инверсии зависимостей считается Di-container. Продвинутые контейнеры, это целые фреймворки, которые занимаются инициализацией приложения, собирают необходимые объекты и прокидывают их друг в друга. В некоторых экосистемах, контейнер – центральная часть всей системы, которая занимается её оркестракцией (управлением). В Java, например, это SpringFramework. Он с лёгкостью может собирать и веб-приложение и демонов.
	 
	 Ключевое отличие контейнера от локатора в том, что зависимости из контейнера попадают внутрь приложения прозрачно. Прикладной код не догадывается о существовании контейнера, он лишь видит объекты которых ждёт. Для инъекции этих зависимостей используются стандартные подходы: либо через конструктор, либо через сеттеры и аргументы методов.
	 
	 Снова посмотрим на Slim и интеграцию с PHP-View, но уже через встроенный контейнер:
	 */
	 
	 use Slim\Views\PhpRenderer;
	 
	 include 'vendor/autoload.php';
	 
	 $app = new Slim\App();
	 
	 // Несмотря на название, это всё же локатор, потому что
	 $container = $app->getContainer();
	 $container['renderer'] = new PhpRenderer('./templates');
	 
	 $app->get('/hello/{name}', function ($request, $response, $args) {
		  return $this->renderer->render($response, 'hello.php', $args);
	 });
	 
	 $app->run();
	 
	 /*
	 Контейнер в Slim очень простой, но, всё же, это контейнер. Посмотрите на его использование. Обработчик запроса работает напрямую с renderer. Он не знает ничего про контейнер и про то, как зависимость попала внутрь $this.
	 
	 В PHP, контейнеры имеют настолько важную роль, что их интерфейс был унифицирован через PSR-11 https://www.php-fig.org/psr/psr-11/. Для более подробного погружения в тему, посмотрите на PHP-DI http://php-di.org/.
	 */
	 
	 
	 /**@@
	 В этом упражнении мы попробуем воспользоваться библиотекой PHP-DI для сборки приложения.
	 
	 В самом приложении есть три сущности:
	 
	 Класс Application. Представим что это и есть само приложение. Через конструктор он принимает логгер (обязательно посмотрите на определение конструктора). Метод run() запускает приложение на выполнение. Для простоты, внутри метода run() логгируется фраза The application has been started!. Именно ее ожидают увидеть тесты.
	 LoggerInterface интерфейс с одним методом info($message)
	 Logger – конкретный логгер, реализующий интерфейс LoggerInterface
	 Приложение можно собрать и запустить на выполнение так:
	 */
	 
	 $app = new Application(new Logger());
	 $app->run();
	 
	 /*
	 Ваша задача состоит в том, чтобы собрать приложение с помощью библиотеки PHP-DI. Для реализации этого кода, вам потребуется провести немного времени в документации.
	 
	 Что потребуется:
	 
	 Контейнер – это объект класса \DI\Container
	 Контейнер нужно заполнить классами. Для этого используется метод set http://php-di.org/doc/container.html#set
	 При добавлении классов в контейнер, испольуйте функцию \DI\autowire http://php-di.org/doc/php-definitions.html#autowired-objects
	 Для извлечения готового приложения из контейнера, понадобится метод get http://php-di.org/doc/container.html#get-amp-has
	 
	 src/Main.php
	 Реализуйте функцию buildApplication(), которая собирает приложение и возвращает его наружу.
	 */
	 
	 // FILE: /app/src/Main.php:
	 namespace App\Main;
	 
	 use App\Logger;
	 use App\Application;
	 use App\LoggerInterface;
	 
	 function buildApplication()
	 {
		  $container = new \DI\Container();
		  $container->set(LoggerInterface::class, \Di\autowire(Logger::class));
		  $container->set(Application::class, \DI\autowire(Application::class));
		  $app = $container->get(Application::class);
		  
		  return $app;
	 }
	 
	 
	 // FILE: /app/src/Logger.php:
	 namespace App;
	 
	 class Logger implements LoggerInterface
	 {
		  public function info($message)
		  {
				echo $message;
		  }
	 }
	 
	 
	 // FILE: /app/src/LoggerInterface.php:
	 namespace App;
	 
	 interface LoggerInterface
	 {
		  public function info(string $message);
	 }
	 
	 
	 // FILE: /app/src/Application.php:
	 namespace App;
	 
	 class Application
	 {
		  public $logger;
	 
		  public function __construct(LoggerInterface $logger)
		  {
				$this->logger = $logger;
		  }
	 
		  public function run()
		  {
				$this->logger->info('The application has been started!');
		  }
	 }
	 
	 
	 // FILE: /app/tests/MainTest.php:
	 namespace App\Tests;
	 
	 use PHPUnit\Framework\TestCase;
	 use function App\Main\buildApplication;
	 
	 class ApplicationTest extends TestCase
	 {
		  public function testMain()
		  {
				$app = buildApplication();
				$app->run();
				$this->expectOutputString('The application has been started!');
		  }
	 }