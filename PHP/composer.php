<?
########## PHP: Настройка окружения ##########
/*
мы поддерживаем репозиторий php-package (https://github.com/hexlet-boilerplates/php-package) — так называемый бойлерплейт. Репозиторий, содержащий базовую структуру проекта на PHP. Вы всегда можете подглядывать в него и делать по аналогии.

Если все прошло удачно, то теперь самое время повыполнять код на PHP. PHP поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для его запуска достаточно набрать php -a (в Windows REPL не работает):
*/

$ php -a
Interactive shell

php >

// Теперь можно выполнять код на PHP и сразу же смотреть результат его выполнения. Наберите любой валидный код на PHP, например такой:

php > echo 5 + 10;
15
php >

/*
REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из репла достаточно нажать Ctrl + C. Если вы ошиблись при вводе команды, например забыли ;, то всегда можно выйти и зайти снова.

Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
*/

php > $a = 5;
php > $b = 10;
php > echo $a + $b;
15

// Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях, когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением php, например, index.php, а затем запустить:

// index.php:

<?php

echo 'hello!';


$ php index.php
hello!

// Обратите внимание, что запускать код нужно из той же директории, в которой лежит файл index.php, либо указывать путь до файла.




########## Composer ##########

/*
Composer — это свободный пакетный менеджер для установки зависимостей и самих модулей PHP. С помощью скрипта можно в несколько нажатий установить нужный модуль, а также все его зависимости, например, ZendFramework или Symphony. Он широко используется разработчиками PHP скриптов. 

Практически с самого зарождения программирования (когда код стал храниться в памяти компьютера), появилась идея переиспользования кода не только в рамках одного проекта, но и сквозь разные проекты. Например, функции для работы с датами, математическими формулами, всевозможными расчетами одни и те же во всех проектах, где они требуются. Подобное переиспользование приводит к резкому возрастанию производительности. Программисты современности могут сосредоточиться на решении уникальных задач бизнеса, вместо создания своих велосипедов для решения инфраструктурных задач. Особенно просто стало жить во времена git и github.

Первоначально общий код выносился в файлы, которые программисты часто держали на своих собственных компьютерах и копировали из проекта в проект. Такой способ обладает рядом существенных недостатков:

    Сложно передать другим
    У каждого своя собственная копия решений одних и тех же решений (немного разных решений)
    Доработкой занимается только автор
    В сумме много разных копий без возможности быстрого обновления
    Из-за того, что код копируется прямо в другой проект, он, как правило, модифицируется и становится специфичным

Если использовать git, то часть проблем решается автоматически. Мы можем сказать, что набор общих файлов называется "библиотека", а конечные проекты начинают использовать библиотеки как написанные нами, так и сторонними разработчиками. Но тут возникает следующая сложность - когда таких библиотек становится много, то у них также появляется общий код более низкого уровня. Например, финансовые библиотеки могут использовать функции для преобразования валют. Чтобы подобный код не дублировался, хочется его вынести в общее место. Этот процесс может продолжаться бесконечно. Одни библиотеки зависят от других, те в свою очередь от третьих и так далее. С точки зрения переиспользования кода все хорошо, большое число маленьких библиотек, решающих всевозможные задачи, позволяют быстро двигаться вперед, но с точки зрения управления появляются проблемы:

    Необходимо ввести понятие "версия", а библиотеки начинают зависеть не только друг от друга, но и от версий друг друга. Почему это нужно? Очень просто. Предположим, что создатель библиотеки обновил её, изменив сигнатуры функций (другое число параметров, другие параметры, другой возврат), или, как говорят, сломал обратную совместимость. В такой ситуации наша первоначальная библиотека перестанет работать (если мы обновим вторую библиотеку), так как она рассчитывала на одно поведение зависимой библиотеки, а получила другое.

    Необходимо стандартизировать способ создания библиотек, только в таком случае станет возможным автоматизировать процесс их соединения без ручного управления. Скажу навскидку, типичный веб проект может зависеть от сотни библиотек, которые в свою очередь зависят от других библиотек. Общее число зависимостей может легко перевалить за тысячу. Руками управлять таким зоопарком не представляется возможным.

    Проблема, описанная выше, также требует наличия автоматизированного средства по управлению зависимостями. Обновлению, установке и удалению.

Всеми этими вопросами занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется прямо с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.

# Терминология

В PHP используются следующие понятия.
Пакет - собственно, та самая библиотека, которую мы либо пишем, либо используем в проекте как зависимость.

Репозиторий (Registry) - хранилище пакетов PHP, которое называется Packagist. Каждый желающий может опубликовать пакет в Packagist, потратив буквально минуту времени, а остальные смогут его использовать. В хранилище, на текущий момент, сотни тысяч пакетов и их количество растет. Исходный код пакетов, как правило, хранится на гитхабе, но это не обязательно. Пакеты в PHP никак не связаны с git и github.



# Глобальная установка пакетов

Многие пакеты в PHP представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту phploc, которая умеет считать количество строк и сущностей в PHP проекте. Инструкция по установке подобных пакетов обычно присутствует на странице репозитория в гитхабе (https://github.com/sebastianbergmann/phploc).
*/
$ composer global require phploc/phploc

/*
Отмечу несколько моментов:
	global - означает, что установка глобальная, то есть пакет ставится в операционную систему как обычная программа

	Чтобы shell увидел программу, установленную глобально, нужно правильно настроить переменную окружения $PATH

# Переменные окружения

PATH

В файловых системах ОС существует понятие "исполняемый файл" или, как часто говорят, бинарник (в реальности он не всегда бинарный). Именно эти файлы запускаются, когда определенная команда в shell представлена реальной программой (и это бывает не всегда). Например, запуск ls в Bash. Кстати, узнать где лежит этот файл можно командой which ls. Возможно, сейчас вам кажется, что в запуске программ ничего необычного, но дьявол кроется в деталях. Правильный вопрос звучит так: откуда shell знает, где искать этот бинарник? Ведь, если взять и самостоятельно создать подобный файл и назвать его hey, а потом положить в произвольное место системы, то попытка запустить hey ни к чему не приведет.
*/

$ hey
-bash: hey: command not found

// Весь секрет состоит в использовании переменных окружения. Мы не будем говорить про них подробно (об этом в курсе по командной строке), но общий принцип следующий — переменные окружения глобальны и доступны всем. Их основное предназначение - конфигурация. Так вот, существует некая системная переменная PATH, внутри которой содержатся пути, по которым shell ищет то, что вы пытаетесь запустить. Вот вывод на моем ноутбуке:

$ echo $PATH
/usr/local/sbin:/usr/local/opt/postgresql@9.5/bin:~/.composer/vendor/bin:~/.yarn/bin:/var/tmp/nim/bin:~/.local/bin:~/.nimble/bin:~/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/Library/Frameworks/Mono.framework/Versions/Current/Commands

/*
: отделяет пути друг от друга. Этот список у всех разный, так как его можно настраивать и многие программы это делают автоматически. Иногда приходится его расширять самостоятельно.

В большинстве языков программирования пакетные менеджеры подкладывают ссылки на установленные пакеты в стандартные пути. Например, в /usr/local/bin. Этот путь добавлен в $PATH по умолчанию, а значит любой исполняемый файл внутри него будет найден при вызове из командной строки.

В случае Composer необходимо добавлять путь в $PATH самостоятельно. Самый простой способ это сделать - добавить в конец файла ~/.bash_profile следующую строку: export PATH=$PATH:$HOME/.composer/vendor/bin (после этого нужно открыть новую терминальную сессию). Теперь оболочка будет искать исполняемые файлы и в папке ~/.composer/vendor/bin.

Возвращаемся к phploc. Процесс установки занимает некоторое время, в течении которого видно как скачивается не только сам пакет, но и его зависимости. Дальше ничего делать не нужно, так как phploc создан утилитой командной строки, он сразу готов к использованию.
*/

$ phploc src

phploc 4.0.0 by Sebastian Bergmann.

Directories                                          3
Files                                               10

Size
  Lines of Code (LOC)                             1882
  Comment Lines of Code (CLOC)                     255 (13.55%)
  Non-Comment Lines of Code (NCLOC)               1627 (86.45%)
  Logical Lines of Code (LLOC)                     377 (20.03%)
    Classes                                        351 (93.10%)
      Average Class Length                          35
        Minimum Class Length                         0
        Maximum Class Length                       172
      Average Method Length                          2
        Minimum Method Length                        1
        Maximum Method Length                      117
    Functions                                        0 (0.00%)
      Average Function Length                        0
    Not in classes or functions                     26 (6.90%)

/*
Если что-то пошло не так, убедитесь что вы все правильно настроили:
	Изучите вывод echo $PATH. Есть ли там путь до исполняемых файлов Composer.
	Проверьте, все ли установилось командой which phploc.


# Проект

Composer работает таким образом, что объединяет понятия "проект" (приложение или application) и "пакет" в одно целое. В общем случае считается, что проект, в отличие от пакета, это конечный продукт, который никуда не публикуется, что довольно очевидно. Если компания делает сайт на PHP, то этот сайт, хотя и использует публичные зависимости, сам по себе хранится в приватном репозитории и никуда не утекает. Но с точки зрения Composer все происходит одинаково. Причем под проектом понимается не обязательно что-то большое. Даже если ваш проект (файл) состоит из 3 строчек кода и использует зависимости, вам понадобится работать с ним как с полноценным проектом. Начинается все просто. Необходимо выполнить команду composer init в той папке, где вы собираетесь писать код.
*/

$ composer init


  Welcome to the Composer config generator

This command will guide you through creating your composer.json config.

Package name (<vendor>/<name>) [sergey/example]:
Description []:
Author [Kirill Mokevnin <mokevnin@gmail.com>, n to skip]:
Minimum Stability []:
Package Type (e.g. library, project, metapackage, composer-plugin) []:
License []:

Define your dependencies.

Would you like to define your dependencies (require) interactively [yes]?
Search for a package:
Would you like to define your dev dependencies (require-dev) interactively [yes]?
Search for a package:

{
    "name": "sergey/example",
    "authors": [
        {
            "name": "Sergey",
            "email": "sergey@sergey.com"
        }
    ],
    "require": {}
}

Do you confirm generation [yes]?


/*
После этого вам предложат ответить на десяток вопросов. Если вы не понимаете значение некоторых вопросов, то смело жмите Enter, потом все можно будет поправить.

Когда вопросы закончатся, Composer покажет конечный результат в виде JSON. JSON - это текстовый формат для представления структурированных данных. Если вы не знакомы с ним, то не стоит переживать, формат это не язык программирования. Достаточно выучить несколько правил по формированию данных в виде JSON для того, чтобы чувствовать себя комфортно.
*/

{
    "name": "mokevnin/myproject",
    "authors": [
      {
      "name": "Kirill Mokevnin",
      "email": "mokevnin@gmail.com"
      }
    ],
    "require": {}
}

/*
Если вас все устраивает, то Composer создаст файл composer.json. Именно этот файл является ключевым. Абсолютно все, что касается зависимостей (и не только), полностью описывается в нем.

Имя пакета, записанное в composer.json, состоит из двух частей. Первая - vendor name, имя, под которым вы зарегистрированы в Packagegist, вторая - project name. Причем vendor name уникален глобально (то есть все пользователи имеют свое собственное неповторимое имя), а вот project name должен быть уникален только в пределах vendor name.

Composer рекомендует именовать пакет словами в нижнем регистре и в качестве разделителя использовать дефис, например: dependency-injection.

# Проблемы

Если в файле composer.json содержатся синтаксические ошибки, иными словами, есть нарушения правила форматирования JSON, то при попытке сделать что-то с проектом будут появляться подобные ошибки:
*/

[Seld\JsonLint\ParsingException]
"./composer.json" does not contain valid JSON
Parse error on line 2:
"name": "mokevnin/myproject",
---------^

/*
Обычно любые сообщения с «неожиданными» (unexpected) символами или строками говорят о наличие синтаксической ошибки.

Воспользуйтесь валидаторами JSON для проверки корректности своего файла. Например, jsonlint.com или другими подобными инструментами, которые можно загуглить по запросу "json validator".


# Самостоятельная работа
    Создайте директорию my-project в любом удобном месте вашего компьютера
    Создайте проект в директории my-project используя composer init

В результате в папке проекта должен оказаться файл composer.json
*/



##########  Управление зависимостями ########## 

# Зависимости
/*
В файле composer.json по умолчанию создается две секции: require и require-dev. Внутри них необходимо описать то, от чего зависит проект. Две секции понадобилось для разделения тех зависимостей, которые нужны при использовании библиотеки, и тех, которые нужны только для тестирования и локальной разработки. Например, тесты при использовании пакета совершенно ни к чему, поэтому их зависимости можно смело описывать в require-dev.

Предположим, что наш пакет зависит от библиотеки tightenco/collect. Эту библиотеку мы будем активно использовать в наших курсах позже. Разберем процесс установки:


1. Для начала нужно понять, а под каким именем существует наша библиотека. Тут вариантов два: либо мы уже знаем, как в случае tightenco/collect, либо мы загуглили библиотеку на гитхабе и хотим выяснить ее имя. Часто имя можно извлечь из строки установки, которая есть в ридми, но если ее нет, вы всегда можете узнать имя, открыв файл composer.json и прочитав значение свойства name.

2. Затем нужно взять это имя и вставить в секцию require. Самый лучший способ сделать это — набрать команду в папке пакета:
*/
$ composer require tightenco/collect

/*
Отличие от глобальной установки в том, что здесь нет global. При таком подходе зависимости ставятся в папку vendor, находящуюся в корне проекта. Не забудьте добавить эту папку в .gitignore, так как библиотеки не являются частью вашего репозитория и ставятся по необходимости. Обратите внимание на то, что эта команда автоматически изменяет ваш composer.json. Секция require теперь выглядит примерно так:
*/

"require": {
    "tightenco/collect": "^5.5"
}

/*
Кроме того, Composer создаст файл composer.lock в корне проекта. Этот файл должен храниться в репозитории, а его значение я объясню в следующем уроке.

Точно таким же способом ставятся последующие зависимости. Если зависимость должна оказаться в require-dev, то команда установки меняется так:
*/

# двойные кавычки могут быть нужны чтобы shell не принял спец символы за команды
$ composer require --dev "phpunit/phpunit=*"

/*
Теперь самое интересное — как, собственно, использовать установленные зависимости? Ответ, как обычно, находится в документации репозитория на гитхабе того пакета, который вы хотите использовать.

Создайте в корне вашего проекта папку src, а внутри неё файл Runner.php. Добавьте следующий код:

<?php
*/

namespace My\Project\Runner;

use Illuminate\Support\Collection;

function run()
{
    $collection = collect(['taylor', 'abigail', null])->map(function ($name) {
    return strtoupper($name);
    });

    return $collection;
}

/*
К сожалению, на текущем этапе код, указанный выше, упадет в любом случае. Для его работы необходимо настроить автозагрузку, но об этом в следующем уроке.

Если вы склонировали репозиторий с гитхаба, папка vendor будет отсутствовать, как и пакеты в ней. Первое, что нужно будет сделать — выполнить команду composer install. Установка пакетов — это идемпотентная операция, её можно запускать сколько угодно раз и всё будет хорошо.


# Пакет

Все, что описывалось выше для проекта, также применимо и для пакета. Единственное ключевое отличие — пакет нужно опубликовать, если вы хотите, чтобы другие люди могли им пользоваться. Для этого обязательно нужно изменить версию, указанную в composer.json, так как нельзя публиковать уже опубликованную версию. Ушедший код не может изменяться, ведь на него завязываются другие.

Для успешной публикации должны выполниться два условия:

    Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет.

    Вы зарегистрированы на сайте https://packagist.org/

Далее следуйте указаниям на странице https://packagist.org/packages/submit. После того, как пакет будет опубликован, его можно устанавливать стандартным способом через вызов composer require.

Интересный вопрос заключается в том, как правильно версионировать пакет. На этот счет был придуман стандарт, названный SEMVER (http://semver.org/lang/ru). Его описание занимает буквально пару страниц на русском языке. Обязательно ознакомьтесь.

# Самостоятельная работа

    Зарегистрируйтесь на сайте https://packagist.org/ (это пригодится для участия в проектах)
*/




########## Автозагрузка ##########

/*
# Namespace

Любой код на PHP, написанный в современном стиле, вызывается с указанием неймспейса. Не важно о каком коде речь, будь то вызов кода из файла, лежащего в соседнем файле, или вызов кода из установленной зависимости. Давайте еще раз посмотрим на код из предыдущего примера:

<?php
*/

namespace My\Project\Runner;

use Illuminate\Support\Collection;

function run()
{
    $collection = collect(['taylor', 'abigail', null])->map(function ($name) {
        return strtoupper($name);
    });

    return $collection;
}


/*
Как видите, для использования collect мы указываем использовать неймспейс Illuminate\Support\Collection. Тоже самое касается любой другой библиотеки, включая те, которые пишем мы сами. По этой причине нужно как-то выбрать имя неймспейса. Имя пакета отображается в имени неймспейса так Dependency\Injection, что дефис заменяется на \ (обратный слеш), а каждое слово начинается с заглавной буквы.

К сожалению, из-за того, что неймспейсы в языке появились не сразу, PHP позволяет создавать файловую структуру и структуру неймспейсов независимо. Кроме того, в разных пакетах разные способы именования файлов, разные способы формирования самих имен пакетов, разные способы организации файлов внутри пакета. По этой причине я постарался использовать в php-package (https://github.com/hexlet-boilerplates/php-package) те практики, которые наиболее распространены и похожи на то, как все организовано в других языках.


    Пакет именуется в kebab-case стиле.

    Каждый пакет может выставлять наружу только один неймспейс, что снижает риск пересечения с другими пакетами, а так же позволяет легко определить принадлежность неймспейса к пакету. В терминологии стандарта PSR-4, такой неймспейс называется "vendor namespace".

    Неймспейсы именуются в PascalCase и напрямую отображаются на файловую систему, не считая корневого неймспейса, который получается путем трансформации имени пакета

    Исходный код проекта лежит в папке src, а тесты в папке tests.

Что касается именования файлов, то, что бы не хранилось внутри, придерживайтесь PascalCase именования (например, MySuperFile.php).


# Autoload

В предыдущем уроке мы создали файл src/Runner.php, но я сказал, что попытка запустить его завершится с ошибкой. Дело в том, что попытка использовать любой сторонний код, включая другие файлы, принадлежащие текущему пакету, требует загрузки этих файлов. Указание неймспейса, само по себе, никак не влияет на их загрузку. По умолчанию считается, что если вы пытаетесь использовать какой-то код, то он уже загружен, используя require или require_once. Чисто технически можно так и делать. Каждый раз, когда нам нужно использовать сторонний код, мы можем сначала делать его подгрузку через require. К счастью, этого делать не нужно. Более того, линтер ругается на попытку использовать require самостоятельно.

Дело в том, что Composer умеет автоматически загружать все необходимые файлы. Эта функциональность частично опирается на возможности автозагрузки самого PHP. Мы еще не проходили классы, но стандарт PSR-4 описывает загрузку именно классов. Грубо говоря, если правильно сконфигурировать автозагрузчик, то при добавлении нового файла с КЛАССОМ, тот будет загружен автоматически. В случае с файлами, в которых есть только НЕЙМСПЕЙС и ФУНКЦИИ, чуть сложнее. Каждый новый файл должен быть прописан внутри composer.json, только тогда он будет загружен. Вот как это выглядит:
*/

{
    "name": "hexlet/pairs",
    "autoload": {
        "files": [
            "src/Pairs.php",
            "src/Lists.php"
        ]
    }
}

/*
В composer.json добавляется секция autoload, внутрь которой добавляется еще одна секция files, которая в свою очередь содержит список файлов, которые надо загрузить. После обновления секции autoload нужно обязательно запускать команду 
*/

composer dump-autoload

/*
Она генерирует необходимый код, реализующий указанную загрузку. Затем остается только один шаг. Чтобы ваш код начал использовать все, что сделал Composer, необходимо в начале вашего кода, прописать следующую строку: 
*/

require __DIR__ . '/vendor/autoload.php';.


##########  Lock-Файл ########## 

/*
Поговорим об обновлении зависимостей. Для обновления всех зависимостей нужно выполнить команду composer update. Чтоб выполнить обновление конкретной зависимости:
*/ 

composer update vendor-name/project-name. 

/*А вот то, как будет происходить обновление, зависит от того, что написано в composer.json.

Рассмотрим доступные варианты:
*/

require {
  'package1': "*",
  'package2': "1.3.5",
  'package3': ">2.3.4",
  'package4': "~3.9",
  'package5': "^1.2"
}

/*
* означает, что можно ставить любую версию библиотеки. После выполнения команды обновления, в папке vendor окажется последняя доступная версия package1.

1.3.5 - конкретный номер. Если версия библиотеки жестко зафиксирована, никакая команда не сможет обновить ее.

Кроме этих вариантов существует масса других способов указать зависимость, часть из них вы видите в списке выше. Все они подробно описаны в официальном руководстве (https://getcomposer.org/doc/articles/versions.md), поэтому не будем повторяться. На текущем этапе для вас и так слишком много новой информации, которую нужно усвоить, а тонкости указания зависимостей не такая важная тема сейчас.

// Stability Constraints
If you are using a constraint that does not explicitly define a stability, Composer will default internally to -dev or -stable, depending on the operator(s) used. This happens transparently.

If you wish to explicitly consider only the stable release in the comparison, add the suffix -stable.

Examples:
Constraint 	Internally
1.2.3 	=1.2.3.0-stable
>1.2 	>1.2.0.0-stable
>=1.2 	>=1.2.0.0-dev
>=1.2-stable 	>=1.2.0.0-stable
<1.3 	<1.3.0.0-dev
<=1.3 	<=1.3.0.0-stable
1 - 2 	>=1.0.0.0-dev <3.0.0.0-dev
~1.3 	>=1.3.0.0-dev <2.0.0.0-dev
1.4.* 	>=1.4.0.0-dev <1.5.0.0-dev



# Lock

На предыдущем шаге каждая новая установка зависимостей приводила сначала к созданию, а потом и обновлению файла composer.lock.

Попытаемся разобраться в смысле этого файла. Как мы помним, в composer.json указываются зависимости, и мы рассмотрели то, как их устанавливать и обновлять. Но также мы помним, что у каждой зависимости могут быть свои собственные зависимости, которые также обновляются и так до бесконечности. Зависимости зависимостей называются транзитивными, и с ними не все так просто. Настолько не просто, что существует понятие dependency hell (ад зависимостей).

Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей. Предположим, что в нашем пакете есть зависимость A с зафиксированной версией 1.3.2, у которой в зависимостях стоит пакет B, причем с версией *. В такой ситуации (и без лок файла), composer install поставил бы версию зависимости A указанной версии, но того же самого нельзя сказать про пакет B. Composer поставит последнюю доступную версию из репозитория. Такое поведение не детерминировано. Если создатель обновит B так, что нарушится обратная совместимость, наш проект просто сломается, так как перестанет работать A. Фактически, если бы мы полгода не заходили в проект, а затем зашли и поставили зависимости заново (удалив папку vendor или выполнив новое клонирование), то с почти 100% вероятностью ничего не заработает. Как правило, пакеты обновляются часто, и какой-нибудь из них обязательно изменит мажорную версию за столь большой срок.

Очевидный, но не рабочий выход из данной ситуации - руками отслеживать зависимости всех зависимостей и явно прописывать их версии в composer.json. Такой способ сработает, но даже в проекте, который содержит штук 5 зависимостей, транзитивных зависимостей будет сотни! Вдумайтесь в эту цифру. Я уже не говорю про то, что пакеты обновляются и меняются. Такую ситуацию невозможно контролировать, она выльется в то, что зависимости просто перестанут обновляться.

Другой выход — требовать того, чтобы создатели всех библиотек всегда жестко указывали версии. По понятным (человеческим) причинам так не сработает, а автоматизация этого процесса привела бы к полному параличу.

И тут на сцену выходит lock файл. По сути он представляет собой автоматизированное решение первого способа. Его содержимое выглядит примерно так:
*/

{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
        "This file is @generated automatically"
    ],
    "content-hash": "ab2dac1e4b8d91d81b2295ca726e9499",
    "packages": [
        {
            "name": "tightenco/collect",
            "version": "v5.5.27",
            "source": {
                "type": "git",
                "url": "https://github.com/tightenco/collect.git",
                "reference": "07d58f7f663d5033a08541f9c481d33ad3f514a5"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/tightenco/collect/zipball/07d58f7f663d5033a08541f9c481d33ad3f514a5",
                "reference": "07d58f7f663d5033a08541f9c481d33ad3f514a5",
                "shasum": ""
            }
        }
    ]
}

/*
Первый запуск установки зависимостей формирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные и их версии. При дальнейших запусках composer install всегда ставится то, что указано в lock файле, даже если стереть папку vendor, а в Packagist добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь всегда можно быть уверенным, что если заработало сейчас, то заработает и потом (и не только у нас).

Наличие lock файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в composer.json, обновился и может быть обновлен в соответствии с тем, как указана его версия, то загрузится новая версия, а файл lock обновится автоматически. После чего нужно не забыть его залить в репозиторий.

На самом деле поведение чуть сложнее и количество различных ситуаций тоже больше, но в целом, для понимания схемы работы, достаточно описанного выше.

# Самостоятельная работа

    Склонируйте репозиторий php-package, а затем выполните внутри него команду composer update. Изучите вывод команды git diff.
    Попробуйте изменить версию любого пакета в composer.json и выполнить composer install. Доступные версии можно найти на сайте Packagist.

В результате можно увидеть что обновился composer.lock
*/



########## Scripts ##########

/*
Как правило, даже исполняемые пакеты ставятся не глобально, а локально в текущий проект. Composer складывает их в папку vendor, а если пакет содержит бинарник (то есть может выполняться как программа), то на него создается ссылка в папке ./vendor/bin. Попробуйте ответить на вопрос. Заработает ли запуск phpcs после локальной установки https://github.com/squizlabs/PHP_CodeSniffer содержащего соответствующий бинарник? Правильный ответ - нет. Путь ./vendor/bin не добавлен в $PATH и более того - не должен быть туда добавлен. Локальная установка на то и локальная, что доступна только внутри проекта. Мы можем запустить бинарник, обратившись к нему непосредственно ./vendor/bin/phpcs. Но есть способ лучше.
*/

# Scripts

/*
Секция scripts (https://getcomposer.org/doc/articles/scripts.md), внутри файла composer.json, позволяет описывать произвольные команды, которые затем можно выполнять. Ее особенностью является то, что Composer в контекст выполнения команды добавляет путь /vendor/bin в PATH (только для текущего вызова!). А папка vendor/bin это место куда Composer складывает бинарники всех локально установленных пакетов.

Рассмотрим пример. Предположим, что мы установили программу phpcs как зависимость.
*/

$ composer require phpcs

/*
Следующим шагом нужно создать в Scripts такую запись: "phpcs": "phpcs". Имя свойства используется как команда в командной строке, значение - то что реально исполнится. Теперь, если вы попробуете сделать так:
*/

$ composer run-script phpcs -- --standard=PSR2

/*
То выполнится проверка кода.

# Hooks

Есть целый набор предопределенных свойств в Scripts, которые Composer запускает автоматически в разные моменты жизни. Например, может понадобиться выполнить некоторые действия до или после установки пакета. Composer определяет для этого следующий список скриптов:

    pre-package-install
    post-package-install
    pre-package-update
    post-package-update
    pre-package-uninstall
    post-package-uninstall

Подробнее об этом можно прочитать в официальной документации (https://getcomposer.org/doc/articles/scripts.md).

# Самостоятельная работа

Попробуйте выполнить скрипт test в пакете php-package
Вы увидите, что запустились и успешно выполнились тесты.
*/



########## Исполняемые файлы в пакетах ##########

/*
Многие пакеты представляют из себя приложения командной строки, так называемые cli-утилиты, взаимодействие (запуск команд, передача аргументов и опций, вывод результатов) которых с пользователем происходит интерактивным образом через терминал. Для обеспечения такой возможности (запуск файлов из командной строки) в composer существует секция bin конфигурационного файла composer.json, например:
*/

"bin": ["bin/php-package"]

/*
Эта запись означает, что при установке пакета в операционной системе будет физически создан файл (а точнее, его особая разновидность — символическая ссылка, symlink - https://en.wikipedia.org/wiki/Symbolic_link) с именем php-package, запуск которого приведёт к запуску файла вашего проекта по адресу bin/php-package. Как можно заметить, имя ссылки задаётся именем файла (совпадает с ним). Также обратите внимание, что ссылок может быть множество (столько, сколько сами укажите в секции bin).

Месторасположение символической ссылки и способ её запуска из командной строки различаются в зависимости от способа установки пакета: глобального (с командой global: например, composer global vendor/package) или локального. Рассмотрим каждый случай отдельно.


# Глобальная установка: генерация ссылок и запуск исполняемых файлов

При глобальной установке пакета composer создаёт символические ссылки в каталоге $HOME/.composer/vendor/bin. То есть, при создании ссылок, в домашнюю директорию пользователя (от имени которого запускалась установка пакета) будет добавлен (если ещё не существует) каталог .composer/vendor/bin, куда и будут размещены ссылки. Это каталог по умолчанию, но путь к нему нам надо самостоятельно прописать в переменной окружения PATH. Как это сделать, мы проходили в соответствующем уроке. После этого мы можем запускать приложение по имени символической ссылки из командной строки, находясь в любой точке файловой системы (ведь при поиске исполняемых файлов командная оболочка ищет их последовательно по всем путям, прописанных в переменной окружения PATH).

В зависимости от версии composer директория по умолчанию может различаться. Кроме того, это значение можно конфигурировать (https://getcomposer.org/doc/articles/vendor-binaries.md#can-vendor-binaries-be-installed-somewhere-other-than-vendor-bin-). Посмотреть, в какую конкретно директорию composer складывает ссылки на исполняемые файлы можно с помощью команды composer global config bin-dir:
*/

$ composer global config bin-dir --absolute

// Посмотреть содержание переменной окружения PATH в вашей системе можно с помощью команды echo:

$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin/:/sbin:/bin:/usr/games:local/games:/home/hex/.composer/vendor/bin/

$ echo $PATH | grep '.composer/vendor/bin'
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin/:/sbin:/bin:/usr/games:local/games:/home/hex/
				.composer/vendor/bin/

# Пример

// 	Давайте создадим и опубликуем пакет, который для краткости и наглядности будет очень простым, сосотоящим всего из двух бинарников, запуск которых выводит соответственно приветствие и прощание с Хекслетом. Структура проекта:			

~/projects/smallTalkWithHexlet$ ls -al
drwxrwxr-x 2 hex hex 4096 Jul  1 04:32 .
drwxrwxr-x 3 hex hex 4096 Jul  1 04:21 ..
-rw-rw-r-- 1 hex hex  225 Jul  1 04:31 composer.json
-rw-rw-r-- 1 hex hex    0 Jul  1 04:32 sayBye.php
-rw-rw-r-- 1 hex hex    0 Jul  1 04:32 sayHi.php

// Содержимое исполняемого файла sayHi:

#!/usr/bin/env php
<?php

print_r("Hello, Hexlet!\n");

// Содержимое исполняемого файла sayBye:

#!/usr/bin/env php
<?php

print_r("Bye-bye! See you later, Hexlet!\n");


// Содержимое конфигурационнного файла composer.json:

~/projects/smallTalkWithHexlet$ cat composer.json 
{
    "name": "hex/small-talk-with-hexlet",
    "description": "Small talk with Hexlet",
    "keywords": ["hexlet", "php", "composer"],
    "license": "MIT",
    "bin": [
        "./sayHi",
        "./sayBye"
    ]
}

/*
Небольшое отступление про исполняемые файлы:

    Для возможности запуска файла из командной строки у пользователя должно быть право на выполнение (атрибут x) этого файла.
    
    Если исполняемый файл содержит код, то надо указать командной оболочке интерпретатор, который будет исполнять этот код при запуске бинарника. Это делается с помощью так называемого шебанга.
    В примере выше мы указали в качестве интерпретатора php, а путь к нему задали не абсолютный (в разных системах php может лежать по совершенно разным путям), а с помощью специальной утилиты env.

Итак, мы подготовили пакет, и после публикации, он становится доступен для установки под именем hex/small_talk_with_hexlet.

Теперь установим этот пакет в систему глобально.

Но сначала убедимся, что никаких символических ссылок в директории не существует.    
*/

$ composer global config bin-dir --absolute // =>
/*
Changed current directory to /ho,e/hex/.composer
/home/hex/.composer/vendor/bin
*/

ls -al /home/hex/.composer/vendor/bin | grep 'say'
// $
ls -al /home/hex/.composer/vendor/bin // =>
/*
total 8
drwxrwxr-x 2 hex hex 4096 Jul  3 23:32 .
drwxrwxr-x 3 hex hex 4096 Jul  3 23:21 ..


Здесь с помощью фильтра grep мы попытались найти файлы, содержащие в своём имени (как наши ссылки в секции bin) строчку "say". Но поиск не дал результатов, потому что таких файлов (до установки пакета) нет.

Далее глобально устанавливаем пакет в систему:
*/

composer global require hex/small-talk-with-hexlet

// Теперь снова проверим с помощью grep директорию установки исполняемых файлов

ls -al /home/hex/.composer/vendor/bin | grep 'say' // =>
/*
total 8
drwxrwxr-x 2 hex hex 4096 Jul  3 23:32 .
drwxrwxr-x 3 hex hex 4096 Jul  3 23:21 ..
lrwxrwrwx  1 hex hex   36 Jul  4 02:05 sayBay -> ../hex/small-talk-with-hexlet/sayBay
lrwxrwrwx  1 hex hex   36 Jul  4 02:05 sayBay -> ../hex/small-talk-with-hexlet/sayHi

// Как и ожидалось, в этом каталоге лежат символические ссылки (об этом свидетельствует первый символ l, определяющий тип файла в строке атрибутов файла lrwxrwxrwx), которые мы можем запускать из любой точки файловой системы:
*/

$sayHi // Hello, Hexlet!
$sayBy // => Bye-bye! See you later, Hexlet!

cd /media/
/media$ sayHi // => Hello, Hexlet!
/media$ sayBy // => Bye-bye! See you later, Hexlet!

// Из примера видно, что мы можем успешно запускать одни и те же команды из разных директорий. Почему так происходит подробно обсуждалось выше.

# Что происходит при локальной установке

/*
В подавляющем большинстве случаев для целей разработки пакеты устанавливаются не глобально, а локально. При такой установке они "привязываются" к конкретному проекту и размещаются внутри его каталога по пути ./vendor/. При этом ссылки на исполняемые файлы устанавливаемых пакетов composer размещает в каталоге ./vendor/bin.

Ссылки на исполняемые файлы локально установленных пакетов "заточены" на использование их в скриптах (секция scripts конфигурационного файла composer.json), для чего существует особенный синтаксис. Эту тему мы проходили в уроке, посвящённом скриптам.

Естественно, к символическим ссылкам можно также обратиться напрямую, указав нужный путь. Давайте рассмотрим это на примере, подключив к нашему разрабатываемому проекту small_talk_with_hexlet пакет PHP_CodeSniffer (https://packagist.org/packages/squizlabs/php_codesniffer):
*/

~/projects/smallTalkWithHexlet$ composer require --dev "squizlabs/php_codesniffer=*"

/*
Если в корневом каталоге проекта установить какой-либо пакет с флагом --dev (composer require --dev some_package) — то он автоматически добавится в зависимости проекта: в раздел require-dev файла composer.json. Этой возможностью мы и воспользовались.
*/

~/projects/smallTalkWithHexlet$ composer require --dev "squizlabs/php_codesniffer=*"

/*
require-dev: {
	"squizlabs/php_codesniffer": "*"
}
*/

/*
Как и ожидалось, появился каталог ./vendor, в котором лежит код подключенного пакета, а также других пакетов, от которых он, в свою очередь, зависит.

Узнать место, где composer складывает ссылки на исполняемые файлы локально подключаемых пакетов, позволяет команда composer config bin-dir (обратите внимание, что здесь нет команды global). В нашем случае это каталог ./vendor/bin, заглянем в него:
*/
~/projects/smallTalkWithHexlet$ composer config bin-dir --absolute /home/hex/projects/smallTalkWithHexlet/vendor/bin

~/projects/smallTalkWithHexlet$  ls -al vendor/bin // =>
/*
total 8
drwxrwxr-x 2 hex hex 4096 Jul  4 23:32 .
drwxrwxr-x 5 hex hex 4096 Jul  4 23:21 ..
lrwxrwrwx  1 hex hex   43 Jul  4 02:46 phpcbf -> ..squizlabs/php_codesniffer/scripts/phpcbf
lrwxrwrwx  1 hex hex   43 Jul  4 02:46 phpcs -> ..squizlabs/php_codesniffer/scripts/phpcs

// Как видно, при установке PHP_CodeSniffer добавилось два бинарника для запуска разных программ. Давайте запустим phpcs (т.н. линтер — утилита, отвечающая за проверку кода на соответствие стандартам):
*/

./vendor/bin/phpcs --standart=PSR2 sayHi Say Bye 

phpvs // => command not found


/*

Программа отработала корректно и "молча" (без дополнительного вывода отчета об ошибках), потому что в наших скромных файлах не было никаких нарушений стиля кодирования.

Затем была попытка запустить бинарник из командной строки только по имени, но она привела к неудаче — bash: phpcs: command not found — командная оболочка просто не нашла его (в отличие от того, как это было бы при глобальной установке).

# Заключение

В этом уроке мы рассмотрели как общие принципы, так и отдельные нюансы работы Composer с исполняемыми файлами проекта. Важно отметить, что эти принципы характерны для большинства других пакетных менеджеров из разных языков (например, node package manager в javascript). Поэтому, если в будущем вам придётся столкнуться с чем-то из них, то это не должно вызвать затруднений.
*/


{
    "autoload": {
        "psr-4": {
            "src\\": "Filemanager";  
        }
    }
}

# https://phpprofi.ru/blogs/post/52

composer self-update // обновление composer
composer dump-autoload --optimize // обновить загрузчик, т. к. появились новые классы без установки или обновления пакетов . Ключ --optimize преобразует PSR-0 в автозагрузку как для classmap, чтобы автозагрузчик был наиболее быстрым. Это настоятельно рекомендуется для production (вы можете получить 20% прирост).
