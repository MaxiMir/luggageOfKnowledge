<?
	 
	 ####################### Laravel #######################
	 
	 
	 # >>>>>>>>>>>> О курсе <<<<<<<<<<< #

/**
	 Ларавел – популярный веб-фреймворк на PHP, предназначенный для быстрой разработки сайтов. Он сочетает в себе большие возможности сложных фреймворков и простоту написания кода с минимум конфигурирования.
	 
	 В этом курсе, шаг за шагом создается проект под названием hexlet-laravel-blog. Это простой блог, в который можно добавлять статьи и оставлять комментарии.
	 
	 Во время создания мы рассмотрим следующие темы:
	 
	 > Ресурсный (RESTLike) роутинг. Создание CRUD, валидация данных.
	 > Шаблонизатор Blade. Лейаутинг
	 > Управление приложением из командной строки. Tinker.
	 > Интеграционное тестирование, фабрики.
	 > ORM. Создание сущностей. Связи.
	 > Интернационализация (I18n). Правильная работа с текстами.
	 Практика этого курса выполняется в среде Хекслета, но для полноценного погружения, крайне рекомендуется повторять все действия на своем компьютере. Для этого убедитесь что в вашей системе установлен PHP (>= 7.1.3) и Composer.
	 
	 Этот курс сильно опирается на знания, полученные в курсе "PHP: Веб-Разработка". Если вы не знакомы с маршрутами, CRUD, MVC и шаблонизацией, то обязательно пройдите его перед этим курсом

	# Дополнительные материалы
	Homestead (Разработка на Ларавел под Windows) https://laravel.com/docs/6.x/homestead
 */
	 
	 

	 
	 # >>>>>>>>>>>> Hello World <<<<<<<<<<< #
	 
/**
	Проекты на Ларавел создаются из командной строки. Проще всего создать новый проект с помощью команды composer create-project (https://getcomposer.org/doc/03-cli.md#create-project):
	 
	# Перейдите в домашнюю директорию и выполните команду
	$ composer create-project --prefer-dist laravel/laravel hexlet-laravel-blog
	
	Эта команда создаст приложение в директории hexlet-laravel-blog и установит все зависимости, необходимые для работы Ларавел.

	После завершения установки, перейдите в директорию с проектом:
	
	$ cd hexlet-laravel-blog
	
	Ларавел управляется утилитой artisan, которая находится в корне проекта. Она включает в себя десятки команд, упрощающих процесс разработки. Одна из них – это запуск сайта в режиме разработки:
	
	$ php artisan serve
	Laravel development server started: <http://127.0.0.1:8000>
	
	Эта команда запускает встроенный в PHP веб-сервер и настраивает его для работы с Ларавел. Чтобы увидеть сайт, откройте браузер и загрузите http://127.0.0.1:8000. Вы увидите приветственную страницу фреймворка.
	
	Для остановки сервера переключитесь на терминал в котором он запущен и наберите CTRL+C.

	Эта страница нужна только для проверки того, что все работает. Ее код можно будет смело удалить.
*/

	#@ Artisan
	
/**
	Утилита artisan является центральным пультом управления фреймворка. Через artisan мы будем автоматически генерировать код, управлять базой данных, запускать сервер, консоль и многое другое. Чтобы увидеть список всех команд, запустите artisan без аргументов:
	
	$ php artisan
	
	Этот список команд может расширяться как нами, так и разработчиками расширений. На гитхабе можно найти множество полезных дополнений на все случаи жизни.

	В последующих уроках, мы постоянно будет возвращаться к этой утилите и изучать ее возможности. А пока мы с ними не знакомы, попробуйте поиграться с командой inspire:
	
	$ php artisan inspire
	Computer science is no more about computers than astronomy is about telescopes. - Edsger Dijkstra
	$ php artisan inspire
	Simplicity is an acquired taste. - Katharine Gerould
*/

	#@ Структура директорий

/**
	 Современные фреймворки, предназначены для разработки сайтов любых размеров. С одной стороны это хорошо, больше возможностей, с другой, очень легко потеряться в круговороте фич, особенно если это ваш первый фреймворк. Помимо большого числа понятий самого Ларавела, внутри него встроена поддержка фронтенда (js, фронтенд фреймворки), работа со статикой (js, css, media), разные виды кеширования, работа с очередьми, тестирование, логгирование и многое другое.
	 
	 Это не значит что придется использовать сразу все, но, иметь общее представление об этих возможностях нужно. Хотя бы на уровне понимания структуры директорий. Ниже приведена таблица директорий с описанием их содержимого. В этом описании будут встречаться названия, с которыми вы, возможно, не знакомы. Позже мы их разберем.

	 Директория	Описание
	 app			Код приложения. Именно здесь будет расположено большая часть того что пишется разработчиками.
	 
	 bootstrap	Содержит файл app.php, который инициализирует фрейморк. Кроме того, здесь располагается кеш кода, ускоряющий запуск сайта.
	 
	 config	Конфигурация приложения. Параметры доступа к базе данных, настройка отправки почты, логгирования, кеширования, все это происходит здесь
	 
	 database	Ресурсы необходимые для работы с базой данных: миграции, фабрики, сиды.
	 
	 public	Содержит файл index.php, который является входной точкой на сайт. Именно в него попадают все запросы. Еще здесь содержатся подготовленные к раздаче статические файлы: js, css и images
	 
	 resources	Содержит шаблоны и исходные фронтенд файлы, такие как scss, javasript
	 
	 routes	Роутинг приложения
	 
	 storage	Служебная директория, содержит сессионные файлы, логи, файловые кеши, откомпилированные шаблоны (для ускорения)
	 
	 tests	Тесты приложения
	 
	 vendor	Сюда Composer ставит зависимости

	#@ Дополнительные материалы
	Репозиторий готового проекта HexletLaravelBlog https://github.com/hexlet-components/laravel-blog
*/
	 


	 
	 # >>>>>>>>>>>> Запрос-Ответ <<<<<<<<<<< #

/**
	Как и любой серверный веб-фреймворк, Ларавел построен вокруг HTTP. Он принимает запросы, на основе которых формируют и отдает http-ответы. Ларавел берет на себя всю грязную работу: разбор запроса, выбор правильного обработчика, отправку ответа клиенту. Программисту остается выполнить только самый необходимый минимум для добавления новых страниц на сайте.

	В этот минимум входят три вещи:
	> Маршрут. Определяет адрес конкретной страницы или набора страниц на сайте. Маршрут связывает эти адреса с конкретным обработчиком, который будет вызван при запросе этих страниц.

	> Контроллер. Слой кода, в котором расположены обработчики страниц сайта. Они анализируют запрос (если нужно) и формируют ответ, который фреймворк отправляет пользователю.

	> Шаблон. Специальный файл, который используется для формирования HTTP-ответа.

	Маршруты любого проекта на Ларавел хранятся в директории routes. В зависимости от типа маршрута, они могут находиться в разных файлах. Сейчас нас интересует только web.php, этот файл предназначен для описания маршрутов обычных страниц сайта.

	Изначально этот файл содержит только один маршрут, соответствующий главной странице /.
*/
	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
/**
	Функция Route::get($pattern, $action) задает маршрут. Первым параметром она принимает адрес запрашиваемой страницы (или паттерн описывающий группу страниц). В коде выше это адрес главной страницы сайта. Вторым параметром передается обработчик (относится к слою контроллер). Обработчики запросов в Ларавел называют экшенами (action, хотя по-русски это "действие", но так не говорят).

	Кроме метода get, в роутере определены методы для всех глаголов HTTP. В зависимости от глагола HTTP одни и те же адреса могут вести на разные обработчики. Выбор правильного глагола для маршрута определяется его семантикой.
*/
	 Route::post('/posts', function () {
		  // Логика создания поста
	 });

	// В самом простом случае, экшену достаточно вернуть строку, которая станет телом http-ответа. Например если переписать маршрут так:
	 
	 Route::get('/', function () {
		  return 'hello, world!';
	 });
	 
/**
	И обновить страницу, то на экране отобразится фраза hello, world!.
	
	И обновить страницу, то на экране отобразится фраза hello, world!.
	 
	 Однако, в исходном варианте возвращается результат вызова view('welcome'). view($templateName) – глобальная функция, которая принимает на вход имя шаблона и возвращает его содержимое в виде строки. Затем это содержимое возвращается из экшена. Такой подход позволяет отделить обработку запроса, от формирования ответа (в данном случае HTML). Это часть архитектурного подхода MVC.
	 
	 Сам шаблон доступен по пути resources/views/welcome.blade.php. Функция view автоматически подставляет нужные директории, поэтому достаточно указывать имя шаблона. Попробуйте открыть этот шаблон и посмотреть что находится внутри него. Это тот самый HTML, который отображается при заходе на главную страницу.
	 
	 Создадим новую страницу /about. Для этого добавим маршрут, экшен и шаблон:
	 
	 Добавьте в файл routes/web.php новый маршрут и экшен:
*/
	 Route::get('/about', function () {
		  return view('about');
	 });

/**
	 Создайте шаблон resources/views/about.blade.php и добавьте туда следующий HTML:

	 <h1>О блоге</h1>
	 <p>Эксперименты с Ларавелем на Хекслете</p>
	 

	 Теперь если открыть страницу /about то отобразится вновь добавленная страница.

	# Дополнительные материалы
	Логгирование https://laravel.com/docs/6.x/logging#writing-log-messages
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Шаблонизатор Blade <<<<<<<<<<< #
/**
	 Мы знаем из курса по веб-разработке что PHP это не только язык программирования, но и шаблонизатор. Он позволяет мешать PHP код и HTML в одном файле формируя из этого общий ответ в консоль или браузер пользователя. Это одна из важных причин его популярности, но за все приходится платить.
	 
	 Когда создавался PHP, интернет только начинал свой путь. Разработчики PHP ,в то время, о многих вещах либо не знали либо не подумали. Это привело к серьезным проблемам, с которыми придется жить всегда, потому что никто не будет ломать обратную совместимость. К таким проблемам относится безопасность. Обычные PHP шаблоны, по умолчанию, не безопасны. Любой текст из кода вставляется как есть. Это значит, что если специально об этом не подумать, то сайт станет подвержен XSS-атаке. Она выполняется через внедрение JS кода на страницу, который начинает работать, а не отображаться как текст:
	 
	 <!-- Можно передать url.../?query=<script>alert('boom!')</script> -->
	 <!-- При выводе вместо PHP кода подставится тег script который будет выполнен браузером -->
	 <p><?= $_GET['query'] ?></p>
	 
	 Есть способы избежать этого, но все они требуют постоянного внимания. С точки зрения организации безопасной среды это в корне неверно и гарантированно будет приводить к ошибкам. Должно быть ровно наборот: по умолчанию все безопасно и только там где нужно, поведение меняется.
	 
	 Можно ли как-то изменить эту ситуацию? Да, первый путь это изменение самого языка. Этот путь, которым никто никогда не пойдет. Такое изменение гарантированно сломает все существующие сайты. Другой путь – создание шаблонизаторов написанных на PHP. Именно так и делают уже очень много лет.
	 
	 В итоге одна из тех вещей которая помогла PHP взлететь, теперь только мешает и создает у многих несерьезное отношение к языку. До сих пор можно встретить людей которые говорят что PHP это не язык программирования, а шаблонизатор.
	 
	 За время существования PHP были созданы десятки только популярных шаблонизаторов и сотни тех что не взлетели. Со временем они развивались и становились лучше. Когда-то популярный Smarty сейчас уже никто не вспомнит. А вот Blade входящий в состав Laravel знают почти все.
	 
	 Это не отменяет того факта, что до сих пор огромное число сайтов и цмс используют встроенную шаблонизацию PHP. Как по историческим причинам, так и из-за общей низкой культуры разработки и кустарного обучения программированию. Стоит ли говорить о том, что большинство этих сайтов легко взломать.
	 
	 Посмотрите на пример простого Blade-шаблона:
*/
?>
	 
	 <h1>{{ $object->title }}</h1>
	 <p>{{ $object->description }}</p>
	 <pre>
		  {{ $object->code }}
	 </pre>
	 <p>Question submitted at: {{ $object->created_at }}</p>

<?
/**
	 На первый взгляд похоже. Шаблон выглядит как HTML с вкраплениями кода. В отличии от самого PHP в Blade, вставка любого значения выполняется в двойных фигурных скобках {{ ... }}. Это очень похоже на интерполяцию, если сам шаблон рассматривать как строку. За сценой, Blade выполняет дополнительную обработку и экранирует любые данные, вставленные таким образом. Это значит что нам больше не нужно прилагать усилия к обеспечению безопасности в шаблонах.
	 
	 Откуда в этом шаблоне взялся $object? Вспомним код обработчика:
*/
	 
	 Route::get('/about', function () {
		  return view('about');
	 });

/**
	 Такой вариант использования шаблонов подходит только для простых информационных страниц. В которых нет динамического содержимого (получаемого, например, из базы). В большинстве же реальных ситуаций, контроллер получает какие-то данные, обрабатывает их если нужно и передает в шаблон. Делается это крайне просто, достаточно передать ассоциативный массив с данными вторым параметром функции view. В шаблоне каждое значение этого массива становится доступно под именем переменной соответствующей ключу массива:
*/
	 // routes/web.php
	 Route::get('/about', function () {
		  $tags = ['обучение', 'программирование', 'php', 'oop'];
		  return view('about', ['tags' => $tags]);
	 });

?>

	<!-- resources/views/about.blade.php -->
	 <h1>О блоге</h1>
	 <p>Эксперименты с Ларавелем на Хекслете</p>
	 <p>{{ implode(', ', $tags) }}</p>
	 
<?
/*
	 Как видно из примера выше, двойные фигурные скобки позволяют выполнять произвольный PHP код. Главное не злоупотреблять. В основном данные должны быть подготовлены в обработчике до того как они попадут шаблон. Тут стоит сказать отдельно, что PHP, как шаблонизатор, давал слишком много свободы, которая очень влияла на качество кода. При таком использовании PHP, в шаблоне нередко выполнялись SQL-запросы, HTTP-вызовы и тому подобные вещи. По понятным причинам этого делать ни в коем случае нельзя. Шаблоны про отображение, а не про логику работы.
	 
	 Кроме подстановки, в Blade есть директивы. С их помощью реализованы все управляющие конструкции, такие как циклы, условия и другое:
*/
?>
	 @if (count($records) === 1)
		  I have one record!
	 @endif
	 
	 @foreach ($users as $user)
		  <p>This is user {{ $user->id }}</p>
	 @endforeach
<?
/**
	Директивы всегда начинаются со знака @ и часто (но не всегда) имеют закрывающую часть. Синтаксис директив содержит меньше деталей и он проще чем синтаксис чистого PHP. С его помощью можно делать практически все тоже самое что и в самом PHP. Более того, можно сказать что Blade, фактически, является самостоятельным языком программирования. Но лучше про это сразу забыть)

	 Blade имеет встроенную поддержку разных элементов, полезных в шаблонах. То что в PHP шаблонах нужно делать "руками", тут есть сразу. К таким возможностям, например, относится определение первой и последней итерации в цикле:
*/
?>

@foreach ($users as $user)
    <!-- $loop специальная переменная доступная внутри цикла -->
    @if ($loop->first)
        This is the first iteration.
    @endif

    @if ($loop->last)
        This is the last iteration.
    @endif

    <p>This is user {{ $user->id }}</p>
@endforeach

<?
/**
	Кроме указанных структур, директивы Blade поддерживают цикл for, switch isset и некоторые другие, более специфичные.
	
	# Дополнительные материалы
	Blade https://laravel.com/docs/6.x/blade
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Макеты (Layout) <<<<<<<<<<< #
	 
/**
	Каждая страница любого сайта, содержит свое собственное содержимое и общие части, такие как футер или боковое меню. Существует два подхода по работе с этими общими частями.
*/

	#@ Включение
	
/**
	До эры фреймворков, фактически, был ровно один способ выделять общие части. Он сводился к созданию двух шаблонов: хедера (шапка сайта) и футера (подвал). Затем, эти шаблоны включались во всех остальных шаблонах, отвечающих за основную часть страницы. Выглядело это так:
*/
?>
	 
	 <?= include('header.php'); ?>
	 
		  <div id="page-content">
				<!-- Тут основная часть -->
		  </div>
	 
	 <?= include('footer.php'); ?>


<?

/**
	 Такой подход все еще популярен в самописных решениях и в популярных CMS. Где-то в силу исторических причин, где-то потому, что его очень просто понять и начать использовать.
	 
	 С другой стороны, у такого подхода слишком много недостатков, из-за которых фреймворки отказались от него:

	> Футер и Хедер хранят куски кода, которые сами по себе не являются правильным HTML. В хедере открывающие теги, в футере закрывающие. Из-за этого крайне легко ошибиться и потом долго искать незакрытый тег.

	> Страница разбитая на хедер и футер не дает увидеть всю картину целиком. Придется скакать туда сюда для понимания того, что из себя представляет страница.

	> Появляется очень много дублирования из-за постоянных вставок хедера и футера

	> Все сильно усложняется, если хедеры и футеры могут быть разными

	> Невозможно обработать ситуацию, когда страницы имеют более сложное разбиение и включение хедера и футера не поможет.
*/

	#@ Макеты
/**
	Это совершенно другой подход при работе с шаблонами. Он строится не от шаблона конкретного обработчика (экшена), а от макета. Макет – это базовая структура страницы, в которую вставляются данные, сгенерированные конкретным обработчиком. Для работы макетов недостаточно стандартных PHP файлов с HTML разметкой. Разработчикам шаблонизаторов приходится придумывать специальные маркеры, которые указывают куда и какой блок можно поместить.

	В Laravel используется шаблонизатор Blade. Фактически, Blade, это свой собственный язык, с помощью которого создаются шаблоны. Blade-специфичные команды в шаблонах начинаются со знака @ и называются директивами. Большинство директив похожи на вызов функций, в которые передаются аргументы.
*/
?>
	 <!-- Хранится в resources/views/layouts/app.blade.php -->
	 <html>
		  <head>
				<title>Hexlet Blog - @yield('title')</title>
		  </head>
		  <body>
				<div class="container">
					 @yield('content')
				</div>
		  </body>
	 </html>
	 
<?
/**
	В макете выше, используется директива @yield. Она указывает на то, куда будет вставлен контент конкретного обработчика.

	 В шаблоне самого обработчика, используется директива @section, которая определяет блок контента. Каждый такой блок имеет собственное имя, что позволяет одновременно делать вставку сразу множества блоков. Это особенно удобно для сложных макетов, где кроме самого контента, есть и другие блоки, специфичные для конкретных страниц.
*/
?>
	 
	 <!-- Хранится в resources/views/about.blade.php -->

	 @extends('layouts.app')

	 <!-- Секция, содержимое которой обычный текст. -->
	 @section('title', 'О блоге')

	 <!-- Секция, содержащая HTML блок. Имеет открывающую и закрывающую часть. -->
	 @section('content')
	 	<h1>О блоге</h1>
	 	<p>Эксперименты с Ларавелем на Хекслете</p>
	 @endsection

<?
/**
	 Директива @extends указывает на макет, внутрь которого должны попасть данные из текущего шаблона. В эту директиву передается путь относительно директории resources/views. Обратите внимание что вместо / используется точка.
	 
	 Далее идут секции. У каждой секции есть имя, благодаря которому можно точечно управлять местом ее отображения. Выше создаются две секции content и title. Одна из них отображается в теге <title>, другая внутри <body> и является центральной контентной частью страницы.
	 
	 Имена выбираются произвольно. Количество секций не ограничено. Количество макетов тоже.
	 
	 Несмотря на наличие макетов, иногда бывает полезно иметь общий шаблон, который вставляется в конкретных местах. Blade позволяет создавать и включать такие шаблоны с помощью директивы @include:
*/
?>
	 <html>
		  <head>
				<title>Hexlet Blog - @yield('title')</title>
				@include('shared.metatags')
		  </head>
		  <body>
				<div class="container">
					 @yield('content')
				</div>
		  </body>
	 </html>

<?
/*
	Код подобный тому что выше, часто встречается в тех проектах где несколько макетов. Как правило, их общие части выносят в обшие шаблоны, которые затем включаются через @include. Хорошей практикой считается помещать общие шаблоны в директорию resources/views/shared. Так легче понять какие шаблоны можно переиспользовать.

	# Самостоятельная работа

	Создайте макет resources/views/layouts/app.blade.php со следующим содержимым:
*/
?>
	 <!doctype html>
	 <html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
		  <head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">
				<title>Hexlet Blog - @yield('title')</title>
				<meta name="csrf-token" content="{{ csrf_token() }}">
				<meta name="csrf-param" content="_token" />
				<link href="{{ asset('css/app.css') }}" rel="stylesheet">
				<script src="{{ asset('js/app.js') }}"></script>
		  </head>
		  <body>
				<div class="container mt-4">
					 <h1>@yield('header')</h1>
					 <div>
						  @yield('content')
					 </div>
				</div>
		  </body>
	 </html>

<?
/*
	 Переделайте шаблон about.blade.php так как показано в уроке (возможно понадобится почистить кеши php artisan view:clear).
	 
	 Прочитайте про CSRF.
	 
	 Зафиксируйте изменения в git (Дальше этот пункт повторяться не будет. Не забывайте фиксировать любые изменения в git)


	# Дополнительные материалы
	Документация Blade https://laravel.com/docs/6.x/blade#template-inheritance
*/

/*@@@
	resources/views/layouts/app.blade.php:
	Добавьте вывод двух секций:
	 Секция header, содержимое которой выводится в заголовке <h1>
	 Секция content, содержимое которой выводится под заголовком в <div>
 
	resources/views/about.blade.php:
	 Подключите макет layouts/app
	 Добавьте в секцию header текст "О блоге"
	 Добавьте в секцию content:

	<p>Эксперименты с Ларавелем на Хекслете</p>

	resources/views/articles.blade.php:
	 Подключите макет layouts/app
	 Добавьте в секцию header текст "Статьи"
	 Добавьте в секцию content:
	 
	 <p>Тут будут статьи</p>
*/

# FILE: resources/views/layouts/app.blade.php:
?>
<!doctype html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
	 <head>
		  <meta charset="utf-8">
		  <meta name="viewport" content="width=device-width, initial-scale=1">
		  <title>Laravel</title>
	 </head>
	 <body>
		  <a href="/">Home</a>
		  <a href="/about">About</a>
		  <a href="/articles">Articles</a>
		  
		  <!-- BEGIN (write your solution here) -->
		  <h1>@yield('header')</h1>
		  <div>
				@yield('content')
		  </div>
		  <!-- END -->
	 </body>
</html>



<?
# FILE: resources/views/about.blade.php:
?>
	 @extends('layouts.app')
 
	 @section('header', 'О блоге')

	 @section('content', '<p>Эксперименты с Ларавелем на Хекслете</p>')

<?
# FILE: resources/views/articles.blade.php:
?>

	 @extends('layouts.app')
	 
	 @section('header', 'Статьи')
	 
	 @section('content', '<p>Тут будут статьи</p>')

<?



	# >>>>>>>>>>>> Консоль (Tinker) <<<<<<<<<<< #
	
/**
	В PHP встроен REPL, который позволяет быстро поэкспериментировать с языком.
	
	$ php -a
	Interactive shell
	
	
	# Некоторые используют его как калькулятор
	php > echo 3 ** 2;
	9
	
	 # Можно вызывать любые функции и смотреть что получится
	 php > echo array_sum([1, 3, 2]);
	 6
	 php >
	
	
	 Для разработчиков, которые никогда не имели с ним дело, может показаться что REPL это игрушка, но это не так. Во многих языках, программисты значительное время проводят в REPL постоянно исследуя код. В мире Lisp языков даже есть понятие REPL-driven development.
	 
	 Сейчас ситуация в PHP стала меняться. В первую очередь благодаря PsySH https://psysh.org/. Это тоже REPL для PHP, но в отличие от встроенного, он значительно мощнее и ориентирован на удобство отладки и исследования (интроспекции) кода. Одна из приятных особенностей этого REPL, в том, что не нужно ставить точку с запятой в конце выражений и результат любого выражения автоматически выводится на экран. А еще цветной вывод.
	
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> 3 ** 2
	=> 9
	
	>>> array_sum([1, 3, 2])
	=> 6
	
	 PsySH умеет конфигурироваться, что позволяет при его старте прогружать в память любой код на PHP. Благодаря этому, разработчики Laravel смогли создать REPL, который позволяет экспериментировать не только с обычными функциями, но и со всем фреймворком. Этот REPL называется Tinker. Начиная с текущего момента и на протяжении всего курса, мы постоянно будем использовать Tinker для проверки работы любых аспектов фреймворка.

	Запускается Tinker как команда Artisan:
	
	$ php artisan tinker
	
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> array_reverse([1, 2, 3, 4])
	=> [
		  4,
		  3,
		  2,
		  1,
	]
	
	Из приветствия видно что мы имеем дело с PsySH. Здесь можно работать как с самим PHP, так и с Laravel. В последний включено множество функций, не имеющих прямого отношения к вебу, но упрощающих работу:

	>>> Str::ascii('трансляция в аски')
	=> "translyatsiya v aski"
	
	>>> last([3, 2, 8])
	=> 8
	
	Tinker и Psysh добавляют несколько полезных функций от себя. Эти функции позволяют посмотреть историю команд, документацию по функциям, увидеть их содержимое и многое другое. Ниже несколько примеров:
	
	>>> show last # посмотреть определение функции
	> 726|     function last($array)
     727|     {
     728|         return end($array);
     729|     }
	
	>>> history # история
	75: Str::ascii('трансляция в аски')
	76: last([3, 2, 8])
	77: show last
	
	>>> dd([1, 2, [3, 2, ['show', ['one' => 'two']]]]) # вывести красиво данные
	 array:3 [
		0 => 1
		1 => 2
		2 => array:3 [
		  0 => 3
		  1 => 2
		  2 => array:2 [
			 0 => "show"
			 1 => array:1 [
				"one" => "two"
			 ]
		  ]
		]
		]
	
	>>> doc head # посмотреть документацию по функции
	function head($array)
	
	Description:
  		Get the first element of an array. Useful for method chaining.
	
	Param:
  		array  $array

	Return:
  		mixed
	
	Самое интересное при работе с Tinker начнется позже, когда мы познакомимся с ORM и тестами.
*/




	# >>>>>>>>>>>> Конфигурация <<<<<<<<<<< #
	
	#@ Переменные окружения

/**
	Любое нетривиальное приложение, взаимодействует с внешним миром: ходит в базу данных, обращается к внешним сервисам (например платежным), отправляет письма и загружает друзей из, например, фейсбука. Для подавляющего большинства этих операций необходимы специальные параметры: ключи, пароли, адреса серверов и порты. Все эти параметры называются конфигурацией приложения.

	 Возникает вопрос, где хранить конфигурацию? Самый простой и самый неправильный ответ – прямо в приложении. Проблем у такого подхода две:

	> Часть этих данных секретная. Хранить их в репозитории просто нельзя из-за возможных проблем с безопасностью. Любой кто имеет доступ к репозиторию сможет получить любой доступ. Правда еще есть вариант с шифрованием, но он выходит за рамки обсуждаемой темы (для интересующихся Ansible Vault https://docs.ansible.com/ansible/latest/user_guide/vault.html).

	> При изменении этих параметров придется заново "деплоить" (то есть выкладывать) сайт, хотя, по сути, ничего не изменилось, нет новых фич, нет исправления старых багов. Просто изменилась конфигурация.


	В 2011 году, разработчики компании heroku, выложили в интернете сайт, который называется 12factors https://12factor.net/ru/. Он описывает методологию для создания веб-приложений, которая уменьшает затраты на установку и настройку приложения, повышает переносимость между средами исполнения, позволяет масштабироваться без существенных изменений в инструментах, архитектуре и практике разработки. С тех пор, эта методолгия, фактически, стала стандартом в индустрии.

	 Я крайне рекомендую прочитать этот документ целиком, но прямо сейчас нас интересует один его аспект – конфигурация. 12факторов требуют строгого разделения конфигурации и кода. Конфигурация может меняться между развертываниями (локальное окружение разработчика, продакшен, среда для тестирования), код – нет. Конфигурация должна передавать в приложение снаружи и единственный универсальный способ сделать это, использовать переменные окружения.

	Laravel имеет большое число настроек для разных подсистем, которые задаются через переменные окружения. Например вот как можно запустить фреймворк в режиме отладки:


	# при запуске устанавливается переменная окружения APP_DEBUG со значением true
	$ APP_DEBUG=true php artisan serve

	 Таких переменных довольно много, они отвечают за настройку кеширования, за отправку почты и многое другое. Для простоты конфигурации, Laravel использует библиотеку phpdotenv https://github.com/vlucas/phpdotenv, которая позволяет загружать переменные не только из окружения, но и из специального файла .env находящегося в корне проекта. Этот файл не хранится в репозитории, так как он специфичен для окружения, в котором идет запуск. Вот его небольшой кусок:

	 APP_NAME=Laravel
	 APP_ENV=local
	 APP_KEY=base64:MUD1rJ2GkEp7P5PdlsGe5MGfdwxu0v08IVDLodGW3zE=
	 APP_DEBUG=true
	 APP_URL=http://localhost
	 
	 LOG_CHANNEL=stack
	 
	 BROADCAST_DRIVER=log
	 CACHE_DRIVER=file
	 QUEUE_CONNECTION=sync
	 SESSION_DRIVER=file
	 SESSION_LIFETIME=120

	Это обычный текстовый файл, в каждой строке которого находится имя переменной и ее значение. Laravel автоматически подгружает его и затем, эти переменные используются в коде (если они там используются конечно).

	Возможно у вас возникает вопрос, каким образом формируется этот файл? После генерации проекта, Laravel создает файл .env.example, который хранится в репозитории, а в момент выполнения команды composer install он копируется в файл .env. Благодаря этому проект на Laravel старутет из коробки без необходимости дополнительной конфигурации. По крайней мере в режиме разработки. А вот для конфигурации продакшен окружения одним фреймворком не обойтись. Здесь нужно применять либо системы управления конфигурацией, такие как ansible https://www.ansible.com/, либо использовать системы оркестрации, например, kubernetes https://kubernetes.io/, либо системы подобные vault https://www.vaultproject.io/
*/

	#@ База данных

/**
	По умолчанию, ларавел, хочет взаимодействовать с MySQL, одной из самых популярных баз данных используемых в веб-разработке (наряду с PostgreSQL). Мы же поменяем базу данных и запустим наше приложение с SQLite. SQLite крайне проста в первоначальной настройке и запуске, это позволит нам прямо сейчас не отвлекаться на борьбу с операционной системой.

	 Учтите что SQLite нельзя использовать в конкуретной среде, то есть там где много пользователей. Она на это не рассчитана. Основное применение SQLite это мобильные приложения, настольные приложения, например браузеры. Еще SQLite используют как базу данных для прогона тестов или запуска веб-сайта в режиме разработки. Последнее это наш случай.
	 
	SQLite хранит данные в обычном файле. Создадим его:

	$ touch database/database.sqlite

	 Этот файл не может лежать в репозитории так как он меняется при любых изменениях данных. Laravel уже побеспокоился об этом и добавил все файлы с расширением sqlite в .gitignore.
	 
	 Теперь необходимо настроить приложение так, чтобы оно начало использовать SQLite. Для этого откройте .env и установите там тип соединения:

	DB_CONNECTION=sqlite


	 Кроме того, нужно закомментировать или удалить переменную окружения DB_DATABASE. В таком случае Laravel попробует искать файл с базой данных по пути database/database.sqlite.
	 
	 Проверить что подключение работает можно в репле:

	 $ php artisan tinker
	 Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman

	 >>> DB::select('select 1')
	 # Если нет ошибок, значит все хорошо



	 # Самостоятельная работа
	 1. Изучите файл .env.example.
	 2. Найдите в composer.json код, который отвечает за копирование .env.example в .env.
	 3. Настройте подключение к SQLite и проверьте что оно работает. Возможно вам понадобится доставить в систему пакет, который подключает sqlite3 к PHP. Точнее имя пакета зависит от системы и версии PHP.

	 # Дополнительные материалы
	 Конфигурация Laravel https://laravel.com/docs/6.x/configuration


	? Если в приложении поменялся пароль к базе данных. Что нужно сделать чтобы приложение начало работать с новым паролем, учитывая что пароль передается в код как переменная окружения.
	> Поменять переменную окружения => Перезапустить приложение

	? Если в приложении поменялся пароль к базе данных. Что нужно сделать чтобы приложение начало работать с новым паролем, учитывая что пароль "зашит" в код приложения, а не передается как переменная окружения.
	> Подготовить новую версию приложения => Выполнить деплой с новым паролем
*/




/*
	В отличии от самостоятельной работы. В упражнениях на Хекслете мы будем работать с базой данных PostgreSQL.

	.env

	Добавьте переменные окружения:
		DB_CONNECTION=pgsql
		DB_DATABASE=app_development
		DB_USERNAME=nobody
		DB_PASSWORD=secret

# РЕШЕНИЕ:
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:z0mNjzYC9xSgWQ1pYWyJxTaOT6J5J+kFDgSF6Ciqsc0=
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack

# BEGIN (write your solution here)
DB_CONNECTION=pgsql
DB_DATABASE=app_development
DB_USERNAME=nobody
DB_PASSWORD=secret
# END

BROADCAST_DRIVER=log
CACHE_DRIVER=file
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_DRIVER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_APP_CLUSTER=mt1

MIX_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
MIX_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
*/




	# >>>>>>>>>>>> ORM <<<<<<<<<<< #

/**
	 Любое веб-приложение оперирует внутри себя понятиями предметной области: пользователь, статья, курс, урок и другими. Эти понятия связаны между собой и включены в различные процессы, например, регистрацию пользователя или публикацию статьи.
	 
	 За эту часть приложения (основную!) в Laravel отвечает ORM (название группы фреймворков или библиотек, которые помогают моделировать предметную область и связывать ее с базой данных). ORM в ларавел называется Eloquent. Это фреймворк внутри фреймворка, который определяет то, как создаются сущности, как они связываются друг с другом и каким образом все это отображается на базу данных.
	 
	 Подробнее работа с ORM рассматривается в отдельном курсе, здесь же дается необходимый минимум.
	 
	 Любая сущность, создаваемая внутри приложения, называется моделью. Модели в ларавел лежат в директории app. Конкретный набор моделей зависит от приложения и может измениться со временем. На Хекслете таких моделей сотни, вот лишь некоторые, с которыми наши пользователи сталкиваются каждый день:
	 
	 > Пользователь
	 > Курс
	 > Урок
	 > Профессия
	 > Упражнение
	 > Подписка
	 > Участник курса (Мембер)
	 > Статья в блоге
	 > Топик
	 > Комментарий к топику
	 > Проект
	 
	 Важно не путать понятие модель во фреймворке, с понятием модель в MVC. Последнее это не класс не файл не функция не структра данных, это слой приложения отвечающий за модель предметной области. И это не про базу данных.
	 
	 Модели, как и большинство других частей приложения, создаются через утилиту artisan. Этот вызов создаст два файла:
	 
	 
	 $ php artisan make:model Article --migration
	 Model created successfully.
	 Created Migration: 2019_07_28_220908_create_articles_table
*/

	#@ Миграция
	
	// Первый файл – миграция в директории database/migrations.
	 
	 use Illuminate\Support\Facades\Schema;
	 use Illuminate\Database\Schema\Blueprint;
	 use Illuminate\Database\Migrations\Migration;
	 
	 class CreateArticlesTable extends Migration
	 {
		  /**
			* Run the migrations.
			*
			* @return void
			*/
		  public function up()
		  {
				Schema::create('articles', function (Blueprint $table) {
					 $table->bigIncrements('id');
					 $table->timestamps();
				});
		  }
		  
		  /**
			* Reverse the migrations.
			*
			* @return void
			*/
		  public function down()
		  {
				Schema::dropIfExists('articles');
		  }
	 }


/**
	Миграция – sql-запрос, который выполняется в базе при любом ее изменении. В данном случае запрос создает таблицу articles. Это соглашение пришло в Laravel из Rails: для каждой модели создается таблица, где имя модели берется в нижнем регистре и множественном числе. Например Article – articles или Person – people.

	Сама миграция не выглядит как SQL. Внутри нее используется библиотека, которая позволяет описывать изменения в базе в виде кода, который затем превращается в SQL. Структура этого кода достаточна проста, если знать PHP. В нем описывается таблица, все ее колонки и их типы.

	По умолчанию, Laravel добавляют в миграцию два вызова:
	> $table->bigIncrements('id') – колонка, которая будет первичным ключем
	> $table->timestamps() – два поля: updated_at (время последнего обновления) и created_at (время добавления). Это стандартная практика для многих фреймворков, эти колонки добавляются во все таблицы для удобства отслеживания дат.

	Остальные колонки нужно добавлять самостоятельно. Для статей полная миграция выглядит так:
*/
	 
	 Schema::create('articles', function (Blueprint $table) {
		  $table->bigIncrements('id');
		  $table->string('name'); // название статьи
		  $table->text('body'); // тело статьи
		  $table->timestamps();
	 });


/**
	 Миграции не выполняются автоматически. Их нужно "применять" или, как говорят "накатывать" на базу данных. Команда php artisan migrate находит все миграции, которые еще не были применены и выполняет их все в том порядке, в котором они расположены в файловой системе.

	$ php artisan migrate
	Migrating: 2014_10_12_000000_create_articles_table
	Migrated:  2014_10_12_000000_create_articles_table

	Если все прошло успешно, то в базе данных появилась таблица articles.

	 Миграции можно не только накатывать, но и откатывать. Для этого нужно набрать:

	 $ php artisan migrate:rollback.

	Эта команда попробует отменить последнюю миграцию. Повторный вызов откатит еще одну миграцию, которая была перед последней. И так далее до самого конца.
*/




	#@ Модель
	
	// Второй файл – класс (модель) с именем Article в директории app
	 
	 namespace App;
	 
	 use Illuminate\Database\Eloquent\Model;
	 
	 class Article extends Model
	 {
		  //
	 }
	 
/**
	Модель в Laravel – это класс который наследуется от Model. В самом простом случае, этот класс не содержит ни строчки кода. Большую часть работы по его функционированию берет на себя Eloquent. Эта ORM связывает класс с таблицей в базе данных и предоставляет множество необходимых методов, которых достаточно для большинства задач.
	 
	 # Самостоятельная работа
	 1. Создайте модель Article
	 2. Выполните миграции
	 
	 # Дополнительные материалы
	 Eloquent https://laravel.com/docs/6.x/eloquent
	 
	 ? Выберите верные утверждения про понятие "модель" в ORM
	 > Модель начинает работать тогда, когда создана и выполнена миграция описывающая таблицу для этой модели
	 > M в MVC это не тоже самое что и модель как сущность ORM.
	 > Модель связана с таблицей в базе данных один-к-одному
*/

	#@ database/migrations
	// Сгенерируйте файл миграции, в котором добавьте поле views_count (количество просмотров) в таблицу статей
	
	 /**
	 	Сгенерируйте файл миграции, в котором добавьте поле views_count (количество просмотров) в таблицу статей
	  */
	
	 use Illuminate\Database\Migrations\Migration;
	 use Illuminate\Database\Schema\Blueprint;
	 use Illuminate\Support\Facades\Schema;
	
	 class AddViewsCountToArticles extends Migration
	 {
		  /**
			* Run the migrations.
			*
			* @return void
			*/
		  public function up()
		  {
				Schema::table('articles', function (Blueprint $table) {
					 $table->integer('views_count');
				});
		  }
		 
		  /**
			* Reverse the migrations.
			*
			* @return void
			*/
		  public function down()
		  {
				Schema::table('articles', function (Blueprint $table) {
					 $table->dropColumn('views_count');
				});
		  }
	 }



	 
	# >>>>>>>>>>>> Модель <<<<<<<<<<< #
	
/**
	Модель в MVC v2 – это слой приложения, отвечающий за связь с предметной областью. В нем находится вся бизнес-логика приложения. Для простоты реализации, сюда часто включают механизмы для работы с базой данных.
	
	Очень важно понимать, что модель, как слой, существует независимо от фреймворка, HTTP и веба в целом. Вся остальная система может обращаться к моделям, но модели не могут знать и не знают ничего про среду в которой они выполняются.
	
	В том числе это значит, что мы можем работать с моделями вне фреймворка. В этом нам поможет Tinker. Одна из самых полезных возможностей Tinker – загрузить приложение и "поиграться" с моделями, поисследовать базу данных.
	
	Текущая версия Tinker не умеет подтягивать изменения файлов в репл. Поэтому если вы что-то меняете в коде с которым работаете в репле, придется его перезапускать
	
	Выполним полный пример, создадим новую статью, наполним ее данными и сохраним в базе:
	
	$ php artisan tinker
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> $a = new App\Article()
	=> App\Article {#2970}
	
	# После того как объект модели создан, его можно наполнять данными через обычные свойства (на самом деле внутри используется `__set` и `__get`). Имена этих свойств, соответствуют именам в таблице.
	
	>>> $a->name = 'my super article'
	=> "my super article"
	
	>>> $a->body = 'my content'
	=> "my content"
	
	>>> $a
	=> App\Article {#2970
     name: "my super article",
     body: "my content",
   }
	
	
	Когда объект готов, его можно сохранить в базу данных. Для этого надо вызвать метод save():
	
	>>> $a->save()
	=> true
	
	>>> $a
	=> App\Article {#2970
     name: "my super article",
     body: "my content",
     updated_at: "2019-07-29 19:17:08",
     created_at: "2019-07-29 19:17:08",
     id: 1,
   }
	
	Этот метод делает INSERT запрос в базу данных. Затем он обновляет сам объект:
	> Внутрь записывается идентификатор статьи взятый из базы данных.
	> Заполняются поля created_at и updated_at. Если это новая запись, то значения этих полей совпадают.
	
	Созданный объект можно тут же поменять:
	
	>>> $a->name = 'another title'
	=> "another title"
	
	>>> $a
	=> App\Article {#2972
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:17:08",
   }
	
	Изменение свойств никак не затрагивает базу данных. Все это происходит только на уровне самого объекта. Если в этот момент закрыть консоль, то все изменения потеряются. Для сохранения нужно опять вызвать save(). Этот метод универсальный, он подходит как для создания новой сущности, так и для ее обновления.
	
	>>> $a->save()
	=> true
	
	>>> $a
	=> App\Article {#2972
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:31:56",
   }
	
	
	Метод save() выполняет запрос в базу только тогда, когда что-то поменялось. В этом случае обязательно меняется значение поля updated_at. Оно ставновится равным текущему времени.
	
	Теперь предположим, что у нас нет переменной с текущей статьей. Например мы перезапустили консоль. Каким образом получить нужный объект? Делается это с помощью статических методов, которые появляются у каждой модели. Самый простой способ достать запись, сделать поиск по ее идентификатору:
	
	>>> $a = App\Article::find(1)
	=> App\Article {#2980
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:31:56",
   }
	
	find всегда ищет по первичному ключу и возвращает ровно одну запись или null. Если нужен поиск по полям, который вернет коллекцию, то для этого подходит метод where:
	
	 # Такой запрос извлечет все статьи, у которых имя равно _another title_.
	 >>> $articles = App\Article::where('name', 'another title')->get()
	 => Illuminate\Database\Eloquent\Collection {#2973
     all: [
       App\Article {#2967
         id: "1",
         name: "another title",
         body: "my content",
         created_at: "2019-07-29 19:17:08",
         updated_at: "2019-07-29 19:31:56",
       },
     ],
   }
	
	Кроме where, нам понадобятся два похожих метода:
	> Model::all() извлекает все записи из таблицы. Такой метод подходит только в некоторых ситуациях, в основном при работе со справочниками где немного данных. В остальных случаях он может выбрать в память слишком много записей, что породит ненужную нагрузку на сервер.
	
	> Model::paginate($page) – извлекает записи постранично. Основной метод, который используется в списках.
	
	И последнее что можно сделать с сущностью, это удалить ее:
	
	 >>> $a->delete()
	 => true
	
	 >>> Article::find(1)
	 => null
*/



	#@ Состав модели

/*
	 В реальных проектах от десятков до тысяч (или десятков тысяч!) сущностей. При таких количествах, помнить из чего состоят модели – невозможно. Более того, в проект могут и будут приходить новые люди, которые не знают структуры моделей.
	 
	 Узнать какие поля есть у модели можно несколькими способами. Ими придется пользоваться регулярно:
 	> База данных. Всегда можно подключиться напрямую и посмотреть структуру таблицы. В разных базах данных это делается по разному.

	> Laravel имеет встроенный механизм извлечения структуры таблицы. Он сам им пользуется для работы модели.
*/
	
	 DB::getSchemaBuilder()->getColumnListing('имя таблицы');

/*
	> Пожалуй самый простой и распространенный способ. Достаточно зайти в REPL, извлечь первую сущность нужной модели и распечатать ее.

	 >>> $u = \App\User::first()
	 >>> $u->toArray()

	 string(29) "select * from "users" limit 1"
	 => [
     "id" => 1,
     "email" => "streich.viva@example.net",
     "first_name" => "Tatum",
     "last_name" => "Hudson",
     "password" => "$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi",
     "created_at" => "2019-08-29 19:31:38",
     "updated_at" => "2019-08-29 19:31:38",
   ]
*/



/**@@@
	 Добавьте несколько статей через REPL. Консоль вызывается так:
	 # Внутри выполняется команда `php artisan tinker` плюс кое-какие настройки
	 make console
	 
	 routes/web.php
	 Реализуйте обработчик маршрута /articles, который извлекает из базы данных все статьи и выводит их в шаблон.
	 
	 Получите из базы все статьи и передайте их в шаблон
	 Выведите их в шаблоне
 */


	// FILE: resources/views/articles.blade.php:
?>
	 <!-- BEGIN -->
	 @extends('layouts.app')

	 @section('content')
		  @foreach ($articles as $article)
		  		<h2>{{ $article->name }}</h2>
		  		<div>{{ $article->body }}</div>
		  @endforeach
	 @endsection

<?
	// FILE: /routes/web.php:
	
	 Route::get('/', function () {
		  return view('welcome');
	 });
	
	 Route::get('/articles', function () {
		  $articles = App\Article::all();
		  return view('articles', ['articles' => $articles]);
	 });





	# >>>>>>>>>>>> Модель <<<<<<<<<<< #
	

/**
	 Реализация CRUD – самый быстрый способ познакомиться с любым веб-фреймворком. Он затрагивает все основные его части и позволяет понять насколько в этом фреймворке удобно работать.
	 
	 Создать CRUD в Laravel можно несколькими способами. Самый простой – добавить в файл роутинга нужные маршруты вместе с обработчиками. Внутри обработчиков реализовать логику вывода списка, создания, обновления и удаления статьи. Этот способ очень муторный, он требует много движений от программиста. И он быстро захламляет файл с маршрутами. Когда таких "крудов" станет хотя бы несколько штук, то ориентироваться в нем станет проблематично. А если добавить сотню другую как в реальных проектах, так вообще станет невозможно.
	 
	 Проблема одного файла решается с помощью "контроллера". В Laravel, контроллером называют класс, который расположен в директории app/HTTP/Controllers. Методы этого класса связываются с конкретными маршрутами и отвечают за его обработку:
*/

	 // routes/web.php
	 
	 // Вторым параметром передается строчка: 'controllerName@methodName'
	 Route::get('/about', 'PageController@about');
	 Route::get('/team', 'PageController@team');
	 
	 
	 // app/HTTP/Controllers/PageController.php
	 
	 namespace App\Http\Controllers;
	 
	 // Должен наследоваться от Controller
	 class PageController extends Controller
	 {
		  public function about()
		  {
				// Точка используется вместо /.
				// То есть шаблон находится по пути resources/views/page/about.blade.php
				return view('page.about');
		  }
		  
		  public function team()
		  {
				return view('page.team');
		  }
	 }
	 
/*
	 Методы в контроллерах принято группировать по смысловой связи. Например все что относится к обычным страницам на сайте можно поместить в контроллер PageController, а CRUD статьи в контроллер ArticleController. Ниже пример структуры контроллеров из нашего открытого проекта hexlet-sicp:

	 app/Http/Controllers/
	 ├── Auth
	 │   ├── ForgotPasswordController.php
	 │   ├── LoginController.php
	 │   ├── RegisterController.php
	 │   ├── ResetPasswordController.php
	 │   ├── Social
	 │   │   └── GithubController.php
	 │   └── VerificationController.php
	 ├── Controller.php
	 ├── HomeController.php
	 ├── MyController.php
	 ├── RatingController.php
	 ├── UserChapterController.php
	 └── UserController.php
		
	 Еще одно соглашение, расположение шаблонов. Шаблоны одного контроллера лучше группировать вместе, в одной директории. В примере выше, все шаблоны страниц расположены по пути resources/views/page. Это позволяет удобнее ориентироваться в шаблонах и избегать коллизий имен.

	Контроллеры, также, как и модели не нужно создавать руками. Их можно генерировать через artisan:
	 
	 $ php artisan make:controller PageController
	 Controller created successfully.
	 
	 А вот шаблоны и методы контроллера придется добавлять самостоятельно.
	 
	 
	 # Самостоятельная работа
	Перенесите обработчик about в контроллер PageController. Убедитесь что страница открывается.
	
	 # Дополнительные материалы
	 Controller https://laravel.com/docs/6.x/controllers
*/



/*

*/



/*

*/



/*

*/

