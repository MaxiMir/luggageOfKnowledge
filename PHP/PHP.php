<?

############## PHP Basics ##############
	 
	 /** Код-гайд:
	  * https://www.php-fig.org/psr/psr-1/
	  * http://www.php-fig.org/psr/psr-2/
	  *
	  ** Проверка кода:
	  * https://github.com/squizlabs/PHP_CodeSniffer
	  *
	  * Тестовые задания:
	  * https://github.com/Hexlet/ru-test-assignments
	  *
	  * Гайды:
	  * https://guides.hexlet.io
	  *
	  * Книги:
	  * https://ru.hexlet.io/pages/recommended-books
	  *
	  * Рассказы о множествах книга: http://ilib.mccme.ru/pdf/rasomn.pdf
	  */


# >>>>> Введение <<<<<<< #
	 
	 /**
	  * PHP — динамический, слабо-типизированный, интерпретируемый язык программирования.
	  *
	  * #@ Интерпретируемый:
	  * У PHP отсутствует стадия компиляции, как у языков подобных Java или C.
	  * Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на PHP состоит из текстовых файлов.
	  *
	  * Откровенно говоря, это не совсем так.
	  * У PHP все же есть стадия компиляции, но она скрыта от глаз пользователя и внешне PHP ведет себя именно как интерпретируемый язык программирования.
	  *
	  * #@ Динамический:
	  * В отличие от статических языков, проверка типов в PHP происходит в момент выполнения кода.
	  * Поэтому если, мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статические анализаторы кода (слово статический как раз означает что программа не выполняется). Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок.
	  *
	  * #@ Слабо типизированный:
	  * Слабая типизация означает то, что PHP автоматически приводит типы там, где считает нужным (описано в спецификации). С одной стороны, слабая типизация позволяет писать более короткий код, но с другой, количество ошибок резко возрастает, так как вместо падения, код продолжает работать там, где он не должен работать.
	  * Например, мы можем сложить число со строкой по ошибке и PHP молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Нужно стараться никогда не полагаться на эту особенность языка во избежания проблем.
	  */
	 
	 
	 // Comment - однострочный комментарий
	 
	 /*
	  * Multi
	  * Line
	  * Comment
	 */
	 
	 ### Statements (перев. инструкции)
	 
	 ; // пустая инструкция
	 
	 return 3; // выражение - вычисляется, инструкция выполняется
	 return 5 + 5; // выражение
	 $name = 'Max'; // инструкция с выражением

	 
	 

# >>>>>  Арифметические операции <<<<<<<
	 
	 // Operator, Operand:
	 7 * 9; // infix - Инфиксный оператор
	 -1; // prefix - Префиксный оператор
	 $i++; // postfix - Постфиксный оператор
	 
	 -1; // unary - Унарная операция - операция с 1 операндом
	 3 ** 4; // binary - Бинарная операция - операция с 2-мя операндами
	 
	 sqrt(4); // => 2
	 sin(deg2rad(90)); // => 1
	 cos(pi()); // => -1


	 
	 
# >>>>>  Функции <<<<<<< #
	 
	 function hypotenuse($cathetus1, $cathetus2) // $cathetus1, $cathetus2 - формальные параметры
	 {
		  return sqrt($cathetus1 ** 2 + $cathetus2 ** 2);
	 }
	 
	 echo hypotenuse(3, 4); // 3, 4 - фактические параметры => 25


	 
	 
# >>>>>  Включение файлов <<<<<<< #
	 
	 namespace 'Theory';
	 
	 echo include 'Example.php'; // При ошибке -> Warning => 1
	 
	 require 'Example.php'; // При ошибке -> Fatal error
	 require_once 'Example.php'; // Предпочтительный способ, чтобы избежать ошибок при повторном подключении файла
	 
	 set_include_path('/tmp'); // меняем директорию (*). PHP просмотривает всегда текущую директорию
	 echo get_include_path(); // возвращает список директорий.
	 echo include 'Anather.php'; // без * будет ошибка, поскольку подкл. файл лежит в '/tmp' => Hello World


	// Файл: theory/Example.php
	 return 1;

	// Файл: tmp/Anather.php
	 return 'Hello World';




# >>>>>  Пространство имен <<<<<<< #
	 /*
	  * Проблематика:
	  * Отстутсвие пространств имен подобно отсутствию директорий в файловой системе
	  * - Все глобальные идентификаторы должны быть уникальны: константы, функции, классы...
	  * - В свою очередь это ведет к подобным именам: PHPUnit_Framework_TestCase
	 
	  * Решение:
	  * Пространства имен предоставляют возможность для группировки определений php
	  */
	 
	 namespace App\Template;
	 
	 /*
	  Особенности:
	  * Могут быть вложенными
	  * Не связаны с файловой структурой
	  * В одном файле может быть несколько определений пространств
	  * Определения находящихся в одном и том же пространстве имеют прямо доступ друг к другу


	  Директории:
	  * theory/
	  *   Another.php
	  *   Example.php
	  *   main.php
     */

	 
	// Файл main.php
	 namespace Theory;
	 
	 require_once 'Example.php';
	 require_once 'Another.php';
	 
	 echo \Theory\Example\iam(); // с полным путем (абсолютный путь - а значит не смотрим относительно текущего namespace)
	 echo \Another\iam();
	 
	 echo Example\iam(); // относительно текущего namespace Theory


	// Ниже задаются абсолютные пути, но без ведущего '/'
	 use function Theory\Example\iam; // импортирование функции. бэкслеш вначале можно ставить, а можно нет (*)
	 use function Theory\Example\iam as eiam; // задаем альтернативное имя функции
	 use function Another\iam as aiam; // без задания альтернативного имени -> конфликт имен с (*)
	// => после этого можно обращаться к функции как-будто она была уже определена здесь:
	 echo iam();
	 echo eiam();
	 echo aiam();

	// Файл Another.php:
	 namespace Another;
	 
	 function iam()
	 {
		  return "another\n";
	 }

	// Файл Example.php:
	 namespace Theory\Example;
	 
	 // вложенный namespace
	 function iam()
	 {
		  return "example\n";
	 }


	// Настоятельно не рекомендуется при программировании комбинировать несколько пространств имен в один файл.
	 //  Основным применением этому может быть объединение нескольких PHP-файлов в один файл.
	 
	 namespace MyProject {
		  
		  const CONNECT_OK = 1;
		  
		  class Connection
		  {
		  	 /* ... */
		  }
		  
		  function connect()
		  {
		  	 /* ... */
		  }
	 }
	 
	 namespace { // глобальный код
		  session_start();
		  $connect = MyProject\connect();
		  echo $connect::start();
	 }
	 
	 /*
		PHP-код не может находиться вне скобок конструкции пространства имен, кроме начального выражения declare.
		Значение константы __NAMESPACE__ - это строка, которая содержит имя текущего пространства имен.
		В глобальном пространстве, вне пространства имен, она содержит пустую строку.

		Неймспейс задается с помощью ключевого слова namespace, за которым следует имя неймспейса. По стандарту, один файл должен соответствовать одному неймспейсу. В случае когда внутри неймспейса определяются только функции (а не классы) имя неймспейса должно соответстовать имени файла с учетом регистра, то есть для нашего примера имя файла math.php, следовательно имя неймспейса math. Теперь посмотрим на то, как использовать функции определенные в неймспейсе:
	*/

	// file: math.php:
	 namespace math;
	 
	 function sum($a, $b)
	 {
		  return $a + $b;
	 }

	// file: index.php:
	 require_once('math.php');
	 
	 \math\sum(5, 8); // 13
	 
	 
	 /*
	 Файловая структура практически любого проекта на PHP выглядит так:
	 
	 src/
		  Formatters/
				Pretty.php
				Generator.php
	 
	 tests/
	 
	 composer.json
	 composer.lock
	 .git
	 README.md
	*/

	// file: Pretty.php:
	 namespace Formatters\Pretty;
	 
	 function render($data)
	 {
		  // some code
	 }

	// file: Generator.php
	 namespace Generator;
	 
	 function generate($data)
	 {
		  return \Formatters\Pretty\render($data);
	 }

	// Каждый проект или пакет принято помещать в одно общее пространство и не загрязнять глобальное пространство множеством неймспейсов. Это название выбирается на основе названия самого проекта, той директории внутри которой лежит src. В нашей структуре директорий это my-site. Это значит, что общим пространством для всех файлов внутри src будет MySite:

	// file: src/Formatters/Pretty.php
	 namespace MySite\Formatters\Pretty;
	 
	 // some code


	// C помошью механизма импорта функцию можно импортировать в текущий неймспейс так, как будто она определена прямо здесь:
	 namespace Generator;
	 
	 use function Formatters\Pretty\render;
	 
	 function generate($data)
	 {
		  return render($data);
	 }


	// Изредка случаются ситуации, когда хочется импортировать функцию, но в текущем пространстве либо уже определена функция с таким именем, либо функция с таким именем была импортирована ранее из другого неймспейса. Сделать это можно через алиасы (псевдонимы), механизм позволяющий переименовывать импортируемые функции:
	 
	 namespace Generator;
	 
	 use function Formatters\Pretty\render;
	 use function Formatters\Simple\render as simpleRender;
	 
	 function generate($data)
	 {
		  return simpleRender($data);
	 }
	 
	 
	 # >>>>> Константы <<<<<<< #
	 
	 namespace Theory;
	 
	 define('VERSION', 'version-1.5'); // global definition (глобальное определение) - игнорирует namespace, желательно использовать const
	 const FOO = 7 ** 10;
	 
	 echo VERSION;
	 echo FOO;
	 echo \Theory\FOO;
	 
	 defined('\Theory\FOO'); // проверяет определена ли данная константа true
	 // но!
	 defined('\Theory\VERSION'); // false
	 
	 defined('\Theory\HI'); // false

	 // Предопределенные константы, примеры:
	 PHP_VERSION; // версия
	 PHP_OS; // ОС
	 PHP_BINDIR; // местонахождение исполняемого файла у PHP
	 
	 // Magic constants:
	 __LINE__; // текущая строчка
	 __FILE__; // текущий файл
	 __DIR__; // текущая директория
	 __FUNCTION__;
	 __CLASS__;
	 __TRAIT__;
	 __METHOD__;
	 __NAMESPACE__;

	constant('FOO'); // возвратит значение константы, указанной параметром name. Используется, если вам необходимо запросить значение константы, но вам не известно её имя, если, например, она хранится в переменной или возвращается функцией.

	


# >>>>>  Boolean <<<<<<< #

	 /*
	  ! - Отрицание
	  && - И (Конънкция)
	  || - Или (Дизъюнкция)
	  == Совпадение
	  != Не совпадение
	  xor - исключающее или
	 
	  * Правила логики:
	  true != false
	  true == !false
	  true && true == true
	  true && false == false
	  false && false == false
	  true || true == true
	  true || false == true
	  false || false == false
	 
	  * Ассоциативность:
	  (a && b) && c = a && (b && c)
	  (a || b) || c = a || (b || c)
	  (a XOR b) XOR c = a XOR (b XOR c)
	 
	  * Коммутативность:
	  a && b = b && a
	  a || b = b || a
	  a XOR b = b XOR a
	 
	  * Дистрибутивность:
	  a && (b || c) = (a && b) || (a && c)
	  a || (b && c) = (a || b) && (a || c)
	 
	  * Двойное отрицание:
	 !!a = a
	 
	  * Законы Де Моргана:
	  !(a && b) = (!a) && (!b)
	  !(a || b || c) = (!a) || (!b) || (!c)
	 
	  Закон импликации:
	  a->b = !b -> !a
	 
	  and, or - #! имеют пониженный приоритет лучше не использовать
	 */

	 
	 function isOdd($num) // проверка на нечетность
	 {
		  return $num % 2 != 0;
	 }



	#>>>>>  Условие if <<<<<<<#
	 
	 function lucky($num)
	 {
		  if ($num == rand(1, 3)) { //  генерирует случайное число
				return 'You are lucky!';
		  } elseif ($num < 1 || $num > 3) {
				return 'Unexpected number';
		  } else {
				return 'Sorry, you are not lucky!';
		  }
	 }
	 
	 function mod($num)
	 {
		  return $mod >= 0 ? $num : -$num; // тернарный оператор
	 }
	 
	 
	 /**@@@
	  * Реализуйте функцию result, которая принимает на вход результат хоккейного матча и исход, который предполагался. Если счет был угадан верно, то функция должна вернуть 2, если исход был угадан верно (победа первой команды, ничья, поражение первой команды), то функция должна вернуть 1, во всех остальных случаях функция возвращает 0.
	  */
	 
	 function result($a, $b, $c, $d)
	 {
		  if ($a == $c && $b == $d) {
				return 2;
		  } elseif ($a > $b && $c > $d || $a < $b && $c < $d || $a == $b && $c == $d) {
				return 1;
		  } else {
				return 0;
		  }
	 }



	#>>>>>  Переменные <<<<<<< #
	 
	 function factorial($n)
	 {
		  $result = 1;
		  
		  for ($i = 2; $i <= $n; $i++) {
				$result *= $i;
		  }
		  
		  return $result;
	 }
	 
	 function isPrime($n) // проверка на простое число
	 {
		  for ($i = 2; $i = $n / 2; $i++) {
				if ($n % $i == 0) {
					 return false;
				}
		  }
		  
		  return true;
	 }
	 
	 
	 /**@@@
	  * Напишите функцию sumDouble, которая принимает на вход два числа: начало последовательности и конец последовательности, а возвращает сумму возведенных в квадрат чисел последовательности с шагом 2. То есть из последовательности от 3 до 7 будут взяты числа 3, 5, 7.
	  */
	 
	 function sumDouble($a, $b)
	 {
		  $result = 0;
		  
		  for ($i = $start; $i <= $finish; $i += 2) {
				$result += $i ** 2;
		  }
		  
		  return $result;
	 }



	 
#>>>>>  Именование в программировании <<<<<<<#

	 /*
	 Нотация:
	 * Верблюжья нотация (CamelCase): MyClass
	 * Змеиная нотация (snake_case): my_const
	 * Шашлычная нотация (kebab-case): my-data
	 * Венгерская нотация https://ru.wikipedia.org/wiki/Венгерская_нотация
	 
	 # Сущность-Действие:
	 Имя функции должно быть глаголом, переменной - существительным.
	 
	 # Предикаты:
	 Предикат это функция-проверка, она всегда возвращает либо true, либо false.
	 
	 В большинстве языков предикаты предваряют префиксом is.
	 isEmpty();
	 isValid();
	 isBusy();
	 
	 Но не все языки следуют этому правилу. В большинстве лиспов, а так же в ruby (который взял это из лиспов) используется знак ? в конце слова:
	 empty?
	 valid?
	 busy?
	 
	 Если учесть что в указанных языках вызов функции не требует скобок в конце, то такая форма смотрится особенно естественной.
	 
	 # Вхождение:
	 Но не все предикаты можно выразить через is. Например, как задать вопрос если мы хотим узнать есть ли в списке чисел нечетное? В таких ситуациях принято использовать слово has:
	 
	 node.hasChildren();
	 
	 # Количество:
	 Если вам нужна переменная, в которой содержится количество чего-либо, то используйте комбинацию: сущность во множественном числе + count.
	 
	 symbolsCount
	 peopleCount
	 
	 Это правило важнее даже в другом варианте, а именно, как не надо называть переменную обозначающую количество:
	 errors;
	 
	 Такое именование гарантированно вводит в заблуждение. Сущность во множественном числе всегда должна обозначать только коллекцию.
	 
	 Примеры:
	 */
	 
	 // Нормализация данных
	 normalizeDomainName('hexlet.io');
	 
	 // Извлечение части данных
	 getName(user);
	 getDomainFromEmail('support@hexlet.io');
	 
	 // Получение массива с ошибками
	 const errors = validate(user);
	 if (errors.length > 0) {
		  // ...
	 }
	 
	 // Подсчеты
	 calculateDiff(first, second);

	 // Допуск
	 canSwim(user);
	 canViewProfile(user);

	 
	 

#>>>>>  Variable Scope - Область видимости переменной <<<<<<<#

	 // переменная доступна вне цикла for и if:
	 for ($i = 0; $i < 3; $i++) {
		  echo $i . "\n";
	 }
	 
	 if (true) {
		  $val = 'cat';
	 }
	 
	 echo $i; // => 2
	 echo $val; // => cat


	# Чистая функция - зависит только от своих аргументов и не делает побочных эффектов.
	# Детерминированная функция - функция, которая всегда производит тот же результат при одинаковых вводных даннных


	 // #! Не использовать глобальные переменные в функции:
	 $increment = 1;
	 
	 function increment($num)
	 {
		  global $increment; // <-> $_GLOBALS['increment']
		  return $num + $increment;
	 }



#>>>>>  Строки <<<<<<<#
	 
	 $value = 'text';
	 echo "string \t with \n \\ escape sequence\n" . PHP_EOL; //  \\ - экранирование '\', PHP_EOL - константа конец  строки (в Unix системах - \n / в Windows \n\r)
	 
	 echo "interpolation example: $value" . PHP_EOL; // интерполяция

function hereDoc($hello)
{
	 return <<<EOD
	  Example "of $hello string"
	  spaning 'multiple lines
	  using heredoc syntax.\n\n
EOD;

}

function nowDoc()
{
	 return <<<'EOD'
	  Example of string
	  spaning 'multiple lines
	  using nowdoc syntax. $hello.
EOD;

}
	 
	 
	 $str = 'simple string';
	 
	 echo $str[0]; // => s
	 echo $str[strlen($str) - 1]; // => g
	 
	 
	 /**@@@
	  * Реализуйте функцию reverse, которая переворачивает строку.
	  */
	 
	 function reverse(String $str)
	 {
		  $result = [];
		  
		  for ($i = strlen($str) - 1; $i >= 0; $i--) {
				$result[] = $str[$i];
		  }
		  
		  return implode('', $result);
	 }
	 
	 
	 /**@@@
	  * Для определения является ли слово палиндромом, достаточно сравнивать попарно символ с обоих концов слова. Если они все равны, то это палиндром. Решите задачу без использования реверса строки. Примеры использования:
	  */
	 
	 isPalindrome('radar'); // true
	 isPalindrome('maam'); // true
	 isPalindrome('a');     // true
	 isPalindrome('abs');   // false
	 
	 function isPalindrome(String $word)
	 {
		  $charsCount = strlen($word) - 1;
		  
		  for ($i = 0; $i < ceil($charsCount / 2); $i++) {
				if ($word[$i] !== $word[$charsCount - $i]) {
					 return false;
				}
		  }
		  
		  return true;
	 }

	 
	 /**@@@
	  * Реализуйте функцию reverse, которая переворачивает цифры в переданном числе:
	  */
	 
	 use function Number\reverse;
	 
	 reverse(13); // 31
	 reverse(-123); // -321
	 
	 function reverse(int $num): int
	 {
		  $reverse = (int)strrev((string)abs($num));
		  
		  return $num > 0 ? $reverse : -$reverse;
	 }


	 

#>>>>>  Массив <<<<<<<#
	 
	 [1, 2, 3, 5] + [8, 1, 2]; // [1, 2, 3, 5]
	 [] == []; // true. !# в JS => false
	 [1] != [2]; // true
	 
	 sizeof($arr); // размер массива (кол-во элементов)
	 in_array('apple', $arr); // проверяет наличие элемента в массиве
	 empty($arr); // проверяет пустой ли массив
	 end($arr); // возвращает последний элемент
	 unset($arr[2]); // удаление элемента массива
	 
	 function myMax(Array $arr)
	 {
		  if (empty($arr)) {
				return;
		  }
		  
		  $max = $arr[0];
		  
		  foreach ($arr as $val) {
				if ($max < $val) {
					 $max = $val;
				}
		  }
		  
		  return $max;
	 }


		
	 /**@@@
	  * Реализуйте функцию uniq, которая принимает, как аргумент, массив, и возвращает новый массив, в котором ни один элемент исходного массива не повторяется.
	  */
	 
	 function uniq(Array $arr)
	 {
		  $res = [];
		  
		  foreach ($arr as $value) {
				if (!in_array($res, $value)) {
					 $res[] = $val;
				}
		  }
		  
		  return $res;
	 }
	 


	 
#>>>>>  Ассоциативный массив <<<<<<<#
	 
	 array_key_exists('undefined', $map); // проверяет присутствует ли данный ключ в ассоц. массиве
	 
	 $arr = [];
	 $arr[] = 'val1';
	 $arr['key'] = 'val2';
	 $arr[] = 'val3';
	 $arr['9'] = 'val4';
	 $arr[] = 'val5';
	 
	 /* =>
	 [0] => val
	 [key] => val
	 [1] => val
	 [9] => val
	 [10] => val // #! '9' - ключ был строкой
	 */

	 
	 
	 /**@@@
	  * Реализуйте функцию wordsCount, которая считает количество одинаковых слов в предложении. Результатом функции является ассоциативный массив, в ключах которого слова из исходного текста, а значения это количество повторений.
	  */
	 
	 function wordsCount(String $sentence)
	 {
		  $words = explode(' ', $sentence);
		  $countWords = [];
		  
		  foreach ($words as $word) {
				if (empty($word)) {
					 continue;
				}
				
				array_key_exists($word, $countWords) ? $countWords[$word]++ : $countWords[$word] = 1;
		  }
		  
		  return $countWords;
	 }



#>>>>>  Аргументы <<<<<<<#
	 
	 round(10.61234, 2); // 10.61
	 round(1.55, 1); // 1.6
	 round(1.55, 1, PHP_ROUND_HALF_DOWN); // округление вниз 1.5
	 
	 // float, string, bool, int, array
	 
	 function drop(Array $array, Int $count = 1) // возвращает обрезанный с начала массив на count элементов
	 {
		  $result = [];
		  
		  for ($i = $count; $i < sizeof($array); $i++) {
				$result[$i] = $array[$i];
		  }
		  
		  return $result;
	 }
	 
	 function sumArgs()
	 {
		  return array_sum(func_get_args()); // func_get_args() - возвращает массив переданных аргументов
	 }
	 
	 function sumArgs1(...$numbers)
	 {
		  return array_sum($numbers); // $numbers - массив переданных аргументов
	 }
	 
	 function sumArgs2($arg, ...$numbers) // $arg - можно задавать обязательные параметры
	 {
		  return array_sum($numbers); // $numbers - массив переданных аргументов
	 }
	 
	 sumArgs2(10, 2, 4); // !!! => 6
	 
		
	 
	 /**@@@
	  * Реализуйте функцию multiArgs, которая возвращает произведение всех переданных аргументов. Вызванная без аргументов, должна вернуть null.
	  */
	 
	 function multiArgs(...$numbers)
	 {
		  return empty($numbers) ? null : array_product($numbers); // array_product - произведение элементов массива
	 }
	 
	 
	 

#>>>>>  null <<<<<<<#

$var = null;
is_null($var); // true

$result = $var ?? 'nobody'; // <-> $result = isset($var) ? $var : 'noboby'

example(); // ! вызов пустой функции возвращает null. В JS => undefined

function example($var = null) // необязательный аргумент
{
	 return; // <-> return null;
}


/**@@@
 * Реализуйте функцию compact которая принимает на вход массив и возвращает новый, полученный удалением элементов со значением null. Ключи оставшихся элементов (тех которые не были null) должны сохраняться.
 */

function compact(array $array)
{
	 $newArray = [];
	 
	 foreach ($array as $key => $value) {
		  if (!is_null($value)) {
				$newArray[$key] = $value;
		  }
	 }
	 
	 return $newArray;
}



>>>>>  Типы <<<<<<<

/*
Система типов - совокупность правил в языках программирования, назначающих свойства, именуемые типами, различным конструкциям, составляющих программу - таким как переменные, выражения, функции или модули

Основная роль системы типов заключается в уменьшении числа багов в программах посредством определения интерфейсов между различными частями программы и последующей проверки согласованности взаимодействия этих частей.

Виды типизации:
 * Статическая - указываем какого типа будут сущности языка. Например, если описываем переменную, то указываем, что переменная типа integer, записать туда можем число и работать можем только как с числом. Ошибки на стадии компиляции (преобр. в машинный код)

 * Динамическая - не надо указывать какого типа будут сущности языка. Тип будет вычисляться в момент операции над переменной. Ошибки на стадии runtime

 * Сильная (Строгая) - не преобразовывает автоматически типы данных (Python, Ruby)
 * Слабая (Не строгая) - автоматически преобразовывает типы данных (JS, PHP)
*/

[] + 1; // => Fatal Error. В JS => "1"
"" + []; // => Fatal Error. В JS => ""

// Type Casting (приведение типов):
$foo = 100;
$bar = (bool)$foo;

/*
false:
 * 0;
 * '0';
 * 0.0;
 * '';
 * null;
 * [];
*/

// Comparison (сравнение):
0 !== false; // true
0 === '0'; // false;

// Functions:
gettype(true); // возвращает тип переданного аргумента - boolean
is_string('asfs'); // true
// is_numeric, is_int и т.д.

// Type Hinting
function drop(Array $array, Int $count = 1): array // float, string, bool, int, array
{
}


/**@@@
 * Дано неотрицательное целое число num. Итеративно сложите все входящие в него цифры до тех пор, пока не останется одна цифра.
 *
 * Для числа 38 процесс будет выглядеть так:
 *
 * 3 + 8 = 11
 * 1 + 1 = 2
 * Результат: 2
 */

function addDigits(Int $num)
{
	 $sum = (string)$num;
	 
	 while (strlen($sum) > 1) {
		  $sum = array_sum(str_split($sum));
	 }
	 
	 return $sum;
}


/**@@@
 * Реализуйте функцию binarySum, которая принимает на вход два бинарных числа (в виде строк) и возвращает их сумму. Результат (вычисленная сумма) также должна быть бинарным числом в виде строки. Посмотрите примеры работы функции:
 *
 * '11' == binarySum('10', '1');
 * '10010' == binarySum('1101', '101');
 */

function binarySum($num1, $num2)
{
	 // decbin — переводит число из десятичной системы счисления в двоичную
	 // bindec — переводит двоичное число в десятичное
	 return decbin(bindec((int)$num1) + bindec((int)$num2));
}


/**@@@
 * Реализуйте функцию isPrime определяющую, является ли число простым. Пример:
 * echo isPrime(1); // → false
 * echo isPrime(7); // → true
 * echo isPrime(10); // → false
 */

function isPrime($num)
{
	 if ($num < 2) {
		  return false;
	 }
	 
	 for ($i = 2; $i <= $num / 2; $i++) {
		  if ($num % $i == 0) {
				return false;
		  }
	 }
	 
	 return true;
}


/**@@@
 * Реализуйте функцию isPowerOfThree которая определяет, является ли переданное число натуральной степенью тройки. Например число 27 это третья степень (33), а 81 это четвертая (34). Пример:
 *
 * isPowerOfThree(1); // → true (3^0)
 * isPowerOfThree(3); // → true
 * isPowerOfThree(4); // → false
 * isPowerOfThree(9); // → true
 */

function isPowerOfThree(Int $num)
{
	 $current = 1;
	 
	 while ($current <= $num) {
		  if ($current === $num) {
				return true;
		  }
		  
		  $current *= 3;
	 }
	 
	 return false;
}


/**@@@
 * Реализуйте функцию reverseInt, которая переворачивает цифры в переданном числе:
 * 31 == reverseInt(13);
 * -321 == reverseInt(-123);
 */

function reverseInt($num)
{
	 $reverse = (int)strrev((string)abs($num)); // strrev - переворачивает строку задом наперед / abs - модуль числа
	 return $num > 0 ? $reverse : -$reverse;
}



>>>>>  HTTP <<<<<<<

/*
Что происходит после того, как в браузер ввели адрес сайта?
https://habr.com/company/htmlacademy/blog/254825/

Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией.
http — это набор правил, который известен и вашему компьютеру и физически отдаленному компьютеру.
С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передается информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
*/

$ curl--head - v code - basics . ru
	 * Rebuilt URL to: code - basics . ru /
*   Trying 35.157.19.194...
* TCP_NODELAY set
	 * Connected to code - basics . ru(35.157.19.194) port 80 (#0)
> GET / HTTP / 1.1
> Host: code - basics . ru
	 > User - Agent: curl / 7.54.0
	 > Accept: */*
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

http нужно не просто знать, но и уметь делать сырые http-запросы, то есть не косвенно через браузер, но и самостоятельно, эмулируя поведение браузера.
Для этой задачи используют программу telnet.
*/



>>>>>  Микрофреймворки <<<<<<<

/*
 Фреймворк(каркас) - общая логика, которая структурирует приложение:
 * Принять запрос.
 * Определить, какой обработчик должен выполниться.
 * Выполнить обработчик и подготовить ответ.
 * Вернуть ответ клиенту.

 Сам код на микрофреймворках простой и требует создания буквально одного файла. Микрофреймворки практически ничего не могут самостоятельно. Любая новая функциональность достигается сторонними библиотеками.
 
 Возможности, которыми обладают современные фреймворки:

 * Генерация кода. Любой полноценный фреймворк содержит утилиту cli, позволяющую генерировать код, например, тесты или миграции.
 * Встроенные механизмы для тестирования. Другими словами, фреймворк дает возможность начать писать тесты практически без необходимости что либо дополнительное ставить или конфигурировать.
 * ORM. Либо своя, либо популярная для языка в целом.
 * Шаблонизатор и хелперы (вспомогательные функции) для повторяющихся задач вывода информации.
 * Абстракции для работы с письмами.
 * Инструменты для интернационализации и локализации.
 * Механизмы, обеспечивающие безопасность, например, CQRS.
 * Интеграция с frontend инструментами.
 * Кеширование.
*/



>>>>>  СУБД <<<<<<<

// Библиотека PDO

// PDO Connection to MySQL
$conn = new PDO('mysql:host=localhost;dbname=yourdbname', 'username', 'password');

// PDO Connection to PostgreSQL
$conn = new PDO('pgsql:host=localhost;dbname=yourdbname', 'username', 'password');

// A quick Select Query with For Loop
$result = $conn->query("SELECT * FROM profile");

foreach ($result as $row) {
	 echo $row['id'];
	 echo $row['title'];
	 echo $row['telephone'];
}

// Slim-PDO. Для Slim /https://github.com/FaaPz/Slim-PDO/ существует проект Slim-PDO, который позволяет взаимодействовать с базой из фреймворка Slim.

$app->post('/ads', function (ServerRequestInterface $request) {
	 $parsedBody = $request->getParsedBody(); // Данные пришедшие из формы
	 
	 // Соединение с базой должно выполняться на этапе старта приложения (как было с шаблонизатором), а не в конкретном обработчике.
	 $dsn = 'mysql:host=your_db_host;dbname=your_db_name;charset=utf8';
	 $usr = 'your_db_username';
	 $pwd = 'your_db_password';
	 
	 $pdo = new \Slim\PDO\Database($dsn, $usr, $pwd);
	 
	 $insertStatement = $pdo
		 ->insert(['telephone', 'title'])
		 ->into('ads')
		 ->VALUES([$parsedBody['telephone'], $parsedBody['title']]);
	 
	 $insertId = $insertStatement->execute(false);
});

// Обратите внимание на то, что библиотека Slim-PDO позволяет выполнять SQL не в виде "сырых" запросов, где SQL писался бы как строка текста (как в репле), а предоставляет небольшой DSL (мини-язык) для написания запроса: insert()->into()->VALUES(). Библиотеку, позволяющую таким образом строить запросы, называют Query Builder. В отличие от сырого SQL в виде строчки, подход, описанный выше, удобен в случаях, когда SQL собирается по условиям. Такое часто бывает на страницах с фильтрами.

/*
Нормализация баз данных заключается в приведении структуры хранения данных к нормальным формам (NF). Всего таких форм существует 8, но часто достаточным является соблюдение первых трех.
 
 * В нормализованной структуре базы данных вы можете производить сложные выборки данных относительно простыми SQL-запросами.
 * Целостность данных. Нормализованная база данных позволяет надежно хранить данные.
 * Нормализация предотвращает появление избыточности хранимых данных. Данные всегда хранятся только в одном месте, что делает легким процесс вставки, обновления и удаления данных. Есть исключение из этого правила. Ключи, сами по себе, хранятся в нескольких местах потому, что они копируются как внешние ключи в другие таблицы.
 * Масштабируемость – это возможность системы справляться с будущим ростом. Для базы данных это значит, что она должна быть способна работать быстро, когда число пользователей и объемы данных возрастают. Масштабируемость – это очень важная характеристика любой модели базы данных и для РСУБД.

https://habr.com/post/193756/

# Денормализация - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.
Устранение аномалий данных в соответствии с теорией реляционных баз данных требует, чтобы любая база данных была нормализована, то есть соответствовала требованиям нормальных форм. Соответствие требованиям нормализации минимизирует избыточность данных в базе данных и обеспечивает отсутствие многих видов логических ошибок обновления и выборки данных.

Однако при запросах большого количества данных операция соединения нормализованных отношений выполняется неприемлемо долго. Вследствие этого в ситуациях, когда производительность таких запросов невозможно повысить иными средствами, может проводиться денормализация — композиция нескольких отношений (таблиц) в одну, которая, как правило, находится во второй, но не в третьей нормальной форме. Новое отношение фактически является хранимым результатом операции соединения исходных отношений.

За счёт такого перепроектирования операция соединения при выборке становится ненужной и запросы выборки, которые ранее требовали соединения, работают быстрее.

Следует помнить, что денормализация всегда выполняется за счёт повышения риска нарушения целостности данных при операциях модификации. Поэтому денормализацию следует проводить в крайнем случае, если другие меры повышения производительности невозможны. Идеально, если денормализованная БД используется только на чтение.

Кроме того, следует учесть, что ускорение одних запросов на денормализованной БД может сопровождаться замедлением других запросов, которые ранее выполнялись отдельно на нормализованных отношениях.


# Нормальная форма - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных. Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение.


# Cериализация - процесс перевода какой-либо структуры данных в последовательность битов.
# Десериализация - восстановление начального состояния структуры данных из битовой последовательности.
# Идемпоте́нтность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.
*/



>>>>>  ORM <<<<<<<

/*
На основе модели предметной области формируется модель данных в коде. Создаются сущности, определяются их связи. Затем строится рабочий код, который оперирует сущностями, исходя из требований (бизнес-правил). На этом этапе возникает вопрос: а как эти сущности отображаются («маппятся» от англ. "map") на базу данных, ведь именно там в конечном итоге все хранится.

Самый простой вариант — создавать по таблице на каждую сущность и связывать их через внешние ключи. Именно так и делают в большинстве проектов, но не руками, а используя ORM (object-relation mapper). По сути, ORM — фреймворк для данных. С помощью него описываются сущности и их связи, определяется то, как сущность отображается на базу данных (как правило в полуавтоматическом режиме). ORM берет на себя серьезную часть работы по генерации SQL-запросов, по извлечению данных и кастингу (преобразование типов базы данных в типы целевого языка и обратно), по автоматическому извлечению связей. В итоге получается, что ORM прячет всю работу с базой данных (требуя только правильного конфигурирования) и сама выполняет все необходимые запросы. В сложных случаях их все равно приходится писать самостоятельно, но, как минимум, ORM содержат в себе query builder, который упрощает генерацию sql.

В php таких ORM довольно много, некоторые из них разрабатывались под конкретные фреймворки и поставляются с ними. Посмотрим на пример с фреймворком Doctrine2.

Определение сущности Photo
*/

// src/Entity/Photo.php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
/**
 * @ORM\Entity
 * @ORM\Table(name="photos", uniqueConstraints={@ORM\UniqueConstraint(name="photo_slug", columns={"slug"})}))
 */
class Photo
{
	 /**
	  * @ORM\Id
	  * @ORM\Column(name="id", type="integer")
	  * @ORM\GeneratedValue(strategy="AUTO")
	  */
	 protected $id;
	 /**
	  * @ORM\Column(type="string", length=64)
	  */
	 protected $title;
	 /**
	  * @ORM\Column(type="string", length=150)
	  */
	 protected $image;
	 /**
	  * @ORM\Column(type="string", length=100)
	  */
	 protected $slug;
	 
	 /**
	  * Get photo id
	  *
	  * @ORM\return integer
	  */
	 public function getId()
	 {
		  return $this->id;
	 }
	 
	 /**
	  * Get photo title
	  *
	  * @ORM\return string
	  */
	 public function getTitle()
	 {
		  return $this->title;
	 }
	 
	 /**
	  * Get photo slug
	  *
	  * @ORM\return string
	  */
	 public function getSlug()
	 {
		  return $this->slug;
	 }
	 
	 /**
	  * Get photo image
	  *
	  * @ORM\return string
	  */
	 public function getImage()
	 {
		  return $this->image;
	 }
}

// Использование

$app->get('/photos', function () {
	 // Получаем из базы список всех фотографий
	 $photos = $this->entityManager->getRepository('App\Entity\Photo')->findAll();
	 // Передаем их в шаблон
	 return $this->renderer->render($response, "/photos.phtml", ['photos' => $photos]);
});

/*
 * Модель предметной области (или просто Модель) описана с помощью ORM (хотя это не обязательно, хранилище — вещь отдельная от модели).
 * Функция-обработчик обращается к модели для выполнения запрошенных операций и выводит необходимые данные в шаблон.
 * Шаблон описывает представление конкретной страницы и строится на основании данных переданных из функции-обработчика.
*/



>>>>>  MVC <<<<<<<

/*
Описанная выше структура носит гордое имя MVC или Model-View-Controller (обычно добавляют приписку version 2, так как первая версия MVC используется для толстых клиентов, в которых все работает немного по-другому), где M - модель предметной области, C - наша функция обработчик (в других фреймворках могут быть другие сущности), а V - шаблон. MVC разделяет приложение минимум на три слоя и определяет то, как они могут взаимодействовать друг с другом. Это важно для создания модульных приложений, то есть таких, которые легко развивать и модифицировать. При этом никто не запрещает добавлять новые и дробить текущие слои, все это уже зависит от сложности самого приложения.


* MODEL - хранение данных; целостность; консистентность; запросы; мутации
* CONTROLLER - получение, интерполяция и валидация информации; создание и обновление views; запросы в MODEL; изменение MODEL
* VIEW - презентация

MODEL -> CONTROLLER -> VIEW -> User
VIEW-> CONTROLLER -> MODEL
User-> CONTROLLER -> MODEL
* M — ядро приложения. В идеале — чистая бизнес-логика. M не знает ничего о других частях приложения и не может на них влиять.
* C - использует M для выполнения запрашиваемых операций и отвечает за генерацию V.
* V - получает данные от C и иногда от M, но такое не приветствуется. И уж точно V не должен знать ничего о базе данных. Кстати, этим грешат начинающие разработчики, которые выполняют SQL запросы прямо из шаблонов.

MVC является архитектурным шаблоном (или паттерном проектирования).
# Шаблон проектирования в разработке — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. В нашем случае контекст — обработка http-запросов.

Паттернов проектирования очень много на все случаи жизни. Некоторые из них очень простые и ближе к идиомам, то есть каким-то локальным участкам кода, которые принято писать тем или иным способом в конкретном  языке. Некоторые паттерны — всеобъемлющие, подобные MVC. Они определяют глобальные ограничения, но ничего не говорят о способе реализации. В любом случае паттерны — не догма и не формальная спецификация, а значит всегда есть место для самостоятельного выбора.

В MVC заложена довольно простая, но важная идея разделения приложения на слои с четкими границами. Такой подход позволяет развивать каждый слой независимо от других, при условии, что у вас правильно выстроены зависимости между ними. Обратите внимание, что в MVC все связи однонаправленные. Другими словами, в MVC нет двух слоев, которые знают друг о друге одновременно. Если один слой знает о другом, то второй ничего не знает о первом и наоборот. Модульность (в общем случае — абстракция) — это один из ключевых факторов, делающих приложения по настоящему качественными с точки зрения разработки.
*/



>>>>>  Коллекции <<<<<<<

/*
Например, в JavaScript канонический способ работы с коллекциями — функции высшего порядка. Посмотрите внимательно:

// Задача: извлечь имена пользователей, оканчивающиеся на `ya` без учета регистра, и привести имена к нижнему регистру
const users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];

const filteredUsers = users.map(n => n.toLowerCase()).filter(n => n.endsWith('ya'));

Возможность так писать доступна в js из коробки, но php — другое дело. Для эффективной работы вам придется «обмазаться» дополнительными библиотеками. Тогда код на php для той же задачи станет таким:
*/

use Stringy\Stringy as S;
use Illuminate\Support\Collection;

$users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];
$collection = collect($users);
$filteredUsers = $collection->map(function ($n) {
	 return strtolower($n);
})->filter(function ($n) {
	 return s($n)->endsWith('ya');
});



>>>>>  Другое <<<<<<<

/*
# Аутентификация и авторизация
Аутентификация почти целиком построена на сессиях http, то авторизация требует понимания принципов построения списков контроля доступа (ACL). В наиболее продвинутых фреймворках подобная функциональность либо встроена в сам фреймворк, либо существует в виде дополнений, которые если и не покрывают все потребности, то, по крайней мере, дают основу для построения своей системы.

# OAuth
Аутентификация с помощью социальных сетей стала почти также распространена, как и аутентификация по паролю. Чисто технически её реализация значительно сложнее, она основана на протоколе oauth2, который включает в себя общение по API. Опять же, с нуля ничего писать не придется: для работы с OAuth написана не одна библиотека, но это не отменяет необходимости понимать, что творится под капотом.

# Валидация
Валидация — проверка данных на соответствие установленным требованиям (ограничениям).

# Инфраструктура
Пилить фичи — только полдела. Чтобы начать разрабатывать нужно для начала настроить окружение разработчика, используя Docker Compose. Затем, чтобы было куда выкладываться, нужно настроить продакшен-окружение (то, где будет работать сайт) и в конце концов задеплоить (развернуть) туда сайт.

Современная инфраструктура — тоже код, и её нужно программировать. Вот список самых важных программ, созданных для этого: Ansible, Terraform, Docker.
*/



>>>>>  МАССИВЫ <<<<<<<

/**@@@ Реализуйте функцию addPrefix, которая добавляет каждому элементу в массиве переданный префикс. Функция предназначена для работы со строковыми элементами. После префикса автоматически добавляется пробел.
 */

#1:
function addPrefix($names, $prefix)
{
	 $result = [];
	 
	 for ($i = 0; $i < sizeof($names); $i++) {
		  $result[$i] = "{$prefix} {$names[$i]}";
	 }
	 
	 return $result;
}

#2:
function addPrefix($names, $prefix)
{
	 return array_map(function ($name) use ($prefix) {
		  return "{$prefix} {$name}";
	 }, $names);
}



/**@@@
 * Реализуйте функцию reverse, которая располагает значения в обратном порядке без создания нового массива
 */

function reverseArray($coll)
{
	 $size = sizeof($coll);
	 $maxIndex = floor($size / 2);  // округляет дробь в меньшую сторону
	 
	 for ($i = 0; $i < $maxIndex; $i++) {
		  $mirrorIndex = $size - $i - 1;
		  $temp = $coll[$i];
		  $coll[$i] = $coll[$mirrorIndex];
		  $coll[$mirrorIndex] = $temp;
	 }
	 
	 return $coll;
}



/**@@@
 * Реализуйте функцию swap, которая меняет местами два элемента относительно переданного индекса. Например, если передан индекс 5, то функция меняет местами элементы, находящиеся по индексам 4 и 6.
 */

function swap($coll, $center)
{
	 $prevIndex = $center - 1;
	 $nextIndex = $center + 1;
	 $isSwappable = array_key_exists($prevIndex, $coll) && array_key_exists($nextIndex, $coll);
	 
	 if ($isSwappable) {
		  $temp = $coll[$prevIndex];
		  $coll[$prevIndex] = $coll[$nextIndex];
		  $coll[$nextIndex] = $temp;
	 }
	 
	 return $coll;
}


/*
Работая на таких высокоуровневых языках как php, позволительно не знать устройство массивов для решения повседневных задач. С другой стороны, подобное понимание делает код менее магическим и дает возможность заглядывать чуть дальше.

Реальные массивы лучше всего рассматривать на языке C, который, с одной стороны, достаточно простой и понятный, с другой - очень близок к железу и не скрывает от нас практически ничего. Когда мы говорим про примитивные типы данных, такие как "строка" или "число", то, на интуитивном уровне, все довольно понятно. Под каждое значение выделяется некоторый размер памяти (в соответствии с типом), в которой и хранится само значение. А как должна выделиться память под хранение массива? И что такое массив в памяти? На уровне хранения, понятия массив - не существует. Массив представляется цельным куском памяти, размер которого вычисляется по формуле "количество элементов * количество памяти под каждый элемент". Из этого утверждения есть два интересных вывода:

Размер массива - фиксированная величина. Те динамические массивы, с которыми мы имеем дело во многих языках, реализованы уже внутри языка, а не на уровне железа.
Все элементы массива имеют один тип и занимают одно и тоже количество памяти. Благодаря этому появляется возможность простым умножением (по формуле, описанной выше) получить адрес той ячейки, в которой лежит нужный нам элемент. Именно это происходит под капотом, при обращении к элементу массива под определенным индексом.

Фактически индекс в массиве - смещение относительно начала куска памяти содержащего данные массива. Высчитывается он так: "индекс * количество памяти занимаемое одним элементом (для данного типа данных)". Пример на C:

// Инициализация массива из пяти элементов типа int
int mark[] = {19, 10, 8, 17, 9};
mark[3]; // 17

Если предположить, что тип int занимает в памяти 2 байта (зависит от архитектуры), то адрес элемента, соответствующего индексу 3, высчитается так: "начальный адрес + индекс * объем памяти для одного элемента типа int".

Теперь должно быть понятно почему индексы в массиве начинаются с нуля. 0 - означает отсутствие смещения.

# Безопасность
В отличие от высокоуровневых языков, в которых код защищен от выхода за границу массива, в таком языке как C, выход за границу не приводит к ошибкам. Обращение к элементу, индекс которого находится за пределами массива, вернет данные, которые лежат в той самой области памяти, куда его попросили обратиться (в соответствии с формулой выше). Чем они окажутся - никому не известно (но они будут проинтерпретированы в соответствии с типом массива. Если массив имеет тип int, то вернется число). Благодаря отсутствию какой-либо защиты выход за границу массива активно эксплуатируется хакерами для взлома программ.

Еще один распространенный вариант использования циклов на массивах — агрегация. Агрегацией являются любые вычисления, которые строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее.
*/

function calculateMax($coll)
{
	 if (empty($coll)) {
		  return null;
	 }
	 
	 $max = $coll[0];
	 for ($i = 1; $i < sizeof($coll); $i++) {
		  if ($coll[$i] > $max) {
				$max = $coll[$i];
		  }
	 }
	 
	 return $max;
}

print_r(calculateMax([]));
print_r(calculateMax([3, 2, -10, 38, 0]));

/*
Если массив пустой, то возвращаем null. Это классический пример использования идиомы guard expression.

Нейтральный элемент бинарной операции — элемент, который ничего не меняет в результате его использования в бинарной операции. По простому, сложение любого числа с нулем всегда дает это же число. Тогда любую сумму, например 3 + 2 + 8, можно вычислить как 0 + 3 + 2 + 8
*/


/**@@@
 * Реализуйте функцию calculateAverage, которая высчитывает среднее арифметическое элементов массива. В случае пустого массива функция должна вернуть значение null (используйте в коде для этого guard expression)
 */

function calculateAverage($arr) // my
{
	 return empty($arr) ? null : array_sum($arr) / sizeof($arr);
}

function calculateAverage($coll) // hexlet
{
	 if (empty($coll)) {
		  return null;
	 }
	 
	 $sum = 0;
	 foreach ($coll as $item) {
		  $sum += $item;
	 }
	 
	 return $sum / sizeof($coll);
}


/**@@@
 * Реализуйте функцию isContinuousSequence, которая проверяет, является ли переданная последовательность целых чисел - возрастающей непрерывно (не имеющей пропусков чисел). Например, последовательность [4, 5, 6, 7] - непрерывная, а [0, 1, 3] - нет. Последовательность может начинаться с любого числа, главное условие - отсутствие пропусков чисел.
 */

function isContinuousSequence($coll)
{
	 if (empty($coll)) {
		  return false;
	 }
	 
	 $start = $coll[0];
	 
	 foreach ($coll as $i => $item) {
		  if ($start + $i !== $item) {
				return false;
		  }
	 }
	 
	 return true;
}



>>>>>  Удаление элементов массива <<<<<<<

/*
Несмотря на то, что из массива можно удалить элемент, лучше так никогда не делать. Особенно плохо изменять массив во время обхода. Правильный выход из ситуации — создание нового массива. Такой код проще и для понимания и для отладки.

В стандартную библиотеку большинства языков программирования входит функция compact, которая удаляет все null из массива. Вот ее реализация:
*/

function mycompact($coll)
{
	 $result = [];
	 
	 foreach ($coll as $item) {
		  if (!is_null($item)) {
				$result[] = $item;
		  }
	 }
	 
	 return $result;
}

print_r(mycompact([0, 1, false, null, true, 'wow', null]));

/*
Главное, на что нужно обратить внимание, не происходит никаких удалений и модификаций исходного массива. Вместо этого инициализируется новый массив, который наполняется только подходящими под условие значениями. Именно так нужно воспринимать фразу "удалить из массива что-то". Код с созданием нового массива меньше подвержен ошибкам, проще в отладке и оставляет больше возможностей для анализа. Вы всегда можете посмотреть исходный массив, если что-то пошло не так. Вы всегда можете наблюдать за процессом наполнения результирующего массива, что позволит четко отследить правильность поставленных условий.

По сути, код выше — пример агрегации. Только в отличие от предыдущих примеров, в которых  результатом был примитивный тип, здесь результат — массив. Это совершенно нормально. Сама операция прореживания массива обычно называется фильтрацией.
*/



>>>>>  Генерация строки в цикле <<<<<<<

// Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример в вебе, функция-хелпер, помогающая генерировать html списки в шаблонах. Она принимает на вход коллекцию элементов и возвращает список из них:

$coll = ['milk', 'butter', 'eggs', 'bread'];
buildList($coll); // => <ul><li>milk</li><li>butter</li><li>eggs</li><li>bread</li></ul>

// Самый примитивный алгоритм, который приходит в голову. Пройтись циклом по элементам коллекции и дописать в результирующую строку очередной li элемент. В начале и конце добавить ul и вернуть строчку наружу.

$result = '';

foreach ($coll as $item) {
	 $result .= "<li>{$item}</li>";
	 // либо так
	 // $result = "{$result}<li>{$item}</li>";
}

$result = "<ul>{$result}</ul>";

// Такой способ вполне рабочий, но для большинства языков программирования максимально не эффективный. Дело в том, что конкатенация и интерполяция порождают новую строчку вместо старой и подобная ситуация повторяется на каждой итерации. Причем строка становится все больше и больше. Копирование строк приводит к серьезному расходу памяти и может влиять на производительность. Конечно, для большинства приложений данная проблема не актуальна из-за малого объема прогоняемых данных, но более эффективный подход не сложнее в реализации и обладает дополнительными плюсами. Поэтому стоит сразу приучить себя работать правильно и никогда больше не возвращаться к этому вопросу. В статических языках для подобной цели используется так называемый String Buffer. В динамических — обычный массив. Перепишем программу выше, используя новое знание:

$coll = ['milk', 'butter', 'eggs', 'bread'];
$parts = []; // переименовал для того, чтобы не менять значения переменной

foreach ($coll as $item) {
	 $parts[] = "<li>{$item}</li>";
}

$innerValue = implode("\n", $parts);
$result = "<ul>{$innerValue}</ul>";

/*
Как видите, код не сильно поменялся. Разница в том, что теперь собирается массив вместо строки, и в конце он собирается в строку с помощью implode. Помимо эффективности у такого подхода есть дополнительные плюсы:
 * Такой код проще отлаживать и анализировать внутренности
 * Массив можно дообработать, если надо, а строчку — уже нет
*/


/**@@@
 * Реализуйте функцию buildDefinitionList, которая генерирует html список определений (теги dl, dt и dd) и возвращает получившуюся строку.
 *
 * Параметры функции:
 * Список определений следующего формата:
 */
$definitions = [
	['definition1', 'description1'],
	['definition2', 'description2']
];

// Пример:
$definitions = [
	['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
	['Бобр', 'Животное из отряда грызунов']
];

buildDefinitionList($definitions);
// => '<dl><dt>Блямба</dt><dd>Выпуклость, утолщение на поверхности чего-либо</dd><dt>Бобр</dt><dd>Живтоное из отряда грызунов</dd></dl>';


function buildDefinitionList(Array $definitions)
{
	 $parts = [];
	 
	 foreach ($definitions as [$name, $description]) {
		  $parts[] = "<dt>{$name}</dt><dd>{$description}</dd>";
	 }
	 $innerValue = implode('', $parts);
	 $result = "<dl>{$innerValue}</dl>";
	 
	 return $result;
}



>>>>>  Обработка строк через преобразование в массив <<<<<<<

/*
Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. На любые хитрые вопросы «а есть ли в строке знаки препинания» ответ — выбирайте самый простой случай для обработки.

Решить её можно достаточно большим количеством способов. Чем больше называет человек, тем лучше. К ним относятся:

* Посимвольный перебор строки. Эта задачка может быть решена двумя способами. Один из которых связан с использованием конечных автоматов.
* Регулярные выражения.
* Через преобразование в массив. Этот способ тоже распадается на два. Одно решение через функции высших порядков или решение через цикл.
*/

function capitalizeWords($sentence)
{
	 $words = explode(' ', $sentence);
	 
	 for ($i = 0; $i < sizeof($words); $i++) {
		  $words[$i] = ucfirst($words[$i]);
	 }
	 
	 return implode(' ', $words);
}


// В случае, если строчку нужно разбить по символам, а не по словам, можно воспользоваться функцией str_split.
$chars = str_split($text);
foreach ($chars as $char) {
	 print_r($char);
}

// str_split принимает второй параметр, в котором можно указать количество символов в каждой группе (элементе получившегося массива). По умолчанию используется число 1, поэтому мы получаем массив, в котором каждый элемент — один символ. Но, если указать, например, 3, то в каждом элементе массива будет по три символа.

$text = 'Hello Friend';
$arr2 = str_split($str, 3); // ->
/*
[0] => Hel
[1] => lo
[2] => Fri
[3] => end
*/


/**@@@
 * Реализуйте функцию makeCensored, которая заменяет каждое вхождение указанного слова в предложении на последовательность $#%! и возвращает полученную строку. Аргументы:
 * Текст / Слово
 * Словом считается любая непрерывная последовательность символов, включая любые спецсимволы.
 */

function makeCensored(string $text, $stopWord) // hexlet
{
	 $words = explode(' ', $text);
	 $result = [];
	 
	 foreach ($words as $word) {
		  $result[] = ($word === $stopWord) ? '$#%!' : $word;
	 }
	 
	 return implode(' ', $result);
}



>>>>>  Вложенные циклы <<<<<<<

// Во многих языках программирования есть очень полезная функция flatten. В определенных задачах она сильно упрощает жизнь и сокращает количество кода. flatten принимает на вход массив и выправляет его: если элементами массива являются массивы, то flatten сводит все к одному массиву, раскрывая каждый вложенный. Посмотрим на пример:

flatten([[3, 2], 5, 3, [3, [4, 2]], 10]); // => [3, 2, 5, 3, 3, 4, 2, 10]


// Давайте напишем функцию flatten. В общем случае эта функция раскрывает массивы на всех уровнях вложенности. Но мы для простоты сделаем вариант функции, в котором происходит раскрытие только до первого уровня. То есть, если элемент основного массива — массив, то он раскрывается без просмотра его внутренностей (там тоже могут быть массивы).

function flatten($coll)
{
	 $result = [];
	 
	 foreach ($coll as $item) {
		  if (!is_array($item)) {
				$result[] = $item;
		  } else {
				foreach ($item as $subitem) {
					 $result[] = $subitem;
				}
		  }
	 }
	 
	 return $result;
}

/*
Вложенные циклы коварны. Их наличие может резко увеличить сложность кода и в особо тяжелых случаях значительно замедлить его. В тех местах, где можно от них избавиться, лучше от них избавляться.

Для реализации функции flatten лучше использовать слияние массивов, которое мы рассмотрим в одном из следующих уроков. Если же от вложенных массивов уйти не получается, то с высокой вероятностью вложенный цикл можно вынести в отдельную функцию.
*/

function concat($result, $items)
{
	 foreach ($items as $item) {
		  $result[] = $item;
	 }
	 
	 return $result;
}

function flatten($coll)
{
	 $result = [];
	 
	 foreach ($coll as $item) {
		  if (is_array($item)) {
				$result = concat($result, $item)
		} else {
				$result[] = $item;
		  }
	 }
	 
	 return $result;
}


/**@@@
 * Реализуйте функцию getSameCount, которая считает количество общих уникальных элементов для двух массивов. Аргументы: Первый массив / Второй массив
 */

function getSameCount($coll1, $coll2)
{
	 $count = 0;
	 $uniqColl1 = array_unique($coll1);
	 $uniqColl2 = array_unique($coll2);
	 
	 foreach ($uniqColl1 as $item1) {
		  foreach ($uniqColl2 as $item2) {
				if ($item1 === $item2) {
					 $count++;
				}
		  }
	 }
	 
	 return $count;
}



>>>>>  Теория Множеств <<<<<<<

/*
Множеством обозначают совокупность объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество арабских цифр включает в себя 10 элементов и является конечным. Понятие конечности носит интуитивный характер и обозначает, что в множестве конечное число элементов.

Пример бесконечного множества — натуральные числа. В свою очередь множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее.

«Подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством (по отношению к подмножеству).

Главное для нас в теории множеств — операции над ними. К ним относятся: дополнение, объединение, пересечение, разность, декартово произведение и некоторые другие.

Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

Переходя к программированию, можно заметить, что массив очень похож на множество, и его действительно можно так рассматривать. Почему это так важно? Понимая принципы, на которых основаны некоторые операции, вы сможете реализовывать их наиболее быстрым и эффективным способом. Например, зная, что вам нужна операция пересечения множеств в php, вы можете попытаться найти функцию, которая делает поставленную задачу. Для этого достаточно ввести в гугл запрос: php set intersect (set — множество, intersect — пересечение). Первая (по крайней мере, у меня) ссылка в поисковой выдаче ведет на нужную функцию array_intersect. Тоже самое вас ждет и с другими операциями.

Отдельно стоит сказать, что реляционные базы данных построены на идеях реляционной алгебры, в которой теория множеств играет центральную роль.
*/


// Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.
$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

array_intersect($friends1, $friends2); // => ['vasya', 'petya'] // Эта функция принимает любое количество массивов. То есть вы можете находить пересечение любого количества массивов за один вызов.

// Объединением множеств называется множество, в которое входят элементы всех данных множеств. Объединение множеств в php нельзя сделать одним вызовом, но его можно имитировать, соединив две функции:

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

// merge выполняет слияние двух массивов, в отличие от объединения, в нем повторяются элементы которые встречаются там и там (а не должны)
$friends = array_merge($friends1, $friends2);
// => ['vasya', 'kolya', 'petya', 'igor', 'petya', 'sergey', 'vasya', 'sasha'];

// unique удаляет дубли
$sharedFriends = array_unique($friends);
// => ['vasya', 'kolya', 'petya', 'igor', 'sergey', 'sasha']

// Дополнение (разность). Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется diff.
$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];
array_diff($friends1, $friends2); // => ['kolya']

// Принадлежность множеству. Проверку принадлежности элемента множеству можно выполнить с помощью функции in_array:
$terribleNumbers = [4, 13];

if (in_array(10, $terribleNumbers)) {
	 print_r('woah!');
}


/**@@@
 * Реализуйте функцию countUniqChars, которая считает количество уникальных символов в переданной строке. Если передана пустая строка, то функция должна вернуть 0, т.к. пустая строка вообще не содержит символов. Задание необходимо выполнить без использования функции array_unique.
 */

function countUniqChars($text)
{
	 if ($text === '') {
		  return 0;
	 }
	 
	 $uniqChars = [];
	 $chars = str_split($text);
	 
	 foreach ($chars as $char) {
		  if (!in_array($char, $uniqChars)) {
				$uniqChars[] = $char;
		  }
	 }
	 
	 return count($uniqChars);
}



>>>>>  Сортировка массивов <<<<<<<

function bubbleSort(array $arr) // пузырьковая сортировка
{
	 $size_arr = sizeof($arr);
	 
	 do {
		  $flag = false;
		  
		  for ($i = 0; $i < $size_arr - 1; $i++) {
				if ($arr[$i] > $arr[$i + 1]) {
					 $curr_val = $arr[$i];
					 $arr[$i] = $arr[$i + 1];
					 $arr[$i + 1] = $curr_val;
					 $flag = true;
				}
		  }
		  
		  $size_arr--;
		  
	 } while ($flag);
	 
	 return $arr;
}

/*
Весь код делится на два уровня:

* Внутренний цикл for, который проходит по массиву от начала до конца, меняя элементы попарно, если нужно сортировать.
* Внешний цикл while..do, определяющий, когда нужно остановиться. Обратите внимание, что в худшем случае этот цикл выполнится sizeof($arr) раз, что совпадает с теоретическим худшим случаем этого алгоритма, при котором самый большой или маленький элемент находятся в противоположных конце массива от сортированного варианта.
*/



>>>>>  Ссылки <<<<<<<

/*
Большинство функций, работающих с массивами, после обработки возвращают новый массив. Но некоторые работают по-другому.
В этих функциях, как правило, не используется возврат. Они меняют исходный массив напрямую за счет использования ссылок. К таким функциям, например, относится функция сортировки:
*/

$arr = [3, 8, 1];

sort($arr);
print_r($arr);

// Несмотря на то, что подход, меняющий массивы напрямую, сложнее в отладке, его используют в некоторых языках для увеличения эффективности работы. Если массив достаточно большой, то полное копирование окажется дорогой операцией. В реальной жизни (веб разработчика) это почти никогда не проблема, но знать об этом полезно.



>>>>>  Структура данных <<<<<<<

/*
Структура данных — это конкретный способ хранения и организации данных. В зависимости от решаемых задач, удобным оказывается либо один способ организации данных, либо другой. Как минимум, одну структуру данных вы уже знаете достаточно хорошо — это массив. С точки зрения организации, массив представляет собой совокупность элементов, к которым имеется индексированный доступ (доступ по индексу), а вот с точки зрения хранения — все сложнее. Массивы бывают разные и внутри языка реализуются тоже по-разному.

Каноническая организация хранения массива — непрерывный блок памяти. А индекс в таком случае играет роль смещения по ней. Именно поэтому индексация в массивах начинается с нуля, так как указывает на начало этого блока, а индекс под номером 1 уже является смещением. Но на практике все сложнее. В PHP нет настоящих массивов.

Кроме массивов существует множество других структур данных, таких как списки, хеш-таблицы, деревья, графы, стек, очередь и другие. Использование структуры данных, подходящей под решаемую задачу, позволяет кардинально упростить код, устраняя запутанную логику.

Стоит разделять три понятия:
 * Структура данных
 * Конкретный тип данных (или просто «тип данных»)
 * Абстрактный тип данных
 
Со структурой данных все понятно, выше было определение. С типом данных тоже все просто. Например, массив в PHP — это тип данных. Понятие «тип данных» всегда привязано к конкретному языку и может быть абсолютно чем угодно в зависимости от предпочтений разработчиков языка. Другими словами если бы разработчики PHP решили, что числа надо назвать типом данных Array, то никто бы им этого не запретил, несмотря на абсурдность такого имени для чисел. Кроме встроенных типов данных, бывают и пользовательские.

А вот АТД — теоретическое понятие. АТД целиком и полностью определяется набором операций, которые можно выполнять над ним. АТД абстрактный потому, что он ничего не говорит о способе хранения и существует лишь на бумаге и в головах. А вот уже в конкретных языках существуют конкретные типы, реализующие АТД.

АТД нередко путают с понятием «структура данных», более того, часто, структуры данных и АТД имеют одно и тоже название.
*/



>>>>> Стек <<<<<<<

/*
Стек — упорядоченная коллекция элементов, в которой добавление новых и удаление старых элементов всегда происходит с одного конца коллекции. Обычно его называют вершиной стека.

У стека есть аналоги из реальной жизни. Слово stack, с английского, переводится как «стопка». По сути, любая стопка может рассматриваться как стек. Если не применять грубую физическую силу, то со стопками мы работаем двумя способами. Либо кладем новый элемент (например, книгу) на верхушку стопки, либо снимаем элемент с верхушки. Еще более показательный пример — магазин в огнестрельном оружии. Первый заложенный патрон выйдет из магазина последним. Поэтому стек еще называют "Last In First Out" (LIFO), то есть "последний зашел, первый вышел".

Перед тем, как разбирать конкретную задачу, я покажу вам, что стек играет огромную роль в программировании. Вспомните, как исполняется любая программа. Одни функции вызывают другие, которые, в свою очередь, вызывают третьи, и так далее. После того, как выполнение заходит в самую глубокую функцию, та возвращает значение, и начинается обратный процесс. Сначала идет выход из наиболее глубоких функций, затем из тех, что уровнем выше, и так далее до тех пор, пока не дойдет до самой внешней функции. Вызов функций — ничто иное, как добавление элемента в стек, а возврат — снятие со стека. Именно так всё устроено на аппаратном уровне. К тому же, если в процессе выполнения программы происходит ошибка, то её вывод часто называют Stack Trace (трассировка стека).

Другой пример, связанный с программированием — кнопка «назад» в браузере. История посещений представляет собой стек, каждый новый переход по ссылке добавляет её в историю, а кнопка «назад» извлекает из стека последний элемент.


Стек — абстрактный тип данных со следующим набором операций:
 * Добавить в стек (push)
 * Взять из стека (pop)
 * Вернуть элемент с вершины стека без удаления (peek)
 * Проверить на пустоту (isEmpty)
 * Вернуть размер (size)
 
В PHP стек можно построить на основе массивов. Для этого используется следующий набор функций: array_push, array_pop, empty, sizeof.

Обратите внимание, что array_pop и array_push изменяют исходный массив. array_pop не только изменяет его, но и возвращает элемент, снятый со стека.

Рассмотрим задачку, решение которой тривиально при использовании стека.


Задача:
Необходимо реализовать функцию, которая проверяет, что парные символы сбалансированы. То есть каждый открывающий символ имеет закрывающий, и они не перекрываются, например так [{]}. К таким символам в нашем случае относятся <>, {}, () []. Входом в функцию может быть ()<>{}. Такой пример проходит проверку, а вот этот уже нет: [({)}]. Здесь происходит перекрытие фигурных и круглых скобок.

Решение со стеком выглядит так:

Если перед нами открывающий элемент, то заносим его в стек
Если закрывающий, то достаем из стека элемент (очевидно, последний добавленный) и смотрим, что он открывающий для данного закрывающего. Если проверка провалилась, значит выражение не соответствует требуемому формату.
Если мы дошли до конца строки и стек пустой, то все хорошо. Если в стеке остались элементы, то проверка не прошла. Такое может быть, если в начале строки были открывающие элементы, но в конце не было закрывающих.
Разберем его построчно:
*/

function checkIfBalanced(string $expression): boolean
{
	 $stack = [];
	 $startSymbols = ['{', '(', '<', '['];
	 $pairs = ['{}', '()', '<>', '[]'];
	 
	 for ($i = 0; $i < strlen($expression); $i++) {
		  $curr = $expression[$i];
		  
		  if (in_array($curr, $startSymbols)) {
				array_push($stack, $curr);
		  } else {
				$prev = array_pop($stack);
				$pair = "{$prev}{$curr}";
				
				if (!in_array($pair, $pairs)) {
					 return false;
				}
		  }
	 }
	 
	 return sizeof($stack) == 0;
}

/*
Предположим, что на вход функции попала следующая строка: [{]. Ниже описание ключевых шагов при выполнении функции проверки:

 * Первый символ [ заносится в стек, так как он входит в список открывающих
 * Символ { также заносится в стек по той же самой причине
 * Символ ] относится к закрывающим, поэтому со стека забирается последний символ {. Из них составляется пара {], которая не проходит проверку.
 

# Семантика
Может возникнуть соблазн использовать эти функции в повседневной практике. Например, чтобы извлечь из массива последний элемент. Несмотря на то, что array_pop действительно позволяет это сделать, такой вариант использования крайне нежелателен по нескольким причинам:

Побочный эффект данной операции — изменение исходного массива. Даже если далее массив не используется, такой код вносит потенциальные проблемы и заставляет его переписывать в будущем.
Нарушается семантика. Инструменты нужно использовать по назначению, иначе рождается код, который декларирует одно, но в реальности делает другое. Любой опытный программист, который видит array_pop или array_push сразу считает, что массив в данной части программы используется как стек, но на самом деле он этого не делает. Подобный код заставляет напрягаться и анализировать его лишний раз для понимания сути.
 */
 
/**@@@
 * Реализуйте функцию checkIfBalanced, которая проверяет балансировку круглых скобок в арифметических выражениях.
 */

function checkIfBalanced(string $expression): bool
{
	 // инициализируем стек
	 $stack = [];
	 
	 for ($i = 0; $i < strlen($expression); $i++) {
		  $curr = $expression[$i];
		  if ($curr == '(') {
				array_push($stack, $curr);
		  } elseif ($curr == ')') {
				if (empty($stack)) {
					 return false;
				}
				
				array_pop($stack);
		  }
	 }
	 
	 // !Если стек оказался пустой после обхода строки, то значит все хорошо
	 return sizeof($stack) == 0;
}



>>>>>  Big O <<<<<<<

/*
Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» и нотация О-большое (Big O notation). Она не только полезна при прохождении собеседований, но и даёт понимание того, как вообще оценивать эффективность кода (очень относительно).

Как вы помните, алгоритмов сортировок существует много, я бы сказал очень много. Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом (или классифицируются) по их вычислительной (или алгоритмической) сложности. Сложность оценивается по количеству выполняемых операций. Понятно, что конкретное количество операций зависит от входных данных, например, если массив отсортирован, то количество операций будет минимальным (но они все равно будут, потому что алгоритм должен убедиться в том, что массив отсортирован). Если не отсортирован, то для каждого алгоритма можно подобрать такие входные данные, при которых он будет работать максимально долго и не эффективно. Эти случаи называют соответственно верхней и нижней границей.

Нотация Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Вот некоторые примеры того, как записывается сложность: O(1), O(n), O(nlog(n)).

O(1) описывает так называемую константную сложность. Например обращение к элементу массива по индексу оценивается константой, другими словами оно не зависит от размера массива, поэтому внутри O записывается единица, символизирующая константу. А вот функция, которая печатает на экран все элементы переданного массива используя обычный перебор имеет сложность O(n) (линейная сложность). То есть количество выполняемых операций будет равно количеству элементов массива. Именно это количество символизирует символ n в скобках.

Еще один простой пример — вложенные массивы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью функции in_array, чья сложность O(n), ведь в худшем случае она просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны n, то получается, что поиск пересечений имеет квадратичную сложность или O(n^2) (n в квадрате). Существуют как очень эффективные, так и абсолютно не эффективные алгоритмы. Первые, как правило имеют логарифмическую сложность, последние — степенную, такую, при которой n находится в степени. Скорость работы подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов.

Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность паралеллиться (и если это происходит, то работают крайне эффективно). Как и все в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

Big O, во многом, теоретическая оценка, на практике всё может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых, архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет, потому что работает с небольшим объемом памяти, а где-то в это время есть другой кусок, который вызывается тысячи раз, и приводит к реальному замедлению.

Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд Кнут
*/

// Поиск пересечения двух неотсортированных массивов, операция в рамках которой выполняется вложенный цикл с полной поверкой каждого элемента первого массива, на вхождение во второй. Сложность данного алгоритма O(nm) (проивезедение n и m), где n и m размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше. Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идет проверка элементов находящихся под этими индексами в обоих массивах. Если они совпадают то значение заносится в результирующий массив, а оба индекса инкрементируются, если значение в первом массиве больше чем во втором, то инкрементируется указатель второго массива, иначе первого.


function getIntersectionOfSortedArray($arr1, $arr2)
{
	 $result = [];
	 $i1 = 0;
	 $i2 = 0;
	 $size1 = sizeof($arr1);
	 $size2 = sizeof($arr2);
	 
	 if ($size1 == 0 || $size2 == 0) {
		  return [];
	 }
	 
	 do {
		  if ($arr1[$i1] == $arr2[$i2]) {
				$result[] = $arr1[$i1];
				$i1++;
				$i2++;
		  } elseif ($arr1[$i1] > $arr2[$i2]) {
				$i2++;
		  } else {
				$i1++;
		  }
	 } while ($i1 < $size1 && $i2 < $size2);
	 
	 return $result;
}

# Разновидности Big O:
/*
В порядке убывания скорости выполнения:
> O(log n), или логарифмическое время. Пример: бинарный поиск.
> 0(n), или линейное время. Пример: простой поиск.
> O(n * log n). Пример: эффективные алгоритмы сортировки (быстрая сортировка)
> O (n2). Пример: медленные алгоритмы сортировки (сортировка выбором)
> O(n!). Пример: очень медленные алгоритмы.
*/



>>>>>  Destructuring <<<<<<<
/*
В программировании часто встречается понятие «синтаксический сахар». Им обозначают конкретные конструкции в языках программирования, которые упрощают часто используемые операции, делая их синтаксически проще.

PHP не богат на подобные конструкции, но кое-что все же имеется.

Самый простой пример сахара — обмен переменных местами. Обычно для этого используют третью переменную (хотя те, кто сильны в теории, скажут и о XOR варианте обмена):
*/

$a = 5;
$b = 8;

$temp = $a;
$a = $b;
$b = $temp;

// Довольно утомительное занятие. А вот как можно сделать короче:
$a = 5;
$b = 8;

list($b, $a) = [$a, $b];
[$b, $a] = [$a, $b]; // c версии 7.1

// Не так круто, как в других языках, где можно писать a, b = b, a, но уже что-то.

// Другой интересный пример синтаксического сахара — destructuring (дестракчеринг или деструктуризация). Представьте, что у нас есть массив из двух элементов, которыми мы хотим оперировать в нашей программе. Самый простой вариант использования — постоянное обращение по индексу $arr[0] и $arr[1]. Такой код не очень хорошо читается, потому что надо понять, что это такое. Поэтому гораздо лучше сначала присвоить эти значения переменным с хорошими именами. Тогда код будет выглядеть так:
$firstName = $arr[0];
$lastName = $arr[1];

// Как видно, код стал значительно понятнее без лишних слов. Дестракчеринг позволяет извлекать элементы из составной структуры, используя особый синтаксис:
[$firstName, $lastName] = $arr;

/*
Получилось и короче и понятнее (особенно если привыкнуть к этому способу записи). Пример с обменом переменных тоже построен на дестракчеринге. Обратите внимание, что справа от = фактически был создан массив [$a, $b]. Дестаркчеринг работает для любого количества элементов и не только с массивами.

Разложение массива можно использовать не только как отдельную инструкцию в коде, но и, например, в циклах:
*/
$points = [[4, 3], [0, -3]];

foreach ($points as [$x, $y]) {
	 print_r([$x, $y]);
}

// =>
Array
(
	[0] => 4
	[1] => 3
)
Array
(
	[0] => 0
	[1] => -3
)


// Напишем функцию, считающую количество вхождений каждого слова в предложение. Результатом работы этой функции является ассоциативный массив, в котором ключ — "слово", а значение — "количество вхождений". Пример:

function getWordsCount($content)
{
	 $result = [];
	 $words = explode(' ', $content);  // Разбиваем на слова
	 
	 foreach ($words as $word) {
		  if (!array_key_exists($word, $result)) {
				$result[$word] = 1; // Инициализация при первом упоминании
		  } else {
				$result[$word]++;
		  }
	 }
	 
	 return $result;
}


/**@@@
 * Реализуйте функцию getIn, которая извлекает из массива (который может быть любой глубины вложенности) значение по указанным ключам. Аргументы: Исходный массив / Массив ключей, по которым ведется поиск значения. В случае, когда добраться до значения невозможно, возвращается null.
 */

function getIn(array $data, array $keys)
{
	 $current = $data;
	 
	 foreach ($keys as $key) {
		  if (!is_array($current) || !array_key_exists($key, $current)) {
				return null;
		  }
		  
		  $current = $current[$key];
	 }
	 
	 return $current;
}


// Реализуем функцию findKeys, которая возвращает список ключей массива, значение которых равно переданному значению:
$lessonMembers = [
	'syntax' => 3,
	'using' => 2,
	'foreach' => 10,
	'operations' => 10,
	'destructuring' => 2,
	'array' => 2,
];

$result = findKeys($lessonMembers, 10);
// => ['foreach', 'operations']

$result = findKeys($lessonMembers, 3);
// => ['syntax']

function findKeys(array $data, $expectedValue)
{
	 $result = [];
	 
	 foreach ($data as $key => $value) {
		  if ($value === $expectedValue) {
				$result[] = $key;
		  }
	 }
	 
	 return $result;
}


/**@@@
 * Реализуйте функцию pick, которая извлекает из переданного массива все элементы по указанным ключам и возвращает новый массив. Аргументы: Исходный массив / Массив ключей, по которым должны быть выбраны элементы (ключ и значение) из исходного массива, и на основе выбранных данных сформирован новый массив
 */

function pick(array $arr, array $keys)
{
	 $res = [];
	 
	 foreach ($keys as $key) {
		  if (array_key_exists($key, $arr)) {
				$res[$key] = $arr[$key];
		  }
	 }
	 
	 return $res;
}



>>>>>  Популярные функции для работы с ассоциативными массивами <<<<<<<

// Функция array_keys извлекает из ассоциативного массива ключи и создает из них массив.

$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data); // => ['first_name', 'last_name']

// Типичное применение данной функции в языках отличных от PHP — обход ассоциативного массива:

$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data);
foreach ($keys as $key) {
	 print_r($data[$key]);
}

// В PHP то же самое самое делается прямым обходом ассоциативного массива, но знать про функцию все равно полезно. Например, в JSON (как и в языках, отличных от PHP) массив и ассоциативный массив — разные типы данных.

{
	 "autoload": {
	 "files": [
		 "src/Arrays.php"
	 ]
  },
  "config": {
	 "vendor-dir": "/composer/vendor"
  }
}

// Выше files — обычный массив, а config — ассоциативный.


// Функция array_VALUES извлекает из ассоциативного массива значения и создает из них массив.


$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_values($data); // => ['Mark', 'Smith']

/*
array_merge
Наиболее интересная функция — array_merge или так называемое слияние. Слияние двух массивов порождает новый массив, в котором поверх первого массива накладывается второй по следующим правилам:

* Если в первом массиве есть ключ, которого нет во втором, то он остается
* Если в первом и во втором массиве есть один и тот же ключ, то его значением становится значение из второго массива
* Если в первом массива нет ключа, который есть во втором, то он добавляется.

Операция слияния не коммутативна, так же, как и вычитание. Изменение порядка аргументов (перемена массивов) приведет к другому результату.
*/

$data1 = [
	'first_name' => 'Mark',
	'last_name' => 'Polo',
];

$data2 = [
	'last_name' => 'Brin',
	'age' => 15,
];

$result = array_merge($data1, $data2);
// => [
//     'first_name' => 'Mark',
//     'last_name' => 'Brin',
//     'age' => 15,
// ]

// Иногда в программировании возникает задача поиска разницы между двумя наборами данных, такими как ассоциативные массивы. Например, при поиске различий в json файлах. Для этого даже существуют специальные сервисы, например, http://www.jsondiff.com/ (попробуйте нажать на ссылку sample data и затем кнопку Compare).

/*
Реализуйте функцию genDiff, которая возвращает ассоциативный массив, в котором каждому ключу из исходных массивов соответствует одно из четырех значений: added, deleted, changed или unchanged. Аргументы:

* Ассоциативный массив
* Ассоциативный массив
* Расшифровка:

* Added - ключ отсутствовал в первом массиве, но был добавлен во второй
* Deleted - ключ был в первом массиве, но отсутствует во втором
* Changed - ключ присутствовал и в первом и во втором массиве, но значения отличаются
* Unchanged - ключ присутствовал и в первом и во втором массиве с одинаковыми значениями

$result = genDiff(
	  ['one' => 'eon', 'two' => 'two', 'four' => true],
	  ['two' => 'own', 'zero' => 4, 'four' => true]
);

// => [
//     'one' => 'deleted',
//     'two' => 'changed'
//     'zero' => 'added',
//     'four' => 'unchanged',
// ];

*/

function union(array $data1, array $data2)
{
	 return array_unique(array_merge($data1, $data2));
}

function genDiff(array $data1, array $data2)
{
	 $keys = union(array_keys($data1), array_keys($data2));
	 $result = [];
	 
	 foreach ($keys as $key) {
		  if (array_key_exists($key, $data1) && array_key_exists($key, $data2)) {
				if ($data1[$key] === $data2[$key]) {
					 $result[$key] = 'unchanged';
				} else {
					 $result[$key] = 'changed';
				}
		  } elseif (array_key_exists($key, $data2)) {
				$result[$key] = 'added';
		  } elseif (array_key_exists($key, $data1)) {
				$result[$key] = 'deleted';
		  }
	 }
	 
	 return $result;
}



>>>>>  Destructuring <<<<<<<

// Напомню, что деструктуризация (дестракчеринг) — специальный синтаксис, позволяющий извлекать части из составных данных. Самый простой пример, который мы рассмотрели, заключается в извлечении значений массива состоящего из двух элементов.

[$firstName, $lastName] = $arr;

// На части можно раскладывать не только индексированные, но и ассоциативные массивы, извлекая из них значения по определенным ключам.

$person = ['first' => 'Rasmus', 'last' => 'Lerdorf', 'manager' => true];

// Порядок извлечения не важен

['last' => $lastname, 'first' => $firstname] = $person;

// Теперь переменные $lastname и $firstname содержат соответствующие значения. Имена самих переменных выбираются произвольно, главное — совпадение по ключам.
// PHP допускает вложенный дестракчеринг. С помощью него можно получать значения не только внешнего массива, но и вложенных.

$options = ['enabled' => true, 'compression' => ['algo' => 'gzip']];

[
	'enabled' => $enabled,
	'compression' => [
		'algo' => $compressionAlgo
	]
] = $options;

// Дестракчеринг ассоциативного массива можно комбинировать с дестракчерингом индексированного.

$x = ['o' => [1, 2, 3]];
['o' => [$a, $b, $c]] = $x;

$y = ['o' => [[1, 2, 3], ['what' => 'WHAT']]];
['o' => [[$one, $two, $three], ['what' => $what]]] = $y;

// Дестракчеринг допустим и в циклах:

$persons = [
	['first' => 'Rasmus', 'last' => 'Lerdorf'],
	['first' => 'Fabien', 'last' => 'Potencier'],
	['first' => 'Taylor', 'last' => 'Otwell']
];

foreach ($persons as ['first' => $firstname, 'last' => $lastname]) {
	 var_dump($firstname, $lastname);
} // =>
/*
string(6) "Rasmus"
string(7) "Lerdorf"
string(6) "Fabien"
string(9) "Potencier"
string(6) "Taylor"
string(6) "Otwell"
*/

// Extract
// Кроме описанного выше, в PHP существует еще один способ дестракчеринга, который на первый взгляд кажется проще. Вызов функции extract с переданным ассоциативным массивом приводит к тому, что создаются переменные с именами ключей, в которые записываются значения из массива.


$vars = [
	'color' => 'blue',
	'size' => 'medium',
	'shape' => 'sphere'
];
extract($vars);

var_dump($color, $size, $shape); // => string(4) "blue" string(6) "medium" string(6) "sphere"

/*
Ни в одном другом популярном языке нет возможности создать переменные без явного определения переменных. Данный способ обладает массой недостатков и не рекомендуется к использованию. Перечислим их:

* Переменные всегда создаются для всех ключей массива. Они засоряют локальное окружение и могут приводить к ошибкам если пересекутся с названиями уже существующих переменных.
* Безопасность. Если содержимое массива приходит извне (из формы или базы данных), то есть потенциальная вероятность попадания в массив ключа, который приведет к перезаписыванию значения существующей переменной.
* Неявное создание переменных вообще само по себе странная вещь (и нигде не встречается!). Такой код значительно сложнее в анализе.
*/



>>>>>  Хеш - таблицы <<<<<<<

/*
Ассоциативный массив — абстрактный тип данных. У него есть и другие названия: «словарь», «мап». В разных языках ему соответствуют разные типы данных, названия которых имеют мало общего с названием ADT. Например:

Ruby - Hash
Lua - Table
Python - Dictionary
JS - Object
Elixir/Java - Map

Ассоциативный массив, в отличие от индексированного массива, нельзя положить в память «как есть». Непонятно, как хранить ключи и связывать их со значениями. Для реализации ассоциативных массивов используют, так называемые, хеш-таблицы.

Хэш-таблица — это структура данных, реализующая интерфейс ассоциативного массива. Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. Независимо от выбранного варианта, основа любой хеш-таблицы — индексированный массив, в котором и хранится вся информация и хеширование, о котором мы поговорим ниже. Остальная логика сводится к разрешению коллизий.

Хеширование
Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс массива. Именно так производятся все операции. Сначала вычисляется индекс на основе ключа, дальше туда либо записываются данные, либо читаются.

Преобразование ключа в индекс массива выполняется с помощью хеширования. Хеширование — операция, которая преобразует любые входные данные в строку фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой».

С хешированием мы встречаемся в разработке крайне часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 ни что иное, как хеш, полученный в результате хеширования.

Самый простой способ хешировать данные на PHP — использовать функцию crc32:
*/

$checksum = crc32('The quick brown fox jumped over the lazy dog.'); // => 2191738434

/*
И хотя хеширование позволяет отображать ассоциативный массив на обычный массив, оно не лишено недостатков, с которыми нужно уметь работать.

Коллизии
Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и состава). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат любой хешируемой функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

Из этого факта следует, что не для всех входных данных найдется уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.

Коллизии не так редки, как может показаться. Убедиться в этом можно изучив парадокс дней рождений (https://ru.wikipedia.org/wiki/Парадокс_дней_рождения).
*/



>>>>>  Массив и Ассоциативный Массив <<<<

/*
В PHP есть только один тип данных для массивов — Array. Его уникальность заключается в том, что с одной стороны он работает как обычный массив, а с другой — как ассоциативный. Зависит от того, как его используют.

Поначалу такой подход может подкупить своей кажущейся простотой, особенно тех, кто не имел дела с другими языками. Но чем дальше в код, тем больше проблем он приносит.

Самый простой пример — JSON. В JSON массив и ассоциативный массив — разные сущности. Если конвертировать JSON в массив, то эта информация теряется. Если мы не знаем структуру JSON, то у нас нет простого способа понять, что перед нами — массив или ассоциативный массив. В интернете с подобным сталкиваются постоянно и предлагают такой способ, как анализ ключей. Если они все числовые, то считаем, что массив, иначе — ассоциативный массив. Конвертация из массива в JSON сопряжена с такими же проблемами. Как понять, во что конвертировать переданный массив?

Другая проблема заключается в том, что достаточно легко ошибиться с типом массива и начать его использовать не по назначению:
*/

$data = [];
$data[] = 10;
$data['key'] = 'value';
$data[] = 'hi!';

// Первое удивление — код работает! Теперь попробуйте догадаться, что находится внутри $data.

print_r($data);

// => Array
// (
//     [0] => 10
//     [key] => value
//     [1] => hi!
// )

// Из этого вывода должно быть понятно, что индексированных массивов в PHP нет. Есть упорядоченные ассоциативные массивы, с операцией [] =: добавить элемент с автоматическим присвоением ключа.

$data = ['key' => 'value'];
$data[] = 'console';

// => Array
// (
//     [key] => value
//     [0] => console
// )

// Но самое неудобное — функции которые могут сохранять, а могут не сохранять ключи. Обычно в таких функциях есть дополнительный параметр флаг preserve_keys, который меняет описанное поведение. По сути в описании каждой функции, которая принимает на вход массив (или массивы) и возвращает массив, есть секция с пояснением, сохраняет ли ключи функция или нет, и как это поведение можно изменить.


// Реализуйте функцию, которая принимает на вход массив, состоящий из массивов-пар, и возвращает ассоциативный массив, полученный из этих пар.

fromPairs([['fred', 30], ['barney', 40]]); // → ['fred' => 30, 'barney' => 40]

function fromPairs(array $data)
{
	 $result = [];
	 
	 foreach ($data as [$key, $value]) {
		  $result[$key] = $value;
	 }
	 
	 return $result;
}


// Реализуйте функцию, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

buildQueryString(['per' => 10, 'page' => 1]);
// → page=1&per=10

// Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).

function buildQueryString(array $array)
{
	 $result = [];
	 ksort($array);
	 
	 foreach ($array as $key => $value) {
		  $result[] = "{$key}={$value}";
	 }
	 
	 return implode('&', $result);
}


// Реализуйте функцию findWhere, которая принимает на вход массив (элементы которого - ассоциативные массивы) и пары ключ-значение (тоже в виде массива), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам.

findWhere(
	[
		['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
		['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
		['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
		['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
		['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
		['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
	],
	['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]


function findWhere($data, $where)
{
	 foreach ($data as $item) {
		  $find = true;
		  
		  foreach ($where as $key => $value) {
				if ($item[$key] !== $value) {
					 $find = false;
				}
		  }
		  
		  if ($find) {
				return $item;
		  }
	 }
}


/*
Чанкованием (от англ. Chunk — ячейка, кусок, осколок) в программировании называют разбиение коллекции (массива) на несколько более мелких коллекций. Например, разобьём массив на чанки, так чтобы в каждом чанке было не более двух элементов: ['a', 'b', 'c', 'd'] -> [['a', 'b'], ['c', 'd']].

src\Arrays.php
Реализуйте функцию getChunked, которая принимает на вход массив и число, задающее размер чанка (куска). Функция должна вернуть массив, состоящий из чанков указанной размерности.
*/

getChunked(['a', 'b', 'c', 'd'], 2); // → [['a', 'b'], ['c', 'd']]
getChunked(['a', 'b', 'c', 'd'], 3); // → [['a', 'b', 'c'], ['d']]
getChunked(['a', 'b', 'c', 'd', 'e', 'f'], 2)); // → [['a', 'b'] ['c', 'd'], ['e', 'f']]

// PS: Попробуйте реализовать это упражнение без использования встроенной в PHP функции array_chunk. То есть вам нужно написать свою реализацию данной функции.


function getChunked(Array $array, Int $size)
{
	 $result = [];
	 
	 for ($i = 0; $i < ceil(sizeof($array) / $size); $i++) { // ceil - округляет дробь в большую сторону
		  $result[] = array_slice($array, $i * $size, $size);
	 }
	 
	 return $result;
}


/*
Реализуйте функцию compareVersion, которая сравнивает переданные версии version1 и version2. Если version1 > version2, то функция должна вернуть 1, если version1 < version2, то - -1, если же version1 = version2, то - 0.

Версия - это строка, в которой два числа (мажорная и минорные версии) разделены точкой, например: 12.11. Важно понимать, что версия - это не число с плавающей точкой, а несколько чисел не связанных между собой. Проверка на больше/меньше производится сравнением каждого числа независимо. Поэтому версия 0.12 больше версии 0.2.
Пример порядка версий:
0.1 < 1.1 < 1.2 < 1.11 < 13.37
*/
compareVersion("0.1", "0.2"); // → -1
compareVersion("0.2", "0.1"); // → 1
compareVersion("4.2", "4.2"); // → 0

function compareVersion(String $first, String $second)
{
	 $version1 = explode('.', $first);
	 $version2 = explode('.', $second);
	 
	 if ($version1 > $version2) {
		  return 1;
	 } elseif ($version1 === $version2) {
		  return 0;
	 } else {
		  return -1;
	 }
}


/*
Вес Хэмминга это количество единиц в двоичном представлении числа.
Реализуйте функцию hammingWeight, которая считает вес Хамминга.
*/

hammingWeight(0); // → 0
hammingWeight(4); // → 1
hammingWeight(101); // → 4



function hammingWeight(int $num) // my
{
	 // decbin — переводит число из десятичной системы счисления в двоичную
	 // bindec — переводит двоичное число в десятичное
	 $bin_str = (string)decbin($num);
	 return substr_count($bin_str, '1'); // substr_count - возвращает число вхождений подстроки
}

function hammingWeight(Int $num) // hexlet
{
	 $weight = 0;
	 $digits = str_split(decbin($num));
	 foreach ($digits as $value) {
		  if ($value === '1') {
				$weight += 1;
		  }
	 }
	 
	 return $weight;
}


// Реализуйте функцию lengthOfLastWord, которая возвращает длину последнего слова переданной на вход строки. Словом считается любая последовательность, не содержащая пробелов.

lengthOfLastWord(''); // → 0

lengthOfLastWord('man in BlacK'); // → 5

lengthOfLastWord('hello, world!  '); // → 6

function lengthOfLastWord(String $str)
{
	 $words = explode(' ', trim($str));
	 return strlen(end($words));
}


// Реализуйте функцию summaryRanges, которая находит в массиве непрерывные возрастающие последовательности чисел и возвращает массив с их перечислением.

summaryRanges([1, 2, 3])); // → ["1->3"]
summaryRanges([0, 1, 2, 4, 5, 7]); // → ["0->2", "4->5"]
summaryRanges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5]); // → ['110->112', '-5->-4']


function summaryRanges(array $arr) // my
{
	 $resOp = [];
	 $rec = false;
	 
	 foreach ($arr as $key => $val) {
		  if ($key == 0) {
				continue;
		  }
		  
		  if (!$rec && $arr[$key - 1] == $val - 1) {
				$beginningOfSequence = $arr[$key - 1];
				$rec = true;
		  } elseif ($rec && $arr[$key - 1] != $val - 1) {
				$resOp[] = "$beginningOfSequence->" . $arr[$key - 1];
				$rec = false;
		  } elseif ($rec && $key == sizeof($arr) - 1) {
				$resOp[] = "$beginningOfSequence->{$val}";
		  }
	 }
	 return $resOp;
}


function summaryRanges(Array $array) // hexlet
{
	 $result = [];
	 
	 if (empty($array)) {
		  return $array;
	 }
	 
	 $firstValue = $array[0];
	 $firstIndex = 0;
	 foreach ($array as $index => $value) {
		  if ($index === 0) {
				continue;
		  }
		  $expectedValue = $array[$index - 1] + 1;
		  if ($expectedValue !== $value) {
				if ($firstIndex !== $index - 1) {
					 $result[] = "$firstValue->{$array[$index - 1]}";
				}
				$firstValue = $value;
				$firstIndex = $index;
		  } elseif ($index === sizeof($array) - 1 && $expectedValue === $value) {
				$result[] = "$firstValue->{$array[$index]}";
		  }
	 }
	 
	 return $result;
}


// Реализуйте функцию getMirrorMatrix, которая принимает двумерный массив (матрицу) и возвращает массив, изменённый таким образом, что правая половина матрицы становится зеркальной копией левой половины, симметричной относительно вертикальной оси матрицы. Для простоты условимся, что матрица всегда имеет чётное количество столбцов и количество столбцов всегда равно количеству строк.

getMirrorMatrix([
	[11, 12, 13, 14],
	[21, 22, 23, 24],
	[31, 32, 33, 34],
	[41, 42, 43, 44],
]);

// → [
//     [11, 12, 12, 11],
//     [21, 22, 22, 21],
//     [31, 32, 32, 31],
//     [41, 42, 42, 41],
//   ]

function getMirrorMatrix(array $array)
{
	 $size = sizeof($array);
	 $mirrorArray = [];
	 
	 for ($i = 0; $i < $size; $i++) {
		  for ($j = 0; $j < $size / 2; $j++) {
				$mirrorArray[$i][$j] = $array[$i][$j];
				$mirrorArray[$i][$size - $j - 1] = $array[$i][$j];
		  }
	 }
	 
	 return $mirrorArray;
}


/*
ДНК и РНК это последовательности нуклеотидов.
Четыре нуклеотида в ДНК это аденин (A), цитозин (C), гуанин (G) и тимин (T).
Четыре нуклеотида в РНК это аденин (A), цитозин (C), гуанин (G) и урацил (U).
Цепь РНК составляется на основе цепи ДНК последовательной заменой каждого нуклеотида:
G -> C
C -> G
T -> A
A -> U

Напишите функцию toRna, которая принимает на вход цепь ДНК и возвращает соответствующую цепь РНК (совершает транскрипцию РНК).
*/
toRna('ACGTGGTCTTAA'); // → 'UGCACCAGAAUU'

function toRna(String $nucleotide)
{
	 $map = [
		 'G' => 'C',
		 'C' => 'G',
		 'T' => 'A',
		 'A' => 'U',
	 ];
	 
	 $length = strlen($nucleotide);
	 $result = [];
	 
	 for ($i = 0; $i < $length; $i++) {
		  $result[] = $map[$nucleotide[$i]];
	 }
	 
	 return implode('', $result);
}


/*
Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов, имеющая треугольную форму. В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел. Строки треугольника симметричны относительно вертикальной оси.

0:      1
1:     1 1
2:    1 2 1
3:   1 3 3 1
4:  1 4 6 4 1

Напишите функцию generate, которая возвращает указанную строку треугольника паскаля в виде массива
Пример:
*/
generate(1); // → [1, 1]
generate(4); // → [1, 4, 6, 4, 1]

function generate(Int $rowNumber) // hexlet
{
	 $currentRow = [1];
	 
	 for ($i = 0; $i < $rowNumber; $i++) {
		  $newRow = [];
		  
		  for ($j = 0; $j <= $rowNumber; $j++) {
				$first = isset($currentRow[$j - 1]) ? $currentRow[$j - 1] : 0;
				$second = isset($currentRow[$j]) ? $currentRow[$j] : 0;
				$newRow[$j] = $first + $second;
		  }
		  
		  $currentRow = $newRow;
	 }
	 
	 return $currentRow;
}


/*
В данном упражнении необходимо реализовать стековую машину, то есть алгоритм, проводящий вычисления по обратной польской записи.

Обратная польская нотация или постфиксная нотация — форма записи математических и логических выражений, в которой операнды расположены перед знаками операций. Выражение читается слева направо. Когда в выражении встречается знак операции, выполняется соответствующая операция над двумя ближайшими операндами, находящимися слева от знака операции. Результат операции заменяет в выражении последовательность её операндов и знак, после чего выражение вычисляется дальше по тому же правилу. Таким образом, результатом вычисления всего выражения становится результат последней вычисленной операции.

Например, выражение (1 + 2) * 4 + 3 в постфиксной нотации будет выглядеть так: 1 2 + 4 * 3 +, а результат вычисления: 15. Другой пример - выражение: 7 - 2 * 3, в постфиксной нотации: 7 2 3 * -, результат: 1.

Реализуйте функцию calcInPolishNotation, которая принимает массив, каждый элемент которого содержит число или знак операции (+, -, *, /). Функция должна вернуть результат вычисления по обратной польской записи.
*/

calcInPolishNotation([1, 2, '+', 4, '*', 3, '+']); // → 15
calcInPolishNotation([7, 2, 3, '*', '-']); // → 1



function calcInPolishNotation(Array $expr)
{
	 $stack = [];
	 
	 foreach ($expr as $val) {
		  if (is_int($val)) {
				array_push($stack, $val);
		  } else {
				$endElemDel = array_pop($stack);
				$indexLastElem = sizeof($stack) - 1;
				
				switch ($val) {
					 case '*':
						  $stack[$indexLastElem] *= $endElemDel;
						  break;
					 case '/':
						  $stack[$indexLastElem] /= $endElemDel;
						  break;
					 case '+':
						  $stack[$indexLastElem] += $endElemDel;
						  break;
					 case '-':
						  $stack[$indexLastElem] -= $endElemDel;
						  break;
				}
		  }
	 }
	 
	 return $stack[0];
}




>>>>>  Функции <<<<<<<

// Ранее, я показывал пример того, как в PHP работают с современными фреймворками:

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;

require 'vendor/autoload.php';

$app = new \Slim\App;
$app->get('/hello/{name}', function (Request $request, Response $response, array $args) {
	 $name = $args['name'];
	 $response->getBody()->write("Hello, $name");
	 
	 return $response;
});
$app->run();

// В этом коде еще много новых синтаксических конструкций, но я хочу заострить внимание только на одной. Обратите внимание на странное определение функции. Во-первых, у нее нет имени, а во-вторых, функция определяется в том месте, куда должен передаваться второй параметр функции get. Это так называемая анонимная или лямбда функция. Лямбда функции в PHP являются объектами первого рода. В свою очередь, функция get представляет из себя функцию высшего порядка.

/*
Основные понятия данного курса:
 * Детерминированность
 * Побочные эффекты
 * Splat operator
 * Объекты первого рода
 * Функции высшего порядка (map/filter/reduce)
 * Функциональное программирование

Не все из перечисленных тем и возможностей используются в повседневной жизни PHP разработчика (в других языках может быть совсем по-другому), но знать про них нужно. Во-первых, подходы, разбираемые в этом курсе, не являются специфичными для PHP. Зная их, вы гораздо легче сможете переключаться на другие языки. Особенно это касается JS, в котором используется сильно отличающийся от PHP стиль программирования. Во-вторых, работа с функциями, сильно прокачивает общий уровень разработчика.
*/



>>>>>  Чистые функции <<<<<<<

# Детерминированность

// Стандартная функция rand, вызванная без аргументов, возвращает некоторое случайное число.
rand(); // => 151273074
rand(); // => 1129177627

// Функция нужная и полезная, но неудобная в отладке и тестировании. Связано это с тем, что для одних и тех же входных аргументов (отсутствие аргументов так же попадает под это понятие), она может возвращать разные значения. Функции с таким поведением называются недетерминированными. К ним, в том числе, относятся функции, оперирующие системным временем.

// возвращает текущий год
date('Y'); // => 2018

/*
Хотя прямо сейчас повторный запуск вернет точно такое же значение, через год оно уже будет другим (2019). То есть недетерминированной функция считается в том случае, когда она ведет себя так хотя бы единожды.

Детерминированные функции, напротив, ведут себя предсказуемо. Для одних и тех же входных данных, они всегда выдают один и тот же результат. Именно такими являются функции в математике. Для одного и того же x результат работы функции y = f(x) будет один и тот же. Интересно то, что, например, функция print_r детерминированная. Дело в том, что она всегда возвращает одно и тоже значение для любых входных данных. Это значение true, а не то, что печатается на экран, как можно было бы подумать. Печать на экран - побочный эффект, о нем мы поговорим чуть позже.
*/

var_dump(print_r('lala')); // => bool(true)

/*
Понятие детерминированности играет огромную роль в администрировании, в задачах связанных с программной настройкой серверов (configuration managmenet), выкладкой ПО и обновлениями. Ключевые слова: docker, immutable infrastructure, ansible.

Функция становится недетерминированной и в том случае, если она обращается не только к своим аргументам, но и некоторым внешним данным, например глобальным переменным, переменным окружения и так далее. Так происходит потому, что внешние данные могут измениться, и функция начнет выдавать другой результат даже если в нее передаются одни и те же аргументы
*/

function getCurrentShell()
{
	 // Функция getenv обращается к указанной переменной окружения
	 return getenv('SHELL'); // => /bin/bash
}

# Побочные эффекты

// Вторая ключевая характеристика функций - наличие побочных эффектов. Побочным эффектом называют любые действия изменяющие среду выполнения. К ним относятся любые файловые операции, такие как запись в файл, отправка или прием данных по сети, даже вывод в консоль или чтение файла. Кроме того, побочными эффектами считаются обращения к глобальным переменным (как на чтение, так и запись) и изменение входных аргументов в случае, когда они передаются по ссылке. Вызов функции с побочными эффектами также считается побочным эффектом.

function sayHiTo($name)
{
	 print_r("Hi, {$name}");
}

// С другой стороны, любые вычислительные операции не являются побочными эффектами. Например, функция, суммирующая два переданных аргументами числа.

function sum($num1, $num2)
{
	 return $num1 + $num2;
}


// Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам.

print_r(2 ** 5);

/*
Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет тестирование и отладку. Приводит к возникновению огромного числа ошибок (только при работе с файлами количество возможных ошибок измеряется сотней, начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла). Для их предотвращения код обрастает большим числом проверок и защитных механизмов.

Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе, побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце.

Например, программа, которая конвертирует файл из текстового формата в pdf, в идеале выполняет ровно два побочных эффекта:

 * Читает файл в самом начале работе программы.
 * Записывает результат работы программы в новый файл.

Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Следовательно, побочные эффекты будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.

Инкремент и декремент — единственные базовые арифметические операции в PHP, которые обладают побочными эффектами (изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотловимым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет), а в JS стандарты кодирования предписывают их не использовать.
*/

# Чистые функции

/*
Идеальная функция с точки зрения удобства работы с ней называется чистой (pure). Чистая функция — это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведет себя предсказуемо. Такие функции на 100% соответствуют своим математическим аналогам и могут рассматриваться как математические функции.

Чистые функции обладают рядом ключевых достоинств:

 * Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
 * Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
 * Их легко комбинировать получая новое поведение без необходимости переписывать программу.

В хорошо спроектированных программах, побочные эффекты стараются изолировать в небольшой части приложения так, чтобы большая часть кода была чистой.
*/


// Реализуйте функцию sayPrimeOrNot, которая проверяет переданное число на простоту и печатает на экран yes или no.

sayPrimeOrNot(5); // => yes
sayPrimeOrNot(4); // => no


function isPrime(int $num)
{
	 for ($i = 2; $i < $num; $i++) {
		  if ($num % $i == 0) {
				return false;
		  }
	 }
	 
	 return true;
}

function sayPrimeOrNot($num)
{
	 $text = isPrime($num) ? 'yes' : 'no';
	 print_r($text);
}




>>>>>  Разделение команд и запросов <<<<<<<

/*
Command-query Separation (CQS) - принцип программирования, изобретенный Бертандом Майером, создателем языка Eiffel.

Он утвеждает, что каждая функция является либо командой которая выполняет действие (action), либо запрос (query) который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.
*/

# Команда

// Возвращает true или false как результат своего выполнения
save($user);


/*
Согласно принципу CQS, функция save является командой. Единственное что она может возвращать (опять же согласно принципу) - успешность своего выполнения, то есть true или false, либо null, как, например, в случае с print_r. Возврат этой функцией любых осмысленных данных, рассматривается как нарушение CQS. Однако, стоит сказать, что существуют ситуации в которых невозможно соблюсти этот принцип. Например открытие файла на запись возвращает файловый дескриптор (идентификатор через который происходят манипуляции с файлом).

Отделение команд от запросов тесно связано с идеями, описанными в уроке про чистые функции. Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторому выполнению действия (хотя их и можно сделать детерминированными, но как правило, такой код скрывает логические ошибки). Следовательно выделение запроса (возврата данных) из команды в отдельную функцию, помогает разделить более чистый код от не чистого. Запросы, как мы увидим позже, можно выполнять множество раз не боясь чего-либо сломать.
*/

$file = fopen('/etc/hosts', 'r');


# Запрос

// Возвращает true или false
isAdmin($user);

/*
Функция isAdmin - предикат, типичный запрос (query) или, можно даже сказать, вопрос, который звучит так "Пользователь администратор?" Такая функция, с точки зрения CQS, не может изменять состояние системы, например, поменять дату проверки на администоратора внутри пользователя или даже сделать пользователя администратором. Это противоречит не только CQS, но и здравому смыслу. В отличие от предыдущего примера, true и false в случае предкатов, это не успешность выполнения функции, а ответ на заданный вопрос. CQS имеет альтернативную формулировку, которая отлично характеризует код выше: "Задавая вопрос, не изменяй ответ". К запросам относятся и любые вычисления.
*/

$max = max([1, 30, 4]);


/*
Этот код не создает никаких побочных эффектов и детерминирован. Его можно вызывать сколько угодно раз без риска получить ошибку или неверный результат.

Отсутствие изменения в вопросах, очень важный принцип, который нужно соблюдать всегда. Даже на интуитивном уровне, ни один человек не ожидает, что проверка isAdmin или вычисление максимального числа в массиве, может выполнить какое-то деструктивное действие. С другой стороны, на практике, такой код иногда попадается и теперь вы знаете как правильно его исправить.
*/



>>>>> Упаковка аргументов <<<<<<<

// Сигнатура функции array_merge в документации определяется так:

array array_merge(array $array1 [, array $... ] )

// Она говорит нам о том, что в array_merge можно передать любое количество массивов:

array_merge([1]);
# => Array
# (
#     [0] => 1
# )
array_merge([1], [1]);
# => Array
# (
#     [0] => 1
#     [1] => 1
# )
array_merge([1], [1], [3, 4]);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )
array_merge([1], [1], [3, 4], []);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )

// С точки зрения вызова - ничего необычного, просто разное число аргументов. А вот определение функции с переменным числом аргументов выглядит необычно и использует незнакомый для нас синтаксис:

function sum(...$numbers)
{
	 return array_sum($numbers);
}

echo sum(9, 4); // => 13
echo sum(-3, 0, 3, 1); // => 1

/*
Три точки представляют собой Splat Operator. В PHP на текущий момент он может использоваться только в определениях и вызовах функций (в других языках его можно использовать значительно шире, в том числе при дестракчиринге). Основная сложность для понимания состоит в том, что Splat Operator выполняет различные действия в зависимости от того, где он применяется. В определении функции он выполняет "упаковку" параметров, а при вызове - наоборот, "распаковку". Про упаковку параметров будем говорить в этом уроке. В следующем же уроке рассмотрим Splat Operator в роли распаковщика.

Итак, назначение Splat Operator в определении функции состоит в том, чтобы собрать в массив все переданные аргументы. Если в функцию не передается ни одного аргумента, то массив будет пустым.
*/

echo sum(); // => 0

// Обратите внимание на то, что этому оператору не важен тип аргументов, они все станут элементами массива, даже если мы передаем на вход функции массивы.

function show(...$arguments)
{
	 print_r($arguments);
}

show([]);
# Array
# (
#     [0] => Array
#         (
#         )
#
# )

show([1, 3], [], 3);
# => Array
# (
#     [0] => Array
#         (
#             [0] => 1
#             [1] => 3
#         )
#
#     [1] => Array
#         (
#         )
#
#     [2] => 3
# )

// Теперь взглянем на сигнатуру array_merge еще раз:

array array_merge(array $array1 [, array $... ] )

// Видно, что функция array_merge ждет на вход как минимум один массив, опциональны только следующие. Такого поведения можно добиться следующим кодом:

function sum($a, ...$numbers)
{
	 return $a + array_sum($numbers);
}

echo sum();
// => PHP Fatal error:  Uncaught ArgumentCountError: Too few arguments to function sum(), 0 passed

echo sum(10); // => 10
echo sum(10, 4); // => 14
echo sum(8, 10, 4); // => 22

// Тоже можно сделать и для двух аргументов:

function sum($a, $b, ...$numbers)
{
	 # ...
}

// Эту идею можно продолжать и дальше, делая обязательными то количество аргументов, которое требуется. Единственное ограничение: Splat Operator может быть использован только для последнего аргумента. То есть такой код синтаксически не верен:

function sum(...$numbers, $a)
{
	 # ...
}

// и такой тоже:

function sum($a, ...$numbers, $a)
{
	 # ...
}


// Реализуйте функцию average, которая возвращает среднее арифметическое всех переданных аргументов. Функция принимает на вход от одного числа и больше.

average(0); // => 0
average(0, 10); // => 5
average(-3, 4, 2, 10); // => 3.25

function average($num1, ...$numbers)
{
	 return (array_sum($numbers) + $num1) / (sizeof($numbers) + 1);
}



>>>>> Распаковка аргументов <<<<<<<

// Splat Operator в вызовах функций синтаксически идентичен Splat Operator в определениях, но выполняет обратное действие:

$arrayOfArrays = [
	[1, 2],
	[2, 3]
];

array_merge(...$arrayOfArrays);
# => Array
# (
#     [0] => 1
#     [1] => 2
#     [2] => 2
#     [3] => 3
# )

// Другими словами, Splat Operator раскладывает массив на аргументы. Количество аргументов, полученных Splat Operator, равно количеству элементов массива. По сути код выше преобразуется в вызов:

array_merge($arrayOfArrays[0], $arrayOfArrays[1]); // array_merge([1, 2], [2, 3]);

// Как и в случае с определением функций, Splat Operator может использоваться совместно с позиционными аргументами:

array_merge([3], ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 1
#     [2] => 2
#     [3] => 2
#     [4] => 3
# )


// Тоже самое справедливо и для большего количества аргументов:

$array = [3, 2];
array_merge([3], $array, ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 3
#     [2] => 2
#     [3] => 1
#     [4] => 2
#     [5] => 2
#     [6] => 3
# )

// И точно так же должен всегда оказываться последним аргументом.

array_merge(...$arrayOfArrays, [3, 2]); // => Fatal error: Cannot use positional argument after argument unpacking

// В PHP Splat Operator применяется не каждый день, но иногда бывает нужен, если аргументы оказываются записаны в массив.


// Реализуйте функцию union, которая находит объединение всех переданных массивов. Функция принимает на вход от одного массива и больше. Ключи исходных массивов не сохраняются (т.е. все значения итогового массива заново индексируются: 0, 1, 2, ...).

union([3]); // => [3]
union([3, 2], [2, 2, 1]); // => [3, 2, 1]
union(['a', 3, false], [true, false, 3], [false, 5, 8]); // => ['a', 3, false, true, 5, 8]

function union($first, ...$rest)
{
	 return array_values(array_unique(array_merge($first, ...$rest)));
}



>>>>> Полезные функции для работы с коллекциями <<<<<<<

/*
Стандартная библиотека в PHP небогата функциями для работы с коллекциями, строками или датами. Этот недостаток можно восполнить, подключив стороннюю библиотеку. Например, в мире JS, есть стандарт де-факто, без которого не обходится практически ни один проект - lodash (https://lodash.com/). В PHP нет единого устоявшегося решения, но есть пачка небольших, которые используются в разных проектах.

Объектные:

	Collect https://github.com/tightenco/collect
	Stringy https://github.com/danielstjules/Stringy
	Carbon https://github.com/briannesbitt/Carbon

Использующие только функции:

	Funct https://github.com/phpfunct/funct
	Bottomline https://github.com/maciejczyzewski/bottomline

Скажу сразу, что необходимость использования такой библиотеки в реальной работе возникает практически сразу. Те, кто не знает про них, постоянно пишут велосипеды. Еще не так давно программисты в PHP создавали файлики с полезными функциями и таскали их из одного проекта в другой. Хорошо, что эти времена уже прошли и можно не тратить время на то, что уже делалось тысячу раз до нас. Однако, мы не сможем разобрать все возможные функции в рамках наших курсов. Кое-что рассмотрим, но в дальнейшем не забывайте периодически просматривать их на наличие чего-либо полезного.

Обратите внимание на документацию указанных библиотек. Зачастую они повторяют те функции, которые уже встроены в сам язык. Делается это по разным причинам. Вот некоторые из них:

 * Консистентность (согласованность). Функции делают для того, чтобы библиотека была полной.
 * Исправление ошибок PHP. Некоторые функции в PHP по историческим причинам иногда ведут себя неверно.
 * Улучшение. Другой порядок аргументов, расширенные возможности, убранные ограничения или просто понятное имя.
*/


// Итак, поехали. Библиотека Funct.

# Collections

/*
last

Такая простая и нужная функция почему-то отсутствует в самом PHP.
*/

Collection\last([1, 2, 3]); // => 3

/*
rest

Принимает на вход массив и возвращает новый массив, в котором отсутствует первый элемент исходного.
*/

Collection\rest([5, 4, 3, 2, 1]); // => [4, 3, 2, 1]


/*
without

Возвращает копию массива, из которого удалены все значения, переданные в функцию вторым и последующими параметрами.
*/

Collection\without([1, 2, 1, 0, 3, 1, 4], 0, 1); // => [2, 3, 4]


/*
flattenAll

"Выпрямляет" вложенный массив, делая его плоским.
*/

Collection\flattenAll(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', 'c', 'd']

/*
union

Находит объединение множеств.
*/

Collection\union([1, 2, 3], [101, 2, 1, 10], [2, 1]); // => [1, 2, 3, 101, 10]


/*
findWhere($collection, $value)

Просматривает массив и возвращает первое значение, совпадающее по всем парам «ключ-значение», переданным вторым параметром.
*/

Collection\findWhere(
	[
		['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
		['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
		['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
		['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
		['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
		['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
	],
	['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]



# Strings

/*
camelize

Принимает на вход строку и возвращает ее версию, записанную в camelCase нотации.
*/

Strings\camelize('data_rate'); //'dataRate'
Strings\camelize('background-color'); //'backgroundColor'
Strings\camelize('-moz-something'); //'MozSomething'
Strings\camelize('_car_speed_'); //'CarSpeed'
Strings\camelize('yes_we_can'); //'yesWeCan

/*
contains

Проверяет, включает ли строчка подстроку.
*/

Strings\contains('PHP is one of the best languages!', 'one'); // true

/*
endsWith

Проверяет, оканчивается ли строчка на подстроку.

*/

Strings\endsWith("hello jon", 'jon'); // => true


// функции для работы с массивами: http://php.net/manual/ru/ref.array.php


/**
 * Реализуйте функцию getSentenceType, которая принимает на вход текст, определяет его тип и возвращает наружу его название. Тип предложения определяется по последнему символу в тексте.
 *
 * ? - question
 * ! - shouting
 * Все остальное - common
 *
 * Если передана пустая строчка, то функция должна вернуть null.
 **/

getSentenceType(''); // => null;
getSentenceType('what?'); // => question
getSentenceType('wow!'); // => shouting
getSentenceType('haha'); // => common

$ composer require funct / funct // in Terminal - installation library 'funct'

function getSentenceType($sentence)
{
	 if ($sentence === '') {
		  return null;
	 }
	 
	 $types = [
		 '?' => 'question',
		 '!' => 'shouting'
	 ];
	 $symbol = \Funct\Strings\right($sentence, 1);
	 return array_key_exists($symbol, $types) ? $types[$symbol] : 'common';
}




>>>>> Объекты первого класса <<<<<<<

/*
В языках программирования существует понятие «объекты первого рода (или класса)». Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным. К таким элементам относятся любые данные, например числа, строки, массивы или логические значения. Переменная под это понятие не попадает, объектом первого рода считаются те данные, которые лежат в переменной.
*/

$num = 5; // 5 - объект первого рода

$result = pow($num, 2) // 2 - объект первого рода, $result, $num - содержимое переменных объекты первого рода

// Описанное выше вы проделывали множество раз, и эту тему можно было бы не поднимать, если бы не одно «но». Функции тоже могут быть объектами первого рода:

$func = function () {
	 echo "For hands of gold are always cold. But a woman's hands are warm";
};

$func();

// Мы привыкли к такому определению функций:

function greeting()
{
	 // ...
}

// У функции есть имя, которое указывается после ключевого слова function, а сама конструкция является инструкцией (кстати, поэтому в конце нет точки запятой). Мы не можем написать так:

// переменная содержащая определение функции?
$fn = function greeting() {
	 // ...
}

// Так как определение функции - инструкция, то оно не может подставляться в те места, где ожидаются выражения. Присваивание как раз подразумевает то, что в правой части находится именно выражение. Соответственно, такой код падает с ошибкой. А следующий код уже работает.

$func = function () {
	 echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Даже не вникая в синтаксис можно делать вывод о том, что конструкция справа от «равно» - выражение. И это выражение порождает функцию. В PHP подобные функции называют анонимными, потому что у них нет имени. Глядя на код выше нужно понимать, что определение функции и ее присваивание переменной - две разных операции. Чистое определение выглядит так:

function ()
{
	 echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Очень похоже на обычную функцию за исключением отсутствия имени. Правда, есть еще и стилевые отличия, закрепленные стандартом PSR-2. В других языках анонимные функции нередко называют лямбда-функциями. В принципе, и в PHP их иногда зовут также.

$func();

/*
Имя переменной можно выбирать произвольно, в этом смысле анонимные функции никак не влияют на ситуацию. Более того, в отличие от именованных функций, которые будучи единожды созданными - никуда не изчезают в процессе жизни программы, анонимные функции постоянно создаются и пропадают вместе с переменными, в которые они записаны. Другими словами, анонимные функции всегда локальны относительно контекста и доступны там, где они были созданы если не предпринимать специальных мер по их возврату.

Анонимные функции подобно именованным могут принимать аргументы. В этом отношении поведение абсолютно идентично. Всё, что мы изучали до этого момента для именованных функций один в один работает и для анонимных.
*/

$sum = function ($a, $b) {
	 return $a + $b;
}; // Определение анонимной функции должно заканчиваться символом ;, так как это выражение.

$sum(1, 4); // => 5

// А раз анонимная функция — выражение, мы можем определять ее в любом месте программы, допускающем использование выражений, например в теле другой функции!

function sum($a, $b)
{
	 // определяем анонимную функцию
	 $sum = function ($a, $b) {
		  return $a + $b;
	 };
	 // вызываем анонимную функцию и возвращаем результат ее выполнения
	 return $sum($a, $b);
}

sum(1, 4); // => 5

/*
Главное в коде выше не забыть поставить return и помнить, что $a и $b снаружи анонимной функции не связаны с переменными, имеющими те же имена внутри анонимной функции.

Думаю что сейчас в вашей голове возник вопрос «зачем все это? жили же как-то раньше и сейчас проживем». Анонимные функции появились в PHP не сразу, но все же появились. Их использование значительно повышает выразительные возможности языка, и в этом вы скоро убедитесь. Если же взять JS, то там анонимные функции составляют костяк любой программы. Функции, создающие функции, возвращающие функции и принимающие функции как аргументы - основной способ разрабатывать в JS.
*/

$square = function ($num) {
	 return $num ** 2;
};

$sumOfSquares = function ($num1, $num2) use ($square) {
	 return $squares($num1) + $squares($num2);
};


# Передача обычных функций

// Несмотря на то, что обычные функции в PHP не являются объектами первого рода, PHP может имитировать соответствующее поведение с помощью строк. Достаточно записать имя функции в переменную и вызвать ее.

$fn = 'strlen';
print_r($fn('clojure for brave')); // => 17

// Точно так же можно осуществить "передачу" функции в функцию.

function call(string $fn, $argument)
{
	 return $fn($argument);
}

$result = call('strlen', 'haskell is power!');
print_r($result); // => 16


// Реализуйте анонимную функцию, которая принимает на вход строку и возвращает ее последний символ (или null если строка пустая). Запишите созданную функцию в переменную $last.

function run(string $text)
{
	 $last = function (string $text) {
		  if ($text === '') {
				return null;
		  }
		  return $text[strlen($text) - 1];
	 };
	 
	 return $last($text);
}

// Анонимные функции: http://php.net/manual/ru/functions.anonymous.php



>>>>>  Функции высшего порядка <<<<<<<

/*
Пока мы рассмотрели только одну возможность объектов первого рода применительно к функциям — присвоение переменной. Самое интересное начинается, когда мы передаем одни функции в другие функции.

За примерами далеко ходить не придется. Вспомним сортировку. В PHP есть функция sort, которая принимает на вход массив и сортирует его. Казалось бы, все отлично, и не о чем больше мечтать, но давайте вообразим себе ситуацию: на вход в программу приходит список пользователей, который нужно отсортировать по возрасту и вывести на экран.
*/

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 1],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16]
];

/*
При таких условиях функция sort становится абсолютно бесполезной, потому что она может сортировать только списки примитивных типов данных. Но выше я описал только лишь одну из тысяч возможных ситуаций. Мы можем захотеть сортировать по любому параметру (или даже по набору параметров) и в любом порядке. Сортировки нужны часто, и многие из них довольно сложны. Худшее, что можно начать делать — реализовывать функцию sort под каждую ситуацию. Так что же делать? Если покопаться в документации PHP, то можно обнаружить функцию usort. Ее определение звучит так:

Сортирует массив по значениям, используя пользовательскую функцию для сравнения элементов
*/

bool usort(array &$array, callable $value_compare_func )

/*
Эта функция сортирует элементы массива, используя для сравнения значений callback-функцию, предоставленную пользователем. Используйте эту функцию, если вам нужно отсортировать массив по какому-нибудь необычному признаку. Слово callback означает то, что наша задача — передать функцию (но не вызывать!), а вызывать ее будет функция usort.

Общая идея состоит в том, что нам не нужно реализовывать алгоритм сортировки каждый раз для каждой ситуации, ведь он не меняется. Все, что меняется — элементы, которые сравниваются между собой в процессе сортировки. И функция usort делегирует взаимодействие с этими элементами нам посредством анонимной функции.
*/

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 1],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16],
];

usort($users, function ($a, $b) {
	 if ($a['age'] == $b['age']) {
		  return 0;
	 }
	 
	 return $a['age'] > $b['age'] ? 1 : -1;
});

print_r($users);
// => [
//      ['name' => 'Danil', 'age' => 1],
//      ['name' => 'Vovan', 'age' => 4],
//      ['name' => 'Matvey', 'age' => 16],
//      ['name' => 'Igor', 'age' => 19],
//    ];

/*
Если элементы равны, то вы должны вернуть 0, если первый элемент больше второго, то считается, что они отсортированы правильно, и вы должны вернуть 1, иначе возвращается -1, а usort производит их сортировку.

Из кода выше видно, что внутри функции сравнение идет по свойству age переданных пользователей. Нетрудно догадаться, что эта функция вызывается внутри usort множество раз (а именно на каждое сравнение). Как только она начнет возвращать 1 для каждой пары элементов — сортировка завершена.

Функция usort относится к так называемым функциям высшего порядка (high order functions). Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают все сразу. Такие функции, как правило, реализуют некий обобщенный алгоритм (например, сортировку), а ключевую часть логики делегируют вам через анонимную функцию. Главный плюс от применения таких функций — серьезное повышение коэффициента повторного использования кода.
*/

function say(callable $fn)
{
	 echo $fn();
}

say(function () {
	 return 'hi!';
}); // => hi!

/*
Функция say делает вызов функции, находящейся внутри переменной $fn. В нашем примере функция возвращает строку, которая тут же выводится на экран.

Функции высшего порядка настолько удобны в большинстве языков, что практически целиком могут заменить использование тех же циклов. Например, канонический код на JS выглядит так:
*/

const getJsFiles = dir => fs . readdirSync(dir)
	 . filter(file => file . endsWith('js'))
  .map(file => path . resolve(dir, file));

/*
В этом коде присутствует 2 функции высшего порядка (filter и map), 3 анонимные функции и два прохода (это делают функции высшего порядка) по содержимому директории dir. Подобный код на PHP, с циклами и без, займет примерно в 4 раза больше строк даже при использовании специальных библиотек, упрощающих использование функций высшего порядка (это те же библиотеки, которые мы рассматривали в курсе). Связано это с многословностью синтаксиса PHP.

В следующих уроках мы рассмотрим три самые главные функции высшего порядка, которыми можно решать практически любые задачи. Две из них используются в примере выше, это map и filter, а третья — reduce (ее еще называют fold). Они все доступны в стандартной библиотеке PHP.
*/


// Реализуйте функцию takeOldest, которая принимает на вход список пользователей и возвращает самых взрослых. Количество возвращаемых пользователей задается вторым параметром, который по-умолчанию равен единице.

$users = [
	['name' => 'Tirion', 'birthday' => '1988-11-19'],
	['name' => 'Sam', 'birthday' => '1999-11-22'],
	['name' => 'Rob', 'birthday' => '1975-01-11'],
	['name' => 'Sansa', 'birthday' => '2001-03-20'],
	['name' => 'Tisha', 'birthday' => '1992-02-27']
];

takeOldest($users);
# => Array (
#   ['name' => 'Rob', 'birthday' => '1975-01-11']
# )

// Для преобразования даты в unixtimetamp используйте функцию strtotime

// Описание:
firstN($collection, $n = 1)
Collection\firstN([1, 2, 3]); // => [1]
Collection\firstN([1, 2, 3], 2); // => [1, 2]


function takeOldest(array $users, int $count = 1)
{
	 usort($users, function ($user1, $user2) {
		  return strtotime($user1['birthday']) >= strtotime($user2['birthday']) ? 1 : -1; // strtotime - преобразует текстовое представление даты на английском языке в метку времени
	 });
	 
	 return firstN($users, $count);
}



>>>>>  Отображение(map) <<<<<<<

/*
Первая функция из золотой тройки называется map. Ее название переводится на русский как "отображение", что точно отражает суть выполняемой операции. Если в программировании говорят об отображении, то всегда подразумевают функцию map. Ее можно найти практически в любом языке, и везде это будет одна и та же операция. В PHP она имеет немного отличающееся название - array_map.

Попробуем прийти к этой функции через примеры. Возьмем список пользователей из предыдущего урока и извлечем из него имена всех пользователей.
*/

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 1],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16],
];

$result = [];
foreach ($users as ['name' => $name]) {
	 $result[] = $name;
}
print_r($result); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

// Здесь мы видим обычную агрегацию с использованием foreach. А что, если нам понадобится извлечь возраст? Повторяем:

$result = [];
foreach ($users as ['age' => $age]) { // destructuring
	 $result[] = $age;
}
print_r($result); // => [19, 1, 4, 16]

/*
В примерах выше легко увидеть закономерность. Выполняется один и тот же проход по циклу, и результат собирается в переменную $result. Единственное, что меняется — значение, которое мы извлекаем из элементов исходного массива. Именно этот паттерн называется отображением.

Теперь посмотрим как выполнить ту же самую операцию, используя array_map:
*/

$names = array_map(function ($user) {
	 return $user['name'];
}, $users);

print_r($names); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

/*
array_map принимает первым параметром анонимную функцию и вторым — коллекцию, которая будет отображаться. Дальше внутри себя array_map делает перебор элементов переданной коллекции и для каждого элемента вызывает ту самую анонимную функцию. На вход этой функции передается элемент исходного массива, а ее результат записывается в новый массив, который и возвращается наружу. Некоторые замечания относительно функции array_map (они относятся в принципе к операции отображения):

 * Возвращаемый массив всегда такого же, размера как и исходный. array_map "отображает" каждый элемент исходного массива в элемент возвращаемого.
 * Внутри анонимной функции можно выполнять любые вычисления, а не только возвращать часть исходного элемента.
 * array_map полностью скрывает от нас наличие обхода и процесс сборки нового массива.
Типичный пример, который любят приводить в документации функции к map разных языков программирования, применение некоторой арифметической операции к каждому элементу коллекции.
*/

$numbers = [5, 2, 3];

$newNumbers = array_map(function ($number) {
	 // возводим в квадрат каждое число
	 return $number ** 2;
}, $numbers);

print_r($newNumbers); // => [25, 4, 9]


# Реализация

function myMap(callable $callback, $coll)
{
	 $result = [];
	 
	 foreach ($coll as $item) {
		  $result[] = $callback($item);
	 }
	 
	 return $result;
}

/*
Главное отличие кода функции myMap от ручного обхода массива заключается в том, что функция myMap не знает, что нужно сделать с каждым элементом массива, поэтому она принимает первым аргументом функцию, которую вызывает для каждого элемента исходного массива, а результат вызова записывается в выходной массив. Чем будет этот результат, функция myMap не знает, и ей этого знать не нужно. Ответственность за обработку лежит на пользователях.


Реализуйте функцию getChildren, которая принимает на вход список пользователей и возвращает плоский список их детей. Дети каждого пользователя хранятся в виде массива в ключе children
*/

$users = [
	[
		'name' => 'Tirion',
		'children' => [
			['name' => 'Mira', 'birdhday' => '1983-03-23']
		]
	],
	['name' => 'Bronn', 'children' => []],
	[
		'name' => 'Sam',
		'children' => [
			['name' => 'Aria', 'birdhday' => '2012-11-03'],
			['name' => 'Keit', 'birdhday' => '1933-05-14']
		]
	],
	[
		'name' => 'Rob',
		'children' => [
			['name' => 'Tisha', 'birdhday' => '2012-11-03']
		]
	]
];

getChildren($users);
// [
//     ['name' => 'Mira', 'birdhday' => '1983-03-23'],
//     ['name' => 'Aria', 'birdhday' => '2012-11-03'],
//     ['name' => 'Keit', 'birdhday' => '1933-05-14'],
//     ['name' => 'Tisha', 'birdhday' => '2012-11-03']
// ]


// Описание:
Collection\flatten(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', ['c', ['d']]]
Collection\flatten(['a', ['b', ['c', ['d']]]], 2); // => ['a', 'b', 'c', ['d']]
Collection\flatten(['a', ['b', ['c', ['d']]]], 3); // => ['a', 'b', 'c', 'd']



function getChildren(array $users)
{
	 $children = array_map(function ($user) {
		  return $user['children'];
	 }, $users);
	 
	 return flatten($children);
}

// без flatten:
[
	[['name' => 'Mira', 'birdhday' => 1983 - 03 - 23]],
	[[]],
	[
		['name' => 'Aria', 'birdhday' => '2012-11-03'],
		['name' => 'Keit', 'birdhday' => '1933-05-14']
	],
	[['name' => 'Tisha', 'birdhday' => '2012-11-03']]
]


>>>>>  Фильтрация(filter) <<<<<<<

// Следующая операция называется "фильтрация" и выполняется она в PHP с помощью функции array_filter (в других языках ее называют просто filter или select). Операция "фильтрация", по отношению к коллекции, означает что мы удаляем из нее нежелательные элементы.

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 1],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16]
];

$result = [];
foreach ($users as $user) {
	 if ($user['age'] > 10) {
		  $result[] = $user;
	 }
}

print_r($result);
// => Array
// (
//     [0] => Array
//         (
//             [name] => Igor
//             [age] => 19
//         )
//
//     [1] => Array
//         (
//             [name] => Matvey
//             [age] => 16
//         )
//
// )


/*
Фильтрация встречается так же часто как отображение, а возможно и чаще. Общая схема кода при фильтрации практически один в один как и в отображении, кроме пары ключевых моментов:

 * Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано) либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошел.
 * Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил список пользователей, то список пользователей будет и на выходе.

Теперь посмотрим как выглядит фильтрация при использовании функции высшего порядка array_filter.
*/

// Порядок аргументов обратный. Сначала коллекция, затем функция.

$users = array_filter($users, function ($user) {
	 return $user['age'] > 10;
});

// В отличие от array_map, функция, которая передается в array_filter должна быть предикатом. То есть ее задача вернуть либо true либо false для каждого элемента коллекции. Ее возврат никак не используется, он всего лишь говорит о том, включать ли текущий элемент в итоговый массив либо нет. Новички часто делают ошибку на этом этапе и начинают возвращать из фильтра то, что они бы хотели увидеть в результирующем массиве (для этого надо применять array_map).

#Реализация

function myFilter($coll, callable $callback)
{
	 $result = [];
	 foreach ($coll as $key => $item) {
		  if ($callback($item)) { // Предикат используется только для проверки
				$result[$key] = $item; // В результат всегда добавляется элемент исходной коллекции
		  }
	 }
	 return $result;
}

// Обратите внимание на то, что array_filter сохраняет ключи. При работе с индексированными массивами такое поведение нежелательно, поэтому придется использовать функцию !!! array_values для сброса порядка.



/**
 * Реализуйте функцию getGirlFriends, которая принимает на вход список пользователей и возвращает плоский список подруг всех пользователей (без сохранения ключей). Друзья каждого пользователя хранятся в виде массива в ключе friends. Пол доступен по ключу gender и может принимать значения male или female.
 **/

$users = [
	[
		'name' => 'Tirion',
		'friends' => [
			['name' => 'Mira', 'gender' => 'female'],
			['name' => 'Ramsey', 'gender' => 'male']
		]
	],
	['name' => 'Bronn', 'friends' => []],
	[
		'name' => 'Sam',
		'friends' => [
			['name' => 'Aria', 'gender' => 'female'],
			['name' => 'Keit', 'gender' => 'female']
		]
	],
	[
		'name' => 'Rob',
		'friends' => [
			['name' => 'Taywin', 'gender' => 'male']
		]
	],
];

getGirlFriends($users);
# => Array (
#      ['name' => 'Mira', 'gender' => 'female'],
#      ['name' => 'Aria', 'gender' => 'female'],
#      ['name' => 'Keit', 'gender' => 'female']
# )


function getGirlfriends(array $users)
{
	 $friends = array_map(function ($user) {
		  return $user['friends'];
	 }, $users);
	 
	 $friends = flatten($friends);
	 
	 $girlfriends = array_filter($friends, function ($user) {
		  return $user['gender'] === 'female';
	 });
	 
	 return array_values($girlfriends);
}



>>>>> Агрегация(reduce) <<<<<<<

/*
Последняя функция из нашей тройки - array_reduce используется для агрегации (название в других языках accumulate, fold или, по-русски, "свертка"). Она устроена немного сложнее, чем map и filter, но, в целом, сохраняет общий подход с передачей функции.

Как обычно, начнем с примера на циклах. Реализуем код, находящий самого взрослого пользователя.
*/

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 4],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16],
];

$oldest = $users[0];
foreach ($users as $user) {
	 if ($user['age'] > $oldest['age']) {
		  $oldest = $user;
	 }
}

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может быть любой тип данных, как примитивный так и составной, например, массив. Кроме того, агрегация нередко подразумевает инициализацию начальным значением. В примере выше она выполняется на строчке $oldest = $users[0];.

Посмотрим еще один пример агрегации: группировка имен пользователей по возрасту.
*/

$users = [
	['name' => 'Igor', 'age' => 19],
	['name' => 'Danil', 'age' => 4],
	['name' => 'Vovan', 'age' => 4],
	['name' => 'Matvey', 'age' => 16]
];

$usersByAge = [];

foreach ($users as $user) {
	 if (!array_key_exists($user['age'], $usersByAge)) {
		  $usersByAge[$user['age']] = [];
	 }
	 
	 $usersByAge[$user['age']][] = $user['name'];
}

print_r($usersByAge);

# => Array
# (
#     [19] => Array
#         (
#             [0] => Igor
#         )
#
#     [4] => Array
#         (
#             [0] => Danil
#             [1] => Vovan
#         )
#
#     [16] => Array
#         (
#             [0] => Matvey
#         )
#
# )

/*
В этом примере результатом агрегации становится массив массивов, который в самом начале инициируется пустым массивом. Значение, которое накапливает результат агрегации, принятно называть словом "аккумулятор". В примерах выше это $oldest и $usersByAge.

Реализуем первый пример используя array_reduce.
*/

$oldest = array_reduce($users, function ($acc, $user) {
	 return $user['age'] > $acc['age'] ? $user : $acc;
}, $users[0]);

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Функция array_reduce принимает на вход три параметра. Два из них уже традиционны - это коллекция и функция-обработчик, а вот третьим выступает начальное значение аккумулятора. Поиск самого взрослого пользователя аналогичен поиску максимального (или минимального) числа в массиве. Соответственно, аккумулятор должен быть инициализирован первым пользователем. Этот же аккумулятор возвращается наружу.

Анонимная функция, передаваемая в array_reduce - самая важная часть и ключ к пониманию работы всего механизма агрегации. Она принимает на вход два значения. Первый - текущее значение аккумулятора, второй - текущий обрабатываемый элемент. Задача функции - вернуть новое значение аккумулятора. array_reduce никак не анализирует содержимое аккумулятора. Всё, что она делает, передает его в каждый новый вызов до тех пор, пока не будет обработана вся коллекция, и в конце концов вернет его наружу. Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.

Второй пример с использованием array_reduce выглядит так:
*/

$usersByAge = array_reduce($users, function ($acc, $user) {
	 if (!array_key_exists($user['age'], $acc)) {
		  $acc[$user['age']] = [];
	 }
	 $acc[$user['age']][] = $user['name'];
	 
	 return $acc;
}, []);

print_r($usersByAge);

function getMensCountByYear($users)
{
	 $dates = array_reduce($users, function ($acc, $user) {
		  $year = date('Y', strtotime($user['date']));
		  
		  if (!array_key_exists($year, $acc)) {
				$acc['year'] = 1;
		  } else {
				$acc['year']++;
		  }
		  
		  return $acc;
	 }, []);
	 
}

// Код практически не изменился, за исключением того, что ушел цикл и появился возврат аккумулятора из анонимной функции.


# Реализация

function getMensCountByYear(array $users)
{
	 $menfolk = array_filter($users, function ($user) {
		  return $user['gender'] === 'male';
	 });
	 
	 $years = array_map(function ($user) {
		  return date('Y', strtotime($user['birthday']));
	 }, $menfolk);
	 
	 return array_reduce($years, function ($acc, $year) {
		  if (!array_key_exists($year, $acc)) {
				$acc[$year] = 1;
		  } else {
				$acc[$year] += 1;
		  }
		  
		  return $acc;
	 }, []);
}

function myReduce($coll, callable $callback, $init = null)
{
	 $acc = $init;
	 
	 foreach ($coll as $item) {
		  $acc = $callback($acc, $item); // Заменяем старый аккумулятор новым
	 }
	 
	 return $acc;
}


// array_reduce - очень мощная функция. Формально, можно работать, используя одну лишь ее, так как она может заменить и отображение и фильтрацию. Но делать так не стоит. Агрегация управляет состоянием (аккумулятором) явно. Такой код всегда сложнее и требует больше действий. Поэтому, если задачу возможно решить отображением или фильтрацией, то так и нужно делать.


/** Реализуйте функцию getMensCountByYear, которая принимает на вход список пользователей и возвращает массив, в котором ключ это год рождения, а значение это количество мужчин, родившихся в этот год.
 **/

$users = [
	['name' => 'Bronn', 'gender' => 'male', 'birthday' => '1973-03-23'],
	['name' => 'Reigar', 'gender' => 'male', 'birthday' => '1973-11-03'],
	['name' => 'Eiegon', 'gender' => 'male', 'birthday' => '1963-11-03'],
	['name' => 'Sansa', 'gender' => 'female', 'birthday' => '2012-11-03'],
	['name' => 'Jon', 'gender' => 'male', 'birthday' => '1980-11-03'],
	['name' => 'Robb', 'gender' => 'male', 'birthday' => '1980-05-14'],
	['name' => 'Tisha', 'gender' => 'female', 'birthday' => '2012-11-03'],
	['name' => 'Rick', 'gender' => 'male', 'birthday' => '2012-11-03'],
	['name' => 'Joffrey', 'gender' => 'male', 'birthday' => '1999-11-03'],
	['name' => 'Edd', 'gender' => 'male', 'birthday' => '1973-11-03']
];

getMensCountByYear($users);
# => Array (
#     1973 => 3,
#     1963 => 1,
#     1980 => 2,
#     2012 => 1,
#     1999 => 1
# );

function getMensCountByYear($users) // my
{
	 return array_reduce($users, function ($acc, $user) {
		  $year = date('Y', strtotime($user['birthday']));
		  
		  if ($user['gender'] == 'male') {
				array_key_exists($year, $acc) ? $acc["$year"]++ : $acc["$year"] = 1;
		  }
		  
		  return $acc;
	 }, []);
}

function getMensCountByYear(array $users) // hexlet
{
	 $menfolk = array_filter($users, function ($user) {
		  return $user['gender'] === 'male';
	 });
	 
	 $years = array_map(function ($user) {
		  return date('Y', strtotime($user['birthday']));
	 }, $menfolk);
	 
	 return array_reduce($years, function ($acc, $year) {
		  if (!array_key_exists($year, $acc)) {
				$acc[$year] = 1;
		  } else {
				$acc[$year]++;
		  }
		  
		  return $acc;
	 }, []);
}



>>>>>  Сигналы <<<<<<<

/*
Пример с usort хорошо демонстрирует важность и удобство функций высшего порядка для решения повседневных задач. Описав алгоритм один раз, мы можем получать различные варианты поведения специфицируя их функциями. Тоже самое относится к рассмотренным функциям map, filter и reduce. Но есть еще один важный аспект, который требует рассмотрения.

Типичный код на PHP выглядит так. Делается один цикл внутри которого выполняются сразу все операции и в конце получается некоторый интересующий нас результат. Ничего криминального, но такой код может быть сложен для анализа, потому что требует держать в голове сразу все операции. С другой стороны, при использовании функций высшего порядка принято разделять задачу на подзадачи и выполнять их последовательно друг за другом выстраивая в цепочку операций.

Предположим что мы пишем функцию, которая принимает на вход список путей файловой системы, находит среди них файлы с расширением php без учета регистра и возвращает имена этих файлов. Для решения этой задачи нам понадобятся следующие функции:

 * is_file - проверяет что переданный путь это реально существующий файл
 * pathinfo - позволяет извлекать расширение из имени файла
 * basename - извлекает имя файла из полного пути
*/

function getPHPFileNames(array $paths)
{
	 $result = [];
	 
	 foreach ($paths as $path) {
		  $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
		  
		  if (is_file($path) && $extension === 'php') {
				$result[] = basename($path);
		  }
	 }
	 
	 return $result;
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);

print_r($names);
# => Array
# (
#     [0] => index.php
#     [1] => wop.PHP
# )

/*
В примере выше типовое решение с использованием цикла. Его алгоритм можно описать так:

 * Просматриваем каждый путь
 * Если текущий путь файл и его расширение php без учета регистра то добавляем в результирующий массив

Если попытаться тоже самое реализовать используя функцию array_reduce, то на выходе получится код идентичный решению на циклах. Но если хорошо подумать, то можно увидеть что эта задача распадается на две: фильтрацию и отображение.
*/

function getPHPFileNames(array $paths)
{
	 // фильтруем оставляя только подходящие пути
	 $phpFiles = array_filter($paths, function ($path) {
		  $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
		  return is_file($path) && $extension === 'php';
	 });
	 
	 // извлекаем из оставшихся путей имена файлов и возвращаем их наружу
	 return array_map(function ($path) {
		  return basename($path);
	 }, $phpFiles);
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);


/*
Код получился чуть короче (без учета комментариев), но и многословнее (это исключительно особенность php), но главное не его размер. С увеличением количества операций и их сложности, код разбитый таким образом читается и анализируется значительно проще, так как каждая операция выполняется независимо для всего набора сразу. В голове приходится держать меньше деталей и можно сразу увидеть то, как операция влияет на все данные. Однако, научиться правильно разбивать задачу на подзадачи не так просто, как может показаться в начале.

Сама возможность такого разбиения основывается на простой идее, которую иногда называют "стандартные интерфейсы". Заключается он в том, что на входе и выходе из функций ожидается один и тот же тип данных, в нашем случае, массив. Это позволяет соединять функции и строить цепочки выполняющие большое количество разных задач, без необходимости реализовывать новые функции. Рассмотренные ранее операции: отображение, фильтрация и агрегация, комбинируясь друг с другом позволяют решать подавляющее число задач по обработке коллекций. С чем-то подобным мы все встречались в своей жизни, когда собирали конструкторы Lego. Небольшое число примитивных деталей за счет одинаковых соединений позволяют строить конструкции практически неограниченной сложности.

Кстати, подобные цепочки нередко заканчиваются на агрегации, так как агрегация почти всегда выполняется в конце и сводит коллекцию к некоторому значению.

Для сравнения я покажу задачу выше, реализованную на JS.
*/

const getPHPFileNames = paths => paths
	 . filter(filepath => fs . lstatSync(fullPath) . isFile())
  .filter(filepath => path . extname(filepath) . toLowerCase() === '.php')
  .map(filepath => path . basename(filepath));

const names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
console . log(names);


// Понятно, что он слишком непривычный, но ухватить фильтры и мапы внутри него не так сложно, да и в целом понять смысл того что происходит. Заметьте, что здесь я разбил фильтр на два. Учитывая лаконичность определения функции в js, гораздо лучше разбивать проверки на большее число фильтров чем делать один сложный фильтр.

# Производительность

/*
За кадром остался вопрос производительности. Возможно, кто-то из вас догадался, что на каждый вызов функции, обрабатывающей коллекцию, мы получаем проход по всему списку. Чем больше таких функций, тем больше проходов. Казалось бы код замедляется, зачем так делать? На практике дополнительные проходы практически никогда не проблема. Задачи, в которых требуется одномоментная обработка десятков и сотен тысяч элементов, встречаются крайне редко. Большая часть операций происходит со списками до тысяч элементов. А для такого списка одним проходом больше одним меньше - разницы, можно сказать, никакой.

Но это не вся правда. На самом деле, существуют специальные коллекции, которые в момент вызова функций фильтрации, отображения и т.п. не выполняют операции сразу. Они накапливают необходимые действия, а во время первого использования выполняют сразу все одним проходом. Это так называемые «ленивые коллекции».
*/

// Реализуйте функцию getFreeDomainsCount, которая принимает на вход список емейлов, а возвращает количество емейлов, расположенных на каждом бесплатном домене. Список бесплатных доменов хранится в константе FREE_EMAIL_DOMAINS.

$emails = [
	'info@gmail.com',
	'info@yandex.ru',
	'info@hotmail.com',
	'mk@host.com',
	'support@hexlet.io',
	'key@yandex.ru',
	'sergey@gmail.com',
	'vovan@gmail.com',
	'vovan@hotmail.com'
];

const FREE_EMAIL_DOMAINS = [
	'gmail.com',
	'yandex.ru',
	'hotmail.com'
];

getFreeDomainsCount($emails);
# => Array (
#     'gmail.com' => 3
#     'yandex.ru' => 2
#     'hotmail.com' => 2
#  )


function getFreeDomainsCount(Array $mails) // my
{
	 return array_reduce($emails, function ($acc, $mail) {
		  $domen = explode('@', $mail)[1];
		  
		  if (in_array($domen, FREE_EMAIL_DOMAINS)) {
				array_key_exists($domen, $acc) ? $acc[$domen]++ : $acc[$domen] = 1;
		  }
		  
		  return $acc;
	 }, []);
}

function getFreeDomainsCount(array $emails) // hexlet
{
	 $domains = array_map(function ($email) {
		  return explode('@', $email)[1];
	 }, $emails);
	 
	 $freeDomains = array_filter($domains, function ($domain) {
		  return in_array($domain, FREE_EMAIL_DOMAINS);
	 });
	 
	 
	 return array_reduce($freeDomains, function ($acc, $domain) {
		  if (!array_key_exists($domain, $acc)) {
				$acc[$domain] = 1;
		  } else {
				acc[$domain] += 1;
		  }
		  
		  return $acc;
	 }, []);
}




>>>>>  Полезные функции высшего порядка <<<<<<<

// Библиотека Funct, которую мы рассматривали ранее, кроме обычных функций содержит функции высшего порядка. В этом уроке мы рассмотрим некторые из них, которые могут быть полезными в будущем.


# partition($collection, callable $callback)

// Разбивает массив на два на основании предиката. Те элементы, которые удовлетворяют предикату, попадают в первый массив, другие - во второй.

[$first, $second] = Collection\partition([1, 2, 3, 4, 5, 6, 7, 8, 9], function ($num) {
		  return $num % 2 === 0;
	 }); // => [[2, 4, 6, 8], [1, 3, 5, 7, 9]]

print_r($first); // => [2, 4, 6, 8]
print_r($second); // => [1, 3, 5, 7, 9]


# every($collection, callable $callback = null)

// Возвращает true если каждый элемент коллекции удовлетворяет предикату. По умолчанию проверяет на истинность (== true).

Collection\every([true, 1, null, 'yes']); // => false
Collection\every([true, 1, 'yes']); // => true
Collection\every(
	[2, 4, 6],
	function ($value) {
		 return ($value % 2) === 0;
	}
); // => true


# groupBy($collection, callable $callback)

// Группирует элементы коллекции в множества на основании ключа, полученного в результате вызова колбека.

Collection\groupBy([1.3, 2.1, 2.4], function ($num) {
	 return floor($num);
}); // => [1 => [1.3], 2 => [2.1, 2.4]]


# minValue($collection, callable $callback)

// Возвращает минимальный элемент коллекции на основании результата переданной функции.

Collection\minValue(
	[
		10 => [
			'title' => 'a',
			'size' => 1
		],
		20 => [
			'title' => 'b',
			'size' => 2
		],
		30 => [
			'title' => 'c',
			'size' => 3
		]
	],
	function ($item) {
		 return $item['size'];
	}
);

# => Array (
#    'title' => 'a',
#    'size'  => 1
# )




>>>>>  Замыкание <<<<<<<

// Начнем урок с небольшого повторения пройденного материала. Каждая функция создает так называемую область видимости. Внутри этой области доступны только те переменные, которые были определены там же. Все что снаружи - по-умолчанию невидимо.

$age = 5;

function generate()
{
	 print_r($age);
}

generate();

// Этот код выдаст предупреждение PHP Notice: Undefined variable: age. Переменная $age определена вне контекста функции и невидима внутри. Точно такое же поведение и у анонимных функций.

$age = 5;

$generate = function () {
	 print_r($age);
};

$generate(); // PHP Notice:  Undefined variable: age

// Но передача аргументов все же возможна, и делается она благодаря "замыканию". С помощью этого механизма можно "захватить" переменные из внешнего окружения и использовать их внутри. Правда, только для анонимных функций. Термином "замыкание", нередко называют и саму функцию, которая осуществила захват внешних переменных.

$age = 5;

$generate = function () use ($age) {
	 print_r($age);
};

$generate(); // 5

// Захват переменных осуществляется с помощью ключевого слова use и списка переменных, который идет после этого слова. Крайне важно осознать, что use используется при определении функции, а не ее вызове. Может возникнуть закономерный вопрос, зачем это делать, если переменные можно передать в сам вызов.

$age = 5;

$generate = function ($age) {
	 print_r($age);
};

$generate($age); // 5

/*
Замыкания полезны в тех случаях, когда функция определяется в одном месте, а используется в совершенно другом. Замыкание позволяет не таскать за собой гору переменных. А в некоторых ситуациях без них просто не обойтись. Вспомните функцию without из пакета Funct. Эта функция принимает на вход массив и значение, а возвращает новый массив полученный фильтрацией старого по переданному значению. Его реализация, построенная на функциях высшего порядка, подразумевает фильтрацию. Сложность возникает при описании предиката, ведь внутри анонимной функции нужно сравнивать текущее значение и переданный элемент. Замыкание позволяет решить эту задачу просто.
*/

function without(array $items, $value)
{
	 $filtered = array_filter($items, function ($item) use ($value) {
		  return $item !== $value;
	 });
	 // !!! Сбрасываем ключи
	 return array_values($filtered);
}

without([3, 4, 10, 4, 'true'], 4); // => [3, 10, 'true']

/*
Без добавления use ($value) ничего не получится. $value не виден внутри анонимной функции.
В замыкание можно передать данные по ссылке, что позволит их менять внутри. Но делать так никогда не стоит. Подобное использование создает невероятно сложный в отладке и сопровождении код. Единственная причина, по которой можно использовать передачу по ссылке - рекурсия внутри анонимной функции.
*/



>>>>> Парадигмы программирования <<<<<<<

/*
В программировании часто используется термин "парадигма".

Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Парадигма — это больше, чем просто другой алгоритм решения задачи. Как правило, структура кода при использовании разных парадигм отличается очень значительно и требует знаний, выходящих за рамки только синтаксиса языка (например, автоматное программирование требует хотя бы базового понимания теории автоматов). Причем подавляющее большинство современных (и не очень) языков программирования являются мультипарадигменными и позволяют писать код используя множество стилей. Иногда эти стили взаимоисключающие, иногда они дополняют друг друга. К текущему моменту мы писали код используя две парадигмы: императивную и декларативную.

# Императивная парадигма

Императивная парадигма - стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных. Возможно, данное определение звучит страшно, но на практике императивный стиль является доминирующим. Не считая этого курса, весь остальной код мы писали именно в императивном стиле.

Императивная (КАК) программа - набор инструкций изменяющих состояние (данные).
Примеры: Процедурное, ООП

> Циклы
> Присваивание

Декларативная (ЧТО) программа - спецификация описывающая решение задачи.
Примеры: Логическое, Функциональное

> Функции как объекты первого класса
> Рекурсия
> Неизменяемые данные

Функции первого класса можно передавать в качестве аргументов другим функциям, возвращать их как результат других функций, присваивать их переменным или сохранять в структурах данных. Функция высшего порядка — функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

Мультипарадигменные Scala, F#, Ocaml
Императивные Ruby, PHP, Python, C, C++, C#, Perl, Java, Kotlin, Swift, Javascript
Функциональные Haksell, Erlang
Логические Prolog

Лямбда-исчисление - формальная система, разработнная американским математиком Алонзло Чёрчем, для формализации и анализа понятия вычисляемости. Первоначально было реализовано на языке Lisp (1958г.)

Литерал - значение, указанное в коде программы
*/

// Поиск максимального числа

$numbers = [10, 20, 52, 105, 56, 89, 96];
$max = $numbers[0];

foreach ($numbers as $number) {
	 if ($number > $max) {
		  $max = $number;
	 }
}

print_r($max); // => 105

/*
В императивном стиле широко используется присваивание (а, значит, и переменные) и циклы. Эта парадигма популярна потому, что она в точности соответствует тому, как работает компьютер: последовательно выполняет инструкции и использует память для хранения промежуточных результатов. Обычно говорят, что императивная программа отвечает на вопрос КАК («как достичь нужного результата»).

PHP как, впрочем, и java/ruby/python/c#/perl/javascript/go относится к императивным языкам. То есть языкам, в которых доминирующей является императивная парадигма (язык толкает к ее использованию). Что, однако, не мешает использовать и другие парадигмы в рамках этих языков.

# Декларативная парадигма

Императивному стилю противопоставляют декларативный, который нередко называют функциональным. Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос ЧТО («что мы хотим получить»). Эту грань довольно трудно уловить сразу, но, например, вся математика, по своей сути, декларативна.
*/

$numbers = [10, 20, 52, 105, 56, 89, 96];

$max = array_reduce($numbers, function ($acc, $number) {
	 return $number > $acc ? $number : $acc;
}, $numbers[0]);

print_r($max); // => 105


/*
Главное отличие декларативной парадигмы от императивной на практике - отсутствие присваивания. Вы можете мне возразить, что в коде выше переменные есть и чисто технически это правда. Присмотритесь к коду внимательнее, вы заметите что переменная создана ровно один раз и больше не меняется. По сути, она рассматривается как константа или, если копнуть глубже, как логическое высказывание. В математике это звучало бы так: допустим "A это множество чисел". Что бы мы дальше не делали, "A" остается всегда тем же чем было во время определения.

Дело в том, что в математике доказательства строятся с помощью логических цепочек. Из одних утверждений следуют другие, и таким образом мы можем прийти к решению задачи. Все это возможно только в том случае, когда утверждения не изменяются. Иначе, следствия могут оказаться неверными уже после того, как они были получены, а значит мы не сможем рассуждать логически.

Тоже самое касается и $acc с $number. Эти параметры всегда определяются ровно один раз, так как каждый вызов функции при таком определении (без использования ссылок) не зависит от другого вызова (спасибо чистым функциям). В мире функциональных языков такую операцию называют связывание. Визуально оно выглядит как присваивание, но это не оно. Попытка связать уже связанный идентификатор (в функциональных языка нет переменных) завершится ошибкой. Ниже пример на языке erlang:
*/

1 > A = 4.
4
2 > A = 'hey' .
** exception error: no match of right hand side value hey
	 
	 /*
Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия. Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода. В основном в функциях высшего порядка. Причем они способны заменить рекурсию в подавляющем большинстве задач, в чем мы уже убедились в предыдущих уроках (убедились так, что даже не рассматривали рекурсию). Любая задача из представленных решалась основной тройкой функций высшего порядка.

Функциональных языков довольно много. Они, в своей массе, менее популярны чем императивные, но прочно занимают определенные ниши и активно используются в промышленном программировании. К таким языкам относятся: haskell/erlang/elixir/ocaml/f#. В этих языках нет присваивания и циклов. Императивный код на них написать просто невозможно. Немного особняком стоят такие языки как scala и clojure (и другие из семейства lisp). В этих языках основная парадигма — функциональная, и язык толкает к тому, чтобы писать в таком стиле, но при необходимости на них можно написать самый настоящий императивный код с присваиванием и циклами. А вот, почти все, императивные языки позволяют писать функционально. Причем, если одни языки имеют довольно слабую поддержку функциональной парадигмы, то другие настолько мощную, что в них можно писать только функционально (если хочется). К последним относится и современный JavaScript.

В php поддержка функционального программирования слабее, чем в большинстве других языков, но все же она достаточно серьезная. С каждой новой версией PHP вбирает в себя все больше и больше возможностей, взятых из функциональных языков, многие из которых достаточно быстро становятся популярными и начинают использоваться повсеместно, например, лямбда-функции. С другой стороны, в PHP невозможно обновить массив не используя присваивания (говорят, «в иммутабельном стиле»). Поэтому любой код на PHP использующий функциональные возможности, так или иначе имеет императивные куски.

# Другие парадигмы

Большинство других парадигм являются разновидностями функциональной или императивной парадигм. Из наиболее значимых я бы выделил следующие:

  Логическое программирование
  Автоматное программирование
  Объекто-ориентированное программирование
  Метапрограммирование
*/
	 
	 
	 >>>>>  Абстракция с помощью функций <<<<<<<

/*
Главная причина создания функций - повышение уровня абстракции, а не сокращения дублирования кода, как вы могли бы подумать. Второе является следствием первого. И действительно, вместо того чтобы реализовывать сортировку самостоятельно в каждом месте где это требуется, можно воспользоваться функцией sort, которая прячет реализацию внутри себя и позволяет программисту не отвлекаться на ненужные детали (вид сортировки, код для ее выполнения).

# Abstraction

В этом заключается суть абстракции, мы игнорируем несущественные стороны, свойства и связи рассматриваемого объекта или процесса, что позволяет представить сложную концепцию в более простой форме. Умение абстрагировать - одно из важнейших свойств нашего мозга. Маленькие дети очень быстро учатся классифицировать предметы нашего мира. Без особого труда понимая, что дерево это дерево, даже если конкретную породу дерева они видят впервые. А два разведенных пальца обозначают зайчика (потому что уши).

Несмотря на это, понимание того, как грамотно строить абстракции (в нашем случае выделять функции) не появляется само по себе. Оно приходит с опытом, при условии, что есть другой человек сильнее вас, который может вам указать на допущенные ошибки, и вы сами отслеживаете проблемы вашей абстракции в процессе эксплуатации (рефлексируете). С другой стороны, излишнее абстрагирование скорее вредно, чем полезно. За награмождением новых сущностей можно потерять суть и тратить больше время на понимание происходящего. Построение абстракции — всегда компромисс. Слишком низкий уровень абстракции приводит к дублированию кода, слишком высокий - может быть очень трудным для понимания (Попробуйте понять Теорию Категорий) и усложняющим решение простых задач.

# Huge Java Call Stack

Функции высшего порядка выводят абстрагирование с помощью функций на новый уровень. Благодаря делегированию поведения внешнему коду (используя анонимные функции), резко расширяется возможность повторного использования кода (алгоритма) в разных ситуациях. И вместо десяти функций для десяти разных участков кода появляется одна функция, которая специфицируется 10 раз разным поведением.

Но не забывайте, что абстракции почти всегда текут.

Пример дырявой абстракции

В первом проекте Хекслета наши ученики совершают одну (совершают много, но сейчас нас интересует одна) ошибку, связанную с неверным выделением абстракций. Если отбросить детали (абстрагироваться!), то задача сводится к написанию функции, которая принимает на вход число, и должна напечатать на экран yes если оно четное и no в обратном случае.

Первое решение выглядит примерно так:
*/

function check($number)
{
	 $result = $number % 2 === 0 ? 'yes' : 'no';
	 echo $result;
}

// Оно рабочее, но сама концепция четности не выделена в свою абстракцию, что, например, затрудняет тестирование и понимание кода. Здесь он простой, но в более сложных случаях догадаться до того, что за операция выполняется - проблематично. Правильно было бы выделить четность в отдельную функцию (абстракцию).

function isEven($number)
{
	 return $number % 2 === 0 ? 'yes' : 'no';
}

function check($number)
{
	 $result = isEven($number);
	 echo $result;
}

/*
Посмотрите на код выше внимательно. Все ли с ним нормально?

На самом деле, этот код даже хуже чем первая версия, потому что создана неверная абстракция. Понятие четности числа никак не связано ни с выводом на экран, ни со строчками yes или no. Оно существует в вакууме как математическая концепция и не может знать о том, как её собираются использовать. Я уже не говорю про то, что имя isEven начинается с is, а это значит, что функция - предикат. Такие функции могут возращать только логическое значение и никак иначе (исключений не существует!). Правильный вариант выглядит так:
*/

function isEven($number)
{
	 return $number % 2 === 0;
}

function check($number)
{
	 $result = isEven($number) ? 'yes' : 'no';
	 echo $result;
}

/*
И это самый примитивный вариант создания абстракций. В реальном коде обычно все значительно сложнее.

Реализуйте функцию findIndexOfNearest, которая принимает на вход массив чисел и искомое число. Задача функции — найти в массиве ближайшее число к искомому и вернуть его индекс в массиве.
*/

findIndexOfNearest([], 2); // => null
findIndexOfNearest([15, 10, 3, 4], 0); // => 2


function findIndexOfNearest(array $items, $value)
{
	 if (sizeof($items) === 0) {
		  return null;
	 }
	 
	 return array_reduce(array_keys($items), function ($acc, $i) use ($items, $value) {
		  return abs($items[$i] - $value) < abs($items[$acc] - $value) ? $i : $acc;
	 }, 0);
}


/**
 * Реализуйте функцию getFirstMenWithLessFriends, которая принимает список пользователей и возвращает пользователя у которого меньше всего друзей. Если список пользователей пустой, то возвращается null.
 **/

$users = [
	[
		'name' => 'Tirion',
		'friends' => [
			['name' => 'Mira', 'gender' => 'female'],
			['name' => 'Ramsey', 'gender' => 'male']
		]
	],
	['name' => 'Bronn', 'friends' => []],
	[
		'name' => 'Sam',
		'friends' => [
			['name' => 'Aria', 'gender' => 'female'],
			['name' => 'Keit', 'gender' => 'female']
		]
	],
	['name' => 'Keit', 'friends' => []],
	[
		'name' => 'Rob',
		'friends' => [
			['name' => 'Taywin', 'gender' => 'male']
		]
	]
];

getFirstMenWithLessFriends($users); // => ['name' => 'Bronn', 'friends' => []];

use Funct\Collection;

function getFirstMenWithLessFriends(Array $users)
{
	 return minValue($users, function ($user) {
		  return sizeof($user['friends']);
	 });
}


// Реализуйте функцию enlargeArrayImage, которая принимает изображение в виде двумерного массива и увеличивает его в два раза.

$arr = [
	['*', '*', '*', '*'],
	['*', ' ', ' ', '*'],
	['*', ' ', ' ', '*'],
	['*', '*', '*', '*']
];
// ****
// *  *
// *  *
// ****

enlargeArrayImage($arr);
// ********
// ********
// **    **
// **    **
// **    **
// **    **
// ********
// ********

function enlargeArrayImage($arr)
{
	 $result = [];
	 
	 foreach ($arr as $child) {
		  $childArray = [];
		  
		  foreach ($child as $symbol) {
				$childArray[] = $symbol;
				$childArray[] = $symbol;
		  }
		  
		  $result[] = $childArray;
		  $result[] = $childArray;
	 }
	 
	 return $result;
}


/**
 * NRZI код (Non Return to Zero Invertive) — один из способов линейного кодирования. Код формируется путем инверсного состояния при поступлении на вход кодирующего устройства логической единицы, при поступлении логического нуля состояние потенциала не меняется.
 * https://ru.wikipedia.org/wiki/NRZI
 **/

// Реализуйте функцию decode принимающую в качестве параметра строку в виде линейного сигнала и возвращающую строку с бинарным кодом. Пример использования:

$signal = '_|¯|____|¯|__|¯¯¯';
decode($signal); // => '011000110100'

$signal_2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_2); // => '110010000100111'

$signal_3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_3); // => '010010000100111'

/*
Подсказки
* Символ | в строке разделяет разные такты и означает, что уровень сигнала в следующем такте, был изменён на противоположный по сравнению с предыдущим тактом.

* К сожалению, str_split умеет работать только с ASCII символами, поэтому для разделения строки на символы используйте конструкцию preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);, где $str - строка.

*/

function decode($str)
{
	 $symbols = preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);
	 
	 $mapped = array_map(function ($key) use ($symbols) {
		  if ($symbols[$key] === '|') {
				return '|';
		  }
		  if ($key === 0) {
				return 0;
		  }
		  
		  return $symbols[$key - 1] === '|' ? 1 : 0;
	 }, array_keys($symbols));
	 
	 $filtered = array_filter($mapped, function ($item) {
		  return $item !== '|';
	 });
	 
	 return implode('', $filtered);
}



// Реализуйте функцию getSameParity, которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же четность, как и у первого элемента входного массива.

 function getSameParity($coll)
 {
	  $result = [];
	 
	  if (!empty($coll)) {
			$reminder = $coll[0] % 2;
		 
			foreach ($coll as $item) {
				 if ($item % 2 == $reminder) {
					  $result[] = $item;
				 }
			}
	  }
	 
	  return $result;
 }


/*
Реализуйте функцию getIndexOfWarmestDay, которая находит самый тёплый день (тот, в котором была зарегистрирована максимальная температура) и возвращает индекс этого дня в исходном массиве. Если на вход поступил пустой массив, то функция должна вернуть null

$data = [
  [-5, 7, 1],
  [3, 2, 3],
  [-1, -1, 10]
]

*/

function getIndexOfWarmestDay(array $data)
{
	 if (empty($data)) {
		  return null;
	 }
	 
	 $index = 0;
	 $max = $data[0][0];
	 
	 foreach ($data as $key => $temperatures) {
		  $current = max($temperatures);
		  
		  if ($current > $max) {
				$max = $current;
				$index = $key;
		  }
	 }
	 
	 return $index;
}




################ PHP: Построение абстракций ################


>>>>>  Линейно - рекурсивный процесс <<<<<<<

function Mypow($base, $exp) // Возведение в степень
{
	 if ($exp == 1) {
		  return 1;
	 }
	 return $base * Mypow($base, $exp - 1);
}

/*
Пусть функция fun вычисляет факториал переданного числа используя рекурсию, тогда ее вызов будет работать так:

fun(4)
4 * func(3)
4 * 3 * func(2)
4 * 3 * 2 * func(1)
4 * 3 * 2 * 1
4 * 3 * 2
4 * 6
=> 24

Там где * 1 рекурсия прерывается, потому что стоит условие в начале функции. И после этого начинается сворачивание.
*/

function rFunc($x)
{
	 if ($x == 0) {
		  return 1;
	 }
	 return $x + rFunc($x - 1);
}

echo rFunc(5); // 5+4+3+2+1+1 => 16


/*
Реализуйте рекурсивную функцию factorial, используя линейно-рекурсивный процесс.

Факториал числа можно выразить следующим образом:
factorial(0) -> 1
factorial(1) -> 1
factorial(n) -> n * factorial(n - 1)
*/

function factorial($num)
{
	 return $num <= 1 ? 1 : $num * factorial($num - 1);
}


/* Реализуйте рекурсивную функцию fib, находящую числа Фибоначчи, используя древовидно-рекурсивный процесс.

Формула:
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
*/

function fib($num)
{
	 if ($num <= 1) {
		  return $num;
	 }
	 return fib($num - 1) + fib($num - 2);
}




######################### ДЕКЛАРАТИВНОЕ ПРОГРАММИРОВАНИЕ #########################


>>>>>  Линейно - итеративный процесс <<<<<<<

function myPow($base, $exp)
{ // возведение в степень
	 $powIter = function ($exp, $acc) use (
		 $base,
		 &$powIter
	 ) { // блочная структура - использование внутри функции локальной функции. & - т.к. функцию используем в самой себе и во время определения.
		  if ($exp == 1) {
				return $acc;
		  }
		  return $powIter($exp - 1, $acc * $base);
	 };
	 
	 return $powIter($exp, 1); // задаем $acc = 1
}

/*
powIter 4,4,1
powIter 4,3,4
powIter 4,2,16
powIter 4,1,64
=> 64
*/


/**
 * Реализуйте рекурсивную функцию factorial 2 способами:
 **/

function factorial($num)
{
	 # линейно-рекурсивный процесс #
	 return $num <= 1 ? 1 : $num * factorial($num - 1);
	 
	 # линейно-итеративный процесс #
	 $iter = function ($num, $acc) use (&$iter) {
		  return $num <= 1 ? $acc : $iter($num - 1, $num * $acc);
	 };
	 return $iter($num, 1);
}


// Реализуйте рекурсивную функцию smallestDivisor, используя линейно-итеративный процесс. Функция должна находить минимальный делитель переданного числа. Минимальный делитель числа - это наименьшее число, на которое делится исходное без остатка.


function smallestDivisor($num)
{
	 $iter = function ($acc) use ($num, &$iter) {
		  if ($num <= $acc) {
				return $num;
		  }
		  return $num % $acc == 0 ? $acc : $iter($acc++);
	 };
	 
	 return $iter(2);
}



>>>>>  Функции первого класса . Передача как аргументов <<<<<<<

$sumIntegers = function ($a, $b) use (&$sumIntegers) {
	 if ($a > $b) {
		  return 0;
	 }
	 return $a + $sumIntegers($a + 1, $b);
};

$sumCubes = function ($a, $b) use (&$sumCubes) {
	 if ($a > $b) {
		  return 0;
	 }
	 return ($a * $a * $a) + $sumCubes($a + 1, $b);
};


function sum($a, $b, $func) // Функция высшего порядка. Суммирует от a до b, применяя доп. функцию
{
	 if ($a > $b) {
		  return 0;
	 }
	 return $func($a) + sum($a + 1, $b, $func));
}

echo sum(1, 5, function ($x) {
	 return $x;
}); // => 15


// можно описать функцию заранее:

$identity = function ($x) {
	 return $x ** 2;
};
echo sum(1, 5, $identity); // => 55


// Реализуйте функцию sum из видео, используя итеративный процесс.

function sum($start, $finish, $func)
{
	 $iter = function ($current, $acc) use ($finish, $func, &$iter) {
		  if ($current > $finish) {
				return $acc;
		  }
		  
		  return $iter($current + 1, $acc + $func($current));
	 };
	 
	 return $iter($start, 0);
}


/**
 * Реализуйте функцию product, которая сворачивает последовательность с помощью переданной функции. Последовательность задается первыми двумя аргументами. Первый это начало последовательности, второй это окончание. Например, последовательность [1, 4] это 1, 2, 3, 4. Свертка это сведение последовательности к какому-то значению. Само значение зависит от того, какая операция применяется при свертке. Обратите внимание, что последовательность, типа [$x, $x], состоит из одного числа $x и свертке не подлежит, функция в этом случае должна вернуть само число $x.
 *
 * 'С помощью переданной функции' означает то, что мы применяем эту функцию к элементам последовательности и используем ее результат, как аккумулятор (накопитель результата).
 *
 * Примеры:
 **/

// f(1, 2) => 1 + 2
3 == product(1, 2, function ($first, $second) {
	 return $first + $second;
}) // sum

// f(f(3, 4), 5) => f(-1, 5) => -1 - 5
- 6 == product(3, 5, function ($first, $second) {
		  return $first - $second;
	 }) // minus

/*
По последнему примеру видно, что операция является левоассоциативной. Рассмотрим данное свойство подробнее на последовательности [1, 4]:

Последовательность: 1, 2, 3, 4. Операция: f - внутренности не важны, главное, что это некая функция.

Разложим операцию с учетом ее левоассоциативности:
*/

f($left1, $right1); // $right1 = 4
f(f($left2, $right2), $right1); // $right2 = 3
f(f(f($left3, $right3), $right2), $right1); // $right3 = 2

// f = function ($first, $second) { return $first - $second; };
f(f(f(1, 2), 3), 4);
f(f(-1, 3), 4);
f(-4, 4); // -8

function product($num1, $num2, $func)
{
	 if ($num1 == $num2) {
		  return $num2;
	 }
	 return $func(product($num1, $num2 - 1, $func), $num2);
}

echo product(3, 5, function ($first, $second) {
	 return $first - $second;
}); // => -6

product(1, 3, $func) // ->
$func(product(1, 2, $func), 3); // ->
$func($func(product(1, 1, $func), 2), 3); // ->
$func($func(1, 2), 3);



>>>>>  Функции первого класса . Возврат как значения <<<<<<<

/*
Что дает нам возможность возвращать функции как значения?
 * Возможность повышать уровень абстракции
 * Возможность задавать алгоритмы в более обобщенном виде, без спецификации деталей.
*/

function sumGenerator($func)
{
	 return function ($a, $b) use ($func) { // определение лямбда функции и возврат ее как значения
		  return sum($a, $b, $func);
	 };
}

function sum($a, $b, $func)
{
	 if ($a > $b) {
		  return 0;
	 }
	 return $func($a) + sum($a + 1, $b, $func);
}

$sumIntegers = sumGenerator(function ($x) {
	 return $x ** 2 }); // лямбда-функция
$sumCubs = sumGenerator(function ($x) {
	 return $x * $x * $x;
}) // -//-
echo $sumIntegers(1, 5); // => 55
echo $sumCubs(1, 5); // => 255

/*
Ниже приведен пример определения функции, которая возводит свой аргумент в переданную степень (как замыкание). Один пример через прямое определение лямбды, второй через функцию, которая внутри себя определяет точно такую же лямбду и возвращает ее. Результат эквивалентен.
Определение напрямую:
*/

$exponent = 3;
$func = function ($number) use ($exponent) {
	 return $number ** $exponent; // операция возведения в степень
};

8 == $func(2); // 2^3

// Определение через вызов функции:

function power($exponent)
{
	 return function ($number) use ($exponent) {
		  return $number ** $exponent; // операция возведения в степень
	 };
}

$func = power(3);
8 == $func(2); // 2^3


/**
 * Реализуйте функцию factor, которая принимает на вход число (множитель) и возвращает функцию. Получившаяся функция принимает на вход один аргумент и возвращает результат умножения этого аргумента на множитель.
 *
 * Пример:
 **/

$multiTwo = factor(2); // 2 - множитель

4 == $multiTwo(2); // 2 * 2
20 == $multiTwo(10); // 10 * 2



function factor($multiplier)
{
	 return function ($arg) use ($multiplier) {
		  return $multiplier * $arg;
	 };
}


/**
 * Реализуйте функцию double, которая принимает как аргумент функцию с одним аргументом и возвращает функцию, которая применяет исходную функцию дважды.
 * Пример:
 * Исходная функция с одним аргументом:
 **/

2 == $increment(1); // функция увеличивает свой аргумент на единицу

// double вернул новую функцию, которая применяет inc дважды:

$increment2 = double($increment);
3 == $increment2(1) // эквивалентно $increment($increment(1));

// Тут мы применяем double дважды и в итоге increment выполняется 4 раза:

$increment4 = double(double($increment));
5 == $increment4(1);

function double($func)
{
	 return function ($arg) use ($func) {
		  return $func($func($arg));
	 };
}



>>>>> Что такое данные ? <<<<<<<

$pair = cons(1, 2); // pair - структура данных 'пара', пришла из лиспа. В PHP не реализована. cons - функция-конструтор

print_r($pair); // =>
/*
Closure Object
(
	  [static] => Array
			 (
					 [x] => 1
					 [y] => 2
			 )

	  [parameter] => Array
			 (
					 [$method] => <required>
			 )

)
*/

echo car($pair); // метод селектор - выбор первого значения из пары => 1
echo cdr($pair); // метод селектор - выбор второго значения из пары => 2

function cons($x, $y)
{
	 return function ($method) use ($x, $y) {
		  switch ($method) {
				case "car":
					 return $x;
				case "cdr":
					 return $y;
				default:
					 throw new \InvalidArgumentException("Invalid method $method.");
		  }
	 };
}

function car(callable $pair)
{
	 return $pair('car');
}

function cdr(callable $pair)
{
	 return $pair('cdr');
}

echo $pair("car"); // так нарушаем абстракцию, просто для понимания. 'car' - называется сообщением, а способ программирования - 'передачей сообщений' => 1

function isPair($pair)
{
	 return is_callable($pair);
}

function toString($list)
{
	 if (!isPair($list)) {
		  return $list;
	 }
	 
	 $iter = function ($items, array $acc = []) use (&$iter) {
		  if ($items == null) {
				return $acc;
		  }
		  return $iter(cdr($items), array_merge($acc, [toString(car($items))]));
	 };
	 $arr = $iter($list);
	 
	 return "(" . implode(", ", $arr) . ")";
}




/**
 * В текущем задании представлен другой способ реализации пар.
 * Допишите функцию car основываясь на том как работает функция cons.
 * Допишите функцию cdr основываясь на том как работает функция cons.
 **/

function cons($x, $y)
{
	 return function ($func) use ($x, $y) {
		  return $func($x, $y);
	 };
}

function car(callable $pair)
{
	 return function ($x, $y) use ($pair) {
		  return $x;
	 };
}

function cdr(callable $pair)
{
	 return function ($x, $y) use ($pair) {
		  return $y;
	 };
}


function makeList(...$elements)
{
	 return array_reduce(array_reverse($elements), function ($acc, $item) {
		  return cons($item, $acc);
	 });
}




>>>>>  Абстракция данных <<<<<<<

/*
Абстра́кция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

Это важный инструмент ООП наряду с полиморфизмом, наследованием и инкапсуляцией.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации. Это утверждение неверно, сокрытие особенностей реализации это инкапсуляция.

Абстракция данных — популярная и в общем неверно определяемая техника программирования. Фундаментальная идея состоит в разделении несущественных деталей реализации подпрограммы и характеристик, существенных для корректного её использования. Такое разделение может быть выражено через специальный «интерфейс», сосредотачивающий описание всех возможных применений программы.
*/

$rat = makeRat(1, 2); //  1 - числитель, 2 - знаменатель
printRat($rat); // => 1/2
numer($rat); // достает числитель -> 1
denom($rat); // достает знаменатель -> 1
printRat(addRat($rat, makeRat(2, 3))); // addRat - сложение рациональных чисел => 7/6


function makeRat($numer, $denom)
{
	 return cons($numer, $denom);
}

function numer($rat)
{
	 return car($rat);
}


function denom($rat)
{
	 return cdr($rat);
}

function cons($x, $y)
{
	 return function ($method) use ($x, $y) {
		  switch ($method) {
				case "car":
					 return $x;
				case "cdr":
					 return $y;
				default:
					 throw new \InvalidArgumentException("Invalid method $method.");
		  }
	 };
}


function addRat($rat1, $rat2)
{
	 // n1/d1 + n2/d2 == (n1 * d2 + n2 * d1) / (d1 * d2)
	 $numer = numer($rat1) * denom($rat2) + numer($rat2) * denom($rat1)
	$denom = denom($rat1) * denom($rat);

	return makeRat($numer, $denom);
}

function printRat($rat)
{
	 printf("%d/%d", numer($rat), denom($rat));
}

// ПРИНЦИП ОДНОГО УРОВНЯ АБСТРАКЦИИ:

// Рациональные числа в предметной области:
# addRat subRat equaksRat

// Рациональные числа как числители со знаменателями:
# makeRat numer denom

// Рациональные числа как пары:
# cons car cdr

// То, как реализуются пары
# ...


/*
Программа работает с географическими координатами для вычисления расстояний между точками. Координаты передаются в виде специальных структур данных, так, что широту и долготу можно получить с помощью специальных функций. Широта и долгота представлены в виде чисел, и программе необходимо знать, на каком компьютере были сохранены данные: на 32-битном или 64-битном. Для этого в структуре данных записан специальный флаг, а в программе реализованы две функции для обработки двух форматов чисел.

Нарушается ли в этом случае концепция абстракции данных?

- Да
Ключевое здесь описание уровня абстракции (и зоны ответственности) программы: Программа работает с географическими координатами для вычисления расстояний между точками.

Т.е. на уровне программы происходит работа с такими абстракциями, как географические координаты. Программа не должна знать (и зависеть) о подробностях внутренней реализации этих координат (как, к примеру, код работающий с такими абстракциями как геометрическая точка, не должен знать внутреннее устройство этой точки (пара это или же массив)).

Попытка внутри программы преобразовать значение координат в зависимости от разрядности системы - это уже не зона ответственности программы. Такая абстракция, как географическая координата, не должна зависеть от разрядности системы ("снаружи", с точки зрения кода, который пользуется этой абстракцией) и должна скрывать эти подробности внутри себя, а не перекладывать на использующую программу.
*/

/**
 * Реализуйте функцию subRat, которая производит вычитание рациональных чисел. При этом (с точки зрения внутренней реализации) функция возвращает в качестве результата новую пару (т.е. исходные пары, являющиеся параметрами функции, не изменяются).
 * Реализуйте функцию equalRat, которая делает проверку двух рациональных чисел на равенство.
 **/

function subRat($rat1, $rat2)
{
	 $numer = numer($rat1) * denom($rat2) - numer($rat2) * denom($rat1);
	 $denom = denom($rat1) * denom($rat2);
	 
	 return makeRat($numer, $denom);
}

function equalRat($rat1, $rat2)
{
	 return numer($rat1) * denom($rat2) == numer($rat2) * denom($rat1);
}



>>>>>  Замкнутые множества <<<<<<<

/*
Список - это абстрактный тип данных, представляющий собой упорядоченный набор значений, в котором некоторое значение может встречаться более одного раза. Экземпляр списка является компьютерной реализацией математического понятия конечной последовательности.

В списке нет индексированного доступа и невозможно получить напрямую доступ к произвольному элементу. В программе у нас есть доступ к голове списка через которую мы можем продвигаться дальше вглубь к хвосту списка.
*/

cons(10, cons(1, 30)); // алгебраическое замыкание
$list = cons(1, cons(2, cons(3, null))); // структура данных "список"(или "последовательность"). null - показывает конец списка
makeList(1, 2, 3); // аналогично коду выше
// В списке (1, 2, 3) 1 является головой head списка, а (2, 3) хвостом tail списка.

function listRef($list, $n) // показывает элемент определенной позиции (n)
{
	 if ($n == 0) {
		  return car($list);
	 } else {
		  return listRef(cdr($list), $n - 1);
	 }
}

$l = makeList(1, 2, 5, 7);
echo listRef($l, 0); // => 1
echo listRef($l, 1); // => 2


$l = cons(1, cons(3, cons(5, null)));
echo car(cdr($l)); // cdr возвращает список без головы. (5, 2, 3) -> (2, 3)     => 3

$l = cons(1, cons(3, cons(5, null)));
echo car(cdr(cdr($l)));// => 5

$l = cons(1, cons(3, cons(5, null)));
echo cdr(cdr(cdr($l))); // => null


/*
В видео говорится, что в PHP нет готовой реализации списков, но разве массивы из предыдущего курса не делают ровным счётом то же самое? Получается что мы реализуем массив, только с помощью пар? И есть ли какая-то объективная причина причина использовать пары, в таком ключе, ведь с массивами всё проще? Или это всё просто обучающий пример чтобы поработать головой?

=>
Массивы и списки это разные вещи. Массив, как АТД предоставляет возможность произвольного доступа к элементом и их изменение, а список включает в себя буквально две операции: добавить элемент в голову списка и снять голову.

С помощью пар мы реализуем именно список. А цель всего этого курса научить вас абстракциям, показать как из более простых элементов можно строить более сложные за счет композиции. О том что первично, а что является следствием.

* Абстра́ктный тип да́нных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций.
*/


/**
 * Реализуйте функцию length, которая считает длину списка;
 **/

$list = cons(1, cons(2, cons(3, null)));
	 
	 namespace App\Length;
	 
	 use function Pairs\cons;
	 use function Pairs\car;
	 use function Pairs\cdr;
	 
	 function length($items)
	 {
		  if ($items === null || !is_callable($items)) {
				return 0;
		  } else {
				return 1 + length(cdr($items));
		  }
	 }
	 
	 
	 /**
	  * Реализуйте функцию append, которая соединяет два списка; Подсказка: Попробуйте сначала представить как работала бы функция copy, которая принимает на вход список и возвращает его копию.
	  **/
	 
	 namespace App\Append;
	 
	 use function Pairs\cons;
	 use function Pairs\car;
	 use function Pairs\cdr;
	 
	 function append($list1, $list2)
	 {
		  if ($list1 === null) {
				return $list2;
		  } else {
				return cons(car($list1), append(cdr($list1), $list2));
		  }
	 }

// Пример:
	 append(cons(1, cons(2, cons(3, null))), cons(4, cons(5, cons(6, null)))); // =>
	 
	 cons(1, append(cons(2, cons(3, null)), cons(4, cons(5, cons(6, null)))));
	 cons(1, cons(2, append(cons(3, null), cons(4, cons(5, cons(6, null))))));
	 cons(1, cons(2, cons(3, append(null, cons(4, cons(5, cons(6, null)))))));
	 cons(1, cons(2, cons(3, cons(4, cons(5, cons(6, null))))));
	 cons(2, cons(3, cons(4, cons(5, cons(6, null)))));


// Реализуйте функцию reverse, которая переворачивает список;
	 
	 namespace App\Reverse;
	 
	 use function Pairs\cons;
	 use function Pairs\car;
	 use function Pairs\cdr;
	 
	 function reverse($list)
	 {
		  $iter = function ($list, $acc) use (&$iter) {
				return is_null($list) ? $acc : $iter(cdr($list), cons(car($list), $acc));
		  };
		  
		  return $iter($list, null);
	 }
	 
	 
	 reverse(cons(1, cons(2, cons(3, null)))); // =>
	 
	 $iter(cons(1, cons(2, cons(3, null))), null));
$iter(cons(2, cons(3, null)), cons(1, null));
$iter(cons(3, null), cons(2, cons(1, null)));
$iter(null, cons(3, cons(2, cons(1, null))));
cons(3, cons(2, cons(1, null)));



>>>>>  Map <<<<<<<

/*
map — функция высшего порядка, используемая во многих языках программирования, которая применяет данную функцию к каждому элементу списка, возвращая список результатов. При рассмотрении в функциональной форме она часто называется «применить-ко-всем».
https://ru.wikipedia.org/wiki/Map
https://codeclimate.com/github/hexlet-components/php-pairs/
*/

$scaleList = function ($list, $factor) use (&$scaleList) {
	 if ($list == null) {
		  return null;
	 } else {
		  $rest = $scaleList(cdr($list), $factor);
		  return cons(car($list) * $factor, $rest);
	 }
};


$list = makeList(1, 2, 3);
echo listToString($scaleList($list, 2)); // => 2,4,6

$map = function ($func, $list) use (&$map) { // повышаем уровень абстракции
	 if ($list == null) {
		  return null;
	 } else {
		  $rest = $map($func, cdr($list));
		  return cons($func(car($list), $rest));
	 }
};

$func = function ($item) {
	 return $item * 3;
}
echo listToString($map($func, $list)); // => 3,6,9


/**
 * Реализуйте map используя итеративный процесс.
 **/

require_once 'Pair.php';

use function App\Pair\cons;
use function App\Pair\car;
use function App\Pair\cdr;
use function App\Pair\reverse;
use function App\Pair\listToString;

function map($func, $list)
{
	 $iter = function ($list, $acc) use (&$iter, $func) {
		  return is_null($list) ? reverse($acc) : $iter(cdr($list), cons($func(car($list)), $acc));
	 };
	 return $iter($list, null);
}




>>>>>  Фильтрация <<<<<<<

$removeOdds = function ($list) use (&$removeOdds) { // по четным числам
	 if ($list == null) {
		  return null;
	 } else {
		  $curr = car($list);
		  $rest = $removeOdds(cdr($list));
		  
		  if ($curr % 2 == 0) {
				return cons($curr, $rest);
		  } else {
				return $rest;
		  }
	 }
};

$list = makeList(1, 2, 3, 5, 101, 100);
echo listToString($removeOdds($list)); // => (2, 10, 100)


// Реализуйте функцию filter, используя итеративный процесс.

function filter($func, $list)
{
	 $iter = function ($list, $acc) use (&$iter, $func) {
		  if ($list === null) {
				return reverse($acc);
		  }
		  
		  $newAcc = $func(car($list)) ? cons(car($list), $acc) : $acc;
		  return $iter(cdr($list), $newAcc);
	 };
	 
	 return $iter($list, null);
}




>>>>>  Свертка <<<<<<<

function sum($list)
{
	 $iter = function ($list, $acc) use (&$iter) {
		  if ($list == null) {
				return $acc;
		  }
		  
		  return $iter(cdr($list, $acc + car($list)));
	 };
	 
	 return $iter($list, 0);
}

function accumulate($list, $func, $acc)
{
	 $iter = function ($list, $acc) use (&$iter, $func) {
		  if ($list == null) {
				return $acc;
		  }
		  
		  return $iter(cdr($list), $func(car($list), $acc));
	 }

	return $iter($list, $acc);
}

$list = makeList(1, 5, 9);
$func = function ($item, $acc) {
	 return $acc + $item;
}
echo accumulate($list, $func, 0); // => 15
$func = function ($item, $acc) {
	 return cons($item * 2, $acc);
}
echo listToString(accumulate($list, $func, null)); // => (18, 10, 2)


/**
 * Реализуйте функцию solution которая принимает на вход список чисел и выполняет следующие действия:
 * округляет все числа в списке до верхней границы.
 * удаляет нечетные числа.
 * возвращает произведение оставшихся элементов.
 *
 * Подсказки
 * Округление до верхней границы: ceil.
 * Используйте функции map, filter, reduce из пакета hexlet/pairs, определение которых можно подсмотреть тут https://github.com/hexlet-components/php-pairs.
 **/

solution(l(1.3, 3.01, 5.5, 100.9, 2.5)); // → 48.0
solution(l(1.49, 1.99, 9.9, 9.0, -1.2, -2.5)); // → -80.0
	 
	 
	 namespace App\Solution;
	 
	 use function Lists\map;
	 use function Lists\filter;
	 use function Lists\reduce;
	 
	 function solution($list)
	 {
		  $ceilNums = map(function ($num) {
				return ceil($num);
		  }, $list);
		  
		  $evenNums = filter(function ($num) {
				return $num % 2 == 0;
		  }, $ceilNums);
		  
		  return reduce(function ($num, $acc) {
				return $num * $acc;
		  }, $evenNums, $acc = 1);
	 }
	 
	 
	 >>>>>
	 Деревья <<<<<<<

/*
Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы. Большинство источников также добавляют условие на то, что рёбра графа не должны быть ориентированными. В дополнение к этим трём ограничениям, в некоторых источниках указывается, что рёбра графа не должны быть взвешенными. https://ru.wikipedia.org/wiki/Дерево_(структура_данных)

Дерево можно назвать рекурсивной структурой данных, потому что каждая его часть по сути является деревом само по себе.
https://ru.hexlet.io/blog/posts/recursive
*/

l(2, 3, 4); // => cons(2, cons(3, cons(4, null)));
	 l(2, 3, l(4, 5)) // => cons(2, cons(3, cons(cons(4, cons(5, null)), null)));
	 

function treeMap($list, $func, $acc)
{
	 $iter = function ($list, $acc) use (&$iter, $func) {
		  if ($list == null) {
				return $acc;
		  }
		  
		  $element = car($list);
		  
		  if (isPair($element)) { // isPair - метод проверяет является ли элемент парой
				$newAcc = treeMap($element, $func, $acc);
		  } else {
				$newAcc = $func($element, $acc);
		  }
		  return $iter(cdr($list), $newAcc);
	 };
	 return $iter($list, $acc);
}

$list = l(1, 3, l(1, l(2, 3), 2), 9); // l == makeList()

$result = treeMap($list, function ($item, $acc) { // считает кол-во элементов
	 return $acc + 1;
}, 0); // => 7


/**
 * Реализуйте функцию reverse, которая переворачивает переданный на вход список рекурсивно.
 **/

l(1, l(3, 2), 5, l(6, l(5, 4))) => (((4, 5), 6), 5, (2, 3), 1)
l(l(3, l(4, 100), 5, 6, l(7))) => (((7), 6, 5, (100, 4), 3))

require 'Pair.php';

use function App\Pair\car;
use function App\Pair\isPair;
use function App\Pair\cdr;
use function App\Pair\cons;
use function App\Pair\listToString;


function reverse($list)
{
	 $iter = function ($items, $acc) use (&$iter) {
		  if ($items === null) {
				return $acc;
		  } else {
				$element = car($items);
				
				if (isPair($element)) {
					 $result = reverse($element);
				} else {
					 $result = $element;
				}
				return $iter(cdr($items), cons($result, $acc));
		  }
	 };
	 
	 return $iter($list, null);
}






>>>>>  Стандартные интерфейсы <<<<<<<


$list = l(1, 4, 5, 8, 9, 100);

function sumOfDoubleOdds($list) // сумма нечетных чисел * 2
{
	 return accumalate($list, function ($item, $acc) {
		  if ($item % 2 === 1) {
				return $item * 2 + $acc;
		  } else {
				return $acc;
		  }
	 }, 0);
}

// Принцип "Разделай и властвуй":

$result = filter($list, function ($item) {
	 return $item % 2 === 1;
});

$result2 = map($result, function ($item) {
	 return $item * 2;
});

$result3 = accumulate($result2, function ($item, $acc) {
	 return $acc + $item;
}, 0);

echo($result3); // => 30

// В других языках реализованы "ленивые коллекции", которые не производят вычислений до их использования.


/**
 * Реализуйте функцию solution, которая принимает на вход список чисел и выполняет следующие действия:
 *
 * удаляет все числа, не кратные трем.
 * возводит оставшиеся числа в квадрат.
 * возвращает среднее арифметическое списка полученного после предыдущей операции.
 *
 * Пример:
 *
 * 22.5 == solution(l(1, 3, 8, 6)) // (3 * 3 + 6 * 6) / 2
 *
 * Подсказки:
 *
 * Для подсчета числа элементов в списке используйте функцию length
 **/

function solution($list)
{
	 $multiplicityNums = filter($list, function ($item) {
		  return $item % 3 === 0;
	 });
	 
	 $squareNums = map($multiplicityNums, function ($item) {
		  return $item ** 2;
	 });
	 
	 $sumNums = accumulate($squareNums, function ($item, $acc) {
		  return $item + $acc;
	 }, 0);
	 
	 return $sumNums / length($squareNums);
}



>>>>>  Оператор присваивания <<<<<<<

# Процедурный стиль :

// Демонстрация - так не делать!
function deposit(&$balance, $amount)
{
	 $balance += $amount;
}

$balance = 100;
deposit($balance, 10);
echo $balance; // => 100


function newDeposit($balance) // инкапсуляция
{
	 return function ($amount) use (&$balance) {
		  $balance += $amount;
		  return $balance;
	 };
}

$d = newDeposit(100);
echo $d(10); // => 110
$d2 = newDeposit(100);
echo $d2(10); // => 110



/*
Напишите функцию newWithdraw, которая снимает деньги со счета. При попытке снять больше денег, чем есть на счете, она должна возвращать too much.
Пример:

$withdraw = newWithdraw(100);
$withdraw(1000); // 'too much'
$withdraw(50); // 50
$withdraw(45); // 5
*/

function newWithdraw($balance) // my
{
	 return function ($amount) use (&$balance) {
		  $newBalance = $balance - $amount;
		  return ($newBalance >= 0) ? $balance = $newBalance : 'too much';
	 };
}

function newWithdraw($balance) // hexlet
{
	 return function ($amount) use (&$balance) {
		  if ($balance < $amount) {
				return "too much";
		  } else {
				$balance -= $amount;
				return $balance;
		  }
	 };
}



>>>>>  Объекты <<<<<<<

function newAccount($balance)
{
	 $withdraw = function ($amount) use (&$balance) {
		  $balance -= $amount;
		  return $balance;
	 };
	 
	 $deposit = function ($amount) use (&$balance) {
		  $balance += $amount;
		  return $balance;
	 }

	return function ($funcName, $amount) use ($withdraw, $deposit) { // стиль "передача сообщений"
		 switch ($funcName) {
			  case "withdraw":
					return $withdraw($amount);
					break;
			  case "deposit":
					return $deposit($amount);
					break;
		 }
	};
}

$a = newAccount(100);
echo $a("deposit", 50); // 110
echo $a("deposit", 100); // 10
	 
	 
	 /**
	  * Измените функцию newAccount из видео так, чтобы она создавала счета, защищенные паролем.
	  *
	  * Пример:
	  *
	  * $acc = newAccount(100, "secret password");
	  * 110 == $acc("deposit", 10, "secret password");
	  * 60 == $acc("withdraw", 50, "secret password");
	  * "wrong password!" == $acc("deposit", 10, "wrong password");
	  **/
	 
	 namespace App;
	 
	 function newAccount($balance, $password)
	 {
		  $isPass = function ($pass) use ($password) {
				return $pass === $password ? true : false;
		  };
		  
		  $withdraw = function ($amount) use (&$balance) {
				$balance -= $amount;
				return $balance;
		  };
		  
		  $deposit = function ($amount) use (&$balance) {
				$balance += $amount;
				return $balance;
		  };
		  
		  return function ($funcName, $amount, $pass) use ($isPass, $withdraw, $deposit) {
				if (!$isPass($pass)) {
					 return "wrong password!";
				}
				
				switch ($funcName) {
					 case "withdraw":
						  return $withdraw($amount);
						  break;
					 case "deposit":
						  return $deposit($amount);
						  break;
				}
		  };
	 }
	 
	 
	 >>>>>
	 Преимущества присваивания <<<<<<<
 

function random($seed) // псевдослучайные  числа
{
	 return function () use (&$seed) { // число, являющееся базовым значением для вычисления следующего случайного числа
		  $a = 45;
		  $c = 21;
		  $m = 67;
		  $seed = ($a * $seed + $c) % $m;
		  
		  return $seed;
	 };
}

$a = random(10);
echo $a(); // => 44
echo $a(); // => 58
echo $a(); // => 27
echo $a(); // => 30


/**
 * Измените функцию random из видео так, чтобы можно было обнулять сгенерированную последовательность.
 * Пример:
 **/

$seq = random(3);
$result = $seq(); // 22
$seq(); // 6
$seq(); // 23

$seq("reset");

$result == $seq(); // 22

function random($seed)
{
	 $init = $seed;
	 
	 return function ($method = null) use (&$seed, $init) {
		  $a = 45;
		  $c = 21;
		  $m = 67;
		  
		  switch ($method) {
				case "reset":
					 $seed = $init;
					 break;
				
				default:
					 $seed = ($a * $seed + $c) % $m;
					 break;
		  }
		  
		  return $seed;
	 };
}



>>>>>  Недостатки присваивания <<<<<<<

function makeDecrementer($balance) // чистая функция
{
	 return function ($amount) use ($balance) {
		  return $balance - $amount;
	 };
}

$d = makeDecrementer(100);
echo $d(10); // 90
echo $d(10); // 90
echo $d(10); // 90

$d2 = makeDecrementer(100); // $d и $d2 - являются одним и тем же объектом


function makeWithdraw($balance) // нечистая функция
{
	 return function ($amount) use (&$balance) {
		  $balance -= $amount;
		  return $balance;
	 };
}

$w = makeWithdraw(100); // $w и $w2 разные объекты
$w2 = makeWithdraw(100);
$w(10); // => 90
$w(10); // => 80
$w2 = makeWithdraw(100); // => 90

# референциальная (ссылочная) прозрачность

function factorial($n) // функция в полуимперативном стиле
{
	 $product = 1;
	 $counter = 1;
	 $iter = function () use ($n, &$iter, &$product, &$counter) {
		  if ($counter > $n) {
				return $product;
		  } else {
				$product *= $counter;
				$couner += 1;
				return $iter();
		  }
	 };
	 
	 return $iter;
}
	 
	 
	 /**@@@
	  * Реализуйте функцию fib находящую числа Фибоначчи используя рекурсивно-итеративный процесс, но вместо аккумулятора параметров для вложенной функции $iter используйте переменные.
	  *
	  * Формула:
	  *
	  * f(0) = 0
	  * f(1) = 1
	  * f(n) = f(n-1) + f(n-2)
	  *
	  * Пример:
	  *
	  * 2 == fib(3);
	  * 5 == fib(5);
	  * 55 == fib(10);
	  *
	  * [0, 0]
	  * [1, 1]
	  * [1, 2]
	  * [2, 3]
	  * [3, 4]
	  * [5, 5]
	  * [55, 10]
	  **/


// FILE: /app/src/App/Solution.php:
	 namespace App\Solution;
	 
	 function fib($num)
	 {
		  $tmp;
		  $fib1 = 0;
		  $fib2 = 1;
		  $i = 0;
		  
		  $iter = function () use ($num, &$iter, &$fib1, &$fib2, &$i) {
				if ($i < $num) {
					 $tmp = $fib1;
					 $fib1 = $fib2;
					 $fib2 = $tmp + $fib2;
					 ++$i;
					 $iter();
				}
		  };
		  
		  $iter();
		  
		  return $fib1;
	 }
	 
	 
	 /**@@@
	  * Реализуйте функцию fringe, которая берет в качестве аргумента дерево (представленное в виде списка) и возвращает список, элементы которого - все листья дерева, упорядоченные слева направо.
	  *
	  * Пример:
	  **/
	 
	 l(4, 3, 2, 1) == fringe(l(l(4, 3), l(2, 1)));
	 
	 l() => l()
l(1, 2) => l(1, 2)
l(4, 3, 2, 1) => l(l(4, 3), l(2, 1))
l(4, null, 5, 7, 9, 1, 1) => l(l(4, l(null, 5)), l(l(7, 9), 1), 1)




/**
 * Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и g есть функция x → f ( g (x) ).
 * Solution.php
 *
 * Определите функцию compose которая реализует композицию.
 *
 * Пример:
 **/

$square = function ($num) {
	 return $num ** 2;
};

$half = function ($num) {
	 return $num / 2;
};

$func1 = compose([$square, $half]);
$func1(10); // 25

$func2 = compose([]);
$func2(3); // 3

/*
[3, 3, []],
[1, 0, [$inc]],
[25, 10, [$square, $half]],
[25, -11, [$square, $half, $inc]]
*/



/**
 * Определите функцию sameParity, которая принимает список построенный на парах и возвращает отфильтрованный список у которого четность каждого элемента совпадает с четностью первого элемента этого списка.
 * Пример:
 **/

l(1, 3) == l(1, 10, 3, 2)


// Подсказки: Функция l это сокращенная запись для вложенных cons. Подробнее https://github.com/hexlet-components/php-pairs

/*
l(), l()
l(1), l(1)
l(1, 5), l(1, 2, 5, 0)
l(10, 2, 0), l(10, 2, 5, 0)]
*/



/**
 * Реализуйте функцию deepReverse, которая принимает список в качестве аргумента и возвращает в качестве значения список, где порядок элементов обратный и подсписки также обращены.
 *
 * Пример:
 **/
l(l(1, 2), l(3, 4)) == deepReverse(l(l(4, 3), l(2, 1)));



/*
[l(), l()],
[l(2, 1), l(1, 2)],
[l(l(1, 2), l(3, 4)), l(l(4, 3), l(2, 1))],
[l(1, l(1, l(9, 7)), l(l(5, null), 4)), l(l(4, l(null, 5)), l(l(7, 9), 1), 1)]
*/


/**
 * Реализуйте функцию fib находящую положительные числа Фибоначчи. Аргументом функции является порядковый номер числа.
 *
 * Формула:
 *
 * f(0) = 0
 * f(1) = 1
 * f(n) = f(n-1) + f(n-2)
 *
 * Пример:
 *
 * 2 == fib(3)
 * 5 == fib(5)
 * 55 == fib(10)
 *
 * [0, 0]
 * [1, 1]
 * [1, 2]
 * [2, 3]
 * [3, 4]
 * [5, 5]
 * [55, 10]
 */


/**
 * Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f — функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение которой в точке x есть среднее между f(x − dx), f(x) и f(x + dx).
 * Solution.php
 *
 * Напишите функцию smooth, которая в качестве ввода принимает два аргумента: функцию, вычисляющую f, и малое число dx, а возвращает функцию, вычисляющую сглаженную версию f.
 *
 * Пример:
 **/

$smoothFunc = smooth(function ($sum) {
	 return sin(rad2deg($sum));
}, 15);

$smoothFunc(10) // ~ 0.438


/*
public function testSmooth($expected, $x, $dx, $func)
{
	$smoothFunc = Solution\smooth($func, $dx);
	$this->assertEquals($expected, $smoothFunc($x), '', 0.01);
}

public function additionProvider()
{
 return [
			[0.438, 10, 15, function ($num) {
				  return sin(rad2deg($num));
			}],
			[5, 0, 5, function ($num) {
				  return $num + 5;
			}],
			[4, 2, 0.00001, function ($num) {
				  return $num ** 2;
			}],
			[9, 3, 0.00001, function ($num) {
				  return $num ** 2;
			}]
	];
}
}
*/


####################  Веб-разработка на PHP ######################
	 
	 /*
Переход от написания скриптов (то что мы делали ранее) к созданию полноценных сайтов, сопровождается необходимостью знакомиться с большим числом понятий и инструментов выходящих далеко за рамки языка. Взаимодействие с внешним миром вовлекает в себя знание операционных систем, в частности сетей, работу с регистраторами, хостингом, деплоем сайта. На собеседованиях веб-программистов часто задают вопрос "Что происходит после того как в адресной строке браузера набирается сайт www.google.com и нажимается enter?". Очень подробный ответ на этот вопрос доступен здесь (https://github.com/alex/what-happens-when).
Спрашивающий, в этот момент, хочет услышать от вас ключевые понятия связанные с веб-разработкой.

1. Выполнение DNS запроса для получения IP адреса по имени домена.
2. Соединение с веб-сервером находящемся по этому адресу на порту 443 (или 80) по TCP.
3. Выполнение HTTP запроса на содержимое сайта по указанному домену
4. Получение ответа и рендеринг содержимого во вкладке браузера

Каждый из этих пунктов неявно подразумевает знание следующих тем:

* Протокол HTTP. Понятие виртуальных хостов. Желательно понимание принципов работы HTTPS.
* Принципы работы DNS.
* Знание TCP/IP. Понятия: порт, маска, подсети. Модель OSI. Сетевые сокеты.
* Веб-сервер. Что это такое, как работает и зачем нужен.

Фреймворки, микрофреймворки, роутинг, куки, сессии, безопасность, шаблонизация, взаимодействие с базой данных и многое другое. И даже когда вы научитесь готовить сайт, это еще не конец. Сайт доступен пользователям только находясь на удаленном сервере, а значит в разработку включается понятие "деплой", то есть процесс разворачивания сайта на хостинге. Причем чтобы сайт развернуть, для начала нужно настроить удаленную машину (или машины) используя инструмент наподобие Ansible. Кстати сам хостинг бывает очень разный: IaaS (aws), PaaS (heroku), Shared Hosting, VPS/VDS.

Данный курс посвящен, в первую очередь, разработке веб-сайтов с использованием микрофреймворков и темы указанные выше включает в себя лишь поверхностно (и то не все). Поэтому крайне рекомендуется выполнять задачи не только в среде Хекслета, но и локально, паралелльно выкатывая код на сервис подобный https://www.heroku.com/

# Дополнительные материалы
Что такое протокол HTTPS, и как он защищает вас в интернете https://yandex.ru/blog/company/77455
Как работает DNS https://habr.com/post/137587/
Что такое веб-сервер? https://developer.mozilla.org/ru/docs/Learn/Что_такое_веб_сервер
*/
	 
	 
	 >>>>> Архитектура Веба <<<<<<

/*
Современные сайты разрабатываются на множестве языков используя совершенно разные технологии, но принципы их устройства одинаковые. То почему сайты внутри устроены похожим образом, определяется архитектурой веба. В его основе лежит протокол HTTP, с которым вы уже знакомы по одноименному курсу.

Современный веб несколько сложнее благодаря Websockets, что существенно влияет на принципы построения сайтов активно их использующих.

Принцип взаимодействия с любым сайтом сводится к следующим шагам:

1. Пользователь запрашивает страницу сайта
2. Браузер выполняет HTTP запрос к веб-серверу
3. Веб-сервер возвращает содержимое страницы в HTTP ответе
4. Браузер отрисовывает страницу сайта
5. Пользователь кликает по ссылке на сайте и весь процесс повторяется снова.

Каждый такой цикл включает в себя HTTP сессию: HTTP запрос и HTTP ответ. Проще всего увидеть HTTP сессию используя утилиту curl:
*/

$ curl - v--head http://code-basics.ru
* Rebuilt URL to: http://code-basics.ru/
*   Trying 100.102.175.148...
* TCP_NODELAY set
	 * Connected to code - basics . ru(100.102.175.148) port 80 (#0)
> HEAD / HTTP / 1.1
> Host: code - basics . ru
	 > User - Agent: curl / 7.54.0
	 > Accept: */*
>
< HTTP/1.1 200 OK
< Date: Wed, 04 Jul 2018 08:38:22 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 7902
< Connection: keep-alive
< Server: nginx/1.15.1

<
* Connection #0 to host code-basics.ru left intact

/*
Как видно, принцип взаимодействия не зависит от того на чем написан сайт. С точки зрения сайта, всегда есть запрос который нужно обработать и вернуть ответ в виде, например, HTML. То каким будет HTML для конкретного запроса, определяется самим запросом, то есть запрошенной страницей и различными параметрами HTTP, такими как заголовки. В конечном итоге код сайта представляет из себя набор обработчиков разных страниц, которые принимают входящие запросы, формируют ответ и возвращают его. Ниже вы увидите примеры на разных языках. Даже не зная синтаксиса достаточно легко уловить общую структуру всех примеров кода: функция обработчик привязанная к конкретной странице.
*/

// PHP

$app = new Slim\App();

$app->get('/', function ($request, $response) {
	 $response->write('Welcome to Slim!');
	 return $response;
});

$app->get('/about', function ($request, $response) {
	 $response->write('About My Site');
	 return $response;
});

$app->run();


// Ruby

require 'sinatra'
get '/frank-says' do
		  'Put this in your pipe & smoke it!'
end

// Python

from flask import Flask
app = Flask(__name__)

@app . route("/")
def hello():
  return "Hello World!"

// Java

import static spark . Spark .*;

public class HelloWorld
	 {
		  public static void main(String[] args) {
get("/hello", (req, res) -> "Hello World");
}
}

// JavaScript

import Express from 'expressjs';
const app = new Express();

app . get('/', (req, res) => {
		  res . send('Hello World!');
	 });

/*
Конечно реальные сайты устроены значительно сложнее, но в основе лежит та связка запрос-ответ, которая была описана в этом уроке.
*/

/**@@@
 * src\Url.php
 * Реализуйте абстракцию для работы с урлами. Она должна извлекать и менять части адреса. Интерфейс:
 *
 * make($url) - Конструктор. Создает урл.
 * setScheme($data, $scheme) - Сеттер. Меняет схему.
 * getSchema($data) - Селектор (геттер). Извлекает схему.
 * setHost($data, $host) - Сеттер. Меняет хост.
 * getHost($data) - Геттер. Извлекает хост.
 * setPath($data, $path) - Сеттер. Меняет строку запроса.
 * getPath($data) - Геттер. Извлекает строку запроса.
 * setQueryParam($data, $key, $value) - Сеттер. Устанавливает значение для параметра запроса.
 * getQueryParam($data, $paramName, $default = null) - Геттер. Извлекает значение для параметра запроса. Третьим параметром функция принимает значение по умолчанию, которое возвращается тогда, когда в запросе не было такого параметра
 * toString($data) - Геттер. Преобразует урл в строковой вид.
 */
$url = Url\make("https://hexlet.io/community?q=low");
'https://hexlet.io/community?q=low', Url\toString($url));

$url = Url\setScheme($url, 'http');
Url\toString($url)); // 'http://hexlet.io/community?q=low'

$url = Url\setPath($url, '/404');
Url\toString($url)); // 'http://hexlet.io/404?q=low'

$url = Url\setQueryParam($url, 'page', 5);
Url\toString($url)); // 'http://hexlet.io/404?q=low&page=5'

$url = Url\setQueryParam($url, 'q', 'high');
Url\toString($url)); // 'http://hexlet.io/404?q=high&page=5'

$url = Url\setQueryParam($url, 'q', null);
Url\toString($url)); // 'http://hexlet.io/404?page=5'

/*
Подсказки
 - Парсинг урла - parse_url
 - Парсинг параметров запроса - parse_str
 - Формирование строки запроса - http_build_query
 - Собирать данные в url придется самостоятельно
*/

 function make($url)
 {
	  $data = parse_url($url);
	  $queryParams = [];
	 
	  if (isset($data['query'])) {
			parse_str($data['query'], $queryParams);
	  }
	 
	  $data['queryParams'] = $queryParams;
	 
	  return $data;
 }

function setScheme($data, $scheme)
{
	 $data['scheme'] = $scheme;
	 return $data;
}

function getSchema($data)
{
	 return $data['scheme'];
}

function setHost($data, $host)
{
	 $data['host'] = $host;
	 
	 return $data;
}

function getHost($data)
{
	 return $data['host'];
}

function setPath($data, $path)
{
	 $data['path'] = $path;
	 
	 return $data;
}

function getPath($data)
{
	 return $data['path'];
}

function setQueryParam($data, $key, $value)
{
	 $data['queryParams'][$key] = $value;
	 
	 return $data;
}

function getQueryParam($data, $paramName, $default = null)
{
	 return $data['queryParams'][$paramName] ?? $default;
}

function toString($data)
{
	 $queryString = http_build_query($data['queryParams']);
	 $fullQueryString = $queryString ? "?{$queryString}" : '';
	 $schema = getSchema($data);
	 $host = getHost($data);
	 $path = getPath($data);
	 
	 return "{$schema}://{$host}{$path}{$fullQueryString}";
}


>>>>> Веб - сервер <<<<<
/*

# Процессы

Давайте теперь посмотрим для чего нужен веб-сервер. Ответ на этот вопрос требует небольшой подготовки.

Единицей исполнения в операционных системах является процесс. Это некоторая абстракция внутри ОС (имеется ввиду, что процесс невозможно представить визуально). Любая запущенная программа представляет собой либо один процесс, либо набор процессов. Например, в браузерах одна вкладка, как правило, — это один процесс. Особенность процессов в том, что они изолированы друг от друга. Например, сбой в одном процессе не влечет за собой остановку работы других. Такое свойство процессов можно наблюдать в тех ситуациях, когда одна из вкладок браузера начинает тормозить и в конце концов зависает (и её не всегда удаётся закрыть!). В это время можно без проблем продолжать использовать другие вкладки.

Внутри себя процесс может делиться на потоки, но эта деталь не влияет на описываемую тему, поэтому я её опускаю. Подробнее о менеджменте процессов можно прочитать в книгах по операционным системам.

Посмотреть список процессов в Linux можно командой ps aux либо top

Понимание процессов тесно связано с сетевым взаимодействием. Взаимодействие между двумя компьютерами в сети — всегда сводится к взаимодействию двух процессов. Другими словами, нельзя взять и подключиться к компьютеру в целом — можно подключиться только к конкретному процессу конкретной программы. Происходит это так: одна программа, которая хочет, чтобы к ней можно было подключаться по сети, при запуске начинает слушать сетевой сокет. Такая программа называется сервером. Другая программа к ней подключается. Такая программа называется клиентом. В случае веба, сервер — это конкретный веб-сервер, например, nginx, а клиент — это браузер.

Здесь нужно сделать небольшую ремарку насчет "слушать сетевой сокет". Сетевое взаимодействие между программами двух компьютеров осуществляется с помощью протокола TCP, поверх которого уже работает HTTP. Для обращения к другому комьютеру нужно знать два параметра: IP адрес и порт. Так вот "слушать сетевой сокет" означает занять определённый порт (на определённом сетевом интерфейсе) и дать возможность обращаться к процессу через него. Именно по номеру порта операционная система понимает, к какому процессу пытаются обратиться.

Браузер, благодаря DNS, получает IP адрес компьютера, на котором расположен сайт указанного домена (например, google.com). А вот откуда он знает порт, на котором висит веб-сервер в ожидании входящих запросов? Ответ на этот вопрос очень простой: существует соглашение, согласно которому веб-сервер, обслуживающий сайт по протоколу HTTP, слушает порт 80, а протокол HTTPS обслуживается на порту 443. Но так бывает не всегда. Во время локальной разработки, обычно, используются другие порты, например, 3000, или 4000. Сам номер не принципиален, главное, что он доступен для веб-сервера, и вы обращаетесь через браузер именно к нему. Порт указывавется через двоеточие после названия сайта, например www.google.com:80.

# Веб-сервер
Веб-сервер — специализированная программа для обслуживания сайтов. Один веб-сервер может обрабатывать практически любое число сайтов (благодаря Virtual Hosts). В общем случае он перенаправляет входящие сетевые запросы на код сайтов, получает от них ответ и возвращает его браузеру. Кроме главной функции, у веб-серверов огромное число вспомогательных. Среди них кеширование, перезапись запросов, раздача статики (например, картинки), reverse proxy, балансировка нагрузки и многое другое. Веб-сервера ничего не знают про то, на чём написан сайт. Все способы взаимодействия веб-сервера и сайта на любом языке стандартизированы. Благодря этому веб-серверов существует не так много и все они могут работать с сайтами, написанными на чём угодно.

Первым и самым простым способом взаимодействия веб-сервера с сайтом был CGI (Common Gateway Interface - интерфейс, который описывает способ взаимодействие сайта и веб-сервера. Благодаря этому стандарту, веб-сервер не зависит от того на чем написан сайт.). Этот стандарт сразу разрабатывался с учётом того, что сервер не должен зависеть от того, на чём написан сайт. Он основан на переменных окружения. По сути, сайт представляет из себя исполняемый файл, который запускается веб-сервером во время обработки входящего запроса и передает в него все параметры запроса через переменые окружения. Всё, что требуется от скрипта, — это вернуть HTTP ответ в стандартный вывод (STDOUT). Общий алгоритм работы выглядит так:

1. Клиент запрашивает страницу сайта.
2. Веб-сервер принимает запрос и устанавливает переменные окружения (через них приложению передаются данные и служебная информация).
3. Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
4. CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5. Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
6. Веб-сервер передаёт результаты запроса клиенту.

Дополнительные материалы
Сетевые сокеты https://ru.wikipedia.org/wiki/Сокет_(программный_интерфейс)
CGI https://ru.wikipedia.org/wiki/CGI
FastCGI https://ru.wikipedia.org/wiki/FastCGI
*/



>>>>> Встроенный в PHP веб - сервер <<<<<

/*
PHP единственный язык программирования, в котором работа в CGI режиме встроена прямо в сам язык. А благодаря наличию встроенного веб-сервера, можно сразу видеть результат своей работы.

Разработка сайтов, с точки зрения организации кодовой базы, мало отличается от разработки обычных программ. Первым делом необходимо создать директорию внутри которой будет вестись разработка, а затем ее следует добавить в git репозиторий. Если проект учебный, то лучше сразу создать репозиторий на гитхабе и выкладывать все эксперименты туда.

Затем нужно создать внутри этой директории файл index.php. По соглашению это главный входной файл в PHP, который автоматически ищется веб-серверами. Создайте такой файл в директории проекта со следующим содержимым:
*/

// Печатает год в STDOUT
echo date('Y');

// Затем запустите веб сервер, например, на порту 8000.

$  php - S localhost:8000
PHP 7.2.7 Development Server started at Wed Jul  4 15:28:08 2018
Listening on http://localhost:8000
Document root is /private/tmp
Press Ctrl - C to quit .

/*
После того как сервер будет запущен, он полностью забирает управление. Вкладка терминала больше не доступна для ввода команд. В отличии от обычных скриптов, которые выполняют свою задачу и заканчиваются, веб-сервера должны слушать порт непрерывно и сразу реагировать на входящие соединения. Поэтому однажды запустив сервер, он продолжит работать до тех пор пока его не остановят. Остановить сервер можно набрав Ctrl-C.

Такой способ запуска удобен в разработке, но в реальном окружении сервера запускают в виде Демонов.
Демон - процесс операционной системы работающий в фоне.

Если в это время попытаться запустить еще один веб-сервер в соседней вкладке на том же порту, то запуск завершиться с такой ошибкой:

Failed to listen on localhost:8000 (reason: Address already in use)

В своей программисткой жизни вы встретитесь с этой ошибкой не раз. Она означает что какой-то процесс занял соответствующий порт (в данном случае 8000). В такой ситуации нужно либо остановить процесс который вам мешает, либо стартовать на другом порту.

Посмотреть какой процесс занял порт 8000 можно командой sudo lsof -i :8000

После этого откройте браузер и введите http://localhost:8000. На экран выведется текущий год. В терминале, где запущен веб-сервер, появятся записи (лог) показывающие входящие запросы.

[Wed Jul  4 15:28:16 2018] ::1:51214 [200]: /
[Wed Jul  4 15:28:17 2018] ::1:51215 [404]: /favicon.ico - No such file or directory

Теперь снова откройте файл index.php и добавьте ниже вывод echo 'Hello, world!';. Если теперь сделать f5 в браузере, то вы увидите что изменения применились автоматически. Так происходит потому что веб-сервер запускает файл на выполнение каждый раз заново.

Дополнительные материалы
Встроенный в PHP веб-сервер http://php.net/manual/ru/features.commandline.webserver.php
Демон https://ru.wikipedia.org/Демон_(программа)
*/



>>>>> PHP CGI <<<<<
/*
В предыдущем уроке мы создали сайт буквально из одного PHP файла, печатающего в STDOUT текущий год. Все необходимые HTTP заголовки ответа PHP отправил автоматически.
*/

$ curl - v localhost:8000
	 * Trying::1. ..
* TCP_NODELAY set
	 * Connected to localhost(::1) port 8000 (#0)
> GET / HTTP / 1.1
> Host: localhost:8000
	 > User - Agent: curl / 7.54.0
	 > Accept: */*
>
< HTTP/1.1 200 OK
< Host: localhost:8000
< Date: Thu, 05 Jul 2018 06:20:10 +0000
< Connection: close
< X-Powered-By: PHP/7.2.7
< Content-type: text/html; charset=UTF-8
<
* Closing connection 0


/*
PHP об этом говорит прямо: X-Powered-By: PHP/7.2.7. Заголовки можно менять и добавлять используя функцию header.
*/

// file: index.php

header('X-My-Header: hi!');
echo date('Y');

// Теперь запрос

$ curl--head localhost:8000
HTTP / 1.1 200 OK
Host: localhost:8000
Date: Thu, 05 Jul 2018 06:26:29 + 0000
Connection: close
X - Powered - By: PHP / 7.2.7
X - My - Header: hi!
	 Content - type: text / html; charset = UTF - 8
		 
		 /*
	Как видно, заголовок появился в ответе. Помните, что функцию header можно вызывать только если клиенту еще не передавались данные. То есть она должна идти первой в выводе, перед ее вызовом не должно быть никаких HTML-тегов, пустых строк и т.п.
	*/
		 
		 < p>hi </p >
	 
	 /* Этот пример приведет к ошибке. Обратите внимание
 * на тег вверху, который будет выведен до вызова header()
 */
	 header('Location: http://www.example.com/');

/*
Все что мы обсудили выше, касается HTTP ответа, но не менее важно уметь работать с данными HTTP запроса: посмотреть текущие заголовки, адрес, параметры запроса и его тело. Для этого в PHP реализованы суперглобальные переменные (массивы). Суперглобальность означает то, что они доступны из абсолютно любого места программы. К ним относятся:

$GLOBALS
$_SERVER
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_REQUEST
$_ENV

И хотя чисто технически это обычные массивы которые можно изменять, большинство из них, все же, предназначены только для чтения. Например массив $_SERVER содержит в себе все заголовки запроса:
*/

Array
(
	[DOCUMENT_ROOT] => /private/tmp
	 [REMOTE_ADDR] => ::1
	 [REMOTE_PORT] => 58667
	 [SERVER_SOFTWARE] => PHP 7.2.7 Development Server
	 [SERVER_PROTOCOL] => HTTP / 1.1
	 [SERVER_NAME] => localhost
	 [SERVER_PORT] => 8000
	 [REQUEST_URI] => /
	 [REQUEST_METHOD] => GET
	 [SCRIPT_NAME] => /index . php
	 [SCRIPT_FILENAME] => /private/tmp / index . php
	 [PHP_SELF] => /index . php
	 [HTTP_HOST] => localhost:8000
	 [HTTP_USER_AGENT] => curl / 7.54.0
	 [HTTP_ACCEPT] => */*
	 [REQUEST_TIME_FLOAT] => 1530772973.7628
	 [REQUEST_TIME] => 1530772973
)

/*
Обратите внимание на формат ключей. PHP автоматически переводит все имена заголовков в верхний регистр. Кроме заголовков этот массив содержит некоторые дополнительные параметры, например имя запущенного скрипта и версию PHP. Практически главный ключ в этом массиве REQUEST_URI. Он содержит адрес запрошенной страницы и на основе него выбирается подходящее действие.

$_POST содержит данные отправленные методом POST. А вот $_GET вопреки своему названию, содержит Query Params, которые, если вы помните, можно отправить с любым глаголом. Кстати не все PHP программисты это знают и думают что существует понятие "гет параметры". Массив $_REQUEST содержит объединенные данные массивов $_POST и $_GET.

С одной стороны, поддержка CGI внутри самого языка позволяет начать делать сайт буквально на коленке без особых знаний программирования и HTTP, что многие и делают. С другой, PHP толкает к созданию абсолютно не поддерживаемого кода, который не может никто прочитать кроме автора. Посмотрите сами:
*/

<!DOCTYPE html >
<html >
<head >
  <title > Upload your files </title >
</head >
<body >
  <form enctype = "multipart/form-data" action = "upload.php" method = "POST" >
	 <p > Upload your file </p >
	 <input type = "file" name = "uploaded_file" ></input ><br />
	 <input type = "submit" value = "Upload" ></input >
  </form >
</body >
</html >

//<?php
  if (!empty($_FILES['uploaded_file'])) {
		$path = "uploads/";
		$path = $path . basename($_FILES['uploaded_file']['name']);
		if (move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $path)) {
			 echo "The file " . basename($_FILES['uploaded_file']['name']) . " has been uploaded";
		} else {
			 echo "There was an error uploading the file, please try again!";
		}
  }
//?>
<!DOCTYPE html>
<html>
<head>
  <title>Upload your files</title>
</head>
<body>
  <form enctype="multipart/form-data" action="upload.php" method="POST">
	 <p>Upload your file</p>
	 <input type="file" name="uploaded_file"></input><br />
	 <input type="submit" value="Upload"></input>
  </form>
</body>
</html>

//<?php
  if (!empty($_FILES['uploaded_file'])) {
		$path = "uploads/";
		$path = $path . basename($_FILES['uploaded_file']['name']);
		if (move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $path)) {
			 echo "The file " . basename($_FILES['uploaded_file']['name']) . " has been uploaded";
		} else {
			 echo "There was an error uploading the file, please try again!";
		}
  }
//?>

/*
Такой способ программирования возможен только в PHP. Весь сайт начинает представлять из себя мешанину HTML и кода. Если количество разных страниц сайта достигнет хотя бы десятка (а их обычно сотни и больше), то поддержка уже станет невероятно сложной.

Поэтому несмотря на наличие встроенных механизмов (к слову неудачных), в PHP как и в других языках, принято работать поверх программных абстракций, с которыми мы познакомимся в следующих уроках.
*/


/**
Реализуйте микросайт, со следующими страницами:

/. Содержимое:

<a href="/welcome">welcome</a>
<br>
<a href="/not-found">not-found</a>
/welcome. Содержимое:

<a href="/">main</a>
Все остальные обращения считаются не найденными страницами. На такие запросы должен возвращаться код ответа 404 и содержимое:

Page not found. <a href="/">main</a>
**/

$address = $_SERVER['REQUEST_URI'];

switch ($address) {
	case '/':
	  echo '<a href="/welcome">welcome</a>';
	  echo '<br>';
	  echo '<a href="/not-found">not-found</a>';
	  break;
	case '/welcome':
	  echo '<a href="/">main</a>';
	  break;
	default:
	  header("HTTP/1.0 404 Not Found");
	  echo 'Page not found. <a href="/">main</a>';
	  break;
}

/*
Что значит фраза "PHP имеет встроенную поддержку CGI"?
> Любой PHP скрипт сразу может работать как CGI скрипт, всю работу по анализу входящего окружения (параметры запроса) и возврат ответа, берет на себя рантайм (то что исполняет PHP код).
*/



>>>>> Микрофреймворк Slim <<<<<

/*
Цикл запрос-обработка-ответ включает множество элементов, которые идентичны для всех сайтов. Поэтому возникли, так называемые, фреймворки, специализированные библиотеки, которые определяют структуру программы. В этом их отличие от обычных библиотек. Благодаря фреймворкам можно сосредоточиться на логике сайта, а не на продумывании базовой архитектуры или кодированию вспомогательных инструментов.

Веб-фреймворки подразделяются на две больших группы одна из которых так и называется Фреймворки, а другая - Микрофреймворки. Микрофреймворки устроены значительно проще и содержат внутри себя только минимально необходимую обвязку для комфортной работы в архитектуре HTTP запрос-ответ. Они идеально подходят для обучения, потому что просты в эксплуатации и не отвлекают от главного. С одним микрофреймворком мы уже знакомились ранее - Slim. Теперь, обладая гораздо более глубоким пониманием происходящих процессов, мы сможем изучить его вдоль и поперек, попутно разбирая типичные задачи и их способы решения в вебе.

Slim

.
├── hexlet-slim-example
│   └── public

Создайте репозиторий внутри hexlet-slim-example и добавьте его на github. Не забудьте создать файл .gitignore и поместите туда директорию vendor.
hexlet-slim-example теперь называется корневой директорией проекта (root directory).

Зайдите в корневую директорию проекта и установите Slim:

composer require slim/slim "^3.0"

Добавьте файл hexlet-slim-example/public/index.php со следующим содержимым:
*/

require __DIR__ . '/../vendor/autoload.php';

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ]
];

$app = new \Slim\App($configuration);

$app->get('/', function ($request, $response) {
	 return $response->write('Welcome to Slim!');
});
$app->run();

/*
Создайте файл Makefile в корне проекта и добавьте туда задачу start:
*/
start:
	 php -S localhost:8000 -t public public/index.php

/*
Теперь выполните запуск:
$ make start

Вывод должен быть примерно таким:
php -S localhost:8000 -t public public/index.php
PHP 7.2.7 Development Server started at Thu Jul  5 11:44:03 2018
Listening on http://localhost:8000
Document root is /private/var/tmp/hexlet-slim-example/public
Press Ctrl-C to quit.

И последний шаг, откройте в браузере localhost:8000. Если все хорошо, то на экране появится надпись Welcome to Slim!.
*/

#  Обработчики запросов

// Главная содержательная часть в файле index.php - обработчик запроса:

$app = new \Slim\App();

$app->get('/', function ($request, $response) {
	return $response->write('Welcome to Slim!');
});

/*
Общий принцип работы любого веб-фреймворка отражает архитектуру HTTP. На каждый адрес задается обработчик, который выполняет необходимые действия и возвращает ответ. В Slim, все приложение (сайт) представлено объектом класса Slim\App. Этот объект содержит методы на каждый глагол HTTP: get, post, put и так далее. Эти методы принимают на вход два параметра, первый - адрес (говорят маршрут) для которого вызовется обработчик и второй, собственно сам обработчик. Лямбда-функция с двумя параметрами $request и $response.

Во фреймворках принято (и это соответствует идеям REST - https://ru.wikipedia.org/wiki/REST) определять маршрут как комбинацию глагола HTTP и адреса. То есть GET /users и POST /users с точки зрения большинства фреймворков - разные маршруты с разными обработчиками. В этом достаточно просто убедиться если определить соответствующие маршруты и выполнить к ним запросы с помощью curl.
*/

$app = new \Slim\App;

$app->get('/users', function ($request, $response) {
	return $response->write('GET /users');
});

$app->post('/users', function ($request, $response) {
	return $response->write('POST /users');
});

$app->run();

/*
$ curl localhost:8000/users
GET /users
$ curl -XPOST localhost:8000/users
POST /users

$response по стандарту - неизменяемый, это значит, что каждый метод, который выглядит как мутирующий (изменяющий) $response, на самом деле, возвращает новый $response. Не зная этого, очень легко допустить такую ошибку:
*/

$app->post('/users', function ($request, $response) {
	 // Метод withStatus устанавливает код ответа HTTP
	 $response->withStatus(302);
	 return $response;
});

/*
В этом коде withStatus возвращает новый $response, который никак не используется, а наружу возвращается старый. Если попробовать выполнить запрос к этому обработчику, то он не вернет никаких данных.

Query Params не являются частью маршрута и не влияют на выбор обработчика. Связано это с тем, что такие параметры используются для различных вспомогательных целей, например, параметр page, обозначает страницу просматриваемого списка. Обработчик в такой ситуации всегда один и тот же, а вот данные показываются разные.

$ curl 'localhost:8000/users?page=4&per=3'
GET /users

Параметры извлекаются из объекта $request методом getQueryParam($name, $defaultValue):
*/

$app->post('/users', function ($request, $response) {
	$page = $request->getQueryParam('page', 1); // 1 - значение по умолчанию
	$per = $request->getQueryParam('per', 10);
	return $response;
});

/*
Количество обработчиков и маршрутов которые можно добавить ничем не ограничено. При этом микрофреймворки не задают никакой структуры. Если кода становится много, то разделять код по файлам придется самостоятельно.

Во фреймворках не подразумевается прямая работа с PHP в режиме CGI. Данные запроса берутся из объекта $request, ответ вместе с заголовками записывается в объект в $response. Конкретно для отправки тела вызывается функция write. Ее можно использовать множество раз в рамках одного обработчика.


/**
Пейджинг — механизм, позволяющий итерироваться по большим коллекциям небольшими порциями. Очень часто встречается в Интернете, например, в результатах запросов поисковых систем. Пейджинг с точки зрения пользователя выглядит как параметры запроса: page определяет текущую страницу, а per — количество элементов на страницу. Имена могут быть и другими, но обычно их называют так как показано выше. Запрос c page, равным 1, аналогичен запросу без указания page вообще.

Реализуйте маршрут /companies, по которому отдаётся список компаний в виде json. Компании отдаются не все сразу, а только соответствующие текущей запрошенной странице. По умолчанию выдаётся 5 результатов на запрос.

Подсказки
Список компаний лежит в массиве $companies
Чтобы получить его внутри обработчика, воспользуйтесь замыканием
Возможно, вам пригодится функция array_slice
**/

// file: src/Generator.php:

namespace App;

class Generator
{
	public static function generate($count)
	{
		$numbers = range(1, 100);
		shuffle($numbers);

		$faker = \Faker\Factory::create();
		$faker->seed(1);
		$companies = [];
		for ($i = 0; $i < $count; $i++) {
			$companies[] = [
				 'id' => $numbers[$i],
				 'name' => $faker->company,
				 'phone' => $faker->phoneNumber
			];
		}

		return $companies;
	}
}

// file: public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

$companies = Generator::generate(100);

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$app->get('/companies', function ($request, $response) use ($companies) {
	 $page = $request->getQueryParam('page', 1);
	 $per = $request->getQueryParam('per', 5);
	 $offset = ($page - 1) * $per;

	 $sliceOfCompanies = array_slice($companies, $offset, $per);
	 return $response->write(json_encode($sliceOfCompanies));
});

$app->run();



>>>>> HTTP Сессия <<<<<

/*
Каждая HTTP сессия определяется двумя вещами - запросом и ответом. Запрос формируется клиентом, ответ кодом обработчика соответствующего маршрута. И запрос и ответ, в Slim представлены двумя объектами, которые передаются в каждый обработчик.
*/

$app->get('/', function ($request, $response) {
	return $response->write('Hello, world!');
});

/*
$response по стандарту - неизменяемый, это значит, что каждый метод, который выглядит как мутирующий (изменяющий) $response, на самом деле, возвращает новый $response. Не зная этого, очень легко допустить такую ошибку:
*/

$app->post('/users', function ($request, $response) {
	 // Метод withStatus устанавливает код ответа HTTP
	 $response->withStatus(302);
	 return $response;
});

/*
В этом коде withStatus возвращает новый $response, который никак не используется, а наружу возвращается старый. Если попробовать выполнить запрос к этому обработчику, то он не вернет никаких данных.

Query Params не являются частью маршрута и не влияют на выбор обработчика. Связано это с тем, что такие параметры используются для различных вспомогательных целей, например, параметр page, обозначает страницу просматриваемого списка. Обработчик в такой ситуации всегда один и тот же, а вот данные показываются разные.
*/

$ curl 'localhost:8000/users?page=4&per=3'
GET /users

// Параметры извлекаются из объекта $request методом getQueryParam($name, $defaultValue):

$app->post('/users', function ($request, $response) {
	 $page = $request->getQueryParam('page', 1); // 1 - значение по умолчанию
	 $per = $request->getQueryParam('per', 10);
	 return $response;
});

/*
Количество обработчиков и маршрутов которые можно добавить ничем не ограничено. При этом микрофреймворки не задают никакой структуры. Если кода становится много, то разделять код по файлам придется самостоятельно.

Во фреймворках не подразумевается прямая работа с PHP в режиме CGI. Данные запроса берутся из объекта $request, ответ вместе с заголовками записывается в объект в $response. Конкретно для отправки тела вызывается функция write. Ее можно использовать множество раз в рамках одного обработчика. Подробнее об этих объектах мы поговорим в следующих уроках.

Дополнительные материалы
Request https://www.slimframework.com/docs/v3/objects/request.html
Response https://www.slimframework.com/docs/v3/objects/response.html
*/



>>>>> Динамические маршруты <<<<<

/*
До сих пор мы встречались только со статическими маршрутами. В статическом маршруте нет изменяемых частей: адрес точно совпадает с маршрутом и не меняется (поэтому называется "статический"). На практике чаще встречаются динамические маршруты. Проанализируем адреса курсов на Хекслете.

https://ru.hexlet.io/courses/php-introduction-to-oop
https://ru.hexlet.io/courses/php-object-oriented-design
https://ru.hexlet.io/courses/js-react

Нетрудно заметить, что в этих адресах прослеживается определенная структура /courses/<имя курса>. Можно предположить, что на каждый такой адрес создается свой собственный маршрут и обработчик, но тогда представьте себе процесс наполнения сайта. При добавлении нового курса придется программировать. И хотя курсов у нас не тысячи, такой процесс все равно крайне трудоемок. Тоже самое можно сказать и про профили пользователей /u/<никнейм пользователя>. Причем пользователей сотни тысяч и добавляются они на сайт непрерывно без нашего участия.

В примерах выше мы столкнулись с так называемыми динамическими маршрутами. Такие маршруты имеют внутри себя изменяемые части, но обработчик у маршрута только один. Например, все указанные выше адреса курсов соответствуют одному маршруту, который можно записать так /courses/:id. Где секция :id означает, что на это место подставляется конкретный идентификатор (уникальная запись, отличающая одну сущность от другой) курса. Имя изменяемой части можно выбирать произвольно, вместо :id можно написать :lala. Сам способ записи (в данном случае имя с ведущим двоеточием) зависит от конкретного фреймворка. В Slim для этого используются фигурные скобки, что создает ощущение использования интерполяции.
*/

$app->get('/courses/{id}', function ($request, $response, array $args) {
	 $id = $args['id'];
	 return $response->write("Course id: {$id}");
});

/*
Любая изменяемая часть маршрута называется плейсхолдером (заполнитель). В маршруте выше только один плейсхолдер id. Доступ к значению конкретного плейсхолдера осуществляется по имени через массив $args, передающийся третьим параметром в функцию-обработчик.

Для удобства пользователей в адресах стараются использовать не числовые идентификаторы, а человекочитаемые названия. Например, вместо /courses/332 показывают /courses/php-mvc. Эту часть адреса называют словом slug. Slug должен быть уникален и его формат обязан соответствовать требованиям формирования адресов. Как правило, эти имена делают, используя символы латинского алфавита с дефисом между ними: this-that-other-outre-collection.

Подведем промежуточный итог. Понятия адрес и маршрут обозначают разные вещи. Если маршрут статический, то он всегда совпадает с адресом, например, /about. Если маршрут динамический, то ему могут соответствовать бесконечное число адресов (даже если таких страниц на сайте нет), например, /courses/:id.

Количество плейсхолдеров в маршруте может быть больше одного. Обычно такие маршруты используются для вложенных ресурсов.
*/

$app->get('/courses/{courseId}/lessons/{id}', function ($request, $response, array $args) {
	$courseId = $args['courseId'];
	$id = $args['id'];
	return $response->write("Course id: {$courseId}")
	->write("Lesson id: {$id}");
});


/*
Документация:
https://www.slimframework.com/docs/v3/objects/router.html
*/


/**
Реализуйте Маршрут /companies/{id}, по которому отдается json представление компании. Компания извлекается из списка $companies. Каждая компания представлена массивом у которого есть текстовый (то есть тип данных - строка) ключ id.
**/

namespace App;

require '/composer/vendor/autoload.php';

use Illuminate\Support\Collection;

$companies = Generator::generate(100);

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$app->get('/companies/{id}', function($request, $response, array $args) use ($companies) {
	 $id = $args['id'];
	 $companiesColl = collect($companies);
	 $company = $companiesColl->firstWhere('id', '==', $id);
	 return $response->write(json_encode($company));
});
$app->run();



# Шаблонизатор

/*
Формирование HTML во фреймворках — отдельная нетривиальная тема. Конечно, никто не запрещает создавать HTML напрямую в виде строки, но такой способ просто перестает работать на реальных сайтах, где HTML одной страницы — это сотни строк.
*/

$app->get('/courses/{name}', function ($request, $response, array $args) {
	 $slug = $args['name'];
	 $course = $courses[$slug];
	 return $response->write("<h1>{$course->name}</h1>")
		->write("<div>{$course->body}</div>");
});

/*
У такого подхода масса недостатков:
* Он небезопасен и может привести к взлому. Подробнее эта тема рассматривается в конце курса.
* С ростом количества HTML поддерживать такой код станет практически невозможно из-за неудобства анализа и редактирования.
* В таком коде будут возникать постояные проблемы с необходимостью экранировать одинарные или двойные кавычки.
* В таком коде крайне легко допустить ошибку в HTML и крайне сложно ее обнаружить.
* В типичных сайтах большая часть HTML общая для разных страниц. Выделить, ее используя подход выше — очень сложно.
Для решения подобных задач придумали шаблонизаторы — специализированные библиотеки, позволяющие описывать шаблон отдельно от остальной части кода. Здесь можно вспомнить, что сам по себе PHP уже шаблонизатор. Но так как мы работаем с фреймворком, то использовать шаблонизацию напрямую не получится, прежде его нужно правильно сконфигурировать.

Для начала необходимо установить пакет slim/php-view. Выполните соответствующую команду в корне проекта:

$ composer require slim/php-view

Добавьте в public/index.php после строчки, где создается переменная $app следующие строки:
*/

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

/*
В этих строчках происходит подключение шаблонизатора к Слиму, используя DI container. Наши шаблоны будут храниться в папке templates в корне проекта.

Далее добавьте еще один обработчик:
*/
$app->get('/users/{id}', function ($request, $response, $args) {
	$params = ['id' => $args['id']];
	return $this->renderer->render($response, 'users/show.phtml', $params);
});


/*
Метод render выполняет рендеринг указанного шаблона и добавляет результат в ответ. Сама функция принимает на вход три параметра:

 * Объект ответа
 * Путь до нужного шаблона внутри папки templates
 * Набор параметров, которые будут доступны внутри шаблона. Сюда можно передавать все, что угодно.
И последний шаг, добавьте файл templates/users/show.phtml со следующим содержимым:

<h1>Hello, <?= $id ?></h1>

Теперь откройте браузер и попробуйте загрузить страницу http://localhost:8000/users/nick

$ curl localhost:8000/users/nick
<h1>Hello, nick</h1>

Вместо кода <?= $id ?> на экране появилось значение переменной $id. Откуда она взялась в шаблоне? Наш шаблонизатор берет массив $params, который передается третьим параметром в метод render и создает внутри шаблона локальную переменную на каждый ключ этого массива. Причем имя переменной и ключа совпадают. Этот принцип работает всегда. Если вам нужно вывести данные на странице, то добавляйте их в массив $params и обращайтесь с ним в шаблоне через переменные.

Этой тактики следует придерживаться и для суперглобальных массивов. По понятным причинам их можно использовать напрямую:

<h1><?= $_GET['name'] ?></h1>


Но делать так ни в коем случае нельзя. Такой код значительно сложнее в отладке и потенциально очень опасен (подробнее об этом дальше по курсу).

# Собирая все вместе
Теперь, когда мы добавили поддержку шаблонов во фреймворк, появляется способ создавать нетривиальные сайты. Ниже пример обработчика и шаблона для вывода курсов:


# Обработчик
*/
$app->get('/courses', function ($request, $response) use ($courses) {
    $params = [
        'courses' => $courses
    ];
    return $this->renderer->render($response, 'courses/index.phtml', $params);
});

/*
Шаблон

<table>
  <?php foreach ($courses as $course): ?>
		  
		  
		  <?= $course['id'] ?>
		  
		  
		  <?= $course['name'] ?>
	 
	 
	 <?php endforeach ?>
</table>
<!-- END -->
*/


/**@@@
Реализуйте обработчики для списка пользователей /users и вывода конкретного пользователя /users/{id}. Список пользователей генерируется в начале скрипта. Используйте пейджинг для вывода пользователей. По-умолчанию показывается 5 пользователей.

templates/users/index.phtml
Реализуйте вывод списка пользователей со ссылкой на просмотр каждого из них. Вывод должен содержать пейджинг.

templates/users/show.phtml
Реализуйте вывод всех полей пользователя
**/

// file: app/public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

$users = Generator::generate(100);

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

$app->get('/users', function ($request, $response) use ($users) {
    $params = [
        'users' => $users
    ];
    return $this->renderer->render($response, 'users/index.phtml', $params);
});

$app->get('/users/{id}', function ($request, $response, $args) use ($users) {
    $id = (int) $args['id'];
    $user = collect($users)->firstWhere('id', $id);
    $params = ['user' => $user];
    return $this->renderer->render($response, 'users/show.phtml', $params);
});

$app->run();


// file: app/templates/users/show.phtml :
<?php foreach ($user as $key => $value): ?>
		  
		  <?= $key ?>  <?= $value ?>
	 
	 <?php endforeach ?>


// file: app/templates/users/index.phtml:
<a href="/users">Пользователи</a>

<table>
  <?php foreach ($users as $user): ?>
		  
		  
		  <?= $user['id'] ?>
		  
		  
		  <?= $user['id'] ?>  <?= $user['firstName'] ?>
	 
	 
	 <?php endforeach ?>
</table>

## TESTS:
namespace App\Tests;

use PHPUnit\Framework\TestCase;

class Test extends TestCase
{
	 private $client;

	 public function setUp()
	 {
		  $this->client = new \GuzzleHttp\Client([
				'base_uri' => 'http://localhost:8080'
		  ]);
	 }

	 public function testUser()
	 {
		  $response = $this->client->get('/users/1');
		  $body = $response->getBody()->getContents();
		  $this->assertNotEmpty($body);
	 }

	 public function testUser2()
	 {
		  $response = $this->client->get('/users/99');
		  $body = $response->getBody()->getContents();

		  $this->assertContains('Horace', $body);
		  $this->assertContains('Feest', $body);
		  $this->assertContains('harmstrong@lakin.com', $body);
	 }

	 public function testUser3()
	 {
		  $response = $this->client->get('/users/100');
		  $body = $response->getBody()->getContents();

		  $this->assertContains('Euna', $body);
		  $this->assertContains('Veum', $body);
	 }

	 public function testUsers()
	 {
		  $response = $this->client->get('/users');
		  $body = $response->getBody()->getContents();

		  $this->assertContains('Adah', $body);
		  $this->assertContains('Trinity', $body);
	 }

	 public function testUsers2()
	 {
		  $response = $this->client->get('/users?page=2');
		  $body = $response->getBody()->getContents();

		  $this->assertContains('Cleve', $body);
		  $this->assertContains('Karlie', $body);
	 }
}


# Безопасность

/*
Безопасность сайтов, тема о которой редко говорят с новичками, но от которой зависит судьба любого бизнеса. Проблемы с безопасностью могут привести к утечеке данных пользователей и даже к полному уничтожению сайта. Исследования показывают, что подавляющее большинство сайтов имеют проблемы с безопасностью и подвержены атакам. Время от времени случаются громкие взломы и утечки данных сотен тысяч и миллионов пользователей.

Главное правило касающееся безопасности звучит так: "Никогда не доверяйте пользователям". В первую очередь это правило касается данных вводимых пользователями. Возьмем практику пример из предыдущего урока, в которой выводилось имя пользователя взятое из адреса: /users/nick. Код который реализует эту функциональность, рассчитывает на то, что в адресе используются только допустимые имена. Но что если попытаться открыть такой адрес:

# Запустите сервер для приложения созданного в предыдущем уроке
# Попробуйте открыть этот адрес в FireFox, потому что Chrome и Safari блокируют его,
# они знают про то что такой код вредоносный.
http://localhost:8000/users/%3Cscript%3Ealert('attack!')%3B%3C%2Fscript%3E

В этом адресе закодирован код на JavaScript, который в оригинале выглядит так:

<script>
  alert('attack!');
</script>


Проблема в том, что этот код не отобразился, а был вставлен в HTML как часть этого HTML и соответствовано выполнился. Для браузера такой JS выглядит как часть страницы. Если попробовать открыть получившийся HTML, то он будет выглядеть так:

<h1><script>alert('attack!');</script></h1>
Совсем не то что мы ожидали. Такая атака называется XSS или Межсайтовый скриптинг. Она заключается в том что на страницу внедряется вредоносный код, который выполняется в браузере пользователя и отправляет информацию о пользователе на сервер злоумышленника. Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя. XSS относится к одному из самых распространенных типов атак из-за большого количества уязвимостей даже на сайтах больших и серьезных компаний таких как Facebook.

Уязвимость возникает из-за доверия пользовательским данным. В нашем коде вывод слага делается, без какой-либо предварительной обработки, это в корне неверно. Дело в том, что браузер пытается интерпретировать как HTML все что похоже на HTML. Если в исходном коде встречается конструкция <текст>, то браузер автоматически считает ее тегом. Для вывода данных, которые не рассматриваются как HTML, обязательно использовать специализированные функции превращающие теги в html entities.
*/
$str = "A 'quote' is <b>bold</b>";

// Outputs: A 'quote' is &lt;b&gt;bold&lt;/b&gt;
echo htmlspecialchars($str);

/*
Получившаяся строка содержит безопасное описание тегов в виде html entities. Например &lt; отобразиться как <, а &gt; как >. Возвращаясь к нашему примеру, правильный вывод в шаблоне должен пропускаться через функцию htmlspecialchars.

<h1><?= htmlspecialchars($id) ?></h1>
Теперь мы получим тот вывод, который изначально ожидали.

Тоже самое касается любого другого вывода. В следующих уроках мы начнем активно использовать формы в которых подобная уязвимость встречается очень часто.

К сожалению PHP никак не защищает нас от подобных уязвимостей. Необходимо постоянно держать в голове такую возможность и не забывать вызывать функцию htmlspecialchars. На практике вы обязательно забудете), таков человеческий фактор. Это одна из причин почему популярны другие шаблонизаторы. В большинстве из них любые выводимые данные автоматически пропускаются через функцию подобную htmlspecialchars, что гарантирует безопасность без необходимости задумываться о ней.

Кроме XSS часто встречаются и другие виды атак, например SQL Injection, но для их понимания нужно владеть самим инструментом. В будущих уроках и курсах я буду эпизодически затрагивать тему безопасности с примерами типичных ошибок и способах защиты.

Дополнительно:
Безопасность приложений (Хоть и написано что в Rails, но подходит для всех)

http://rusrails.ru/ruby-on-rails-security-guide
*/



>>>>> Поисковые формы <<<<<<<

/*
HTML Формы - основной инструмент для создания интерактивных сайтов. Через них происходит регистрация пользователя, добавление в друзья, оплата покупок, фильтрация товара в магазине и тому подобное. Самые простые формы - поисковые. Они ничего не изменяют и не создают, а используются только для фильтрации данных. Такой поиск реализован на Хекслете на странице курсов https://ru.hexlet.io/courses. Аналогичная строка поиска используется и в поисковых системах.

<form action="/courses" method="get">
  <input type="search" required name="term">
</form>

Основной элемент формы тег <form>. Все элементы формы должны быть вложены в него. У этого тега один обязательный аттрибут action, в котором нужно указать адрес на который отправятся данные формы. Второй необязательный, но часто используемый аттрибут - method. Он принимает два возможных параметра get или post, что соответствует HTTP глаголам. Напомню что семантика этих глаголов в том, что GET используется для чтения информации и неизменяет состояние системы, а POST неидемпотентный глагол, который используется при отправке форм изменяющих состояние системы, например, во время регистрации нового пользователя. По умолчанию значение этого аттрибута get. После отправки формы этим методом, ее данные передаются как параметры запроса. Если в форму выше ввести строчку sql и нажать Enter, то браузер откроет страницу по адресу https://ru.hexlet.io/courses?term=sql. Такой страницей можно поделиться с другими людьми и они увидят те же данные (если выдача не персонализированная).

Интересный факт. Поисковые боты (программы индексирующие контент в интернете) распознают поисковые формы (смотрят что метод отправки GET) и пытаются их использовать для того чтобы добавить в индекс поисковых систем как можно больше данных.

Для элементов формы используются теги input, button, select и textarea.

В свою очередь тег <input> благодаря аттрибуту type может принимать множество различных форм:

Множественный выбор (checkbox)
Одиночный выбор (radio)
Кнопка отправки формы (submit)
Поле для ввода пароля (password)
Множество других таких как: tel, email, range и т.п.
У всех элементов формы есть как общие, так и специфические аттрибуты. К общим аттрибутам относится имя. Его указание обязательно для всех элементов формы кроме кнопок, так как имя используется для доступа к содержимому. В примере выше используется текстовое поле с типом search и именем term. Именно поэтому после отправки формы в адресе появляется запись ?term=sql. Кроме того во всех формах почти всегда присутствует кнопка с типом submit, она отвечает за отправку данных. Имя кнопки задается через аттрибут value.

<input type="submit" value="Search">
Наличие кнопки отправки не обязательно. По умолчанию достаточно нажать Enter и браузер отправит форму на сервер.

К общим аттрибутам относится аттрибут required. Его наличие включает проверку обязательности заполнения на клиенте (в браузере). Попытка отправить форму с незаполненными элементами помеченными этим аттрибутом, приведет к показу сообщения о том что требуется заполнение. Не забывайте что клиентская проверка данных легко обходится посылкой данных в обход браузера (например через Curl). Поэтому проверка на клиенте не может быть основной, она лишь дублирует серверные проверки.

С точки зрения серверной части - никакой формы не существует. Выполняется обычный обработчик в который приходит типичный запрос с дополнительным набором параметров.
*/

$app->get('/courses', function ($request, $response) {
	 $term = $request->getQueryParam('term', ''); // второй параметр - значение по-умолчанию
	 $courses = /* filter courses by term */;
	 $params = ['courses' => $courses];
	 return $this->renderer->render($response, "./courses/index.phtml", $params);
});

/*
Параметры хранятся в объекте запроса и могут быть извлечены либо все сразу getQueryParams либо по одиночке getQueryParam. Дальнейшая логика целиком и полностью зависит от программиста.

Последняя деталь в работе поисковых форм - подстановка текущих значений. Обычно форма поиска продолжает отображаться на странице результатов, причем ее поля заполнены значениями введенными пользователем. Для реализации этой возможности нужно выполнить два действия. Во-первых передать данные из объекта запроса в шаблон $params = ['term' => $term]. Во-вторых, подставить их в саму форму:

<form action="/courses" method="get">
  <input type="search" name="term" value="<?= htmlspecialchars($term) ?>" />
  <input type="submit" value="Search" />
</form>

Для подобного поля ввода нужно указать аттрибут value и подставить туда текущее значение не забыв его преобразовать в безопасную форму.


/*@@
public/index.php
Реализуйте обработчик /users, который формирует список пользователей. Обработчик поддерживает фильтрацию через параметр term, в котором передается начало firstName. Список пользователей доступен в переменной $users.

templates/users/index.phtml
Реализуйте вывод списка пользователей и формы для фильтрации
*/

// file: app/public/index.php:
namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$users = Generator::generate(100);

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

$app->get('/users', function ($request, $response) use ($users) {
    $term = $request->getQueryParam('term', '');
    $result = collect($users)->filter(function ($user) use ($term) {
        return s($user['firstName'])->startsWith($term, false);
    });
    $params = [
        'users' => $result,
        'term' => $term
    ];
    return $this->renderer->render($response, 'users/index.phtml', $params);
});

$app->run();


// file: app/templates/users/index.phtml
<a href="/users">Все Пользователи</a>

<form action="/users">
  <input type="search" name="term" value="<?= htmlspecialchars($term) ?>">
  <input type="submit" value="Search">
</form>

<?php foreach ($users as $user): ?>
		  
		  <?= htmlspecialchars($user['firstName']) ?>
	 
	 <?php endforeach ?>



namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$users = Generator::generate(100);

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

// BEGIN (write your solution here)

// END

$app->run();



>>>>>  Персистентность <<<<<<<

/*
Среди сайтов выделяют такую категорию сайтов как "статические". Их особенность в том что такие сайты, по сути, представляют собой готовый набор HTML страничек. Например так сделаны наши гайды http://guides.hexlet.io/. Удобно, быстро, дешево. Статическим сайтам не нужна возможность куда-то сохранять информацию, его данные хранятся прямо в HTML.

Для создания статических сайтов используют специальные генераторы сайтов https://jekyllrb.com/

Остальным сайтам повезло меньше. Все что создается пользователем, нужно куда-то сохранять. Самый простой способ сохранять - использовать файлы. Насколько он простой, настолько же нерабочий. Блокировки файловой системы не позволят работать с файлом в конкурентной среде, какой является веб, когда с сайтом могут одновременно работать сотни тысяч пользователей.

Здесь мы снова приходим к необходимости понимать устройство операционных систем.
https://ru.hexlet.io/pages/recommended-books

Для постоянного (персистентного) хранения данных принято использовать специализированные программы - базы данных. Взаимодействие с ними строят двумя способами. Либо работая напрямую через библиотеку предназначенную для данной базы данных. Либо через ORM, которая в большинстве случаев прячет базу данных за горой абстракций.
*/

// Doctrine ORM

$user = new User();
$user->setName($newUsername);

$entityManager->persist($user);
$entityManager->flush();


/*
Тема хранения данных очень глубока и требует определенной подготовки, которая пока нами не рассматривалась. Это сделанно намеренно. Профессия построена так, чтобы мы как можно быстрее добрались до веба и научились с ним работать. Работа с базой данных рассматривается в следующих курсах. По этой причине в следующих уроках данные пользователя будут сохраняться в сессии (механизм работающий поверх Cookie), через предоставленную абстракцию.
*/


$repo = new Repository();
$repo->save($entity);
$repo->save($entity2);

$repo->find($entity['id']); // $entity

$repo->all(); // [$entity, $entity2]



>>>>>  Модифицирующие формы <<<<<<<

/*
Формы изменяющие данные, устроены сложнее как с клиентской стороны, так и с серверной. Для уверенной работы с ними необходимо разбираться в следующих вопросах:

Знание соответствующих HTML тегов.
Понимание того как отправляются формы по HTTP.
Обработка на стороне сервера.
Валидация и вывод ошибок.
Начнем с того что за вывод формы и ее обработку должны отвечать два разных обработчика (а значит это разные маршруты). Ниже пример маршрутов для создания нового пользователя:

GET /users/new - страница с формой, которую заполняет пользователь. Эта форма отправляет POST запрос на адрес /users указанный в аттрибуте action.

POST /users - маршрут обрабатывающий данные формы
Я выбрал именно такие маршруты не случайно. Подобная схема именования рекомендуется и автоматически создается многими фреймворками, такими как Rails. Она хорошо ложится на REST архитектуру, о которой мы еще поговорим.

# Форма

<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
	 <label>
		  Имя
		<input type="text" name="user[name]">
	 </label>
  </div>
  <div>
	 <label>
		Email
		<input type="email" required name="user[email]">
	 </label>
	 </div>
  <div>
	 <label>
		  Пароль
	 <input type="password" required name="user[password]">
	 </label>
	 </div>
  <div>
	 <label>
		  Подтверждение пароля
	 <input type="password" required name="user[passwordConfirmation]">
	 </label>
  </div>
  <div>
	 <label>
		Город
		<select name="user[city]">
		  <option value="3">Москва</option>
		  <option value="13">Пенза</option>
		  <option  value="399">Томск</option>
		</select>
	 </label>
  </div>
  <input type="submit" value="Sign Up">
</form>


В отличии от поисковой формы, форма изменяющая состояние, всегда отправляется методом POST. С точки зрения семантики HTTP это не совсем верно. POST предназначен для создания нового. Для изменения правильно использовать PATCH или PUT в зависимости от того как происходит обновление, а для удаления DELETE. К сожалению, тег <form> не поддерживает возможности указывать глаголы отличные от GET и POST. Фреймворки обходят это ограничение довольно хитро.

Еще один интересный момент в форме выше, то как задаются имена. Каждое имя определяется как ключ в массиве user. Такой способ определения имен не является обязательным, но он очень удобен для массовой обработки значений формы. Их изоляция в одном массиве позволяет избежать потенциальных пересечений с другими данными. В поисковых форма эта схема тоже удобна если количество элементов больше одного.

Здесь стоит сказать, что с точки зрения HTTP не существует способа передавать массивы. Если не указано иного, то данные формы кодируются в теле запроса как application/x-www-form-urlencoded. Чисто технически это выглядит как query string, пары ключ-значения объединенные символом &.
*/

POST /users HTTP/1.1
Host: example.com
Content-type: application/x-www-form-urlencoded
Content-length: 42

key=value&key2=value2&user%5Bname%5D%3Djon

/*
В конце тела закодирован ключ user[name]. Превращение таких ключей в массив идет на уровне интерпретатора, в случае PHP, либо самого фреймворка в случае остальных языков.
*/

# Обработка данных

*/
$repo = new Repository();

$app->post('/users', function ($request, $response) use ($repo) {
	$validator = new Validator();
	$user = $request->getParsedBodyParam('user');
	$errors = $validator->validate($user);
	if (count($errors) === 0) {
	  $repo->save($user);
	  return $response->withRedirect('/');
	}
	$params = [
	  'user' => $user,
	  'errors' => $errors
	];
	return $this->renderer->render($response, "users/new.phtml", $params);
});

/*
Обработка данных формы начинается с извлечения данных из тела запроса. Для этого используется метод getParsedBodyParam, который позволяет достать значение по конкретному ключу. Если нужно получить сразу все, то подойдет метод getParsedBody.
*/

$user = $request->getParsedBodyParam('user');


/*
Далее нужно убедиться в том что данные введены верно. Процесс проверки корректности данных называется валидацией. Slim, как и большинство микрофреймворков не предоставляет никаких механизмов для валидации. Ее можно получить из сторонних библиотек. В простейшем случае валидация реализуется простой функцией, которая проверяет данные формы и формирует специальный массив $errors, в котором ключ это название поля, а значение это текст ошибки, который нужно вывести в форме.
*/

$errors = validate($user);

// function validate($user)
// {
//     $errors = [];
//     if (empty($user['name'])) {
//         $errors['name'] = "Can't be blank"
//     }
//
//     // ...
//
//     return $errors;
// }


/*
Если ошибок нет, то данные формы сохраняются, например, в базу данных. Об этом подробнее в следующем уроке. После сохранения выполняется перенаправление (HTTP redirect), как правило, на главную страницу. За перенаправление отвечает метод withRedirect объекта $response. Результат вызова withRedirect необходимо вернуть из обработчика, только тогда Slim поймет что нужно делать перенаправление.
*/

if (count($errors) === 0) {
	$repo->save($user);
	return $response->withRedirect('/');
}


/*
Если в процессе обработки возникли ошибки, выполняется рендеринг формы из того же шаблона что мы использовали для /users/new. В этот шаблон передаются как данные формы так и список ошибок. Редиректа не проиcходит, в адресной строке остается адрес /users. Если попробовать в этот момент нажать f5, то браузер выдаст предупреждение о том что вы пытаетесь повторно отправить данные. Это сообщение предупреждает о том что метод POST не идемпотентен, и повторная отправка формы может привести к повторному созданию пользователя.
*/


$params = [
	'user' => $user,
	'errors' => $errors
];
return $this->renderer->render($response, "users/new.phtml", $params);

/*
Теперь давайте вернемся к нашей форме и изменим ее так чтобы в нее подставлялись как возникающие ошибки, так и значения полей введеные пользователем.
*/


<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
	 <label>
		  Имя
		<input type="text" name="user[name]" value="<?= isset($user['name']) ? htmlspecialchars($user['name']) : '' ?>">
	 </label>
	 <?php if (isset($errors['name'])): ?>
		  <?= $errors['name'] ?>
	 <?php endif ?>
  </div>
  <div>
	 <label>
		  Email
		<input type="email" required name="user[email]" value="<?= isset($user['email']) ? htmlspecialchars($user['email']) : '' ?>">
	 </label>
	 <?php if (isset($errors['email'])): ?>
		  <?= $errors['email'] ?>
	 <?php endif ?>
  </div>
  <div>
	 <label>
		  Пароль
		<input type="password" required name="user[password]" value="<?= isset($user['password']) ? htmlspecialchars($user['password']) : '' ?>">
	 </label>
	 <?php if (isset($errors['password'])): ?>
		  <?= $errors['password'] ?>
	 <?php endif ?>
  </div>
  <div>
	 <label>
		  Подтверждение пароля
		<input type="password" required name="user[passwordConfirmation]" value="<?= isset($user['passwordConfirmation']) ? htmlspecialchars($user['passwordConfirmation']) : '' ?>">
	 </label>
  </div>
  <div>
	 <label>
		Город
		<select name="user[city]">
		  <option value="">Select</option>
		  <option <?= isset($user['city']) && $user['city'] === '3' ? 'selected' : '' ?> value="3">Москва</option>
		  <option <?= isset($user['city']) && $user['city'] === '13' ? 'selected' : '' ?> value="13">Пенза</option>
		  <option <?= isset($user['city']) && $user['city'] === '399' ? 'selected' : '' ?> value="399">Томск</option>
		</select>
	 </label>
	 <?php if (isset($errors['city'])): ?>
		  <?= $errors['city'] ?>
	 <?php endif ?>
  </div>
  <input type="submit" value="Sign Up">
</form>

/*
В свою очередь такое изменение формы требует изменения обработчика /users/new. Необходимо передать в шаблон пустые массивы $errors и $user во избежании ошибок.
*/


$app->get('/users/new', function ($request, $response) {
	$params = [
	  'user' => [],
	  'errors' => []
	];
	return $this->renderer->render($response, "users/new.phtml", $params);
}

/*
Обратите внимание на то, как увеличилась в размерах форма. На практике она будет еще больше из-за дополнительного оформления, например, отступов и подсветки ошибок. Сделав десяток форм вы быстро поймете что так жить нельзя. Ради простейшей обработки придется писать много практического идентичного кода в HTML. Эта работа требует автоматизации и, к счастью, давно автоматизирована. Для генерации форм используются специальные билдеры. По традиции, микрофреймворки не имеют встроенных билдеров, поэтому придется искать их самостоятельно. Довольно популярны формы (https://symfony.com/doc/current/components/form.html) из фреймворка Symfony. В этом компоненте каждая форма представлена своим собственным классом. Компонент поддерживает валидацию имеет встроенные механизмы защиты от некоторых атак и многое другое.


Какое типичное поведение у страниц с формами, если ее данные не прошли валидацию?
> Сервер возвращает страницу с формой и подставленными ошибками. В идеале отдает код 422, который как раз и предназначен для таких ситуаций.

Какое типичное поведение у страниц с формами, если данные формы успешно обработаны?
> Происходит редирект на какую-то страницу, на которой пишут об успешности операции
*/



>>>>>  Именованные маршруты  <<<<<<<

/*
<form action="/users/<?= $user['id'] ?>" method="post">
  <input type="hidden" name="_METHOD" value="DELETE">
  <input type="submit" value="Remove">
</form>

В примере выше ссылка "зашита" прямо в шаблон. В принципе, ничего криминального, но дальше возможны осложнения. Что если маршрут изменится с /uses/{id} на /u/{id}? Придется пройтись по всем шаблонам и изменить все ссылки. А если этот маршрут удалить? Сайт продолжит работать (и не приемочные тесты тоже), хотя будет лучше если страницы с такими ссылками начнут выдавать ошибки. Тогда выявить подобные ссылки станет крайне просто особенно если есть тесты.

Для решения этой задачи придумали именовать маршруты. Далеко не все микрофреймворки поддерживают именованные маршруты, но Slim здесь отличился в правильную сторону.
*/

$app->get('/users', function ($request, $response) {
	 // ...
})->setName('users');

$app->get('/users/{id}', function ($request, $response) {
	 // ...
})->setName('user');

// Метод setName задает имя маршрута. Построить маршрут по имени можно используя метод pathFor объекта Router.

$app->get('/', function ($request, $response) {
	$this->router->pathFor('users'); // /users
	$this->router->pathFor('user', ['id' => 4]); // /users/4
});


// К сожалению, PHP-View, который мы используем, не прокидывает этот метод в шаблоны, в отличие от Twig-View https://github.com/slimphp/Twig-View. Мой совет: используйте в своих приложениях последний.



>>>>>  Стандарт PSR7 <<<<<<<

/*
Объекты запроса и ответа во фреймворке Slim имеют интерфейс соответствующий стандарту PSR7 (https://www.php-fig.org/psr/psr-7/). Пример на главной странице фреймворка как раз демонстрирует это.
*/

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;

require 'vendor/autoload.php';

$app = new \Slim\App;
$app->get('/hello/{name}', function (Request $request, Response $response, array $args) {
	$name = $args['name'];
	return $response->getBody()->write("Hello, $name");
});
$app->run();

/*
Сам стандарт довольно объемный и не имеет смысла его дублировать. Здесь мы поговорим только о ключевых особенностях.

Request и Response, с точки зрения стандарта, представляют собой абстракцию поверх механизмов встроенных в сам PHP. Например они полностью заменяют собой суперглобальные массивы, механизм загрузки файлов и многое другое.
*/

// Возвращает значение заголовка Host
$request->getHeaderLine('Host');

// Возвращает массив заголовков, в котором значения заголовков разделены по элементам массива
foreach ($request->getHeaders() as $name => $values) {
	echo $name . ': ' . implode(', ', $values);
}

/*
Главная отличительная черта этого интерфейса в том, что он построен в иммутабельном (неизменяемом) стиле и реализует fluent interface. Ни запрос ни ответ поменять невозможно. Вместо этого всегда возвращается новый объект.
*/

// response не меняется!
$newResponse = $response->withStatus(302);
$newResponse == $response; // false

// По этой причине, во фреймворках поддерживающих стандарт PSR7, обработчик запроса всегда должен вернуть объект ответа, только в этом случае фреймворк узнает о том как надо ответить на запрос.

return $response->withStatus(500)
	 ->withHeader('Content-Type', 'text/html')
	 ->write('Something went wrong!');



>>>>> Flash  <<<<<<<

/*
Работая на Хекслете вы не раз видели сообщение о результатах выполнения любого действия — будь то аутентификация, регистрация или вступление в курс.

В веб-разработке такое сообщение называют Flash. Оно обычно используется после перенаправления для индикации успешности или неуспешности предыдущего действия. Flash сообщения используют механизм сессий, который мы пока не рассматривали. Этот механизм позволяет хранить информацию между разными запросами одного и того же пользователя. В свою очередь механизм сессий работает благодаря кукам и встроен в PHP.
*/

// Старт PHP сессии
session_start();

$app = new \Slim\App();

// Контейнеры в этом курсе не рассматриваются (это тема связанная с самим ООП), но если вам интересно, то посмотрите DI Container
$container = $app->getContainer();

$container['flash'] = function () {
	return new \Slim\Flash\Messages();
};

$app->get('/foo', function ($req, $res) {
	// Добавление flash сообщения. Оно станет доступным на следующий HTTP запрос.
	$this->flash->addMessage('Test', 'This is a message');

	// Redirect
	return $res->withStatus(302)->withHeader('Location', '/bar');
});

/*
Если используется шаблонизатор, то сообщения передаются в шаблон и там выводятся. После их извлечения хранилище обнуляется. При следующем запросе getMessages вернёт пустой массив.

Под капотом у флеш сообщений используются сессии. Благодаря этому механизму, сайт запоминает конкретного пользователя и его сообщение.
*/

$app->get('/bar', function ($req, $res, $args) {
	 // Извлечение flash сообщений установленных на предыдущем запросе
	 $messages = $this->flash->getMessages();
	 print_r($messages);
});

$app->run();



/**@@@
public/index.php
Реализуйте два обработчика:

/ — выводит флеш сообщения в шаблон templates/index.phtml
/courses — добавляет сообщение Course Added во Flash и делает редирект на /
templates/index.phtml
Реализуйте вывод Flash сообщений
**/


// file: app/public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

session_start();

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	 return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
    $flash = $this->flash->getMessages();
    $params = ['flash' => $flash];
    return $this->renderer->render($response, 'index.phtml', $params);
});

$app->post('/courses', function ($request, $response) {
    $this->flash->addMessage('success', 'Course Added');
    return $response->withRedirect('/');
});

$app->run();


// file: app/templates/index.phtml:

<form action="/courses" method="post">
  <input type="submit" value="Create Course">
</form>

<?php if (count($flash) > 0): ?>
		  
		  <?php foreach ($flash as $messages): ?>
				<?php foreach ($messages as $message): ?>
					 <?= $message ?>
				<?php endforeach ?>
		  <?php endforeach ?>
	 
	 <?php endif ?>

## TESTS:

// file: app/tests/Test.php

namespace App\Tests;

use PHPUnit\Framework\TestCase;

class Test extends TestCase
{
	 private $client;

	 public function setUp()
	 {
		  $this->client = new \GuzzleHttp\Client([
				'cookies' => true,
				'base_uri' => 'http://localhost:8080'
		  ]);
	 }

	 public function testFlash()
	 {
		  $response = $this->client->get('/');
		  $body = $response->getBody()->getContents();
		  $this->assertNotContains("Course Added", $body);

		  $response = $this->client->post('/courses', []);
		  $body = $response->getBody()->getContents();
		  $this->assertContains("Course Added", $body);

		  $response = $this->client->get('/');
		  $body = $response->getBody()->getContents();
		  $this->assertNotContains("Course Added", $body);
	 }
}



>>>>> CRUD  <<<<<<<

/*
Несмотря на огромное число разнообразных сайтов, практически всю веб разработку можно свести к CRUD https://ru.wikipedia.org/wiki/CRUD операциям.
CRUD широко распространенный термин, означающий 4 стандартные операции над любой сущностью (ресурсом): создание, чтение, обновление и удаление. Например в случае с пользователем можно составить такое соответствие:

Create
	 Регистрация

Read
	 Просмотр профиля пользователями сайта
	 Просмотр пользователя в административном интерфейсе

Update
	 Обновление личных данных
	 Смена емейла
	 Смена пароля

Delete
	 Удаление

Создание полного круда включает в себя следующие действия:

Создание сущности в коде (как правило класса)
Добавление таблицы в базу
Написание тестов на обработчики
Добавление обработчиков
Прикручивание верстки
Новички тратят на создание такого круда не один день. У опытного разработчика, в прокаченном фреймворке, этот процесс занимает максимум часы. Slim, как и другие микрофреймворки, не предоставляет никаких средств автоматизации, поэтому придется многое делать руками. В целях обучения это оправданно, но в промышленной разработке, то что может быть автоматизировано, должно быть автоматизировано.

Ниже мы пройдемся по всему процессу создания круда пользователя за исключением работы с базой данных и тестов. Начнем с роутинга. Полный круд пользователя включает минимум 7 маршрутов. Их может быть больше, так как любое из действий может повторяться не один раз.

Глагол      Маршрут             Шаблон          Описание
GET         /users              index.phtml     Список пользователей
GET         /users/new          new.phtml       Форма создания нового пользователя
POST        /users                              Создание нового пользователя
GET         /users/:id          show.phtml      Профиль пользователя
GET         /users/:id/edit     edit.phtml      Форма редактирования пользователя
PATCH/PUT   /users/:id                          Обновление пользователя
DELETE      /users/:id                          Удаление пользователя

Такое соглашение изначально появилось в Rails и затем было адаптировано во многих фреймворках на языках отличных от Ruby.

С первыми тремя маршрутами мы уже знакомы и умеем с ними работать. Осталось разобрать отображение, обновление и удаление.
*/


# Отображение (SHOW)

$app->get('/users/{id}', function ($request, $response, array $args) use ($repo) {
	$id = $args['id'];
	$user = $repo->find($id);

	$params = [
	  'user' => $user
	];

	return $this->renderer->render($response, "users/show.phtml", $params);
});

/*
Чтение любой сущности происходит по одному и тому же сценарию

1. Из адреса извлекается идентификатор
2. Выполняется поиск сущности
3. Она передается в шаблон
*/

$app->get('/users/{id}', function ($request, $response, array $args) use ($repo) {
	$id =  $args['id'];
	$user = $repo->find($id);

	if (!$user) {
	  return $response->withStatus(404)->write('Page not found');
	}
});

/*
Но обычно механизм обработки таких ошибок построен через исключения.
*/

# Удаление (DELETE)

$app->delete('/users/{id}', function ($request, $response, array $args) use ($repo) {
	$id = $args['id'];
	$repo->destroy($id);
	$this->flash->addMessage('success', 'User has been deleted');
	return $response->withRedirect('/users');
});

/*
Удаление устроено даже проще чем вывод, но включает в себя много ньюансов. Вместо привычных GET и POST удаление делается по глаголу DELETE. По спецификации HTTP этот глагол идемпотентный. Это означает, что поведение, в случае наличия или отсутствия сущности, должно быть одинаковое, другими словами HTTP ответ этого обработчика не зависит от того удалена уже сущность или еще нет.

А что насчет безопасности? Удаление пользователя крайне опасная операция, которую нельзя выполнять всем подряд. Даже те кто могут это делать, должны проходить через процедуру подтверждения чтобы случайно не удалить пользователя. Имеет ли пользователь доступ к конкретным действиям определяется авторизацией.

Авториза́ция — предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий. Авторизацию не следует путать с аутентификацией — процедурой проверки легальности пользователя или данных, например, проверки соответствия введённого пользователем пароля к учётной записи паролю Wiki.

То есть перед выполнением действия необходимо проверить авторизован ли пользователь на выполнение данного действия или нет. Авторизация, отдельная большая тема со своей теоретической базой. Как правило вопрос авторизации решается в каждом конкретном фреймворке самостоятельно, хотя на гитхабе можно найти обобщенные библиотеки.

И последний вопрос который осталось рассмотреть - отправка запроса на удаление. Как вы помните, HTML формы не поддерживают отправку методами отличными от GET и POST. Фреймворки выкручиваются из этой ситуации следующим образом. Если в форме задать скрытое поле с именем _METHOD и значением того глагола который нам нужен, то внутри фреймворка, до входа в обработчик, глагол будет заменен на то что был указан. Таким нехитрым способом фреймворки позволяют посылать любые запросы.

<form action="/users/<?= $user['id'] ?>" method="post">
  <input type="hidden" name="_METHOD" value="DELETE">
  <input type="submit" value="Remove">
</form>

Отдельно стоит сказать, что крайне важно соблюдать семантику HTTP. Ни в коем случае нельзя создавать HTML в котором удаление происходит GET запросом, например, по ссылке. Браузеры, их плагины и поисковые системы действуют в соответствии с семантикой HTTP. Если они видят обычную ссылку, то подразумевается что она не может выполнить деструктивных действий, а значит ее можно посетить. Даже если мы работаем в закрытой от поисковиков части сайта, в браузерах встроен механизм предзагрузки страниц, который с удовольствием вызовет все ссылки до которых сможет дотянуться на открытой странице. А плагины могут делать вообще все что угодно.
*/


# Обновление (UPDATE/PATCH)

$app->get('/users/{id}/edit', function ($request, $response, array $args) use ($repo) {
	$id = $args['id'];
	$user = $repo->find($id);
	$params = [
	  'user' => $user,
	  'errors' => []
	];
	return $this->renderer->render($response, 'users/edit.phtml', $params);
});

$app->patch('/users/{id}', function ($request, $response, array $args) use ($repo) {
	$id = $args['id'];
	$user = $repo->find($id);
	$data = $request->getParsedBodyParam('user');

	$user['name'] = $data['name'];

	$validator = new Validator();
	$errors = $validator->validate($user);

	if (count($errors) === 0) {
	  $this->flash->addMessage('success', 'User has been updated');
	  $repo->save($user);
	  return $response->withRedirect("/users/{$user['id']}/edit");
	}

	$params = [
	  'user' => $user,
	  'errors' => $errors
	];

	return $this->renderer->render($response, 'users/edit.phtml', $params);
});


/*
Обновление самое сложное действие из всех по объему действий. С точки зрения кода новое здесь только одно - процесс заполнения сущности данными формы: $user['name'] = $data['name'];. Этот процесс сильно изменится при использовании ORM, а пока мы будем проставлять каждое значение руками. Теоретически можно сделать и так $user = array_merge($user, $data), но у этого подхода есть один фатальный недостаток. Такой способ абсолютно не безопасен, так как пользователь может послать данные в обход формы, например количество денег на счету и array_merge изменит их значение. Эту проблему решают те же пакеты, которые предоставляют Form Builder и, обычно, они сразу встроены во фреймворки.

/**
src/Validator.php
Реализуйте класс валидатор, который проверяет данные курса. Реализация должна соответствовать интерфейсу ValidatorInterface.

Валидации:

Свойство paid - должно быть заполнено
Свойство title - должно быть заполнено
Если поле не заполнено, то используется сообщение Can't be blank

public/index.php
Реализуйте создание курсов в которое входит два обработчика /courses/new (отображает форму) и /courses создает курс.

Если данные формы валидны, то сохраните курс $repo->save($course) и выполните редирект на страницу со списком курсов /courses. Если данные не валидны, то выведите форму с заполненными полями и сообщения об ошибках.

templates/courses/new.phtml
Выведите форму создания курса со следующими полями:

paid - селект определяющий платность курса (true/false)
title - имя курса
**/

// file: app/public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

$app->get('/courses', function ($request, $response) use ($repo) {
	 $params = [
		  'courses' => $repo->all()
	 ];
	 return $this->renderer->render($response, 'courses/index.phtml', $params);
});

$app->get('/courses/new', function ($request, $response) use ($repo) {
    $params = [
        'course' => [],
        'errors' => []
    ];
    return $this->renderer->render($response, 'courses/new.phtml', $params);
});

$app->post('/courses', function ($request, $response) use ($repo) {
    $course = $request->getParsedBodyParam('course');

    $validator = new Validator();
    $errors = $validator->validate($course);

    if (count($errors) === 0) {
        $repo->save($course);
        return $response->withRedirect('/courses');
    }

    $params = [
        'course' => $course,
        'errors' => $errors
    ];

    return $this->renderer->render($response, 'courses/new.phtml', $params);
});

$app->run();


// file: app/src/Validator.php:
namespace App;

class Validator implements ValidatorInterface
{
	 public function validate(array $course)
	 {
	  	$errors = [];

        if ($course['paid'] == '') {
            $errors['paid'] = "Can't be blank";
        }

        if (empty($course['title'])) {
            $errors['title'] = "Can't be blank";
        }

        return $errors;
	 }
}


// file: app/src/ValidatorInterface.php:
namespace App;

interface ValidatorInterface
{
	 // Return array of errors, or empty array if no errors
	 public function validate(array $data);
}


// file: app/templates/courses/new.phtml:
<form action="/courses" method="post">
  <div>
    <label>
        Имя *
      <input type="text" name="course[title]" value="<?= htmlspecialchars($course['title'] ?? '') ?>">
    </label>
    <?php if (isset($errors['title'])): ?>
		  <?= $errors['title'] ?>
	 <?php endif ?>
    </div>
  <div>
    <label>
      Платность *
      <select name="course[paid]">
        <option value="">Select</option>
        <option <?= isset($course['paid']) && $course['paid'] ? 'selected' : '' ?> value="1">Paid</option>
        <option <?= isset($course['paid']) && !$course['paid'] ? 'selected' : '' ?> value="0">Free</option>
      </select>
    </label>
    <?php if (isset($errors['paid'])): ?>
		  <?= $errors['paid'] ?>
	 <?php endif ?>
  </div>
  <input type="submit" value="Create">
</form>





/**@@@
public/index.php
Реализуйте следующие обработчики:

Список постов: /posts
Конкретный пост /posts/my-post-slug
Список постов находится в переменной $posts. Каждый пост содержит внутри себя четыре поля:

id
name
body
slug
Каждый пост из списка ведет на страницу конкретного поста, причем в качестве идентифкатора используется slug, а не id. Список нужно вывести с пейджингом. По умолчанию на каждой странице отображается 5 постов. На первой странице первые пять постов, на второй вторые пять и так далее. Переключение между страницами нужно сделать двумя кнопками: назад и вперед. То какая сейчас страница открыта, определяется параметром page. По умолчанию загружается первая страница.

Страница конкретного поста отображает данные поста и позволяет вернуться на список. Если поста не существует, то страница обработчик должен вернуть код ответа 404 и текст Page not found.

templates/posts/index.phtml
Выведите список добавленных постов. Каждый пост это имя, которое представлено ссылкой ведущей на отображение (show).

templates/posts/show.phtml
Вывод информации о конкретном посте. Выводить только имя и содержимое поста.
*/

// FILE: /public/index.php

namespace App;

require '/composer/vendor/autoload.php';

$posts = Generator::generate(100);

$configuration = [
    'settings' => [
        'displayErrorDetails' => true,
    ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

$app->get('/', function ($request, $response) {
    return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($posts) {
    $page = $request->getQueryParam('page', 1);
    $per = $request->getQueryParam('per', 5);
    $offset = ($page - 1) * $per;

    $sliceOfPosts = array_slice($posts, $offset, $per);
    $params = [
        'page' => $page,
        'posts' => $sliceOfPosts
    ];
    return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

$app->get('/posts/{id}', function ($request, $response, array $args) use ($posts) {
    $id = $args['id'];
    $post = collect($posts)->firstWhere('slug', $id);
    if (!$post) {
        return $response->withStatus(404)->write('Page not found');
    }
    $params = [
        'post' => $post,
    ];
    return $this->renderer->render($response, 'posts/show.phtml', $params);
})->setName('post');

$app->run();


// FILE: /templates/posts/index.phtml
<?php foreach ($posts as $post): ?>
		  
		  <?= $post['slug'] ?>  <?= htmlspecialchars($post['name']) ?>
	 
	 <?php endforeach ?>

<br>

<div>
<a href="?page=<?= $page < 2 ? 1 : $page - 1 ?>">Prev</a> <a href="?page=<?= $page + 1 ?>">Next</a>
</div>

// FILE: /templates/posts/show.phtml
<h1><?= $post['name'] ?></h1>
<div>
    <?= $post['body'] ?>
</div>


>>>>> CRUD: Создание  <<<<<

/*
Создание сущности, включает в себя два действия: отображение формы и обработка данных формы. За каждое из этих действий отвечает свой собственный маршрут. Вот несколько примеров:

Пользователь

 GET /users/new
 POST /users

Курс

 GET /courses/new
 POST /courses

Сотрудник компании (пример вложенного маршрута)

 GET /companies/3/users/new
 POST /companies/3/users


# Отображение формы
*/

// Обработчик
$app->get('/schools/new', function ($request, $response) {
	 $params = [
		  'schoolData' => [],
		  'errors' => []
	 ];
	 return $this->renderer->render($response, 'schools/new.phtml', $params);
})->setName('newSchool');

// Шаблон

<form action="/schools" method="post">
	 <div>
		  <label>
				Название *
				<input type="text" name="school[name]" value="<?= htmlspecialchars($schoolData['name'] ?? '') ?>">
		  </label>
		  <?php if (isset($errors['name'])): ?>
		  <?= $errors['name'] ?>
	 <?php endif ?>
		  </div>
	 </div>
	 <input type="submit" value="Create">
</form>

/*
Содержимое обработчика очень сильно зависит от того, какой используется инструментарий. В тех местах где есть билдеры форм, в этом обработчике создается форма (как некоторый объект) и отправляется в шаблон. Билдер берет на себя огромное количество задач, он сам обрабатывает вывод ошибок, занимается валидацией и подготовкой данных. Особо умные билдеры знают про ту сущность с которой они рабоают и могут строить формы в полностью автоматическом режиме.

В нашем примере ничего такого нет, поэтому все действия делаются руками. Кроме непосредственно данных, в шаблон передается массив errors. Это нужно по той причине, что форма используется обоими обработчиками: одним только для отображения новой формы, другим для отображения формы в случае наличия ошибок.
*/

$app->post('/schools', function ($request, $response) {
	$repo = new SchoolRepository();
	// Извлекаем данные формы
	$schoolData = $request->getParsedBodyParam('school');

	$validator = new Validator();
	// Проверяем корректность данных
	$errors = $validator->validate($schoolData);

	if (count($errors) === 0) {
	  // Если данные корректны, то сохраняем, добавляем флеш и выполняем редирект
	  $repo->save($schoolData);
	  $this->flash->addMessage('success', 'School has been created');
	  // Обратите внимание на использование именованного роутинга
	  return $response->withRedirect($this->router->pathFor('schools'));
	}

	$params = [
	  'schoolData' => $schoolData,
	  'errors' => $errors
	];

	// Если возникли ошибки, то устанавливаем код ответа в 422 и рендерим форму с указанием ошибок
	$response = $response->withStatus(422);
	return $this->renderer->render($response, 'schools/new.phtml', $params);
});

// Своего шаблона у таких обработчиков не делают. Если данные оказались не валидны, то этот обработчик рисует форму обработчика new и отправляет ее вместе с кодом ответа 422 (Unprocessable Entity).


/**
public/index.php
Реализуйте следующие обработчики:

Форма создания нового поста: GET /posts/new
Создание поста: POST /posts
Посты содержат два поля name и body, которые обязательны к заполнению. Валидация уже написана.

Реализуйте вывод ошибок валидации в форме.
После каждого успешного действия нужно добавлять флеш сообщение и выводить его на списке постов. Текст:

Post has been created
templates/posts/new.phtml
Форма для создания поста

Подсказки
Для редиректов в обработчиках используйте именованный роутинг
**/

namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	'settings' => [
	  'displayErrorDetails' => true,
	],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
	return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($repo) {
	$flash = $this->flash->getMessages();

	$params = [
	  'flash' => $flash,
	  'posts' => $repo->all()
	];
	return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

// BEGIN (write your solution here)

// END

$app->run();


// file: app/public/index.php


namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	'settings' => [
	  'displayErrorDetails' => true,
	],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	 return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
	return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($repo) {
	$flash = $this->flash->getMessages();

	$params = [
	  'flash' => $flash,
	  'posts' => $repo->all()
	];
	return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

// BEGIN (write your solution here)

// END

$app->run();


// file: app/templates/posts/new.phtml

<a href="/posts">Посты</a>

<!-- BEGIN (write your solution here) -->

<!-- END -->


// file: app/templates/posts/index.phtml:

<?php if (count($flash) > 0): ?>
		  
		  <?php foreach ($flash as $messages): ?>
				<?php foreach ($messages as $message): ?>
					 <?= $message ?>
				<?php endforeach ?>
		  <?php endforeach ?>
	 
	 <?php endif ?>

<a href="/posts/new">Новый пост</a>

<?php foreach ($posts as $post): ?>
		  
		  <?= htmlspecialchars($post['name']) ?>
	 
	 <?php endforeach ?>

/*
Какой статус ответа отдается клиенту если данные не прошли валидацию?
> 422

Какой глагол HTTP отвечает за создание ресурса?
> POST
*/


/**@@@
public/index.php
Реализуйте следующие обработчики:

Форма создания нового поста: GET /posts/new
Создание поста: POST /posts
Посты содержат два поля name и body, которые обязательны к заполнению. Валидация уже написана.

Реализуйте вывод ошибок валидации в форме.
После каждого успешного действия нужно добавлять флеш сообщение и выводить его на списке постов. Текст:

Post has been created
templates/posts/new.phtml
Форма для создания поста

Подсказки
Для редиректов в обработчиках используйте именованный роутинг
*/

// FILE: /app/src/public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	'settings' => [
	  'displayErrorDetails' => true,
	]
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
	return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($repo) {
	$flash = $this->flash->getMessages();

	$params = [
	  'flash' => $flash,
	  'posts' => $repo->all()
	];
	return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

$app->get('/posts/new', function ($request, $response) use ($repo) {
    $params = [
        'postData' => [],
        'errors' => []
    ];
    return $this->renderer->render($response, 'posts/new.phtml', $params);
});

$app->post('/posts', function ($request, $response) use ($repo) {
    $postData = $request->getParsedBodyParam('post');

    $validator = new Validator();
    $errors = $validator->validate($postData);

    if (count($errors) === 0) {
        $repo->save($postData);
        $this->flash->addMessage('success', 'Post has been created');
        return $response->withRedirect($this->router->pathFor('posts'));
    }

    $params = [
        'postData' => $postData,
        'errors' => $errors
    ];
    $response = $response->withStatus(422);
    return $this->renderer->render($response, 'posts/new.phtml', $params);
});

$app->run();


// file: app/src/templates/new.phtml:

<a href="/posts">Посты</a>

<form action="/posts" method="post">
  <div>
    <label>
        Имя *
      <input type="text" name="post[name]" value="<?= htmlspecialchars($postData['name'] ?? '') ?>">
    </label>
    <?php if (isset($errors['name'])): ?>
		  <?= $errors['name'] ?>
	 <?php endif ?>
    </div>
  <div>
    <label>
      Содержимое *
    </label>
    <textarea type="text" rows="20" cols="80" name="post[body]"><?= htmlspecialchars($postData['body'] ?? '') ?></textarea>
    <?php if (isset($errors['body'])): ?>
		  <?= $errors['body'] ?>
	 <?php endif ?>
  </div>
  <input type="submit" value="Create">
</form>


// file: app/src/Repository.php:

namespace App;

class Repository
{
	public function __construct()
	{
	  session_start();
	  if (!array_key_exists('posts', $_SESSION)) {
			$_SESSION['posts'] = [];
	  }
	}

	public function all()
	{
	  return array_values($_SESSION['posts']);
	}

	public function find(string $id)
	{
	  return $_SESSION['posts'][$id];
	}

	public function destroy(string $id)
	{
	  unset($_SESSION['posts'][$id]);
	}

	public function save(array $item)
	{
	  if (empty($item['name']) || empty($item['body'])) {
			$json = json_encode($item);
			throw new \Exception("Wrong data: {$json}");
	  }
	  if (!isset($item['id'])) {
			$item['id'] = uniqid();
	  }
	  $_SESSION['posts'][$item['id']] = $item;
	}
}


// file: app/src/Validator.php:

namespace App;

class Validator
{
	public function validate(array $course)
	{
	  $errors = [];
	  if ($course['name'] == '') {
			$errors['name'] = "Can't be blank";
	  }

	  if (empty($course['body'])) {
			$errors['body'] = "Can't be blank";
	  }

	  return $errors;
	}
}



>>>>> CRUD: Обновление <<<<<<<

/*
Обновление самое сложное действие из всех по объему действий. С точки зрения кода новое здесь только одно - заполнение сущности данными формы: $school['name'] = $data['name'];. Этот процесс сильно изменится при использовании ORM, а пока мы будем проставлять каждое значение руками.

Обработчик формы
*/

$app->get('/schools/{id}/edit', function ($request, $response, array $args) {
	$repo = new SchoolRepository();
	$id = $args['id'];
	$school = $repo->find($id);
	$params = [
		'school' => $school,
		'errors' => []
	];
	return $this->renderer->render($response, 'schools/edit.phtml', $params);
});

# Шаблон

<form action="/schools" method="post">
	 <input type="hidden" name="_METHOD" value="PATCH">
	 <div>
		<label>
			 Название *
			 <input type="text" name="school[name]" value="<?= htmlspecialchars($schoolData['name'] ?? '') ?>">
		</label>
		<?php if (isset($errors['name'])): ?>
		  <?= $errors['name'] ?>
	 <?php endif ?>
		</div>
	 </div>
	 <input type="submit" value="Create">
</form>

# Обработчик действия

$app->patch('/schools/{id}', function ($request, $response, array $args)  {
	$repo = new SchoolRepository();
	$id = $args['id'];
	$school = $repo->find($id);
	$data = $request->getParsedBodyParam('school');

	// Ручное копирование данных из формы в нашу сущность
	$school['name'] = $data['name'];

	$validator = new Validator();
	$errors = $validator->validate($school);

	if (count($errors) === 0) {
	  $this->flash->addMessage('success', 'School has been updated');
	  $repo->save($school);
	  return $response->withRedirect($this->router->pathFor('editSchool', ['id' => $school['id']]));
	}

	$params = [
	  'school' => $school,
	  'errors' => $errors
	];

	$response = $response->withStatus(422);
	return $this->renderer->render($response, 'schools/edit.phtml', $params);
});

/*
Теоретически можно сделать и так $school = array_merge($user, $data), но у этого подхода есть один фатальный недостаток. Такой способ абсолютно не безопасен, так как пользователь может послать данные в обход формы, например количество денег на счету и array_merge изменит их значение. Эту проблему решают те же пакеты, которые предоставляют Form Builder и, обычно, они сразу встроены во фреймворки.

Методы
Как вы уже знаете, HTML позволяет указывать только два метода внутри аттрибута method тега <form>. С точки зрения семантики HTTP это не совсем верно. POST предназначен для создания нового. Для изменения правильно использовать PATCH или PUT в зависимости от того как происходит обновление, а для удаления DELETE. Если посмотреть на определение обработчика выше, то там мы увидим использование PATCH. Но как это работает? Браузер все равно пошлет POST.
*/

$app->patch('/schools/{id}', function ($request, $response, array $args)  {
/*
Большинство фреймворков использует один и тот же механизм для обхода этого ограничения. Он простой до безобразия. Если форма не поисковая, то данные в любом случае отправляются POST запросом, но в форму добавляется специальное скрытое поле с именем _METHOD, которое и говорит фреймворку, а какой метод мы бы хотели использовать:

<form action="/schools" method="post">
	 <input type="hidden" name="_METHOD" value="PATCH">
	 ...
</form>

Какие глаголы HTTP отвечают за обновление ресурса?
> PATCH
> PUT
*/

/**
public/index.php
Реализуйте следующие обработчики:

Форма редактирования поста: GET /posts/{id}/edit
Обновление поста: PATCH /posts/{id}
Посты содержат поля name и body, которые обязательны к заполнению. Валидация уже написана. После каждого успешного действия нужно добавлять флеш сообщение и выводить его на списке постов. Текст:

Post has been updated
templates/posts/edit.phtml
Форма для редактирования поста. Общая часть формы уже выделена в шаблон _form, подключите его по аналогии с templates/posts/new.phtml.

Подсказки
Для редиректов в обработчиках используйте именованный роутинг
**/

// file: app/public/index.php

namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	 'settings' => [
		  'displayErrorDetails' => true,
	 ],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	 return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($repo) {
	 $flash = $this->flash->getMessages();

	 $params = [
		  'flash' => $flash,
		  'posts' => $repo->all()
	 ];
	 return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

$app->get('/posts/new', function ($request, $response) use ($repo) {
	 $params = [
		  'postData' => [],
		  'errors' => []
	 ];
	 return $this->renderer->render($response, 'posts/new.phtml', $params);
});

$app->post('/posts', function ($request, $response) use ($repo) {
	 $postData = $request->getParsedBodyParam('post');

	 $validator = new Validator();
	 $errors = $validator->validate($postData);

	 if (count($errors) === 0) {
		  $id = $repo->save($postData);
		  $this->flash->addMessage('success', 'Post has been created');
		  return $response->withHeader('X-ID', $id)
								->withRedirect($this->router->pathFor('posts'));
	 }

	 $params = [
		  'postData' => $postData,
		  'errors' => $errors
	 ];

	 return $this->renderer->render($response->withStatus(422), 'posts/new.phtml', $params);
});

$app->get('/posts/{id}/edit', function ($request, $response, array $args) use ($repo) {
    $post = $repo->find($args['id']);
    $params = [
        'post' => $post,
        'postData' => $post
    ];
    return $this->renderer->render($response, 'posts/edit.phtml', $params);
});

$app->patch('/posts/{id}', function ($request, $response, array $args) use ($repo) {
    $post = $repo->find($args['id']);
    $postData = $request->getParsedBodyParam('post');

    $validator = new Validator();
    $errors = $validator->validate($postData);

    if (count($errors) === 0) {
        $post['name'] = $postData['name'];
        $post['body'] = $postData['body'];
        $repo->save($post);
        $this->flash->addMessage('success', 'Post has been updated');
        return $response->withRedirect($this->router->pathFor('posts'));
    }

    $params = [
        'post' => $post,
        'postData' => $postData,
        'errors' => $errors
    ];

    return $this->renderer->render($response->withStatus(422), 'posts/edit.phtml', $params);
});

$app->run();

// app/templates/posts/posts:

<a href="/posts">Посты</a>

<form action="/posts/<?= $post['id'] ?>" method="post">
  <input type="hidden" name="_METHOD" value="PATCH">
  <?php require '_form.phtml' ?>
  <input type="submit" value="Update">
</form>


<?
>>>>>  CRUD: Удаление <<<<<

/*
Удаление устроено даже проще чем вывод, но включает в себя много ньюансов. Вместо привычных GET и POST удаление делается запросом DELETE. По спецификации HTTP этот глагол идемпотентный. Это означает, что поведение, в случае наличия или отсутствия сущности, должно быть одинаковое, другими словами HTTP ответ этого обработчика не зависит от того удалена уже сущность или еще нет.
*/
$app->delete('/schools/{id}', function ($request, $response, array $args) {
	 $repo = new SchoolRepository();
	 $id = $args['id'];
	 $repo->destroy($id);
	 $this->flash->addMessage('success', 'School has been deleted');
	 return $response->withRedirect($this->router->pathFor('schools'));
});

/*
В процессе удаления есть и чисто интерфейсный момент, который начинающие разработчики упускают из виду. Кнопка удаления ни в коем случае не должна сразу удалять. Человеку свойственно ошибаться (а еще он любопытен) и вероятность что он нажмент на эту кнопку по ошибке, крайне высока. Правильный подход состоит в том чтобы спросить у пользователя, уверен ли он в том что хочет удалить. Если да, то только в этом случае удалять.

А что насчет безопасности? Удаление пользователя крайне опасная операция, которую нельзя выполнять всем подряд. Даже те кто могут это делать, должны проходить через процедуру подтверждения чтобы случайно не удалить пользователя. Имеет ли пользователь доступ к конкретным действиям определяется авторизацией.

Авториза́ция — предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий. Авторизацию не следует путать с аутентификацией — процедурой проверки легальности пользователя или данных, например, проверки соответствия введённого пользователем пароля к учётной записи паролю Wiki.

То есть перед выполнением действия необходимо проверить авторизован ли пользователь на выполнение данного действия или нет. Авторизация, отдельная большая тема со своей теоретической базой. Как правило вопрос авторизации решается в каждом конкретном фреймворке https://laravel.com/docs/5.6/authorization самостоятельно, хотя на гитхабе можно найти обобщенные библиотеки.

И последний вопрос который осталось рассмотреть - отправка запроса на удаление. Как вы помните, HTML формы не поддерживают отправку методами отличными от GET и POST. Фреймворки выкручиваются из этой ситуации следующим образом. Если в форме задать скрытое поле с именем _METHOD и значением того глагола который нам нужен, то внутри фреймворка, до входа в обработчик, глагол будет заменен на то что был указан. Таким нехитрым способом фреймворки позволяют посылать любые запросы.
*/

<form action = "/users/<?= $user['id'] ?>" method = "post" >
  <input type = "hidden" name = "_METHOD" value = "DELETE" >
  <input type = "submit" value = "Remove" >
</form >
	 
	 /*
Отдельно стоит сказать, что крайне важно соблюдать семантику HTTP. Ни в коем случае нельзя создавать HTML в котором удаление происходит GET запросом, например, по ссылке. Браузеры, их плагины и поисковые системы действуют в соответствии с семантикой HTTP. Если они видят обычную ссылку, то подразумевается что она не может выполнить деструктивных действий, а значит ее можно посетить. Даже если мы работаем в закрытой от поисковиков части сайта, в браузерах встроен механизм предзагрузки страниц, который с удовольствием вызовет все ссылки до которых сможет дотянуться на открытой странице. А плагины могут делать вообще все что угодно.
Дополнительные материалы
Библиотека для автоматизации фронтенд части (подстановка правильных глаголов, подтверждение) https://github.com/rails/jquery-ujs
*/
	 
	 /**
	  * public/index.php
	  * Реализуйте удаление поста (обработчик DELETE /posts/{id})
	  *
	  * После каждого успешного действия нужно добавлять флеш сообщение и выводить его на списке постов. Текст:
	  *
	  * Post has been removed
	  * templates/posts/index.phtml
	  * Реализуйте вывод списка постов и добавьте к каждому посту кнопку на удаление.
	  *
	  * Подсказки
	  * Для редиректов в обработчиках используйте именованный роутинг
	  **/

// file: app/public/index.php:
	 
	 namespace App;

require '/composer/vendor/autoload.php';

use function Stringy\create as s;

$repo = new Repository();

$configuration = [
	'settings' => [
		'displayErrorDetails' => true,
	],
];

$app = new \Slim\App($configuration);

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
$container['flash'] = function () {
	 return new \Slim\Flash\Messages();
};

$app->get('/', function ($request, $response) {
	 return $this->renderer->render($response, 'index.phtml');
});

$app->get('/posts', function ($request, $response) use ($repo) {
	 $flash = $this->flash->getMessages();
	 
	 $params = [
		 'flash' => $flash,
		 'posts' => $repo->all()
	 ];
	 return $this->renderer->render($response, 'posts/index.phtml', $params);
})->setName('posts');

$app->get('/posts/new', function ($request, $response) use ($repo) {
	 $params = [
		 'postData' => [],
		 'errors' => []
	 ];
	 return $this->renderer->render($response, 'posts/new.phtml', $params);
});

$app->post('/posts', function ($request, $response) use ($repo) {
	 $postData = $request->getParsedBodyParam('post');
	 
	 $validator = new Validator();
	 $errors = $validator->validate($postData);
	 
	 if (count($errors) === 0) {
		  $id = $repo->save($postData);
		  $this->flash->addMessage('success', 'Post has been created');
		  return $response->withHeader('X-ID', $id)
			  ->withRedirect($this->router->pathFor('posts'));
	 }
	 
	 $params = [
		 'postData' => $postData,
		 'errors' => $errors
	 ];
	 
	 return $this->renderer->render($response->withStatus(422), 'posts/new.phtml', $params);
});

$app->delete('/posts/{id}', function ($request, $response, array $args) use ($repo) {
	 $repo->destroy($args['id']);
	 $this->flash->addMessage('success', 'Post has been deleted');
	 return $response->withRedirect($this->router->pathFor('posts'));
});

$app->run();

// file app/templates/posts/index.phtml:

<?php if (count($flash) > 0): ?>
		  
		  <?php foreach ($flash as $messages): ?>
				<?php foreach ($messages as $message): ?>
					 <?= $message ?>
				<?php endforeach ?>
		  <?php endforeach ?>
	 
	 <?php endif ?>

<a href="/posts/new">Новый пост</a>

<?php foreach ($posts as $post): ?>
		  
		  <?= htmlspecialchars($post['name']) ?>
		  <?= $post['id'] ?>
	 
	 
	 <?php endforeach ?>




<?
>>>>>  Model - View - Controller(MVC) <<<<<<<

/*
Архитектура веб-приложений, в первую очередь, определяется самой природой веба, тем, как работает HTTP. Последовательность запрос-обработка-ответ — базис, на который нанизывается все остальное. Фреймворки идут дальше и разделяют приложение на дополнительные слои уже внутри самого процесса обработки запроса. Такое разделение напрашивается само собой, без него код быстро превращается в мешанину из запросов к базе данных, формирований html и логики обработки данных.

Из обработки запроса естественным образом выделяется слой шаблонов, на основе которых генерируется HTML. Этот слой принято называть View. Кроме него, как минимум, выделяют еще два слоя: Model и Controller. Остальное добавляется по мере роста сложности приложения. Аббревиатура MVC (Model-View-Controller) — тема нашего урока.

Существует две разных версии MVC. Та, которая была придумана изначально (в сообществе SmallTalk программистов), создавалась под толстые клиенты, а они представляют собой событийные системы, как современные фронтенд приложения. На сервере используется другая вариация MVC, которая называется MVC v2. Буквы в ней те же, но означают местами другое, и самое главное, что совсем по-другому строится взаимодействие.

Архитектурный шаблон MVC задает основную структуру приложения и позволяет коду достаточно долго развиваться, оставаясь удобным в поддержке. MVC, с некоторыми модификациями, реализуется всеми веб-фреймворками. И если с View все понятно, то с Model и Controller нужно разбираться отдельно. Под контроллерами понимаются обработчики запросов. Они принимают объект запроса и возвращают объект ответа. В случае Slim, контроллеры представлены анонимными функциями, но это не обязательно: в больших фреймворках контроллер — это класс, а обработчики — его методы. Эти методы обычно именуют действиями (actions). В принципе, на этом наше разделение можно было бы и закончить. При таком подходе вся логика сосредоточена в самих контроллерах, что вполне допустимо в самых примитивных случаях.

Во всех остальных ситуациях выделяют еще один слой, который называют Model. Сразу хочу оговориться, что понятие Model не включает в себя персистентность (постоянное хранение, базы данных). Среди разработчиков распространено заблуждение, что модель — это база данных и данные внутри нее. Но это не так.

Слой Model отвечает за бизнес-логику приложения и данные, связанные с ней. Чисто технически, этот слой может быть представлен большим количеством разных способов, которые еще сильно зависят от конкретного языка программирования и используемых библиотек. Самый распространенный вариант — это ORM, но так бывает не всегда. Более того, довольно часто, даже при наличии отдельного слоя Model, часть логики все же проникает в контроллеры.

Зачем понадобилось выделять слой Model? Достаточно давно мне попалась на глаза интересная статья, которая называлась Rails is not your application http://blog.firsthand.ca/2011/10/rails-is-not-your-application.html (Rails - популярный веб фреймворк, который стал прообразом для большинства современных фреймворков на разных языках программирования). Идея статьи заключается в том, что предметная область, которую мы реализуем внутри нашего сайта, никак не связана ни с сайтом ни тем более с фреймворком, который используется внутри. Посудите сами, могут ли поменяться правила бухгалтерии в зависимости от выбранного фреймворка и вообще, как связана бухгалтерия и фреймворк? Очевидно, никак и бизнес-правила этой области не зависят от существования программирования. Посредством программирования мы можем их выразить в коде, но этот код снова не будет связан с используемым фреймворком. В идеале, код который описывает предметную область и позволяет с ней работать, можно взять и перенести в другой фреймворк без модификаций. Как видно, на логическом уровне есть граница между кодом, моделирующим предметную область, и кодом, обслуживающим веб запросы. Но эту границу иногда провести трудно. Например, к чему относится отправка письма при регистрации, а авторизация, а восстановление пароля? Если закапываться дальше, то на горизонте возникают понятия Application Logic и Business Logic, а затем и Service Layer. Если вам интересно, то прочитайте про них самостоятельно.

Самая большая сложность в коде находится именно в этой части приложения. Модель не имеет никакой четкой структуры, это не классическое запрос-обработка-ответ. Моделирование предметной области довольно сложная тема, на почве которой родится еще не мало холиваров.

Взаимоотношения между слоями в MVC не менее важны, чем наличие самих слоев. Model, как мы уже выяснили, живет своей жизнью и не знает (и не может знать) ничего про существование Controller или View. Последние, в свою очередь, используют модель для запуска бизнес логики или для формирования HTTP ответа. Controller инициирует различные процессы и запуск бизнес-логики. Кроме того, Controller отвечает за формирование ответа и запускает рендеринг шаблонов. Шаблоны не знают про существование слоя Controller, но используют данные, предоставленные им для формирование HTML (или JSON, или чего-то еще).
*/


>>>>> Cookies <<<<<<<

/*
Cookies - это механизм хранения данных браузером удаленной машины для отслеживания или идентификации возвращающихся посетителей. По сути единственный надежный способ понять что перед нами тот же самый пользователь (хотя если угнать чужие куки, то можно подделать запрос от другого пользователя). Куки использует не только сам сайт, но и всемозможные виджеты, которые встраиваются на разные странички. Именно благодаря кукам, гугл узнает вас и преследует рекламой того что вы недавно искали, на сайтах, которые вроде бы не должны знать о ваших предпочтениях.

PHP прозрачно поддерживает работу с куками. Куки приходящие в HTTP запросе становятся доступны через суперглобальный массив $_COOKIES. Этот массив используется только для чтения, писать в него бесполезно. Установка кук осуществляется функцией setcookie(). Так как куки отправляются вместе с заголовками, то вызов этой функции должен происходит до любой отправки данных в браузер.

В PSR7 определены только два метода работающих с куками и оба этих метода извлекают куки.

getCookieParams() - возвращает все куки
getCookieParam($name, $default = null) - возвращает указанную куку
Для установки кук придется воспользоваться более низкоуровневым методом withHeader($name, $value), добавляющим любые заголовки в ответ:
*/

$app->post('/example', function ($request, $response) {
	 // Set-Cookie: <cookie-name>=<cookie-value>
	 return $response->withHeader('Set-Cookie', "foo=bar")
});


// Типичный вариант использования кук - корзина в интернет-магазине. Во время добавления товара, код магазина формирует куку, в которую начинает заносить данные о заказе.

$app->post('/cart-items', function ($request, $response) {
	 // Информация о добавляемом товаре
	 $item = $request->getParsedBodyParam('item');
	 
	 // Данные корзины
	 $cart = json_decode($request->getCookieParam('cart', json_encode([])));
	 
	 // Добавление нового товара
	 $cart[] = $item;
	 
	 // Кодирование корзины
	 $encodedCart = json_encode($cart);
	 
	 // Установка новой корзины в куку
	 return $response->withHeader('Set-Cookie', "cart={$encodedCart}")
		 ->withRedirect('/');
});
	 
	 /*
Обратите внимание на необходимость кодирования данных корзины. Кука с точки зрения HTTP содержит значение в виде строки, а значит для хранения составных структур нужно проводить ручное кодирование в строку и декодирование при извлечении. Иногда простого кодирования недостаточно, особенно если данные имеют повышенную важность и их желательно защитить. В таких случаях дополнительно применяют шифрование на стороне сервера.

У кук существует ограничение на количество данных которые в них можно хранить, оно равно 4кб. Для корзины интернет магазины этого хватит с головой, но в других ситуациях может понадобится больше места и тогда придется воспользоваться сессией.
*/
	 
	 /*
Для каких целей можно использовать куки?
> Хранение пользовательских данных, которые должны оставаться между запросами, например, корзина в интернет магазине
> Аутентификация

Как правильно во фреймворках получить доступ к кукам?
> Через объект $request и его методы для получения кук
*/
	 
	 /**
	  * public/index.php
	  * Реализуйте два обработчика
	  *
	  * POST /cart-items для добавления товаров в корзину
	  * DELETE /cart-items для очистки корзины
	  * Корзина должна храниться на клиенте в куках. Кроме самого товара, необходимо хранить количество единиц. Повторное добавление того же товара приводит к увеличению счетчика и редиректу на главную. Подробнее смотрите в шаблоне. Для сериализации данных используйте json_encode.
	  **/

// file: app/public/index.php:
	 
	 namespace App;
	 
	 require '/composer/vendor/autoload.php';
	 
	 use function Stringy\create as s;
	 
	 $repo = new Repository();
	 
	 $configuration = [
		 'settings' => [
			 'displayErrorDetails' => true,
		 ]
	 ];
	 
	 $app = new \Slim\App($configuration);
	 
	 $container = $app->getContainer();
	 $container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
	 
	 $app->get('/', function ($request, $response) {
		  $cart = json_decode($request->getCookieParam('cart', json_encode([])), true);
		  $params = [
			  'cart' => $cart
		  ];
		  return $this->renderer->render($response, 'index.phtml', $params);
	 });
	 
	 $app->post('/cart-items', function ($request, $response) {
		  $item = $request->getParsedBodyParam('item');
		  $cart = json_decode($request->getCookieParam('cart', json_encode([])), true);
		  
		  $id = $item['id'];
		  if (!isset($cart[$id])) {
				$cart[$id] = ['name' => $item['name'], 'count' => 1];
		  } else {
				$cart[$id]['count'] += 1;
		  }
		  
		  $encodedCart = json_encode($cart);
		  return $response->withHeader('Set-Cookie', "cart={$encodedCart}")
			  ->withRedirect('/');
	 });
	 
	 $app->delete('/cart-items', function ($request, $response) {
		  $encodedCart = json_encode([]);
		  return $response->withHeader('Set-Cookie', "cart={$encodedCart}")
			  ->withRedirect('/');
	 });
	 
	 $app->run();

// app/src/Repository.php:
	 
	 namespace App;
	 
	 class Repository
	 {
		  public function __construct()
		  {
				session_start();
		  }
		  
		  public function all()
		  {
				return array_values($_SESSION);
		  }
		  
		  public function find(int $id)
		  {
				return $_SESSION[$id];
		  }
		  
		  public function save(array $item)
		  {
				if (empty($item['title']) || $item['paid'] == '') {
					 $json = json_encode($item);
					 throw new \Exception("Wrong data: {$json}");
				}
				$item['id'] = uniqid();
				$_SESSION[$item['id']] = $item;
		  }
	 }

// file: app/templates/index.phtml:
	 
	 <
	 form action = "/cart-items" method = "post" >
	 <input type = "hidden" name = "item[id]" value = "1" >
	 <input type = "hidden" name = "item[name]" value = "One" >
		 One
	 <input type = "submit" value = "Add" >
</form >

<form action = "/cart-items" method = "post" >
	 <input type = "hidden" name = "item[id]" value = "2" >
	 <input type = "hidden" name = "item[name]" value = "Second" >
		 Second
	 <input type = "submit" value = "Add" >
</form >

<form action = "/cart-items" method = "post" >
	 <input type = "hidden" name = "_METHOD" value = "delete" >
	 <input type = "submit" value = "Clean" >
</form >

<?php if (count($cart) == 0): ?>
	 
	 <?php else: ?>
		  <?php foreach ($cart as $item): ?>
				
				<?= htmlspecialchars($item['name']) ?>  <?= htmlspecialchars($item['count']) ?>
		  
		  <?php endforeach ?>
	 <?php endif ?>




<?

>>>>> Сессия <<<<<<<

/*
Сессия, в отличие от кук, как понятие, не существует ни в браузере ни в HTTP. Это абстракция, созданная для удобной работы с индивидуальными пользователями. Сессии реализуются на уровне конкретных фреймворков и только в PHP сессии встроены в язык. Общий принцип работы сессии сводится к трем операциям:

 * Старт сессии. Так мы говорим системе что хотим начать следить за пользователем. Во многих фреймворках эта операция выполняется неявно, при попытке чтения или записи в сессию.
 * Запись данных в сессию.
 * Чтение данных из сессии.
Set-Cookie: _hexlet_session=CM5DvfXch6M3uPJHyfLDpv52wBe4iu3og domain=.hexlet.io; path=/; expires=Sun, 12 Aug 2018 12:56:51 -0000; secure; HttpOnly

Старт сессии на техническом уровне означает установку специальной куки в браузер. Обычно эта кука содержит идентификатор сессии, который уникален для каждого пользователя. Данные же сессии, могут хранится где угодно, это зависит от конкретной реализации. В этом одно из ключевых отличий работы с пользователями напрямую через куки или через сессию. Сессия более высокоуровневая абстракция. Например в PHP, по-умолчанию, данные сессии хранятся в файлах. Из этого следует сразу два вывода. Во-первых сессия ограничена только физическим пространством дисков, во-вторых данные хранятся на сервере что безопаснее. Если этого недостаточно, например серверов больше чем один, то буквально парой строк кода в конфигурации, можно изменить тип хранилища с файлов на базу данных.

Другое преимущество заключается в том что работая с сессией не надо думать про имена кук, про сеариализацию и десереализацию составных данных. Все это происходит автоматически.
*/

// Операция идемпотентна. Не важно была ли инициализирована сессия раньше, старт сессии выполняется всегда
session_start();

if (!isset($_SESSION['count'])) {
	 $_SESSION['count'] = 0;
} else {
	 $_SESSION['count']++;
}

print_r($_SESSION['count']);

/*
Этот простой скрипт демонстрирует работу сессий в PHP. В отличии от всех остальных суперглобальных массивов для работы с HTTP, массив $_SESSION мутабельный. Все что добавится в него, автоматически попадает в сессию и сохраняется между запросами до тех пор, пока кука не будет удалена (или изменена). Даже из этого простого примера видно что сессия упрощает работу с пользователем. Кроме того, значением массива $_SESSION может быть любая составная структура, массив или объект. Механизм сессий автоматически беспокоится о сериализации и десереализации.

Внутри Slim нет никакого особенного механизма для работы с сессиями, так как они не являются частью стандарта PSR7. Работа с сессией происходит напрямую. Перепишем наш пример добавления товаров в корзину используя сессию.
*/

session_start();

$app->post('/cart-items', function ($request, $response) {
	 // Информация о добавляемом товаре
	 $item = $request->getParsedBodyParam('item');
	 
	 // Добавление нового товара
	 $_SESSION['cart'][] = $item;
	 
	 return $response->withRedirect('/');
});
	 
	 
	 /*
По сравнению с версией на куках, ушла значительная часть кода. Кодирование и декодирование в json, извлечение куки и перезапись куки.

Иногда возникает задача уничтожать сессию, например при выполнении выхода из системы. Полное уничтожение сессии включает в себя три шага:

Обновление куки с установкой даты в прошлое
Обнуление массива $_SESSION - session_unset()
Обнуление хранилища сессий - session_destroy()
Только в этом случае сессия уничтожится полностью. Первый шаг можно не делать, но второй и третий желательно.

В целом, у сессий в PHP очень много тонкостей и механизмов для управления ими. Если вам интересно разобраться глубоко в том как устроена ее работа, добро пожаловать в официальную документацию.

Сессии можно хранить в куках
*/
	 
	 /**@@@
	  * В этой практике необходимо реализовать систему аутентификации. В простейшем случае она состоит из двух маршрутов:
	  *
	  * POST /session - создает сессию
	  * DELETE /session - удаляет сессию
	  * После выполнения каждого из этих действий происходит редирект на главную.
	  *
	  * templates/index.phtml
	  * Если пользователь не аутентифицирован, то ему показывается форма с текстом "Sign In" полем для ввода имени и пароля. Если аутентифицирован, то его имя и форма с кнопкой "Sign Out".
	  *
	  * public/index.php
	  * Реализуйте указанные выше маршруты и дополнительно маршрут /
	  *
	  * Список пользователей с именами и паролями доступен в массиве $users. Обратите внимание на то что пароль хранится в зашифрованном виде (их не хранят в открытом виде). Это значит, что при сравнении необходимо шифровать пароль, приходящий от пользователя, и сравнивать хеши.
	  *
	  * Если имя или пароль неверные, то происходит редирект на главную, и показывается флеш сообщение Wrong password or name.
	  **/

// file: app/public/index.php:
	 
	 namespace App;
	 
	 require '/composer/vendor/autoload.php';
	 
	 use function Stringy\create as s;
	 
	 $configuration = [
		 'settings' => [
			 'displayErrorDetails' => true,
		 ],
	 ];
	 
	 session_start();
	 
	 $app = new \Slim\App($configuration);
	 
	 $container = $app->getContainer();
	 $container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');
	 $container['flash'] = function () {
		  return new \Slim\Flash\Messages();
	 };
	 
	 $users = [
		 ['name' => 'admin', 'passwordDigest' => hash('sha256', 'secret')],
		 ['name' => 'mike', 'passwordDigest' => hash('sha256', 'superpass')],
		 ['name' => 'kate', 'passwordDigest' => hash('sha256', 'strongpass')]
	 ];
	 
	 $app->get('/', function ($request, $response) {
		  $flash = $this->flash->getMessages();
		  $params = [
			  'currentUser' => $_SESSION['user'] ?? null,
			  'flash' => $flash
		  ];
		  return $this->renderer->render($response, 'index.phtml', $params);
	 });
	 
	 $app->post('/session', function ($request, $response) use ($users) {
		  $userData = $request->getParsedBodyParam('user');
		  
		  $user = collect($users)->first(function ($user) use ($userData) {
				return $user['name'] == $userData['name']
					&& hash('sha256', $userData['password']) == $user['passwordDigest'];
		  });
		  
		  if ($user) {
				$_SESSION['user'] = $user;
		  } else {
				$this->flash->addMessage('error', 'Wrong password or name');
		  }
		  return $response->withRedirect('/');
	 });
	 
	 $app->delete('/session', function ($request, $response) {
		  session_unset();
		  session_destroy();
		  return $response->withRedirect('/');
	 });
	 
	 $app->run();


// file app/templates/index.phtml:
	 
	 <?
	 php if (count($flash) > 0): ?>
		  
		  <?php foreach ($flash as $messages): ?>
				<?php foreach ($messages as $message): ?>
					 <?= $message ?>
				<?php endforeach ?>
		  <?php endforeach ?>
	 
	 <?php endif ?>

<?php if ($currentUser): ?>
		  <?= $currentUser['name'] ?>
	 
	 
	 <?php else: ?>
	 
	 
	 <?php endif; ?>
<?



>>>>>> Деплой <<<<<<<
/*
После того как сайт написан, встает вопрос о том как выложить его в интернет. Стандартный путь включает три пункта:

Покупка домена
Покупка хостинга и его настройка
Деплой
Первый я пропущу (скоро мы его опишем в https://guides.hexlet.io), а вот про два других поговорим.

Деплой - процесс выкладки новой версии сайта на сервер (или сервера). Этот процесс может быть довольно сложным и сильно зависит от используемых технологий. Во время деплоя выполняются следующие задачи (ниже всего лишь один из возможных вариантов, причем довольно примитивный):

Код проекта скачивается на сервер (обычно через клонирование git)
Ставятся все необходимые зависимости
Выполняется процесс сборки, например собирается фронтенд часть
Выполняются миграции. Миграции - sql скрипты, которые изменяют структуру базы данных
Запускается новая версия кода.
Как это ни странно, но во многих компаниях прямо сейчас весь этот процесс выполняется руками. Программист заходит на сервер, запускает git pull и далее проходится по списку выше. Это худший способ деплоить. Деплой относится к тем задачам, которые должны быть автоматизированы от и до.

Несмотря на разнообразие способов деплоя, есть одно важное правило общее для всех - деплоить можно только вперед! Деплой нельзя "откатывать" (в первую очередь это касается миграций, но про базы мы пока не говорим). Если после или во время деплоя что-то пошло не так, то правильно деплоить снова, но предыдущую версию.

Кроме того, деплои можно классифицировать по способу обновления и отката:

Последовательное обновление - сервера обновляются по очереди
Сине-Зеленый деплой https://habr.com/post/309832/ - полное дублирование инфраструктуры с подменой
Отдельно стоит сказать про Канареечный релиз, при таком подходе переключение на использовании новой версии происходит постепенно, сначала для небольшого процента пользователей, а затем и для всех

Способ деплоя сильно зависит от используемого хостинга и даже способа настройки серверного окружения. Выделяют следующие типы хостингов:

Shared Hosting - самый дешевый способ размещать сайт в интернете. Такая услуга включает в себя доступ на сервер с уже настроенным программным обеспечением под конкретный стек, например Linux + PHP + MySQL. Этот способ подходит для самых простых сайтов и требует минимальной настройки.

VPS/VDS - наиболее сбалансированная услуга, в рамках которой предоставляет виртуальная машина. Плюс в том что такой вид хостинга позволяет задействовать больше серверных мощностей: цпу, память и диск. Предустановленного ПО нет, все нужно делать самостоятельно. По сравнению с Shared Hosting вы не ограничены в правах и можете настраивать сервер как вам угодно.

Dedicated Server - выделеный сервер (либо свой, либо арендованный). Такой хостинг требует больше всего участия, но зато вы получаете лучшее соотношение производительность/цена.

IaaS - инфраструктура как сервис. Вид хостинга при котором большая часть возможностей представляется как сервис. Как пример Amazon Web Service (AWS).

PaaS - платформа как сервис. Наиболее дорогой и самый автоматизированный способ из коробки по размещению сайтов. Выкладка сайта происходит буквально по команде git push. Кроме цены важно учитывать используемые технологии и подходы. PaaS обладает наибольшим числом ограничений по тому что и как можно делать, но в обмен вы получаете не просто автоматизированный хостинг, но и платформу которая автоматически "скейлится" (масштабируется) под нагрузку.
Все способы деплоя можно грубо разбить на две большие категории. Деплой на PaaS и деплой на все остальное.

# PaaS
Самый простой способ начать деплоить. Большинство PaaS хостеров имеют бесплатные планы, достаточные для выкладки учебных проектов. Из плюсов, не придется покупать адрес, домен третьего уровня предоставляется бесплатно. Самое популярное PaaS решение на текущий день - Heroku. У Хероку прекрасная документация https://devcenter.heroku.com/start, следуя которой можно быстро выложить свой первый сайт. Пошаговый гайд описывающий выкладку сайта на PHP доступен по ссылке https://devcenter.heroku.com/articles/getting-started-with-php. Хероку используется на Хекслете для JavaScript и PHP проектов.
*/

$ heroku create
Creating sharp - rain - 871. .. done, stack is cedar - 14
http://sharp-rain-871.herokuapp.com/ | https://git.heroku.com/sharp-rain-871.git
Git remote heroku added

$ git push heroku master
remote: Building source:
remote:
remote: -----> PHP app detected
remote: -----> Bootstrapping...
remote: -----> Installing platform packages...
remote:        NOTICE: No runtime required in composer . json; requirements
remote:        from dependencies in composer . lock will be used for selection
																							remote: -php(7.1.3)
remote:        -apache(2.4.20)
remote:        -nginx(1.8.1)
remote: -----> Installing dependencies...
remote:        Composer version 1.4.1 2017 - 03 - 10 09:29:45
remote:        Loading composer repositories with package information
remote:        Installing dependencies from lock file
remote:        Package operations: 12 installs, 0 updates, 0 removals
remote:          -Installing psr / log(1.0.2): Loading from cache
remote:          -Installing monolog / monolog(1.22.1): Loading from cache
...
remote:          -Installing symfony / twig - bridge(v3.2.7): Loading from cache
remote:        Generating optimized autoload files
remote: -----> Preparing runtime environment...
remote: -----> Checking for additional extensions to install...
remote: -----> Discovering process types
remote:        Procfile declares types -> web
remote:
remote: -----> Compressing...
remote:        Done: 14.8M
remote: -----> Launching...
remote:        Released v17
remote:        https://gsphpjon.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done .
		  To https://git.heroku.com/gsphpjon.git
 +264e577...4f2369c master -> master(forced update)

/*
Самостоятельная работа
Выложите на Хероку тот код который вы делали на Slim в течении этого курса.

Все остальное
Если не брать в рассчет самый примитивный Shared Hosting, который не позволяет никак настраивать серверное окружение, все остальные виды хостингов имеют схожие задачи для выкладки.

Самая первая задача - настроить окружение. Если в Shared Hosting всегда есть набор предустановленных программ, то во всех остальных видах хостинга нет ничего кроме голой операционной системы. Установка необходимого ПО такой же автоматизируемый процесс как процесс деплоя и у него есть даже собственное название - Configuration Management. Рекомендую использовать Ansible, популярное решение для настройки.
- hosts: all

  tasks:

	 - lineinfile:
		  create: yes
		  regexp: ~/.local
		  path: ~/.bash_profile
		  line: "export PATH=$PATH:~/.local/bin"

	 - name: install packages
		apt: pkg=python3-pip state=latest update_cache=yes
		tags: pip
		become: yes

	 - pip:
		  name: pip
		  state: latest
		become: yes

Ключевое понятие Ansible - Playbook. Это файл (или файлы) описывающие в yaml, что нужно сделать на указанной машине. В каждом плейбуке используются готовые модули поставляемые вместе с Ansible. Этих модулей сотни, с помощью них можно делать практически все, начиная от установки программ, до настройки сети и управления правами файловой системы. Ansible универасальный инструмент, с его помощью можно не только настраивать окружение, но и собственно деплоить. Причем для деплоя есть готовый модуль - deploy helper https://docs.ansible.com/ansible/2.5/modules/deploy_helper_module.html.

В более продвинутых случаях, там где используется, например, Docker, развертывание осуществляется системами оркестрации, среди которых выделяется Kubernetes https://kubernetes.io/.

Дополнительные материалы
Среды разработки https://ru.hexlet.io/blog/posts/environment
DevOps https://ru.atlassian.com/devops
Непрерывное развертывание https://en.wikipedia.org/wiki/Continuous_delivery
Terraform http://terraform.io/
Ansible https://www.ansible.com/
*/



############## PHP: Ввод и вывод ##############

>>>>> Пути <<<<<<<

echo __FILE__ . PHP_EOL; // абсолютный путь к текущему файлу
echo __DIR__ . PHP_EOL; // абсолютный путь к текущему каталогу <-> dirname(__FILE__)
echo basename(__FILE__) . PHP_EOL; // возвращает название файла
print_r(pathinfo(__FILE__)); // массив с данными о файле: директория, название файла, расширение, название файла без расширения
echo getcwd(); // возвращает директорию в которой был запущен скрипт

// build path
$pathParts = ['var', 'tmp', 'hexlet'];
$path = implode(DIRECTORY_SEPARATOR, $pathParts);
echo DIRECTORY_SEPARATOR . $path . PHP_EOL;

$file = new \SplFileInfo(__FILE__); // класс для работы с файлами
echo $file->getPathInfo() . PHP_EOL;
echo $file->getFileName() . PHP_EOL;
echo $file->getExtansion() . PHP_EOL;


/***
 * Реализуйте функцию cd, принимающую на вход два параметра: текущую директорию и путь для перехода. Функция должна вернуть директорию, в которую необходимо перейти.
 *
 * Пример использования:
 ***/

cd('/current/path', '/etc'); // /etc
cd('/current/path', '.././anotherpath'); // /current/anotherpath
/*
Правила перехода
Если путь для перехода начинается с /, то он же и является конечным путем (так как абсолютный путь).
.. - на уровень выше
. - та же директория
*/

namespace App\FileUtils;

function cd($current, $move)
{
	 // BEGIN (write your solution here)
	 $paths = explode('/', $current);
	 $stack = array_filter($paths, function ($path) {
		  return $path == '';
	 });
	 foreach ($move as $item) {
		  if ($item == '..' || $item == '../') {
				array_pop($stack);
		  } elseif ($item == '.') {
				continue;
		  }
	 }
	 return $stack;
	 // END
}

// Tests:

namespace App\Tests;

use PHPUnit\Framework\TestCase;
use function App\FileUtils\cd;

class FileUtilsTest extends TestCase
{
	 /**
	  * @dataProvider additionProvider
	  */
	 public function testCd($actual, $current, $move)
	 {
		  $this->assertEquals($actual, cd($current, $move));
	 }
	 
	 public function additionProvider()
	 {
		  return [
			  ['/', '/current/path', '/'],
			  ['/current', '/current/path', '..'],
			  ['/current', '/current/path', '../'],
			  ['/current', '/current', '.'],
			  ['/current/anotherpath', '/current/path', '.././anotherpath'],
			  ['/etc', '/current/path', '/etc'],
			  ['/current/anotherpath/path', '/current/anotherpath', '../anotherpath/path'],
		  ];
	 }
}


>>>>>
Файловая система <<<<<<<

namespace Theory;

if (!file_exists($path)) { // проверяет существование файла/директории(в unix директория тоже файл). Проверить на директорию: is_dir($path)
	 mkdir($path, 0755, $recursive); // создать директорию
}

rmdir($path); // удаление директории

if (!file_exists($path)) { // проверить на файл: is_file($path)
	 touch($path); // создать файл
}

unlink($path); // удаление файла

rename($old, $new); // переименование файла
copy($old, $new); // копирование файлов

print_r(glob("/var/tmp/*"));
print_r(scandir("/var/tmp"));


// DirectoryIterator FilesystemIterator RecursiveDirectoryIterator
$iterator = new \GlobIterator('../*');
foreach ($iterator as $item) {
	 print_r($item);
}

$info = new \SplFileInfo(__FILE__);
echo $info->isFile();


/***
 *
 * Реализуйте функцию rrmdir, удаляющую директорию рекурсивно, то есть вместе со всем своим содержимым.
 *
 * Подсказка
 * Одна из возможных реализаций может использовать итераторы.
 * Воспользуйтесь функцией scandir вместо функции glob.
 ***/

namespace App\FileUtils;

function rrmdir($dir)
{
	 $dirIterator = new \RecursiveDirectoryIterator($dir, \FilesystemIterator::SKIP_DOTS);
	 $iterator = new \RecursiveIteratorIterator($dirIterator, \RecursiveIteratorIterator::CHILD_FIRST);
	 foreach ($iterator as $filename => $fileInfo) {
		  if ($fileInfo->isDir()) {
				rmdir($filename);
		  } else {
				unlink($filename);
		  }
	 }
	 rmdir($dir);
}


>>>>>
Чтение файла <<<<<<<

namespace Theory;

$file = __FILE__;

if (file_exists($file) && is_readable($file)) {
	 #1
	 $lines = file(__FILE__);
	 foreach ($lines as $line) {
		  echo $line;
	 }
	 
	 #2
	 $content = file_get_content(__FILE__);
	 echo $content;
	 
	 // #1, #2 - подходят для маленьких файлов (тк. эти функции загружают все в память). Поэтому для больших файлов надо делать это потоково:
	 
	 #3
	 $handle = fopen($filename, "rb"); // rb - чтение без модификации. r+
	 if ($handle) { // $handle - файловый дискриптор. Файл получилось открыть
		  try {
				$contents = fread($handle, filesize($filename)); // 2-й параметр сколько байт прочитать
		  } finally {
				fclose($handler);
		  }
	 }
	 
	 #4
	 $handler = fopen($file, "rb");
	 if ($handler) {
		  try {
				while (!feof($handler)) { // проверяет не достигли ли мы конца файла.
					 echo fgets($handler, 1024); // 2-й параметр сколько байт прочитать
				}
		  } finally { // потому что во время работы могут быть выброшены исключения
				fclose($handler);
		  }
	 }
	 
	 #5
	 $handler = fopen($filename);
	 if ($handler) {
		  try {
				/* javier   argonout    pe */
				/* hiroshi  sculptor    jp */
				/* robert   slacker us*/
				while ($userinfo = fsconf($handle,
					"%s\t%s\t%s\n")) { // возвращает массив значений соотствующий этому паттерну
					 list($name, $profession, $countrycode) = $userinfo;
				}
		  } finally {
				fclose($handler);
		  }
	 }
}

#6
$file = new SplFileObject('file.txt');
while (!$file->eof()) {
	 echo $file->fgets();
}

#7
foreach ($file as $lineNumber => $content) {
	 printf("Line %d: %s", $lineNumber, $content);
}

#8:
$linesTenToTwentyIterator = new LinitIteratir(
	$file,
	9, // start at line 10
	10 // iterate 10 lines
);

foreach ($linesTenToTwentyIterator as $line) {
	 echo $line; // outputs line 10 to 20
}


/**@@@
 * src/App/FileUtils.php
 * Реализуйте функцию grep, принимающую на вход два параметра: подстроку для сопоставления и шаблон в формате glob, по которому будет происходить поиск.
 *
 * Функция должна вернуть список всех строк файлов, в которых содержится подстрока. Поиск должен производиться по всем файлам переданного шаблона.
 *
 * Пример:
 */
sizeof(grep('test', './*')); // 3

// FILE: /app/src/FileUtils.php:
namespace App\FileUtils;

function grep($string, $path)
{
	 if (strpos($move, DIRECTORY_SEPARATOR) === 0) {
		  return $move;
	 }
	 
	 $currentParts = explode(DIRECTORY_SEPARATOR, $current);
	 $parts = explode(DIRECTORY_SEPARATOR, $move);
	 
	 $updatedParts = array_reduce($parts, function ($acc, $item) {
		  switch ($item) {
				case '':
				case '.':
					 return $acc;
				case '..':
					 return array_slice($acc, 0, -1);
				default:
					 $acc[] = $item;
					 return $acc;
		  }
	 }, $currentParts);
	 
	 return implode(DIRECTORY_SEPARATOR, $updatedParts);
}


>>>>>
Запись в файл <<<<<<<

namespace Theory;
$file = __DIR__ . DIRECTORY_SEPARATOR . 'temp';
$data = "my data\n";

file_put_contents($file, $data); // FILE_APPEND - не перезаписывать, добавлять в конец.

if (is_writable($file)) {
	 $handle = fopen($file, 'ab'); // ab - добавление данных в конец; r - перезаписывать; a+ c
	 if ($handle) {
		  try {
				fwrite($handle, $data);
		  } finally {
				fclose($handler);
		  }
	 }
}

$file = new \SplFileObject($file, 'ab');
$file->fwrite($data);


/**@@@
 * Сериализация — процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации (структуризации) — восстановление начального состояния структуры данных из битовой последовательности.
 *
 * Функция serialize в php генерирует пригодное для хранения представление переменной. Это полезно для хранения или передачи значений PHP между скриптами без потери их типа и структуры. Для превращения сериализованной строки обратно в PHP-значение существует функция unserialize.
 *
 * src/App/Serializer.php
 * Реализуйте функцию dump, которая принимает на вход имя файла и структуру данных. После чего она сериализует эту структуру и записывает в файл.
 * Реализуйте функцию load, которая принимает на вход имя файла. После этого она читает содержимое файла и проводит десериализацию.
 * Пример:
 */
Serializer\dump($file, $structure);
$data = Serializer\load($file);

$structure == $data;


// FILE: /app/src/App/Serializer.php:
namespace App\Serializer;

function load($file)
{
	 $data = file_get_contents($file);
	 return unserialize($data);
}

function dump($file, $data)
{
	 $string = serialize($data);
	 file_put_contents($file, $string);
}


>>>>>
Манипуляция с файловыми указателями <<<<<<<

namespace Theoty;

$data = 'ehu';
$handle = fopen('temp', 'wb');
fwrite($handle, $data);
echo ftell($handle) . PHP_EOL; // возвращает позицию указателя => 3
fseek($handle, 0); // rewind($handle); // перемещение указателя; 0 - в начало <-> rewind($handle)
echo ftell($handle) . PHP_EOL; // => 0

// SplFileObject

/**@@@
 * Класс Db представляет собой простую реализацию NoSQL базы данных, основанной на файлах. Она обладает очень простым интерфейсом. Метод get принимает на вход ключ (любая строка) и возвращает значение этого ключа. Метод set принимает на вход ключ и значение (любая строка).
 *
 * Ограничения:
 *
 * Максимальный размер ключа 8 байт.
 * Максимальный размер значения 100 байт.
 * Пример:
 */
$db = new Db($filepath);
$db->set('key', 'value');
$db->get('key'); // value

/*
Db.php
Реализуйте логику работы этого класса используя смещения внутри файла.

Если файла базы не существует, то он должен создаваться в конструкторе
Если ключа не существует, то операция get должна выкидывать исключение Db\NotFoundException
Если ключ существует, то set перезаписывает значение
*/

/// FILE: /app/src/App/Db/Db.php:
namespace App;

class Db
{
	 const KEY_LENGTH = 8;
	 const VALUE_LENGTH = 100;
	 
	 
	 const ZERO = "\0";
	 
	 private $db;
	 
	 public function __construct($file)
	 {
		  if (!file_exists($file)) {
				touch($file);
		  }
		  
		  $this->db = new \SplFileObject($file,
			  'r+'); // r+ - открывает файл для чтения и записи; помещает указатель в начало файла.
	 }
	 
	 public function get($key)
	 {
		  $this->db->rewind(); // сбрасывает курсор файлового указателя
		  
		  while (!$this->db->eof()) {
				$currentKey = rtrim($this->db->fread(self::KEY_LENGTH), self::ZERO);
				$currentValue = rtrim($this->db->fread(self::VALUE_LENGTH), self::ZERO);
				
				if ($key === $currentKey) {
					 return $currentValue;
				}
		  }
		  
		  throw new Db\NotFoundException("'$key' is not exists");
	 }
	 
	 public function set($key, $value)
	 {
		  $this->db->rewind();
		  
		  while (!$this->db->eof()) {
				$currentKey = rtrim($this->db->fread(self::KEY_LENGTH), self::ZERO);
				
				if ($key === $currentKey) {
					 $this->write($value, self::VALUE_LENGTH);
					 
					 return;
				}
				
				$this->db->fread(self::VALUE_LENGTH);
		  }
		  
		  $this->write($key, self::KEY_LENGTH);
		  $this->write($value, self::VALUE_LENGTH);
	 }
	 
	 private function write($data, $length)
	 {
		  $zeroLength = $length - strlen($data);
		  
		  $this->db->fwrite($data);
		  $this->db->fwrite(str_repeat(self::ZERO, $zeroLength));
	 }
}


>>>>>
Временный файл <<<<<<<

$dir = sys_get_temp_dir(); // возращает временную системную директорию

$tmpfname = tempnam(sys_get_temp_dir(), "HEXLET"); // создает пустой временный файл. В первом аргументе передается директория (здесь временная системная директория)

$temp = tmpfile(); // создает файловый дискриптор временного файла
try {
	 fwrite($temp, 'my data');
	 fseek($temp, 0);
	 echo fread($temp, 1024);
} finally {
	 fclose($temp);
}

// SplTempFileObject


/***
 * Реализуйте функцию tmpdir, принимающую на вход лямбда-функцию. tmpdir при этом должна создать временную директорию, а потом вызвать лямбду с переданным туда путем до директории. После вызова tmpdir должна удалить эту временную директорию. Функция tmpdir должна вернуть результат выполнения лямбда-функции.
 *
 * Пример:
 ***/

$path = FileUtils\tmpdir(function ($dir) {
	 is_dir($dir); // true
	 return tempnam($dir, 'hexlet');
});

file_exists($path); // false


namespace App\FileUtils;

function tmpdir($func)
{
	 $dir = sys_get_temp_dir() . DIRECTORY_SEPARATOR . uniqid();
	 mkdir($dir);
	 try {
		  return $func($dir);
	 } finally {
		  rrmdir($dir);
	 }
}

function rrmdir($dir)
{
	 $iterator = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($dir, \FilesystemIterator::SKIP_DOTS),
		 \RecursiveIteratorIterator::CHILD_FIRST); // RecursiveIteratorIterator - делает рекурсивное перемещение по всем файлам и каталогам
	 foreach ($iterator as $filename => $fileInfo) {
		  if ($fileInfo->isDir()) {
				rmdir($filename);
		  } else {
				unlink($filename);
		  }
	 }
	 rmdir($dir);
}

// Tests:

class FileUtilsTest extends TestCase
{
	 public function testTmpdir1()
	 {
		  $exists = false;
		  $path = tmpdir(function ($dir) use (&$exists) {
				$exists = is_dir($dir);
				return tempnam($dir, 'hexlet');
		  });
		  
		  $this->assertTrue($exists);
		  $this->assertFalse(file_exists($path));
	 }
	 
	 public function testTmpdir2()
	 {
		  $exists = false;
		  $isEmpty = tmpdir(function ($dir) use (&$exists) {
				$exists = is_dir($dir);
				return !(new \FilesystemIterator($dir))->valid();
		  });
		  
		  $this->assertTrue($exists);
		  $this->assertTrue($isEmpty);
	 }
}

$files = new RecursiveIteratorIterator($dir);

echo "[$path]\n";
foreach ($files as $file) {
	 echo " ├ $file\n";
}

/*
[tree]
 ├ tree\.
 ├ tree\..
 ├ tree\dirA\.
 ├ tree\dirA\..
 ├ tree\dirA\dirB\.
 ├ tree\dirA\dirB\..
 ├ tree\dirA\dirB\fileD
 ├ tree\dirA\fileB
 ├ tree\dirA\fileC
 ├ tree\fileA


Удаляем записи точек (. и ..), также режим рекурсии будет изменен, чтобы сначала взять родительский элемент (подкаталог) (SELF_FIRST) перед дочерними элементами (файлы и под-поддиректории в подкаталоге):

LEAVES_ONLY (по умолчанию): только файлы списка, нет каталогов.
SELF_FIRST: Перечислите каталог, а затем файлы там.
CHILD_FIRST: сначала укажите файлы в подкаталоге, затем каталог.
*/

$dir = new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS);
$files = new RecursiveIteratorIterator($dir, RecursiveIteratorIterator::SELF_FIRST);

echo "[$path]\n";
foreach ($files as $file) {
	 $indent = str_repeat('   ', $files->getDepth());
	 echo $indent, " ├ $file\n";
}

/*
[tree]
 ├ tree\dirA
	 ├ tree\dirA\dirB
		 ├ tree\dirA\dirB\fileD
	 ├ tree\dirA\fileB
	 ├ tree\dirA\fileC
 ├ tree\fileA
*/


############## «PHP: Функциональное программирование» ##############


>>>>>   Map:
Отображение списков <<<<<<<

$result = array_map(function ($key, $value)){
	return $key . $value;
}, array_keys($map), $map); // передаем ключи массива в array_map
// не поддерживает итерируемые объекты

// Functional\map - поддерживает:
$iterator = new \DirectoryIterator('..'); // .. - директория выше
$result = map($iterator, function ($info) {
	 return $info->getFilename();
});




>>>>>  Фильтрация коллекций <<<<<<<

$result = array_filter($array, function ($key) {
	 return $key > 5;
}, ARRAY_FILTER_USE_KEY); // передаем ключи в array_filter. ARRAY_FILTER_USE_BOTH - передать ключ и значение
// не поддерживает итерируемые объекты

// Functional\select:
$iterator = new \DirectoryIterator('..');
$result = select($iterator, function ($item) {
	 return $item->isDir();
});

/*
Ссылки
Итераторы - http://php.net/manual/en/language.oop5.iterations.php

/**
«Мощность строки» — выдуманное нами понятие, которое показывает ее силу ;-). Вычисляется оно как сумма ASCII кодов букв строки.
Реализуйте функцию powerOfString, которая находит мощность строки.

Подсказки:
Сумма элементов массива — array_sum.
Преобразование строки в массив — str_split.
Получить ASCII код символа — ord.
**/
namespace App\Solution;

require getenv('COMPOSER_HOME') . '/vendor/autoload.php';

use function Functional\select;
use function Functional\map;

function powerOfString($str)
{
	 $result = map(str_split($str), function ($item) {
		  return ord($item);
	 });
	 
	 return array_sum($result);
}

/**
 * Реализуйте функцию evenSquareSum, которая принимает на вход массив и возвращает сумму квадратов четных чисел.
 * [1, 2, 3, 8]; // 2^2 + 8^2 = 68
 **/
namespace App\Solution;

require getenv('COMPOSER_HOME') . '/vendor/autoload.php';

use function Functional\select;
use function Functional\map;

function evenSquareSum($array)
{
	 $evenNumbers = select($array, function ($item) {
		  return $item % 2 == 0;
	 });
	 
	 $squaredNumbers = map($evenNumbers, function ($item) {
		  return $item ** 2;
	 });
	 
	 return array_sum($squaredNumbers);
}


>>>>>
Функция zip <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\zip;

// [1, 2] zip with [3, 4]  (по индексам) => [[1, 3], [2, 4]]

// array_map
$result = array_map(null, range(1, 3), range(11, 13)); // если первый аргумент null array_map работает как zip

print_r($result); // => [[1, 11], [2, 12], [3, 13]]

// Functional\zip
$result = zip(range(1, 3), range(11, 13));

print_r($result); // => [[1, 11], [2, 12], [3, 13]]

// array_map
$result = array_map(function ($a, $b) { // <-> array_map(null, range(1, 3), range(11, 13))
	 return [$a, $b];
}, range(1, 3), range(11, 13);

print_r($result);


// Returns [['one', 1], ['two', 2], ['three', 3]]
zip(['one', 'two', 'three'], [1, 2, 3]);

// Returns ['one|1', 'two|2', 'three|3']
zip(
	['one', 'two', 'three'],
	[1, 2, 3],
	function ($one, $two) {
		 return $one . '|' . $two;
	}
);

/**@@@
 * Один из способов определения победителя в футболе это пенальти. Процесс идет так: В каждой попытке бьет игрок каждой из команд и определяется команда победитель этой попытки. Процесс продолжается до 5 попыток, хотя победитель может быть выявлен и раньше. Если после пяти попыток победитель не выявлен, то процесс продолжается до первой выигранной попытки.
 *
 * src/Solution.php
 * Реализуйте функцию bestAttempt которая принимает на вход результаты попыток и возвращает массив со списком имен футбольных клубов, которые победили в каждой из попыток. Если результатом попытки была ничья, то в результирующем массиве она не фигурирует (потому что никто не победил).
 *
 * Пример:
 */

$firstClubAttempts = [['name' => 'milan', 'scored' => 1], ['name' => 'milan', 'scored' => 0]];
$secondClubAttempts = [['name' => 'porto', 'scored' => 1], ['name' => 'porto', 'scored' => 1]];

bestAttempt($firstClubAttempts, $secondClubAttempts); // ['porto']

// array_map сохраняет ключи. Чтобы их сбросить, используйте array_values


namespace App\Solution;

use function Functional\map;
use function Functional\zip;

function bestAttempt($first, $second)
{
	 $result = zip($first, $second, function ($result1, $result2) {
		  if ($result1['scored'] > $result2['scored']) {
				return $result1['name'];
		  } else {
				if ($result1['scored'] < $result2['scored']) {
					 return $result2['name'];
				} else {
					 if ($result1['scored'] == $result2['scored']) {
						  return null;
					 }
				}
		  }
	 });
	 
	 $result2 = array_filter($result, function ($var) {
		  return !is_null($var);
	 });
	 
	 return array_values($result2);
}


>>>>>
Функция reduce <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\reduce_left;

$array = [1, 3, 2, 9, 8, 4];


// as array

$result = array_reduce($array, function ($acc, $item) { // наибольший элемент массива
	 return $item > $acc ? $item : $acc;
}, $array[0]);

print_r($result);

// Functional\reduce_left

$result = reduce_left($array,
	function ($item, $index, $collection, $acc) { // left обход коллекции слева, right - справа
		 return $item > $acc ? $item : $acc;
	}, $array[0]);

print_r($result);

/**
 * Реализуйте функцию wordsCount, которая принимает на вход массив слов и возвращает массив, в котором ключ это слово, а значение это количество раз, которое это слово встречалось в исходном массиве.
 * Пример:
 **/
['cat' => 1, 'dog' => 1, 'fish' => 2] == wordsCount(['cat', 'dog', 'fish', 'fish'])


function wordsCount($array)
{
	 $result = reduce_left($array, function ($item, $index, $collection, $acc) {
		  if (!array_key_exists($item, $acc)) {
				$acc[$item] = 0;
		  }
		  $acc[$item]++;
		  return $acc;
	 }, []);
	 
	 return $result;
}



>>>>>   Функция sort <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'User.php';

use function Functional\sort as fsort;

$collection = ['first' => 'dog', 'second' => 'cat', 'third' => 'bird'];

// Sorts a collection alphabetically
// uksort, uasort - сохраняет ключи

usort($collection2, function ($left, $right) { // usort - не сохраняет ключи
	 return strcmp($left,
		 $right); // возвращает отрицательное число, если str1 меньше str2, положительное число, если str1 больше str2, и 0, если строки равны.
});

print_r($collection);

// Sorts a collection alphabetically
$result = fsort($collection, function ($left, $right) {
	 return strcmp($left, $right);
});

print_r($collection);

$users = [new User(10), new User(3), new User(4)];

// Functional\sort. Sorts a collection of users by age

$result = fsort($users, function ($user1, $users2) {
	 if ($user->getAge() == $user2->getAge()) {
		  return 0;
	 }
	 return ($user1->getAge() < $user2->getAge()) ? -1 : 1;
});


/**
 * Реализуйте функцию sortByBinary, которая сортирует переданную коллекцию и возвращает новую коллекцию. Сортировка происходит следующим образом:
 *
 * Сортируем по количеству единиц в бинарном представлении (порядок следования не важен).
 * Если количество единиц одинаково, то сортируем на основе десятичного представления.
 * Пример:
 **/
[1, 2, 4, 3] == sortByBinary([3, 4, 2, 1]);

function sortByBinary($collection)
{
	 return fsort($collection, function ($left, $right) {
		  $countBinOneL = substr_count(decbin($left), '1');
		  $countBinOneR = substr_count(decbin($right), '1');
		  if ($countBinOneL == $countBinOneR) {
				return $left < $right ? -1 : 1;
		  }
		  return $countBinOneL < $countBinOneR ? -1 : 1;
	 });
}

# 2

function sortByBinary($collection)
{
	 $onesCount = function ($number) {
		  $binary = decbin($number);
		  $bitsArray = str_split($binary);
		  return sizeof(array_filter($bitsArray, function ($bit) {
				return $bit == "1";
		  }));
	 };
	 
	 $sorted = fsort($collection, function ($prev, $next) use ($onesCount) {
		  $result = bccomp($onesCount($prev), $onesCount($next));
		  if ($result === 0) {
				if ($prev > $next) {
					 return 1;
				} else {
					 if ($prev < $next) {
						  return -1;
					 }
				}
				return 0;
		  }
		  return $result;
	 });
	 
	 return $sorted;
}



>>>>>   Частичное применение функции <<<<<<<


namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\select;
use function Functional\partial_left;
use function Functional\partial_any;
use const Functional\...;


$substractor = function ($a, $b) {
	 return $a - $b;
};

echo substractor(10, 20); // -> -10

// closure
$substractor2 = function ($a) {
	 return function ($b) use ($a) { // $a - замыкание
		  return $a - $b;
	 };
};

$partiallyAppliedSubstractor = $substractor2(10); //  подход - частичное применение функции
echo $partiallyAppliedSubstractor(20); // => -10

// Functional\partial

$partiallyAppliedSubstractor = partial_left($substractor, 10);
echo $partiallyAppliedSubstractor(20); // => -10

$elements = [
	'john',
	'joe',
	'joanna',
	'patric'
];

$selected = select($elements, partial_any('substr_count', ..., 'jo')); // фильтр по substr_count, в подстроке есть 'jo'. ... - заполнитель

print_r($selected); //  => ['john', 'joe', 'joanna'];

/**
 * Реализуйте функцию mapWithPower, которая принимает на вход массив и степень, и возвращает новый массив, в котором каждое значение возведено в переданную степень.
 *
 * Пример:
 **/
[1, 1, 9, 100, 0] == mapWithPower([-1, 1, 3, 10, 0], 2)

function mapWithPower($nums, $exp)
{
	 $func = partial_any('pow', …, $exp);
	 return map($nums, $func);
}



>>>>>   Partition <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'Admin.php';
require 'User.php';

use function Functional\partition;

$collection = [new User(), new Admin(), new User()];

list($admins, $users) = partition($collection, function ($user) { // разбивает на 2 или более коллекций
	 return $user->isAdmin();
});

print_r($admins);
print_r($users);


/**
 * Реализуйте функцию separateEvenAndOddNumbers, которая принимает на вход массив чисел и возвращает массив, в котором первый элемент - это массив четных чисел, а второй элемент - это массив нечетных чисел, полученных из исходного массива.
 **/

function separateEvenAndOddNumbers($numbers)
{
	 return partition($numbers, function ($num) {
		  return $num % 2 == 0;
	 });
}


>>>>>   Группировка <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'User.php';

use function Functional\group;

$array = [
	new User('english'),
	new User('spanish'),
	new User('russian'),
	new User('english');
];

$grupUser = group($array, function ($user) {
	 return $user->getLang();
});

print_r($groupUser); // 'english' => ..., 'spanish' => ... , ...



/**
 * Реализуйте функцию ages, которая принимает на вход список пользователей и возвращает массив, в котором пользователи одинакового возраста расположены рядом. Порядок появления возрастов в массиве должен совпадать с порядком появления в исходном массиве.
 *
 * Пример:
 **/
$u1 = User\make(4);
$u2 = User\make(3);
$u3 = User\make(5);
$u4 = User\make(4);
$u5 = User\make(5);

[$u1, $u4, $u2, $u3, $u5] == ages([$u1, $u2, $u3, $u4, $u5]);


function ages($users)
{
	 $grouped = group($users, function ($user) {
		  return getAge($user);
	 });
	 
	 return flatten($grouped);
}


/**
 * Реализуйте функцию flatten, которая делает плоским массив любой вложенности.
 **/

flatten([]); // []
flatten([[1], ['key' => 'value', [4]]]); // [1, 'value', 4]


function flatten($arr)
{
	 $iterator = new \RecursiveIteratorIterator(new \RecursiveArrayIterator($arr));
	 return iterator_to_array($iterator, false);
}

# 2

function flatten($value)
{
	 if (!is_array($value)) {
		  return [$value];
	 } elseif (sizeof($value) == 0) {
		  return [];
	 } elseif (sizeof($value) == 1) {
		  return flatten(end($value));
	 }
	 return array_merge(flatten(array_slice($value, 0, 1)), flatten(array_slice($value, 1)));
}


/**@@@
 * Solution.php
 * Реализуйте функцию arrangeBiggestNumber, которая составляет самое большое число из переданного массива чисел и возвращает его строковое представление. Например из чисел [3, 24, 4] мы можем составить такие: 3244, 3424, 2434, 2443, 4324, 4243 и самое больше из них это 4324.
 *
 * Пример:
 */
998764543431 == arrangeBiggestNumber([1, 34, 3, 98, 9, 76, 45, 4]);

function arrangeBiggestNumber($numbers)
{
	 if (empty($numbers)) {
		  return;
	 }
	 
	 usort($numbers, function ($prev, $next) {
		  $number1 = (int)($next . $prev);
		  $number2 = (int)($prev . $next);
		  
		  if ($number1 == $number2) {
				return 0;
		  }
		  
		  return ($number1 < $number2) ? -1 : 1;
	 });
	 
	 return implode('', $numbers);
}


############## PHP: Автоматическое тестирование ##############

/*
PHP Unit
В одном тестовом методе желательно тестировать только одну функцию (в юнит тестировании)
Разные виды assert функций нужны для более удобного автоматического вывода сообщений об ошибках
*/


>>>>> Ассерты <<<<<<<

/* factrorial() */
assert(6) = factrorial(3)); // assert - утверждение

// file: teory/Solution.php:

namespace App\Solution;

function isOdd($var)
{
	 return $var % 2 != 0;
}

// file: teory/tests/SolutionTest.php:

namespace App;

require_once 'Solution.php';

class SolutionTest extends \PHPUnit_Framework_TestCase  // Название файла + Test
{
	 public function testIsOdd() // test + название функции для теста
	 {
		  $this->assertTrue(Solution\isOdd(1));
		  $this->assertFalse(Solition\isOdd(8), "Error!"); // Добавлением дополнительное сообщение в случае ошибки
	 }
}

// assertTrue(mixed $value)
$this->assertTrue(isEven(6));

// assertEquals(mixed $expected, mixed $actual)
$this->assertEquals(6, factorial(3));

// assertCount(int $size, array $haystack)
$this->assertCount(1, getChildren());

// assertContains(mixed $needle, Iterator|array $haystack)
$this->assertContains('john', getNames());

$ phpunit tests /    // запуск тестов из консоли. Каждый тест "." - все ок, F - резльтат о и д не совпадают. :11 - номер строчки с ошибкой


/**
 * Напишите тесты на функцию isEven, которая принимает на вход целое число и возвращает true, если это число четное, и false в обратном случае.
 **/

namespace App;

class TestSolution extends \PHPUnit_Framework_TestCase
{
	 public function testIsEven()
	 {
		  $this->assertTrue(isEven(-2));
		  $this->assertFalse(isEven(7));
		  $this->assertTrue(isEven(8));
	 }
}


>>>>> Структура тестов <<<<<<<

// file: teory/Leaf.php

namespace Theory;

class Leaf
{
	 private $value;
	 
	 public function __construct($value = null)
	 {
		  $this->value = $value;
	 }
	 
	 public function getValue()
	 {
		  return $this->value;
	 }
}

// file: teory/tests/LeafTest.php

namespace Treory;

require_once 'Leaf.php';

class TestLeaf extends \PHPUnit_Framework_TestCase
{
	 public function testGetValue()
	 {
		  $value = 100;
		  $leaf = new Leaf($value);
		  $this->assertEquals($value, $leaf->getValue());
	 }
}


// file: teory/Node.php

namespace Theory;

class Node
{
	 private $children;
	 
	 public function addChild($child)
	 {
		  $this->children[] = $child;
	 }
	 
	 public function getChildren()
	 {
		  return $this->children;
	 }
	 
	 public function removeChildren()
	 {
		  return $this->children = [];
	 }
}


// file: teory/tests/NodeTest.php

namespace Treory;

require_once 'Node.php';

class TestNode extends \PHPUnit_Framework_TestCase
{
	 public function testGetChildren()
	 {
		  $tree = new Node();
		  $leaf = new Leaf();
		  $node = new Node();
		  
		  $childen = $tree->getChildren();
		  $this->assertCount(0, $children);
		  
		  $tree = addChild($leaf);
		  $children = $three->getChildren();
		  $this->assertCount(1, $children);
		  $this->assertContains($leaf, $children); // $children содержит $leaf
		  
		  $tree->addChild($node);
		  $childen = $tree->getChildren();
		  $this->assertCount(2, $children);
		  $this->assertContains($leaf, $children);
		  $this->assertContains($node, $children);
	 }
	 
	 public function testRemoveChildren()
	 {
		  $tree = new Node();
		  $leaf = new Leaf();
		  
		  $tree->addChild($leaf);
		  $tree->removeChildren();
		  $children = $tree->getChildren();
		  $this->assertEmpty($children);
	 }
}

/**@@@
 * QueryBuilder это специальный класс для конструирования sql запросов. Подобная функциональность есть практически во всех ORM. Пример использования:
 */

QueryBuilder::from('members')->toSql();
// SELECT * FROM members

QueryBuilder::from('members')->where('id', 12)->toSql();
// SELECT * FROM members WHERE id = '12'

QueryBuilder::from('photos')->select('author', 'id')
	->where('views_count', null)->where('state', 'archived')->toSql();
// SELECT author, id FROM photos WHERE views_count IS NULL AND state = 'archived'

// Реализуйте тесты для QueryBuilder основываясь на примере выше.

// FILE: /app/implementations/query_builder.right.php:
namespace App;

class QueryBuilder
{
	 private $selectPart = '*';
	 private $tablePart;
	 private $whereParts = [];
	 
	 public static function from($table)
	 {
		  $builder = new QueryBuilder($table);
		  
		  return $builder;
	 }
	 
	 public function __construct($table)
	 {
		  $this->tablePart = $table;
	 }
	 
	 public function select(...$args)
	 {
		  if (!empty($args)) {
				$this->selectPart = implode(", ", $args);
		  }
		  
		  return $this;
	 }
	 
	 public function where($key, $value)
	 {
		  $this->whereParts[$key] = $value;
		  
		  return $this;
	 }
	 
	 public function toSql()
	 {
		  $sqlParts = [];
		  $sqlParts[] = "SELECT {$this->selectPart} FROM {$this->tablePart}";
		  
		  if ($this->whereParts) {
				$whereParts = array_map(function ($key, $value) {
					 if (is_null($value)) {
						  return "$key IS NULL";
					 } else {
						  return "$key = '$value'";
					 }
				}, array_keys($this->whereParts), $this->whereParts);
				
				$wheres = implode(' AND ', $whereParts);
				$sqlParts[] = "WHERE $wheres";
		  }
		  
		  return implode(' ', $sqlParts);
	 }
}

// FILE: /app/tests/QueryBuilderTest.php:
namespace App\Tests;

use PHPUnit\Framework\TestCase;

class QueryBuilderTest extends TestCase
{
	 public function testSelect()
	 {
		  $builder = \App\QueryBuilder::from('users');
		  $expected = 'SELECT * FROM users';
		  
		  $this->assertEquals($expected, $builder->toSql());
		  
		  $builder = \App\QueryBuilder::from('photos')->select('age', 'name');
		  $expected = 'SELECT age, name FROM photos';
		  
		  $this->assertEquals($expected, $builder->toSql());
	 }
	 
	 public function testWhere()
	 {
		  $builder = \App\QueryBuilder::from('users')
			  ->where('age', '18')
			  ->where('source', 'facebook');
		  $expected = "SELECT * FROM users WHERE age = '18' AND source = 'facebook'";
		  $this->assertEquals($expected, $builder->toSql());
	 }
	 
	 public function testWhereWithNull()
	 {
		  $builder = \App\QueryBuilder::from('users')
			  ->where('email', null);
		  $expected = 'SELECT * FROM users WHERE email IS NULL';
		  $this->assertEquals($expected, $builder->toSql());
	 }
}


>>>>>
Dataset <<<<<

// FILE: /teory/tests/SolutionTest.php:
namespace App;

require_once 'Solution.php';

use function App\Solution\cube;

class SolutionTest extends \PHPUnit_Framework_TestCase
{
	 public function testCube()
	 {
		  $this->assertEquals(1, cube(1));
		  $this->assertEquals(8, cube(2));
		  $this->assertEquals(27, cube(3));
	 }
}

// <-> Более лакиночный вариант через dataProvider:

// FILE: /teory/tests/Solution2Test.php:
namespace App;

require_once 'Solution.php';

use function App\Solution\cube;

class Solution2Test extends \PHPUnit_Framework_TestCase
{
	 // комментарии указываем функцию, которая будет dataProvider:
	 
	 /**
	  * @dataProvider additionProvider
	  */
	 public function testCubeWithDataSet($expected, $argument)
	 {
		  $this->assertEquals($expected, cube($argument));
	 }
	 
	 public function additionalProvider()
	 {
		  return [
			  [1, 1],
			  [8, 2],
			  [27, 3],
			  [-1, -1]
		  ];
	 }
}


/*
Можно ли использовать более одной функции утверждения (assert) в тестовом методе, работающим с dataProvider?
> Да
*/


/**@@@
 * TestSolution.php
 * Напишите тесты на функцию hasEqualOnesCount, которая принимает на вход два числа и возвращает true если количество единиц в двоичном представлении у этих чисел совпадает и false если не совпадает.
 */

// FILE: /app/TestSolution.php:
namespace App\Tests;

use PHPUnit\Framework\TestCase;

class SolutionTest extends TestCase
{
	 /**
	  * @dataProvider additionProvider
	  */
	 public function testHasEqualOnesCount($actual, $first, $second)
	 {
		  $this->assertEquals($actual, \App\hasEqualOnesCount($first, $second));
	 }
	 
	 public function additionProvider()
	 {
		  return [
			  [true, 1, 1],
			  [false, -1, 1],
			  [false, 5, 2],
			  [true, 5, 3],
		  ];
	 }
}

// FILE: /app/implementations/has_equal_ones_count.right.php:
namespace App;

function hasEqualOnesCount($first, $second)
{
	 $onesCount = function ($number) {
		  $binary = decbin($number);
		  $bitsArray = str_split(strval($binary));
		  return sizeof(array_filter($bitsArray, function ($bit) {
				return $bit == "1";
		  }));
	 };
	 
	 return $onesCount($first) == $onesCount($second);
}

// FILE: /app/Makefile:
test:
right wrong
	@echo "\n\nGreat job! \n\n"

right:
	suppressor pass 'phpunit --bootstrap implementations/has_equal_ones_count.right.php SolutionTest.php'

wrong:
	suppressor fail 'phpunit --bootstrap implementations/has_equal_ones_count.wrong.1.php SolutionTest.php'
	suppressor fail 'phpunit --bootstrap implementations/has_equal_ones_count.wrong.2.php SolutionTest.php'


>>>>>> Тестирование исключений <<<<<<

// FILE: /theory/tests/SolutionTest.php:
namespace App;

require_once 'Solution.php';

class SolutionTest extends \PHPUnit_Framework_TestCase
{
	 // #1:
	 /**
	  * @expectedException \InvalidArgumentException
	  */
	 public function testExceptionUsingAnnotation()
	 {
		  throw new \InvalidArgumentException('Some Message');
	 }
	 
	 // #2:
	 public function testExceptionUsingTry()
	 {
		  try {
				throw new \InvalidArgumentException('Some Message');
				$this->fail('expected exception');
		  } catch (\InvalidArgumentException $e) {
				
		  }
	 }
}


/**@@@
 * ACL (access control list) это механизм проверки доступа определенных ролей к действиям над определенными ресурсами.
 *
 * Включает понятия:
 *
 * Роль - кто выполняет действие.
 * Ресурс - над чем выполняется действие.
 * Привилегия - какое выполняется действие.
 * Например, администратор может редактировать карточку пользователя. Здесь роль - это администратор, ресурс - карточка пользователя, привилегия - редактировать.
 *
 * Принцип работы системы ACL из этого упражнения:
 */

$data = [
	'articles' => [
		'show' => ['editor', 'manager'],
		'edit' => ['editor']
	],
	'money' => [
		'create' => ['editor'],
		'show' => ['editor', 'manager'],
		'edit' => ['manager'],
		'remove' => ['manager']
	]
];

$acl = new Acl($data);
$acl->check('articles', 'show', 'manager')

/*
file: TestSolution.php
Напишите тесты на функцию check объекта $acl. Функция принимает на вход ресурс, привилегию и роль. Принцип работы этой функции:

 - Если не найден ресурс - бросаем исключение Acl\ResourceUndefined.
 - Если не найдена привилегия - бросаем исключение Acl\PrivilegeUndefined.
 - Если доступ запрещен - Acl\AccessDenied.
*/

// FILE: /app/tests/App/Tests/SolutionTest.php
 namespace App\Tests;

 use PHPUnit\Framework\TestCase;
 use App\Acl\Acl;

 require_once 'src/App/Acl/AccessDenied.php';
 require_once 'src/App/Acl/ResourceUndefined.php';
 require_once 'src/App/Acl/PrivilegeUndefined.php';

 class SolutionTest extends TestCase
 {
	  private static $data = [
		  'articles' => [
			  'show' => ['editor', 'manager'],
			  'edit' => ['editor']
		  ],
		  'money' => [
			  'create' => ['editor'],
			  'show' => ['editor', 'manager'],
			  'edit' => ['manager'],
			  'remove' => ['manager']
		  ]
	  ];
	 
	  public function testAccessDenied()
	  {
			$acl = new Acl(static::$data);
		 
			try {
				 $acl->check('articles', 'edit', 'manager');
				 $this->fail('expected exception');
			} catch (\App\Acl\AccessDenied $e) {
			
			}
	  }
	 
	  public function testResourceUndefined()
	  {
			$acl = new Acl(static::$data);
		 
			try {
				 $acl->check('undefined resources', 'edit', 'manager');
				 $this->fail('expected exception');
			} catch (\App\Acl\ResourceUndefined $e) {
			}
	  }
	 
	  public function testPrivilegeUndefined()
	  {
			$acl = new Acl(static::$data);
		 
			try {
				 $acl->check('articles', 'move', 'manager');
				 $this->fail('expected exception');
			} catch (\App\Acl\PrivilegeUndefined $e) {
			}
	  }
 }


 /**@@@
  * SolutionTest.php
  * - Напишите тесты на класс Config, который принимает на вход вложенный массив и рекурсивно строит цепочку вложенных конфигов.
  * - Напишите тесты на метод toArray класса Config, который возвращает массив значений для текущего уровня вложенности конфига.
  * Пример:
  */
 $data = [
	 'key' => 'value',
	 'deep' => [
		 'key' => [],
		 'deep' => 3,
		 'another' => 7
	 ]
 ];

 $config = new Config($data);

// how it works

 $config->key; // 'value'
 $config->deep->another; // => 7

 $config->deep->toArray();
// => ['key' => [], 'deep' => 3, 'another' => 7]

/*
Другими словами из массива строится дерево объектов (на основе этого же массива), которое позволяет заменить обращение с $data['deep']['key'] на $config->deep->key. Соответственно нужно проанализировать массив использующийся в тестах для создания объекта Config и проверить то что он правильно построился сравнив значения по соответствующему пути в массиве и объекте.
*/

// FILE: /app/SolutionTest.php:
namespace App;

use PHPUnit\Framework\TestCase;

class SolutionTest extends TestCase
{
	 private $config;
	 private $data;
	 
	 public function setUp()
	 {
		  $this->data = [
			  'key' => 'value',
			  'deep' => [
				  'key' => [],
				  'deep' => 3,
				  'another' => 7
			  ]
		  ];
		  
		  $this->config = new Config($this->data);
	 }
	 
	 public function testSimpleKey()
	 {
		  $this->assertEquals('value', $this->config->key);
	 }
	 
	 public function testDeepKey()
	 {
		  $this->assertEquals(7, $this->config->deep->another);
		  $this->assertEquals([], $this->config->deep->key);
	 }
	 
	 public function testToArray()
	 {
		  $this->assertEquals($this->data['deep'], $this->config->deep->toArray());
	 }
}


>>>>>>
Stub <<<<<<


// FILE: /theory/Sender:
/*
	$sender = new Sender();
	$worker = new Worker($sender);
	$worker->perform($data);
*/

namespace Theory;

class Sender
{
	 public function send()
	 {
		  // Do something
		  return false;
	 }
}

// FILE: /theory/tests/WorketTest.php:
namespace Theory;

require_once 'Sender.php';

class WorkerTest extends \PHPUnit_Framework_TestCase
{
	 private $stub;
	 
	 public function setUp() // перед выполнением тестового метода будет вызван
	 {
		  // Limitation: final, private, and static methods
		  $this->stub = $this->getMockBuilder('Theory\Sender') // getMockBuilder - возвращает класс 'дублер' переданного класса
		  ->setMethods(['send']) // список методов для подмены
		  ->getMock(); // генерирует конкретный объект
	 }
	 
	 public function testFreshStub()
	 {
		  $this->assertEquals(null, $this->stub->send());
	 }
	 
	 public function testStub()
	 {
		  // Configure the stub.
		  $this->stub->method('send')
			  ->willReturn(true);
		  
		  $this->assertTrue($this->stub->send());
	 }
	 
	 public function testStub2()
	 {
		  // Configure the stub.
		  $this->stub->method('send')
			  ->will($this->returnArgument(0)); // returnArgument(n1, n2...nn) - функция вернет nn - переданный аргумент
		  
		  // $stub->send('foo') return 'foo'
		  $this->assertEquals('foo', $this->stub->send('foo'));
		  
		  // $stub->send('bar') return 'bar'
		  $this->assertEquals('bar', $this->stub->send('bar'));
	 }
}

/*
В каких случаях стоит использовать stub?
> Для кода с побочными эффектами
> Для изоляции кода от внешнего сервиса
*/


>>>>>>
Mock <<<<<<


// FILE: /theory/Http.php:
namespace Theory;

class Http
{
	 public function post($msg)
	 {
		  return true;
	 }
}

// FILE: /theory/Sender.php:
namespace Theory;

class Sender
{
	 public $http;
	 
	 public function __construct($http)
	 {
		  $this->http = $http;
	 }
	 
	 public function send($msg)
	 {
		  return $this->http->post($msg, []);
	 }
}




// FILE: /theory/tests/SenderTest.php:
/*
	$http = new Http();
	$sender = new Sender($http);
	$sender->send($msg);
*/

namespace Theory;

require_once 'Http.php';
require_once 'Sender.php';

class SenderTest extends \PHPUnit_Framework_TestCase
{
	 public function testSend()
	 {
		  $msg = 'hello, world';
		  
		  $http = $this->getMockBuilder('Http')
			  ->setMethods(['post'])
			  ->getMock();
		  
		  $http->expects($this->once()) // $this->once() - вызывается 1 раз
		  ->method('post') // что вызывается 1 раз
		  ->with( // параметры для метода
			  $this->equalTo($msg),
			  $this->anything()
		  );
		  
		  $sender = new Sender($http);
		  $sender->send($msg);
	 }
}

/*
Почему интерфейс создания моков и стабов одинаковый?
> Технически моки получаются из стабов путем добавления ожиданий
*/


/**@@@
 * Существует подход для работы с базой данных, в котором сама сущность отвечает за свое сохранение в базу. Этот подход называется ActiveRecord. С точки зрения грамотной архитектуры это решение не очень хорошее, но благодаря простой реализации является весьма популярным среди программистов. Да и большинство фреймворков внутри себя содержат orm, реализованную именно как ActiveRecord.
 *
 * tests/SolutionTest.php
 * Напишите тесты на то, что внутри класса User правильно вызывается метод query объекта, отвечающего за соединение с базой данных. Правила работы метода query такие:
 *
 * Вызов save на свежесозданном объекте приводит к однократному вызову query.
 * Повторный вызов (без изменения объекта) не выполняет запроса к базе.
 * Вызов методов setFirstName или setLastName приводит к тому что сохранение снова выполнит запрос.
 * Пример:
 */
$connection = new Db();
$user = new User($connection);

$user->save(); // true
$user->setFirstName("John");
$user->save(); // true
$user->save(); // false

// FILE: /app/tests/SolutionTest.php
namespace App\Tests;

use Variant\User;
use PHPUnit\Framework\TestCase;

class SolutionTest extends TestCase
{
	 private $user;
	 
	 private $connection;
	 
	 public function setUp()
	 {
		  $this->connection = $this->getMockBuilder('App\DbInterface')
			  ->setMethods(['query', 'transaction'])
			  ->getMock();
		  
		  $this->user = new User($this->connection);
	 }
	 
	 public function testSaveNew()
	 {
		  $this->connection->expects($this->once())
			  ->method('query');
		  
		  $this->user->save();
	 }
	 
	 public function testTrySaveTwice()
	 {
		  $this->connection->expects($this->once())
			  ->method('query');
		  
		  $this->user->save();
		  $this->user->save();
	 }
	 
	 public function testSaveTwice()
	 {
		  $this->connection->expects($this->once())
			  ->method('query');
		  
		  $this->user->setFirstName('John');
		  $this->user->save();
		  
		  $this->user->save();
	 }
}


// FILE: /app/src/ActiveRecord.php:
namespace App;

interface ActiveRecord
{
	 public function __construct(DbInterface $connection);
	 
	 public function save();
}


// FILE: /app/src/Db.php:
namespace App;

class Db implements DbInterface
{
	 public function transaction($func)
	 {
		  // NOTE: start transaction
		  try {
				return $func($db);
		  } finally {
				// NOTE: rollback transaction
		  }
		  // NOTE: commit transaction
	 }
	 
	 public function query($sql)
	 {
		  return true;
	 }
}


// FILE: /app/src/DbInterface.php:
namespace App;

interface DbInterface
{
	 public function transaction($func);
	 
	 public function query($sql);
}


>>>>>>
Файловая система <<<<<<

// FILE: /theory/Solution.php:
namespace Theory\Solution;

function makeFolderForUser($userId, $rootDir = null)
{
	 $directory = ($rootDir ? $rootDir : sys_get_temp_dir()) . DIRECTORY_SEPARATOR . $userId; // sys_get_temp_dir() - временная директория
	 
	 if (!file_exists($directory)) {
		  mkdir($directory, 0700, true);
	 }
}


// FILE: /theory/tests/SolutionTest.php:
namespace Theory;

require_once 'Solution.php';

use function Theory\Solution\makeFolderForUser;

// #1:
class SolutionTest extends \PHPUnit_Framework_TestCase
{
	 private $directory;
	 private $userId;
	 
	 protected function setUp()
	 {
		  if (file_exists($this->directory)) {
				rmdir($this->directory);
		  }
		  
		  $this->userId = 5;
		  $this->tmpdir = sys_get_temp_dir();
		  $this->directory = $this->tmpdir . DIRECTORY_SEPARATOR . $this->userId;
	 }
	 
	 public function testDirectoryIsCreated()
	 {
		  $this->assertFalse(file_exists($this->directory));
		  
		  makeFolderForUser($this->userId);
		  $this->assertTrue(file_exists($this->directory));
	 }
	 
	 protected function tearDown() // side effects -> чистим за собой
	 {
		  if (file_exists($this->directory)) {
				rmdir($this->directory);
		  }
	 }
}

// #2 через библиотеку (mikey179/vfsStream) виртуальной файловой система:
use org\bovigo\vfs\vfsStream;

class SolutionVirtualFsTest extends \PHPUnit_Framework_TestCase
{
	 private $directory;
	 private $userId;
	 private $root;
	 
	 protected function setUp()
	 {
		  $this->root = vfsStream::setup('dir'); // задаем корневую директорию
		  
		  $this->userId = 10;
		  $this->directory = vfsStream::url('dir') . DIRECTORY_SEPARATOR . $this->userId;  // получаем путь до директории
	 }
	 
	 public function testDirectoryIsCreated()
	 {
		  $folder = (string)$this->userId; // библиотека не со строками не работает
		  $this->assertFalse($this->root->hasChild($folder));
		  
		  makeFolderForUser($this->userId, vfsStream::url('dir'));
		  $this->assertTrue($this->root->hasChild($folder));
	 }
	 
}


/**@@
 * SolutionTest.php
 * Напишите тесты на функцию mkdirs, которая рекурсивно создает директории для переданного пути
 */

// FILE: /app/SolutionTest.php:
namespace App;

require getenv('COMPOSER_HOME') . '/vendor/autoload.php';

use PHPUnit\Framework\TestCase;
use org\bovigo\vfs\vfsStream;

class TestSolution extends TestCase
{
	 public function testMkdirs()
	 {
		  $root = vfsStream::setup('root');
		  
		  mkdirs(implode(DIRECTORY_SEPARATOR, [vfsStream::url('root'), 'test']));
		  $this->assertTrue($root->hasChild('test'));
		  
		  mkdirs(implode(DIRECTORY_SEPARATOR, [vfsStream::url('root'), 'test', 'inner']));
		  $this->assertTrue($root->hasChild(implode(DIRECTORY_SEPARATOR, ['test', 'inner'])));
	 }
}



############## PHP: Разработка микрофреймворка ##############

/**@@@
 * public/index.php
 * Реализуйте маршрут /about, по которому будет отдаваться строка <h1>about company</h1>. Выполните сопоставление с REQUEST_URI используя регулярные выражения, так чтобы один маршрут обрабатывал и концевой слеш (/about/ тоже самое что /about), и различный регистр (/abOuT, /ABout, /about).
 *
 * Подсказка
 * Для регулярных выражений используйте preg_match.
 */

// FILE: /app/public/index.php:
namespace App;

require_once '/composer/vendor/autoload.php';

function server($url)
{
	 if (preg_match('/^\/about\/?$/i', $url)) {
		  return "<h1>about company</h1>";
	 }
}

echo server($_SERVER['REQUEST_URI']);


>>>>>>
Роутер <<<<<<<

// FILE: /theory/index.php:
namespace Theory;

require_once 'Application.php';

$routers = [
	[
		'/',
		function () {
			 return '<p>main page</p>';
		}
	],
	[
		'/sign_in',
		function () {
			 return 'you sign in';
		}
	],
];

$app = new Application($routers);
$app->run();


// FILE: /theory/Application.php:
namespace Application;

class Application
{
	 private $routers;
	 
	 public function __construct($routers)
	 {
		  $this->routers = $routers;
	 }
	 
	 public function run()
	 {
		  $uri = $_SERVER['REQUEST_URI'];
		  foreach ($this->routers as $item) {
				list($route, $handler) = $item;
				$preparedRoute = preg_quote($route, '/');
				
				if (preg_match("/^$preparedRoute$/i", $uri)) {
					 echo $handler();
					 return;
				}
		  }
	 }
}

/*
В реальных приложениях/фреймоворках по роутам так не ходят (долгий способ).
Для них используют префиксные деревья
*/



/**@@@
 * Другой способ добавлять обработчики маршрутов в App это использовать методы, названные по именам глаголов http. Например $app->get($path, $func).
 *
 * src/App/Application.php
 * Реализуйте интерфейс ApplicationInterface в классе Application.
 *
 * Пример:
 */

// FILE: /app/public/index.php:
namespace App;

require_once '/composer/vendor/autoload.php';

$app = new Application();

$app->get('/companies', function () {
	 return 'companies list';
});

$app->post('/companies', function () {
	 return 'company was created';
});

$app->run();


// FILE /app/src/App/ApplicationInterface.php:
namespace App;

interface ApplicationInterface
{
	 public function get($path, $func);
	 
	 public function post($path, $func);
	 
	 public function run();
}


// FILE: /app/src/App/Application.php:
namespace App;

class Application implements ApplicationInterface
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 public function run()
	 {
		  $uri = $_SERVER['REQUEST_URI'];
		  $method = $_SERVER['REQUEST_METHOD'];
		  
		  foreach ($this->handlers as $item) {
				[$route, $handlerMethod, $handler] = $item;
				$preparedRoute = preg_quote($route, '/');
				
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri)) {
					 echo $handler();
					 return;
				}
		  }
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $this->handlers[] = [$route, $method, $handler];
	 }
}


>>>>>>
Шаблонизация <<<<<<

// FILE: /theory/index.php:
namespace Theory;

require_once "Template.php";

use function Theory\Template\render;

$html = render('index.phtml', [
	'site' => 'hexlet.io',
	'subprojects' => ['map.hexlet.io', 'battle.hexlet.io']
]);

print_r($html);



// FILE: /theory/index.phtml: ?>
<h1><?= $site ?></h1>

<? if (!empty($subprojects)): ?>
	 
	 <? foreach ($subprojects as $project): ?>
		  <?= $project ?>
	 <? endforeach; ?>

<? endif; ?>
<?



// FILE: /theory/Template.php:
namespace Theory\Template;

function render($template, $variables)
{
	 extract($variables);
	 ob_start(); // буферизация вывода
	 include $template;
	 
	 return ob_get_clean(); // достает данные из буфера + очищает буфер
}


/**@@@
 * В нашем фреймворке шаблоны лежат в папке resources/views.
 *
 * src/App/Template.php
 * Реализуйте функцию render, которая принимает абсолютный путь до шаблона и массив параметров, а возвращает готовый html.
 *
 * src/App/Renderer.php
 * Реализуйте функцию render в нейсмпейсе App\Renderer. Она принимает на вход относительный путь до шаблона и параметры. Эта функция должна вычислять абсолютный путь к шаблону и вызывать функцию render шаблонизатора App\Template.
 *
 * Пример использования:
 */

use function App\Renderer\render;

$app = new Application();

$app->get('/', function () {
	 return render('index');
});

$app->get('/about', function () {
	 return render('about', [
		 'site' => 'hexlet.io',
		 'subprojects' => ['battle.hexlet.io', 'map.hexlet.io']
	 ]);
});

$app->run();


// FILE: /app/index.php:
namespace App;

require '/composer/vendor/autoload.php';

use function App\Renderer\render;

$app = new Application();

$app->get('/', function () {
	 return render('index');
});

$app->get('/about', function () {
	 return render('about', ['site' => 'hexlet.io']);
});

$app->run();


// FILE: /app/src/Renderer.php:
namespace App\Renderer;

function render($filepath, $params = [])
{
	 $parts = [getcwd(), 'resources', 'views', $filepath]; // getcwd()- имя текущего рабочего каталога.
	 $templatepath = implode(DIRECTORY_SEPARATOR, $parts) . '.phtml';
	 
	 return \App\Template\render($templatepath, $params);
}


// FILE: /app/src/Template.php:
namespace App\Template;

function render($template, $variables)
{
	 extract($variables);
	 ob_start();
	 include $template;
	 
	 return ob_get_clean();
}


>>>>>>
Параметры <<<<<<<

// FILE: /app/theory/index.php:
namespace App;

require_once 'Application.php';

$app = new Application();

$app->get('/', function () {
	 /* $_REQUEST не рекомендуется к использованию */
	 return json_encode($_GET);
});

$app->post('/', function () {
	 return json_encode($_GET);
});

$app->run();

/*
Такого понятния как "get параметры" нет в принципе.
С какими глаголами http можно отправлять query params?
> Параметры не связаны с глаголом и могут отправляться всегда

post, get а так же head, path, put и многие другие http глаголы это не способы передачи параметров, это глаголы http у которых есть определенная семантика. Например семантика get в том что он извлекает информацию, поэтому может кешироваться и обладает еще некоторым набором свойств (должен обладать по стандарту, ответственность лежит на вас как на разработчике). Семантика post это создание/модификация. Параметры в query string это функциональность, которая с глаголами вообще никак не связана. Все что касается http и того как это работает "по настоящему", вы всегда можете узнать в стандарте (и должны там узнавать как разработчик) ссылки на соответствующие документы есть в этой статье https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead. Просто открываете и читаете как оно должно работать.

Путаница идет во многом из-за особенностей форм в html. По умолчанию формы отправляются с глаголом get и передают параметры через query string, если мы напишем method="post", то будет глагол post и параметры уйдут в body.
*/

/**@@@
 * public/index.php
 * Реализуйте маршрут /, который может принимать параметр sort и выполнять сортировку $data в соответствии с содержимым этого параметра. Формат sort: field direction. field - название поля, direction - либо asc либо desc. Пример: id desc.
 *
 * Отдаваемые данные должны кодироваться в json с помощью функции json_encode.
 * Пример:
 */
$data = [
	['id' => 4, 'age' => 15],
	['id' => 3, 'age' => 28],
	['id' => 8, 'age' => 3],
	['id' => 1, 'age' => 23]
];

$actual = file_get_contents('http://localhost:8080?sort=age+desc');

$expected = [
	['id' => 3, 'age' => 28],
	['id' => 1, 'age' => 23],
	['id' => 4, 'age' => 15],
	['id' => 8, 'age' => 3]
];

json_encode($expected) == $actual

// FILE: /app/src/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  $method = $_SERVER['REQUEST_METHOD'];
		  
		  foreach ($this->handlers as $item) {
				[$route, $handlerMethod, $handler] = $item;
				$preparedRoute = preg_quote($route, '/');
				
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri)) {
					 echo $handler($_GET);
				}
		  }
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $this->handlers[] = [$route, $method, $handler];
	 }
}



// FILE: /app/public/index.php:
namespace App;

require_once '/composer/vendor/autoload.php';

$app = new Application();

$data = [
	['id' => 4, 'age' => 15],
	['id' => 3, 'age' => 28],
	['id' => 8, 'age' => 3],
	['id' => 1, 'age' => 23]
];

$app->get('/', function ($params) use ($data) {
	 if (array_key_exists('sort', $params)) {
		  list($key, $order) = explode(' ', $params['sort']);
		  
		  usort($data, function ($prev, $next) use ($key, $order) {
				$prevValue = $prev[$key];
				$nextValue = $next[$key];
				
				if ($prevValue == $nextValue) {
					 return 0;
				}
				
				if ($order == 'desc') {
					 return $prevValue < $nextValue ? 1 : -1;
				} else {
					 if ($order == 'asc') {
						  return $prevValue > $nextValue ? 1 : -1;
					 }
				}
		  });
	 }
	 
	 return json_encode($data);
});

$app->run();


>>>>>>
Динамические маршруты <<<<<<<

// FILE: /app/public/index.php:
namespace App;

require_once 'Application.php';

$app = new Application();

$app->get('/users/(?P<id>\d+)', function ($params, $arguments) { // именованная группа - id
	 return json_encode($arguments);
});

$app->get('/users/(?p<userId>\d+)/articles/(?P<id>[\w-]+)',
	function ($params, $arguments) { // именованная группа - userId и id
		 return json_encode($arguments); // например: {'userId':'100', 'id':'cars'}
	});



// FILE: /app/src/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  $method = $_SERVER['REQUEST_METHOD'];
		  
		  foreach ($this->handlers as $item) {
				[$route, $handlerMethod, $handler] = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 $arguments = array_filter($matches, function ($key) {
						  return !is_numeric($key); // из-за особенностей работы preg_match
					 }, ARRAY_FILTER_USE_KEY);
					 
					 echo $handler($_GET, $arguments);
				}
		  }
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $this->handlers[] = [$route, $method, $handler];
	 }
}

/**@@@
 * Другой способ работы с роутингом это плейсхолдеры. Пример: /users/:id. Плейсхолдеры это такие "заполнители", которые используются вместо написания регулярного выражения напрямую. Удобство заключается в том что их гораздо проще использовать и понимать.
 *
 * Пример:
 */
$app = new Application();

$app->get('/users/:id', function ($params, $arguments) {
	 // $params['id'] будет содержать часть uri из :id
	 return json_encode($arguments);
});

// Пример обращения к этому маршруту:
$ curl localhost:8080 / users / 3
{
	 id:
	 3}
$ curl localhost:8080 / users / 5
{
	 id:
	 3}

/*
То есть вместо :id можно подставить любое значение.

Плейсхолдеры могут появляться внутри uri в любом месте. Например мы можем определить такой маршрут: /users/:userId/photos/:id.

src/App/Application.php
Реализуйте работу с плейсхолдерами в src/app/Application.php.

Алгоритм работы с плейсхолдерами достаточно прост. Все работает практически так же как и с регулярными выражениями + один шаг. На этом шаге плейсхолдеры заменяются на регулярные выражения. По умолчанию регулярное выражение, на которое заменяются плейсхолдеры, это [\w-]+, при этом не забывайте что группа должна быть именованной.
*/

namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $updatedRoute = $route;
		  $matches = [];
		  
		  if (preg_match_all('/:([^\/]+)/', $route, $matches)) {
				$updatedRoute = array_reduce($matches[1], function ($acc, $value) {
					 $group = "(?P<$value>[\w-]+)";
					 
					 return str_replace(":{$value}", $group, $acc);
				}, $route);
		  }
		  
		  $this->handlers[] = [$updatedRoute, $method, $handler];
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  $method = $_SERVER['REQUEST_METHOD'];
		  
		  foreach ($this->handlers as $item) {
				list($route, $handlerMethod, $handler) = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 $arguments = array_filter($matches, function ($key) {
						  return !is_numeric($key);
					 }, ARRAY_FILTER_USE_KEY);
					 
					 echo $handler($_GET, $arguments);
				}
		  }
	 }
}


>>>>>>
Заголовки HTTP <<<<<<

// FILE: /app/public/index.php:
namespace App;

require_once 'Application.php';

$app = new Application();

$app->get('/', function ($params, $arguments) {
	 return 'hello, world';
});

$app->post('/sign_in', function ($params, $arguments) {
	 $headers = getallheaders(); // получаем заголовки
	 
	 error_log(print_r($_SERVER, true));
	 http_response_code(302); // выставляем код ответа (здесь редирект)
	 header('Location: http://localhost:8080');
	 
	 return print_r($headers, true);
});

$app->run();


/**@@@
 * Для формирования ответа очень часто использую специальный Response Builder, который накапливает в себе данные, которые должны быть отправлены клиенту. Это такие данные, как статус, различные заголовки и тело ответа.
 *
 * В данном упражнении необходимо реализовать интерфейс ResponseInterface в классе Response, описав логику накопления данных ответа, а так же реализовать логику разбора и отправки этих данных клиенту в классе Application.
 *
 * Пример использования Response Builder:
 */

$app->get('/', function () {
	 return response(render('index'));
});

$app->post('/users', function ($meta, $params, $attributes) use ($users) {
	 if (!isset($params['email'])) {
		  return response('Expected email')->withStatus(400);
	 }
	 return response()->redirect('/');
});

/*
src/App/Response.php
Реализуйте интерфейс ResponseInterface в классе Response.

src/App/Application.php
Реализуйте логику отправки ответа клиенту. Сначала необходимо извлечь и отправить статус, затем отправить все заголовки и в конце тело ответа, если оно есть.
*/

// FILE: /app/public/index.php:
<?php

namespace App;

require_once '/composer/vendor/autoload.php';

use function App\response;
use function App\Renderer\render;

$users = [
	1 => [
		['id' => 3, 'name' => 'john'],
		['id' => 4, 'name' => 'ada']
	]
];

$app = new Application();

$app->get('/', function () use ($users) {
	 return response(render('index', ['friends' => $users[1]]));
});

$app->post('/users', function ($meta, $params, $attributes) {
	 if (!isset($params['email'])) {
		  return response('Expected email')->withStatus(400);
	 }
	 return response()->redirect('/');
});

$app->get('/users/:id/friends', function ($meta, $params, $attributes) use ($users) {
	 if (!isset($users[$attributes['id']])) {
		  return response(['error' => 'message not found'])->withStatus(404)->format('json');
	 }
	 $response = response($users[$attributes['id']])->format('json');
	 return $response;
});

$app->run();


// FILE: /app/src/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $updatedRoute = $route;
		  if (preg_match_all('/:([^\/]+)/', $route, $matches)) {
				$updatedRoute = array_reduce($matches[1], function ($acc, $value) {
					 $group = "(?P<$value>[\w-]+)";
					 return str_replace(":{$value}", $group, $acc);
				}, $route);
		  }
		  $this->handlers[] = [$updatedRoute, $method, $handler];
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  $method = $_SERVER['REQUEST_METHOD'];
		  foreach ($this->handlers as $item) {
				[$route, $handlerMethod, $handler] = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 $attributes = array_filter($matches, function ($key) {
						  return !is_numeric($key);
					 }, ARRAY_FILTER_USE_KEY);
					 
					 $meta = [
						 'method' => $method,
						 'uri' => $uri,
						 'headers' => getallheaders()
					 ];
					 
					 $response = $handler($meta, array_merge($_GET, $_POST), $attributes);
					 http_response_code($response->getStatusCode());
					 
					 foreach ($response->getHeaderLines() as $header) {
						  header($header);
					 }
					 echo $response->getBody();
					 
					 return;
				}
		  }
	 }
}

// FILE: /app/src/Renderer.php:
namespace App\Renderer;

function render($filepath, $params = [])
{
	 $templatepath = 'resources/views' . DIRECTORY_SEPARATOR . $filepath . '.phtml';
	 return \App\Template\Render($templatepath, $params);
}


// FILE: /app/src/ResponseInterface.php:
namespace App;

interface ResponseInterface
{
	 public function __construct($body);
	 
	 public function redirect($url);
	 
	 public function withStatus($status);
	 
	 public function format($format);
	 
	 public function getStatusCode();
	 
	 public function getBody();
	 
	 public function getHeaderLines();
}


// FILE: /app/src/Response.php:
namespace App;

function response($body = null)
{
	 return new Response($body);
}

class Response implements ResponseInterface
{
	 protected $headers = [];
	 protected $status = 200;
	 protected $body;
	 
	 public function __construct($body)
	 {
		  if (is_string($body)) {
				$this->headers['Content-Length'] = mb_strlen($body);
		  }
		  $this->body = $body;
	 }
	 
	 public function redirect($url)
	 {
		  $this->status = 302;
		  $this->headers['Location'] = $url;
		  
		  return $this;
	 }
	 
	 public function withStatus($status)
	 {
		  $this->status = $status;
		  return $this;
	 }
	 
	 public function format($format)
	 {
		  switch ($format) {
				case 'json':
					 $this->headers['Content-Type'] = 'application/json';
					 $this->body = json_encode($this->body);
					 $this->headers['Content-Length'] = mb_strlen($this->body);
		  }
		  
		  return $this;
	 }
	 
	 public function getStatusCode()
	 {
		  return $this->status;
	 }
	 
	 public function getBody()
	 {
		  return $this->body;
	 }
	 
	 public function getHeaderLines()
	 {
		  return array_map(function ($key, $value) {
				return "$key: $value";
		  }, array_keys($this->headers), $this->headers);
	 }
}



// FILE: /app/src/Template.php:
namespace App\Template;

function render($template, $variables)
{
	 extract($variables);
	 ob_start();
	 include $template;
	 return ob_get_clean();
}


>>>>>>
Формы <<<<<<

$pdo = new \PDO('sqlite:db.sqlite', null, null, $opt);
$repository = new UserRepositiry($pdo);

$newUser = [
	'email' => '',
	'first_name' => ''
];

$app->get('/users', function () use ($repository) {
	 $users = $repository->all();
	 
	 return response(render('users/index', ['users' => $users]));
});

$app->get('/users/new', function ($meta, $params, $attributes) use ($newUser) {
	 return response(render('users/new', ['errors' => [], 'user' => $newUser]));
});

$app->post('/users', function ($meta, $params, $attributes) use ($repository) {
	 $user = $params['user'];
	 $errors = [];
	 
	 if (!trim($user['email'])) {
		  $errors['email'] = "Email can`t be blank";
	 } else {
		  if (!filter_var($user['email'], FILTER_VALIDATE_EMAIL)) {
				$errors['email'] = "Email is not valid";
		  }
	 }
	 
	 if (!empty($errors)) {
		  return response(render('users/new',
			  ['user' => $user, 'errors' => $errors]))->withStatus(422); // 422 - не обрабатываемая сущность
	 } else {
		  $repository->insert($user);
		  
		  return response()->redirect('/users');
	 }
});

$app->run();


/**@@@
 * Кроме get и post в http определено множество других глаголов. Например, для удаления — DELETE, а для частичного обновления — PATCH. Их поддерживают все распространенные веб-сервера, но, к сожалению, формы в html умеют делать отправку только get или post.
 *
 * Фреймворки нашли выход из этой ситуации: при генерации форм (а их обычно не руками выводят) добавляют специальное hidden поле с именем _method и со значением, которое определяет глагол, например, delete. Дальше фреймворк внутри себя проверяет, если текущий метод POST и существует значение для _method то используем его как имя глагола. Таким образом у нас начинают работать такие конструкции:
 */

$app->delete('/users/:id', function ($meta, $params, $attributes) {
	 // тут удаляем пользователя
	 return response()->redirect('/');
});


/*
src/App/Application.php
Реализуйте логику определения $method на основе значения ключа _method из $_POST

public/index.php
Реализуйте следующие обработчики:

 - Форма создания машины: get -> /cars/new
 - Создание машины: post -> /cars
 - Удаление машины: delete -> /cars/:id
resources/views/cars/new.phtml
Реализуйте форму для создания машины
*/

// FILE: /app/public/index.php:
namespace App;

use function App\response;
use function App\Renderer\render;

require_once '/composer/vendor/autoload.php';

$opt = [
	\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
	\PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
];

$pdo = new \PDO('sqlite:/var/tmp/db.sqlite', null, null, $opt);
$repository = new CarRepository($pdo);

$app = new Application();

$app->get('/', function () use ($repository) {
	 $cars = $repository->all();
	 return response(render('index', ['cars' => $cars]));
});

$app->get('/cars/new', function ($meta, $params, $attributes) {
	 return response(render('cars/new', ['errors' => []]));
});

$app->delete('/cars/:id', function ($meta, $params, $attributes) use ($repository) {
	 $repository->delete($attributes['id']);
	 return response()->redirect('/');
});

$app->post('/cars', function ($meta, $params, $attributes) use ($repository) {
	 $car = $params['car'];
	 $errors = [];
	 
	 if (!$car['model']) {
		  $errors['model'] = "Model can't be blank";
	 }
	 
	 if (empty($errors)) {
		  $repository->insert($car);
		  return response()->redirect('/');
	 } else {
		  return response(render('cars/new', ['car' => $car, 'errors' => $errors]))
			  ->withStatus(422);
	 }
});

$app->run();


// FILE: /app/resources/views/cars/new.phtml:
?>
	 
	 
	 <?php if (isset($errors['model'])) : ?>
	 <?= $errors['model'] ?>
<?php endif ?>


<?


// FILE: /app/App/Renderer/Renderer.php:
namespace App\Renderer;

function render($filepath, $params = [])
{
	 $templatepath = 'resources/views' . DIRECTORY_SEPARATOR . $filepath . '.phtml';
	 return \App\Template\Render($templatepath, $params);
}


// FILE: /app/App/Template/Template.php:
namespace App\Template;

function render($template, $variables)
{
	 extract($variables);
	 ob_start();
	 include $template;
	 return ob_get_clean();
}


// FILE: /app/App/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function delete($route, $handler)
	 {
		  $this->append('DELETE', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $updatedRoute = $route;
		  if (preg_match_all('/:([^\/]+)/', $route, $matches)) {
				$updatedRoute = array_reduce($matches[1], function ($acc, $value) {
					 $group = "(?P<$value>[\w-]+)";
					 return str_replace(":{$value}", $group, $acc);
				}, $route);
		  }
		  $this->handlers[] = [$updatedRoute, $method, $handler];
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  
		  
		  if ($_SERVER['REQUEST_METHOD'] == 'POST' && array_key_exists('_method', $_POST)) {
				$method = strtoupper($_POST['_method']);
		  } else {
				$method = $_SERVER['REQUEST_METHOD'];
		  }
		  
		  foreach ($this->handlers as $item) {
				list($route, $handlerMethod, $handler) = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 $attributes = array_filter($matches, function ($key) {
						  return !is_numeric($key);
					 }, ARRAY_FILTER_USE_KEY);
					 
					 $meta = [
						 'method' => $method,
						 'uri' => $uri,
						 'headers' => getallheaders()
					 ];
					 
					 $response = $handler($meta, array_merge($_GET, $_POST), $attributes);
					 http_response_code($response->getStatusCode());
					 foreach ($response->getHeaderLines() as $header) {
						  header($header);
					 }
					 echo $response->getBody();
					 return;
				}
		  }
	 }
}



// FILE: /app/src/App/CarRepository.php:
namespace App;

class CarRepository
{
	 protected $pdo;
	 
	 public function __construct($pdo)
	 {
		  $this->pdo = $pdo;
	 }
	 
	 public function find($id)
	 {
		  $stmt = $this->pdo->prepare('select * from cars where id = ?');
		  $stmt->execute([$id]);
		  
		  return $stmt->fetch();
	 }
	 
	 public function delete($id)
	 {
		  $stmt = $this->pdo->prepare('delete from cars where id = ?');
		  
		  return $stmt->execute([$id]);
	 }
	 
	 public function all()
	 {
		  return $this->pdo->query('select * from cars')->fetchAll();
	 }
	 
	 public function insert($params)
	 {
		  $pdo = $this->pdo;
		  
		  $fields = implode(', ', array_keys($params));
		  $values = implode(', ', array_map(function ($v) use ($pdo) {
				return $pdo->quote($v);
		  }, array_values($params)));
		  
		  return $pdo->exec("insert into cars ($fields) values ($values)");
	 }
}



// FILE: /app/src/App/Response.php:
namespace App;

require_once 'ResponseInterface.php';

function response($body = null)
{
	 return new Response($body);
}

class Response implements ResponseInterface
{
	 protected $headers = [];
	 protected $status = 200;
	 protected $body;
	 
	 public function __construct($body)
	 {
		  if (is_string($body)) {
				$this->headers['Content-Length'] = mb_strlen($body);
		  }
		  $this->body = $body;
	 }
	 
	 public function redirect($url)
	 {
		  $this->status = 302;
		  $this->headers['Location'] = $url;
		  
		  return $this;
	 }
	 
	 public function withStatus($status)
	 {
		  $this->status = $status;
		  return $this;
	 }
	 
	 public function format($format)
	 {
		  switch ($format) {
				case 'json':
					 $this->headers['Content-Type'] = 'json';
					 $this->body = json_encode($this->body);
					 $this->headers['Content-Length'] = mb_strlen($this->body);
		  }
		  
		  return $this;
	 }
	 
	 public function getStatusCode()
	 {
		  return $this->status;
	 }
	 
	 public function getBody()
	 {
		  return $this->body;
	 }
	 
	 public function getHeaderLines()
	 {
		  return array_map(function ($key, $value) {
				return "$key: $value";
		  }, array_keys($this->headers), $this->headers);
	 }
}


// FILE: /app/src/App/ResponseInterface.php:
namespace App;

interface ResponseInterface
{
	 public function __construct($body);
	 
	 public function redirect($url);
	 
	 public function withStatus($status);
	 
	 public function format($format);
	 
	 public function getStatusCode();
	 
	 public function getBody();
	 
	 public function getHeaderLines();
}


>>>>>>
Файлы <<<<<<

// FILE: /app/public/index.php:
$app->post('/user', function ($meta, $params, $attributes) use ($repository) {
	 $user = $params['user'];
	 $errors = [];
	 
	 if (array_key_exists('user', $_FILES)) {
		  error_log(print_r($_FILES, true));
		  $key = 'avatar';
		  $errorCode = $_FILES['user']['error'][$key]; // код ошибки
		  
		  if ($errorCode !== UPLOAD_ERR_NO_FILE) { // файл не был загружен
				if ($errorCode !== UPLOAD_ERR_OK) { // загрузка с ошибкой
					 $errors['avatar'] = codeToMessage($errorCode);
				} else {
					 $tmpName = $_FILES['user']['tmp_name'][$key];
					 $name = $_FILES['user']['name'][$key];
					 $newName = 'images' . DIRECTORY_SEPARATOR . $name;
					 
					 if (!move_uploaded_file($tmpName, $newName)) {
						  $errors['avatar'] = 'Something wrong';
					 } else {
						  $user['avatar'] = $name;
					 }
				}
		  }
	 }
	 
	 error_log($_FILES, true);
	 
	 if (!empty($errors)) {
		  return response(render('users/new', ['user' => $user, 'errors' => $errors]))->withStatus(422);
	 } else {
		  $repository->insert($user);
		  
		  return response()->redirect('/');
	 }
	 
});


/**@@@
 * В форме создания новой машины есть два поля для загрузки файлов.
 */
<
input class="file" type = "file" name = "car[pictures][]" >
<input class="file" type = "file" name = "car[pictures][]" >

// После загрузки на сервер (обработчик POST /cars) происходит проверка на ошибки и готовится массив, содержащий список загруженных файлов:
	
	$pictures = [
		['name' => basename($tmpFileName)],
		 ...
	];

// При этом сами файлы должны быть перемещены в папку:
$newName = __DIR__ . DIRECTORY_SEPARATOR . 'images' . DIRECTORY_SEPARATOR . basename($tmpFileName);

/*
public/index.php
Допишите логику загрузки файлов в соответствующем обработчике. Она включает в себя формирование массива ошибок $errors (при условии что они были), а так же формирование массива $pictures, который уже будет использоваться для сохранения загруженных картинок.
*/

// FILE: /app/public/index.php:
namespace App;

use function App\response;
use function App\Renderer\render;

require_once '/composer/vendor/autoload.php';

$opt = [
	\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
	\PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
];

$newCar = [
	'pictures' => [],
	'model' => ''
];

$pdo = new \PDO('sqlite:/var/tmp/db.sqlite', null, null, $opt);
$repository = new CarRepository($pdo);

$app = new Application();

$app->get('/', function () use ($repository) {
	 $cars = $repository->all();
	 return response(render('index', ['cars' => $cars]));
});

$app->get('/cars/new', function ($meta, $params, $attributes) use ($newCar) {
	 return response(render('cars/new', ['car' => $newCar, 'errors' => []]));
});

$app->post('/cars', function ($meta, $params, $attributes) use ($repository) {
	 $car = $params['car'];
	 $pictures = [];
	 $errors = [];
	 
	 if (!$car['model']) {
		  $errors['model'] = "Model can't be blank";
	 }
	 
	 if (array_key_exists('car', $_FILES)) {
		  $key = 'pictures';
		  $files = $_FILES['car'];
		  foreach ($files['error'][$key] as $errorCode) {
				if ($errorCode !== UPLOAD_ERR_OK && $errorCode !== UPLOAD_ERR_NO_FILE) {
					 $errors[$key] = 'Something was wrong';
				}
		  }
		  
		  if (!array_key_exists($key, $errors)) {
				foreach ($files['tmp_name'][$key] as $index => $tmpName) {
					 if ($files['error'][$key][$index] === UPLOAD_ERR_NO_FILE) {
						  continue;
					 }
					 $newName = __DIR__ . DIRECTORY_SEPARATOR . 'images' . DIRECTORY_SEPARATOR . basename($tmpName);
					 if (move_uploaded_file($tmpName, $newName)) {
						  $pictures[] = ['name' => basename($tmpName)];
					 } else {
						  $errors[$key] = 'Something was wrong';
					 }
				}
		  }
	 }
	 
	 if (empty($errors)) {
		  $repository->insert($car, $pictures);
		  return response()->redirect('/');
	 } else {
		  return response(render('cars/new', ['car' => $car, 'errors' => $errors]))
			  ->withStatus(422);
	 }
});

$app->run();


>>>>>>
Куки <<<<<<

namespace Theory;

require_once '../exercise/Application.php';
require_once '../exercise/Response.php';
require_once '../exercise/Renderer.php';
require_once 'UserRepositiry.php';

use function App\response;
use function App\Renderer\render;

$app = new \App\Application();

$app->get('/', function () {
	 return response(render('index', ['cookies' => print_r($_COOKIE, true)]));
});

$app->get('/cookie', function () {
	 setcookie('session-cookie', uniqid()); // живет до закрытия браузера
	 setcookie('persistent-cookie', uniqid(), time() + 10000); // персисентная куки
	 setcookie('session-cookie-with-path', uniqid(), 0, '/about');
	 setcookie('session-cookie-for-domain', uniqid(), 0, '', 'www.localhost');
	 setcookie('session-cookie-with-httponly', uniqid(), 0, '', '', false, true);
	 
	 return response()->redirect('/');
});

$app->run();


/**@@@
 * Корзина товаров это стандартный механизм для магазинов в интернете. Один из способов ее организации это хранение в куках массива со списком добавленных туда товаров.
 *
 * Пример установки куки:
 */
$app->post('/', function ($meta, $params, $attributes, $cookies) {
	 $cart = ...
    return response()->redirect('/')->withCookie('cart', json_encode($cart));
});

/*
src/app/Application.php
Реализуйте логику отправки cookies
public/index.php
Реализуйте следующие обработчики:

Вывод списка товаров из корзины: get -> /cart.
Добавление товара в корзину: post -> /cart. Каждое добавление одного и того же товара, увеличивает количество единиц на одну. После добавления должен происходить редирект /cart.
Удаление товара из корзины: delete -> /cart. Товар удаляется полностью, независимо от количества единиц в корзине. После удаления должен происходить редирект /cart.
*/

// FILE: /app/public/index.php:
namespace App;

use function App\response;
use function App\Renderer\render;

require_once '/composer/vendor/autoload.php';

$app = new Application();

$goods = ['milk', 'salt', 'beef', 'chiken', 'butter'];

$app->get('/', function ($meta, $params, $attributes, $cookies) use ($goods) {
	 return response(render('index', ['goods' => $goods]));
});


$app->get('/cart', function ($meta, $params, $attributes, $cookies) use ($goods) {
	 $cart = array_key_exists('cart', $cookies) ? $cookies['cart'] : [];
	 return response(render('cart', ['goods' => json_decode($cart, true)]));
});

$app->post('/cart', function ($meta, $params, $attributes, $cookies) use ($goods) {
	 $cart = array_key_exists('cart', $cookies) ? json_decode($cookies['cart'], true) : [];
	 $good = $params['good'];
	 if (array_key_exists($good, $cart)) {
		  $cart[$good]++;
	 } else {
		  $cart[$good] = 1;
	 }
	 return response()->redirect('/cart')->withCookie('cart', json_encode($cart));
});

$app->delete('/cart', function ($meta, $params, $attributes, $cookies) use ($goods) {
	 $cart = array_key_exists('cart', $cookies) ? json_decode($cookies['cart'], true) : [];
	 $good = $params['good'];
	 unset($cart[$good]);
	 return response()->redirect('/cart')->withCookie('cart', json_encode($cart));
});

$app->run();


// FILE: /app/src/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function delete($route, $handler)
	 {
		  $this->append('DELETE', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $updatedRoute = $route;
		  if (preg_match_all('/:([^\/]+)/', $route, $matches)) {
				$updatedRoute = array_reduce($matches[1], function ($acc, $value) {
					 $group = "(?P<$value>[\w-]+)";
					 return str_replace(":{$value}", $group, $acc);
				}, $route);
		  }
		  $this->handlers[] = [$updatedRoute, $method, $handler];
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  
		  if ($_SERVER['REQUEST_METHOD'] == 'POST' && array_key_exists('_method', $_POST)) {
				$method = strtoupper($_POST['_method']);
		  } else {
				$method = $_SERVER['REQUEST_METHOD'];
		  }
		  
		  foreach ($this->handlers as $item) {
				[$route, $handlerMethod, $handler] = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 error_log(json_encode([$method, $route]));
					 $attributes = array_filter($matches, function ($key) {
						  return !is_numeric($key);
					 }, ARRAY_FILTER_USE_KEY);
					 
					 $meta = [
						 'method' => $method,
						 'uri' => $uri,
						 'headers' => getallheaders()
					 ];
					 
					 $response = $handler($meta, array_merge($_GET, $_POST), $attributes, $_COOKIE);
					 http_response_code($response->getStatusCode());
					 
					 foreach ($response->getHeaderLines() as $header) {
						  header($header);
					 }
					 
					 foreach ($response->getCookies() as $key => $value) {
						  setcookie($key, $value);
					 }
					 
					 echo $response->getBody();
					 return;
				}
		  }
	 }
}


>>>>>>
Сессия <<<<<<

namespace Theory;

require_once '../exercise/Application.php';
require_once '../exercise/Response.php';

use function App\response;

$app = new \App\Application();

$app->get('/', function () {
	 session_start();
	 return response(print_r($_SESSION, true));
});

$app->get('/sessin/new', function ($meta, $params) {
	 session_start();
	 $_SESSION = $params;
	 
	 return response()->redirect('/');
});

$app->get('/session/destroy', function ($meta, $params) {
	 session_start();
	 session_destroy();
	 
	 return response()->redirect('/');
});

$app->run();


/*
Время жизни сессии по умолчанию?
> совпадает с браузерной сессией

Где хранятся данные сессии по умолчанию для php?
> В файлах
*/


/**@@@
 * Реализуйте аутентификацию на сайте на основе nickname.
 *
 * src/App/Session.php
 * Реализуйте класс Session в соответствии с интерфейсом SessionInterface;
 *
 * public/index.php
 * Реализуйте следующие обработчики:
 *
 * Форма для входа: get -> /session/new
 * Обработка формы: post -> /session.
 * Выход: delete -> /session.
 * Если обработка успешна, то делаем перенаправление на /.
 */

// FILE: app/public/index.php:
namespace App;

require_once '/composer/vendor/autoload.php';

use function App\response;
use function App\Renderer\render;

$app = new Application();

$app->get('/', function ($meta, $params, $attributes, $cookies, $session) {
	 $session->start();
	 $nickname = $session->get('nickname');
	 return response(render('index', ['nickname' => $nickname]));
});

$app->get('/session/new', function ($meta, $params, $attributes, $cookies, $session) {
	 return response(render('session/new'));
});

$app->post('/session', function ($meta, $params, $attributes, $cookies, $session) {
	 $session->start();
	 $session->set('nickname', $params['nickname']);
	 return response()->redirect('/');
});

$app->delete('/session', function ($meta, $params, $attribute, $cookies, $session) {
	 $session->start();
	 $session->destroy();
	 return response()->redirect('/');
});

$app->run();


// FILE: /app/src/Application.php:
namespace App;

class Application
{
	 private $handlers = [];
	 
	 public function get($route, $handler)
	 {
		  $this->append('GET', $route, $handler);
	 }
	 
	 public function delete($route, $handler)
	 {
		  $this->append('DELETE', $route, $handler);
	 }
	 
	 public function post($route, $handler)
	 {
		  $this->append('POST', $route, $handler);
	 }
	 
	 private function append($method, $route, $handler)
	 {
		  $updatedRoute = $route;
		  if (preg_match_all('/:([^\/]+)/', $route, $matches)) {
				$updatedRoute = array_reduce($matches[1], function ($acc, $value) {
					 $group = "(?P<$value>[\w-]+)";
					 return str_replace(":{$value}", $group, $acc);
				}, $route);
		  }
		  $this->handlers[] = [$updatedRoute, $method, $handler];
	 }
	 
	 public function run()
	 {
		  $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
		  if ($_SERVER['REQUEST_METHOD'] == 'POST' && array_key_exists('_method', $_POST)) {
				$method = strtoupper($_POST['_method']);
		  } else {
				$method = $_SERVER['REQUEST_METHOD'];
		  }
		  foreach ($this->handlers as $item) {
				list($route, $handlerMethod, $handler) = $item;
				$preparedRoute = str_replace('/', '\/', $route);
				$matches = [];
				if ($method == $handlerMethod && preg_match("/^$preparedRoute$/i", $uri, $matches)) {
					 error_log($route);
					 $attributes = array_filter($matches, function ($key) {
						  return !is_numeric($key);
					 }, ARRAY_FILTER_USE_KEY);
					 
					 $meta = [
						 'method' => $method,
						 'uri' => $uri,
						 'headers' => getallheaders()
					 ];
					 
					 $session = new Session();
					 $response = $handler($meta, array_merge($_GET, $_POST), $attributes, $_COOKIE, $session);
					 http_response_code($response->getStatusCode());
					 foreach ($response->getHeaderLines() as $header) {
						  header($header);
					 }
					 echo $response->getBody();
					 return;
				}
		  }
	 }
}


// FILE: /app/src/Renderer.php:
namespace App\Renderer;

function render($filepath, $params = [])
{
	 $templatepath = 'resources' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR . $filepath . '.phtml';
	 return \App\Template\Render($templatepath, $params);
}


// FILE: /app/src/Response.php:
namespace App;

function response($body = null)
{
	 return new Response($body);
}

class Response implements ResponseInterface
{
	 protected $headers = [];
	 protected $status = 200;
	 protected $body;
	 
	 public function __construct($body)
	 {
		  if (is_string($body)) {
				$this->headers['Content-Length'] = mb_strlen($body);
		  }
		  $this->body = $body;
	 }
	 
	 public function redirect($url)
	 {
		  $this->status = 302;
		  $this->headers['Location'] = $url;
		  
		  return $this;
	 }
	 
	 public function withStatus($status)
	 {
		  $this->status = $status;
		  return $this;
	 }
	 
	 public function format($format)
	 {
		  switch ($format) {
				case 'json':
					 $this->headers['Content-Type'] = 'json';
					 $this->body = json_encode($this->body);
					 $this->headers['Content-Length'] = mb_strlen($this->body);
		  }
		  
		  return $this;
	 }
	 
	 public function getStatusCode()
	 {
		  return $this->status;
	 }
	 
	 public function getBody()
	 {
		  return $this->body;
	 }
	 
	 public function getHeaderLines()
	 {
		  return array_map(function ($key, $value) {
				return "$key: $value";
		  }, array_keys($this->headers), $this->headers);
	 }
}



// FILE: /app/src/Session.php:
namespace App;

class Session implements SessionInterface
{
	 public function start()
	 {
		  session_start();
	 }
	 
	 public function set($key, $value)
	 {
		  $_SESSION[$key] = $value;
	 }
	 
	 public function get($key, $default = null)
	 {
		  return array_key_exists($key, $_SESSION) ? $_SESSION[$key] : $default;
	 }
	 
	 public function destroy()
	 {
		  session_destroy();
	 }
}


// FILE: /app/src/Template.php:
namespace App\Template;

function render($template, $variables)
{
	 extract($variables);
	 ob_start();
	 include $template;
	 return ob_get_clean();
}


/**@@@
 * Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и g есть функция x → f ( g (x) ).
 *
 * Solution.php
 * Определите функцию compose которая реализует композицию.
 *
 * Пример:
 */

$square = function ($num) {
	 return $num ** 2;
};

$half = function ($num) {
	 return $num / 2;
};

$func1 = compose([$square, $half]);
$func1(10); // 25

$func2 = compose([]);
$func2(3); // 3


// FILE: /app/Solution.php:
function compose($functions)
{
	 return function ($arg) use ($functions) {
		  $iter = function ($functions, $acc) use (&$iter) {
				if (empty($functions)) {
					 return $acc;
				}
				
				$newAcc = $functions[0]($acc);
				
				return $iter(array_slice($functions, 1), $newAcc);
		  };
		  
		  return $iter(array_reverse($functions), $arg);
	 };
}


/**@@@
 * Solution.php
 * Реализуйте функцию fringe, которая берет в качестве аргумента дерево (представленное в виде списка) и возвращает список, элементы которого - все листья дерева, упорядоченные слева направо.
 *
 * Пример:
 */
l(4, 3, 2, 1) == fringe(l(l(4, 3), l(2, 1)));

// FILE: /app/Solution.php:
function fringe($list)
{
	 $iter = function ($list, $acc) use (&$iter) {
		  if (empty($list)) {
				return reverse($acc);
		  }
		  $element = car($list);
		  if (isPair($element)) {
				$newAcc = reverse($iter($element, $acc));
		  } else {
				$newAcc = cons($element, $acc);
		  }
		  
		  return $iter(cdr($list), $newAcc);
	 };
	 
	 return $iter($list, l());
}


######################### PHP: Погружаясь в классы #########################

/*
PHP как и любой другой классовый язык, уделяет очень много внимания организации классов. Все это делается ради возможности лучше переиспользовать код (в рамках классового подхода, без классов эти ухищрения не нужны) и допускать меньше ошибок.

С одной стороны это хорошо, но с другой, текущих возможностей настолько много, что одну и ту же задачу можно реализовать десятками способов. Количество комбинаций разных подходов порождает целые школы и направления по тому как надо писать код. Как часто нужно использовать наследование? Где применяются абстрактные классы? А анонимные? Зачем нужны трейты? Как совмещать подтипы и иерархии?

В этом курсе, мы глубоко окунемся в организацию классов, познакомимся с концепций наследования. Научимся строить иерархии классов правильно, с учетом принципа подстановки Лисков. В конце концов узнаем о том, почему наследование почти всегда плохой способ организации кода (но популярный потому что легко сделать) и лучше предпочитать композицию наследованию.

Наследование тянет за собой много нового. Здесь появляются абстрактные классы, финальные классы, возможность переопределять поведение. Возникают шаблоны проектирования, специфичные только для наследования. Наследование влияет на то как работает полиморфный код (но не необходимо для него). Все это требует отдельного рассмотрения.

В конце концов, мы познакомимся с действительно интересной концепций – трейтами (их иногда называют миксинами). Трейты предлагают гораздо более жизнеспособный механизм расширения функциональности лишенный недостатков наследования.

# Дополнительные материалы
Джо Армстронг об Elixir, Erlang, ФП и ООП https://habr.com/ru/post/450508/
*/


>>>>>>>
Наследование <<<<<<

/*
Наследование классов – механизм позволяющий создавать классы (говорят подклассы) на основе других классов (называемых базовыми или суперклассами). Подклассы, в таком случае, "наследуют" структуру базовых классов, то есть получают возможность использовать все, что определено в базовом классе.

Механизм наследования – сложная система, со множеством элементов, дополнительных сущностей и особенностей поведения. Поэтому изучаться он будет в несколько приемов, на протяжении всего курса.

Рассмотрим наследование на примере структуры HTML. Каждый тег в HTML по своему уникален. С другой стороны, все они имеют общие аттрибуты и некоторые другие характеристики. Попробуем отобразить это с помощью иерархии классов.
*/

// Базовый класс для всех тегов. Умеет работать с аттрибутами.
class HTMLElement
{
	 public $body;
	 public $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 public function setAttribute(string $key, $value)
	 {
		  $this->attributes[$key] = $value;
	 }
	 
	 public function getAttribute(string $key)
	 {
		  return $this->attributes[$key];
	 }
	 
	 public function getTextContent(string $key)
	 {
		  return $this->body;
	 }
	 
	 public function setTextContent($body)
	 {
		  $this->body = $body;
	 }
	 
	 
	 protected function stringifyAttributes()
	 {
		  // build: key="value" key2="value2"
	 }
}

// Конкретные элементы, представленные тегами в HTML, наследуются от этого класса:
// Anchor – это ссылка. Класс HTMLAnchorElement описывает тег "a".
// Наследование выполняется через ключевое слово extends
class HTMLAnchorElement extends HTMLElement
{
	 public function __toString()
	 {
		  // Родительский метод
		  $attrLine = $this->stringifyAttributes();
		  // Родительский метод
		  $body = $this->getTextContent();
		  return "<a{$attrLine}>{$body}</a>"
    }
}

// Наследование записывается так: A extends B. Эта запись означает, что класс A наследуется от класса B. Теперь посмотрим как работает наследование:

// Конструктор родителя
$anchor = new HTMLAnchorElement(['href' => 'https://ru.hexlet.io']);
$anchor->setTextContent('Hexlet');
echo "Anchor: {$anchor}"; // __toString вызывается автоматически
// Anchor: <a href="https://ru.hexlet.io">Hexlet</a>


/*
Внутри HTMLAnchorElement нет определения конструктора, но благодаря наследованию, этот класс имеет доступ ко всем публичным методам и свойствам суперкласса. PHP вызывает их автоматически при обращении к ним. В свою очередь, внутри __toString() вызываются методы, которых нет в текущих классах, поэтому они также берутся из родительского класса.

# Цепочка наследования
В отличие от интерфейсов, наследование классов в PHP – одиночное. Другими словами, наследоваться можно только от одного класса. Точно так же как и в Java. Множественное наследование в этих языках было убрано специально, из-за его высокой сложности и проблем, которые оно добавляет (например коллизии методов и свойств). С другой стороны, сама по себе цепочка наследования может быть сколь угодно глубокой:
*/

class D
{
}
class C extends D
{
}
class B extends C
{
}
class A extends B
{
}

# Instance Of
// Оператор instanceof учитывает классы из цепочки наследования:

$anchor = new HTMLAnchorElement();
if ($anchor instanceof HTMLElement) {
	 echo '!!!';
}
// !!!


// Если нужно проверить точный класс, то это можно сделать по другому:
$anchor = new HTMLAnchorElement();
get_class($anchor); // 'HTMLAnchorElement'

// Не забывайте, что подобные проверки закрывают возможность использовать полиморфизм. Иногда без них не обойтись, но в подавляющем большинстве случаев лучше завязываться на интерфейс объекта.

/*
# Дополнительные материалы
https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)
*/

/**@@@
 * src\HTMLHrElement.php
 * Реализуйте класс HTMLHrElement (наследуется от HTMLElement), который отвечает за представление тега <hr>. Внутри класса определите функцию __toString(), которая возвращает текстовое представление тега.
 */
$hr = new HTMLHrElement();
echo $hr; // <hr>

$hr = new HTMLHrElement(['class' => 'w-75', 'id' => 'wop']);
echo $hr; // '<hr class="w-75" id="wop">';

/*
src\HTMLElement.php
Реализуйте метод stringifyAttributes(), который формирует строчку для аттрибутов. Используйте этот метод в наследнике для формирования тега.

Подсказки
В практике доступен collect https://github.com/tightenco/collect
*/

// FILE /app/src/HTMLElement.php:
namespace App;

class HTMLElement
{
	 private $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 protected function stringifyAttributes()
	 {
		  if (count($this->attributes) == 0) {
				return '';
		  }
		  $line = collect($this->attributes)
			  ->map(function ($item, $key) {
					return "{$key}=\"{$item}\"";
			  })
			  ->join(' ');
		  return " {$line}";
	 }
}


// FILE /app/src/HTMLElement.php:
namespace App;

class HtmlHrElement extends HTMLElement
{
	 public function __toString()
	 {
		  $attrLine = $this->stringifyAttributes();
		  return "<hr{$attrLine}>";
	 }
}


>>>>>>
Модификаторы доступа <<<<<<

/*
Видимость свойств влияет не только на внешнее поведение объектов, но и на отношения между наследуемыми классами. Публичные свойства и методы доступны всем наследникам. К ним можно обращаться внутри объекта, так и снаружи:
*/

class HTMLElement
{
	 public $visible = true;
	 
	 public function isVisible()
	 {
		  return $this->visible;
	 }
}

class DivElement extends HTMLElement
{
	 public function isVisiblePropertyFromParent()
	 {
		  return $this->visible;
	 }
	 
	 public function isVisibleMethodFromParent()
	 {
		  return $this->isVisible();
	 }
}

$div = new DivElement();

// Вызов родительского свойства напрямую
echo $div->visible; // true
// Вызов родительского метода напрямую
echo $div->isVisible(); // true

// Вызов родительского свойства изнутри объекта
echo $div->isVisiblePropertyFromParent(); // true

// Вызов родительского метода изнутри объекта
echo $div->isVisibleMethodFromParent(); // true

// Количество классов в цепочке наследования никак не влияет на это поведение. Любой подкласс DivElement, точно так же получит доступ к публичным частям HTMLElement:

class DivElementWithEmptyBody extends DivElement
{

}

$div = new DivElementWithEmptyBody();

// Вызов родительского свойства напрямую
echo $div->visible; // true
// Вызов родительского метода напрямую
echo $div->isVisible(); // true

// Наследование не влияет на поведение свойств внутри объектов. Значение visible в каждом конкретном объекте связано только с этим объектом:

$div1 = new DivElementWithEmptyBody();
$div2 = new DivElement();

echo $div1->visible; // true
echo $div2->visible; // true

$div1->visible = false; // true
echo $div1->visible; // false
echo $div2->visible; // true


# Приватные свойства и методы

/*
Приватные свойства и методы, доступны только внутри того класса, где они были определены. Наследники не могут получить к ним доступ. Подразумевается, что приватные вещи это нечто персональное для класса, его внутренняя реализация, которую нельзя выставлять наружу. Однако, это не отменяет возможности взаимодействоать с приватными данными через публичный интерфейс.
*/

class HTMLElement
{
	 private $visible = true;
	 
	 public function isVisible()
	 {
		  return $this->visible;
	 }
}

$div = new DivElement();
$div->isVisible(); // true
$div->visible; // Error


/*
# Защищенные свойства и методы
Они имеют самое необычное поведение, некий микс между публичными и приватными. Ключевое слово protected используется тогда, когда разработчик хочет запретить доступ снаружи объекта, но дать возможность работать с ними внутри объекта класса-наследника или суперкласса. Звучит довольно хитро, посмотрим на практике:
*/

class HTMLElement
{
	 protected $visible = true;
	 
	 public function isVisible()
	 {
		  return $this->visible;
	 }
}

class DivElement extends HTMLElement
{
	 public function isVisiblePropertyFromParent()
	 {
		  return $this->visible;
	 }
}

$div = new DivElement();

// Доступно внутри через родительский метод
$div->isVisible(); // true
// Доступно внутри напрямую
$div->isVisiblePropertyFromParent(); // true

// Недоступно снаружи
$div->visible; // Error

# Выбор

/*
Мы только начали знакомиться с наследованием, но уже сейчас видно что все не просто. Одну и ту же задачу можно сделать множеством способов. Какой предпочесть?

Универсальная стратегия, которой стоит придерживаться в большинстве случаев – всегда работать через абстракцию пока это не мешает. Это значит что все свойства делаются приватными, а наружу выставляется публичный интерфейс (методы). Если из задачи очевидно что публичный интерфейс нужен только наследникам и не должен использоваться снаружи объекта, то для этих методов ставится модификатор protected.
*/


/**@@@
 * src\HTMLElement.php
 * Реализуйте набор методов для работы с классами:
 *
 * addClass($className) – добавляет класс
 * removeClass($className) – удаляет класс
 * toggleClass($className) – ставит класс если его не было и убирает если он был
 * Эти методы должны обрабатывать свойство 'class' (внутри строка) массива $this->attributes. В процессе реализации вам понадобится постоянно преобразовывать строку классов в массив и обратно. Вынесите эту операцию в отдельные функции и установите им правильный модификатор доступа.
 */

$div = new HTMLDivElement(['class' => 'one two']);
$div->getAttribute('class'); // 'one two'

$div->addClass('small');
$div->getAttribute('class'); // 'one two small'

$div->addClass('small');
$div->getAttribute('class'); // 'one two small'

$div->removeClass('two');
$div->getAttribute('class'); // 'one small'

$div->toggleClass('small');
$div->getAttribute('class'); // 'one'

$div->toggleClass('small');
$div->getAttribute('class')); // 'one small'


// FILE /app/src/HTMLElement.php:
namespace App;

class HTMLElement
{
	 private $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 public function getAttribute($key)
	 {
		  return $this->attributes[$key];
	 }
	 
	 
	 public function addClass($className)
	 {
		  $classes = $this->getClasses();
		  $newClasses = array_unique(array_merge($classes, [$className]));
		  $this->attributes['class'] = $this->stringifyClasses($newClasses);
	 }
	 
	 public function removeClass($className)
	 {
		  $classes = $this->getClasses();
		  $newClasses = array_diff($classes, [$className]);
		  $this->attributes['class'] = $this->stringifyClasses($newClasses);
	 }
	 
	 public function toggleClass($className)
	 {
		  if (in_array($className, $this->getClasses())) {
				$this->removeClass($className);
				return;
		  }
		  
		  $this->addClass($className);
	 }
	 
	 private function getClasses()
	 {
		  return explode(' ', $this->attributes['class'] ?? []);
	 }
	 
	 private function stringifyClasses($classes)
	 {
		  return implode(' ', $classes);
	 }
}


>>>>>>>
Позднее связывание <<<<<<

/*
Для понимания того, как соотносятся друг с другом внутренности классов которые связаны наследованием, нужно разобраться с таким понятием как позднее связывание (late binding).

Вспомним базовый класс HTMLElement из прошлого урока. Внутри него активно используется $this для обращения к свойствам:
*/

// Базовый класс для всех тегов. Умеет работать с аттрибутами.
class HTMLElement
{
	 public $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 public function getAttribute(string $key)
	 {
		  return $this->attributes[$key];
	 }
}


/*
Предположим, что мы создаем объект класса HTMLAnchorElement (который наследуется от HTMLElement). Тогда объектом какого класса будет $this внутри методов родительского класса? Правильный ответ: HTMLAnchorElement, то есть того класса, объект которого мы прямо сейчас создаем.
*/

class A
{
	 private $name = 'From A';
	 
	 public function getName()
	 {
		  echo get_class($this);
		  echo "\n";
		  return $this->name;
	 }
}

class B extends A
{
}

$b = new B();
echo $b->getName();
echo "\n";


/*
Эта особенность $this называется поздним связыванием. Оно означает, что на момент определения класса, тип $this не известен. В качестве текущего объекта может выступать объект любого класса, наследуемого от текущего. Все выглядит так, как будто весь код внутри базового класса, скопировали и перенесли в каждый класс наследник. Для позднего связывания не важно насколько глубокая иерархия наследования. $this всегда будет объектом того класса, который конструируется в коде.

Позднее связывание – важный элемент в работе наследования. Без него, взаимодействие классов стало бы значительно сложнее и ограниченнее. Каждый объект должен был бы наверняка знать, к какому классу конкретно относятся свойства и методы в цепочке наследования. Понадобился бы специальный синтаксис для доступа к ним.

С другой стороны, в некоторых ситуациях позднее связывание не нужно. Например константа CLASS всегда ссылается на тот класс, внутри которого она вызвана. В некоторых ситуациях такое поведение может быть полезно как минимум для отладки.
*/

class B
{
	 public function whereiam()
	 {
		  echo __CLASS__;
	 }
}

class A extends B
{
}

new $obj = new A();
$obj->whereiam(); // B

/*
Дополнительные материалы
Позднее связывание (Wiki) https://en.wikipedia.org/wiki/Late_binding
*/


/**@@@
 * src\Base.php
 * Реализуйте метод isInstanceOf($className), который проверяет что объект принадлежит одному из классов в цепочке наследования.
 */
// ChildOfChild extends FirstChild extends Base

$obj = new \App\ChildOfChild();
$obj->isInstanceOf('App\Base'); // true
$obj->isInstanceOf('Base'); // false
$obj->isInstanceOf('App\Base'); // true
$obj->isInstanceOf('App\FirstChild'); // true
$obj->isInstanceOf('SomeClass'); // false

/*
Подсказки
get_class – возвращает название класса текущего объекта
parent_classes – возвращает список всех классов родителей
*/

// FILE: /app/src/Base.php:
namespace App;

class Base
{
	 public function isInstanceOf($className)
	 {
		  $classes = class_parents($this);
		  $currentClass = get_class($this);
		  $classes[$currentClass] = $currentClass;
		  return in_array($className, $classes);
	 }
}


>>>>>>
Шаблонный метод <<<<<<

/*
Позднее связывание приводит к одному интересному следствию. Из базового класса, можно вызывать методы и свойства, определенные в наследниках. Причем самих наследников может даже не существовать. Позднее связывание на то и позднее, что проверка происходит только в тот момент, когда этот код используется.

Эту особенность используют в паттерне "шаблонный метод". Он применяется тогда, когда у подклассов есть общая логика, которая частично опирается на поведение подклассов. Такая логика реализуется в методе базового класса, а та часть которая различается (для каждого подкласса), делегируется наследникам.

Возьмем для примера наши теги. Посмотрите на метод __toString(). Видно, что его код, останется идентичным для большинства тегов. Единственное что меняется – название самого тега.
*/

class HTMLAnchorElement extends HTMLElement
{
	 public function __toString()
	 {
		  // Родительский метод
		  $attrLine = $this->stringifyAttributes();
		  // Родительский метод
		  $body = $this->getTextContent();
		  return "<a{$attrLine}>{$body}</a>";
	 }
}

// Мы можем модифицировать код так, что метод __toString() переместится в HTMLElement. И единственная вещь, которая останется за подклассами – имя тега:

class HTMLElement
{
	 public function __toString()
	 {
		  $attrLine = $this->stringifyAttributes();
		  $body = $this->getTextContent();
		  // getTagName – метод, который должны реализовать все подклассы
		  $tagName = $this->getTagName();
		  return "<{$tagName}{$attrLine}>{$body}</{$tagName}>";
	 }
}

/*
Получившийся код лучше исходного варианта, так как он значительно сокращает дублирование (тегов около 100 штук!). Но есть одна загвоздка. Теги бывают одиночные, а значит текущий вариант __toString не подойдет для них. Из этой ситуации можно выйти разными способами, например, с помощью наследования.

Создадим у HTMLElement два подкласса: один HTMLSingleElement и HTMLPairElement. Теперь классы конкретных тегов, должны наследоваться от одного из указанных классов. В каждом из этих классов будет своя реализация метода __toString().
*/

class HTMLSingleElement extends HTMLElement
{
	 public function __toString()
	 {
		  $attrLine = $this->stringifyAttributes();
		  // getTagName – метод, который должны реализовать все подклассы
		  $tagName = $this->getTagName(); // <== метод, который должны реализовывать наследники
		  // Создается одиночный тег
		  return "<{$tagName}{$attrLine}>"
    }
}

class HTMLPairElement extends HTMLElement
{
	 public function __toString()
	 {
		  $attrLine = $this->stringifyAttributes();
		  $body = $this->getTextContent();
		  // getTagName – метод, который должны реализовать все подклассы
		  $tagName = $this->getTagName(); // <== метод, который должны реализовывать наследники
		  return "<{$tagName}{$attrLine}>{$body}</{$tagName}>";
	 }
}


// Несмотря на различия в реализации __toString(), оба этих подкласса требуют от своих наследников реализации одного и того же метода getTagName().

/**@@@
 * src\HTMLPairElement.php
 * Реализуйте класс HTMLPairElement (наследуется от HTMLElement), который отвечает за генерацию представления парных элементов и работу с телом. Реализуйте следующий интерфейс:
 */

public function __toString();
public function getTextContent();
public function setTextContent(string $body);

/*
src\HTMLDivElement.php
Реализуйте класс HTMLDivElement, который описывает собой парный тег
*/
div = new HTMLDivElement(['name' => 'div', 'data-toggle' => 'true']);
$div->setTextContent('Body');
echo $div; // '<div name="div" data-toggle="true">Body</div>'


// app/src/HTMLDivElement.php:
namespace App;

class HTMLDivElement extends HTMLPairElement
{
	 public function getTagName()
	 {
		  return 'div';
	 }
}


// app/src/HTMLElement.php:
namespace App;

class HTMLElement
{
	 public $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 protected function stringifyAttributes()
	 {
		  if (count($this->attributes) == 0) {
				return '';
		  }
		  $line = collect($this->attributes)
			  ->map(function ($item, $key) {
					return "{$key}=\"{$item}\"";
			  })
			  ->join(' ');
		  return " {$line}";
	 }
}


// app/src/HTMLPairElement.php:
namespace App;

class HTMLPairElement extends HTMLElement
{
	 private $body;
	 
	 public function __toString()
	 {
		  $attrLine = $this->stringifyAttributes();
		  $name = $this->getTagName();
		  $body = $this->getTextContent();
		  return "<{$name}{$attrLine}>{$body}</{$name}>";
	 }
	 
	 public function getTextContent()
	 {
		  return $this->body;
	 }
	 
	 public function setTextContent(string $body)
	 {
		  $this->body = $body;
	 }
}


>>>>>>
Переопределение методов <<<<<<

/*
Устранение дублирование кода, не единственная задача наследования классов. Иногда оно применяется для изменения существующего поведения базового класса.

Тег <select>, в DOM представлен классом HTMLSelectElement. У него есть дополнительные методы, которые нужны для работы со списком элементов. Один из таких методов: item(index). С его помощью можно извлекать конкретный вариант из списка.

<form>
  <select name="variants">
    <option>Opt 1</option>
    <option>Opt 2</option>
    <option>Opt 3</option>
  </select>
</form>
*/

// Гипотетический код, который возвращает форму выше в виде элемента HTMLSelectElement.
$element = $document->querySelector('select');

$element->item(0); // HTMLOptionElement(textContent="Opt 1")
$element->item(1); // HTMLOptionElement(textContent="Opt 2")

// Представим себе, что нам нужно часто обращаться к элементам этого списка с конца. Для этого постоянно придется выполнять подобный код:

// свойство length описывает число option элементов внутри select
$element->item($element->length - 1);

/*
В этом коде нет ничего криминального, но можно лучше. Один из возможных вариантов решения этой задачи состоит в том, чтобы расширить поведение метода и научить его работать с отрицательными числами. Возможность обращаться к индексам в обратном порядке – распространенная практика во многих языках.
*/

// Последний элемент
$element->item(-1); // HTMLOptionElement(textContent="Opt 3")
// Трети с конца
$element->item(-3); // HTMLOptionElement(textContent="Opt 1")

// Как это сделать? Наследование дает возможность переопределять методы суперклассов. Посмотрите на пример:

class HTMLCustomSelectElement extends HTMLSelectElement
{
	 public function item($possibleIndex)
	 {
		  $realIndex = $possibleIndex > 0 ? $possibleIndex : $this->length + $possibleIndex;
		  // parent указыавет на родительский класс
		  return parent::item($realIndex);
	 }
}

/*
Выше создан подкласс HTMLCustomSelectElement, который переопределяет метод item($index). Переопределение означает, что в подклассе создается метод с тем же именем, что и в родительском классе. Наш новый метод выполняет дополнительную работу по вычислению индекса, но ему все еще нужен исходный метод item($index), для выборки нужного элемента. Для этого применяется специальный синтаксис, который указывает явно что нужно взять метод из родительского класса: parent::item($readIndex).

Почему понадобился специальный синтаксис? Представьте что вместо него там был бы такой код:
*/

public function item($possibleIndex)
{
	 $this->item($possibleIndex);
}


/*
Какой, в этом случае, метод item нужно брать, в определении которого мы находимся прямо сейчас или родительский? Наследование так устроено, что всегда выбирается тот метод, который находится ближе в в цепочке наследования. Поэтому вызов через $this породит рекурсию, но родительский метод никогда не будет вызван.

По этой же причине, снаружи объекта невозможно вызвать методы, которые были переопределены в наследниках:
*/

$select = new HTMLCustomSelectElement();

// Этот вызов всегда относится к методу item переопределенному внутри HTMLCustomSelectElement
// Вызвать напрямую item из HTMLSelectElement невозможно
$select->item(3);

/*
Методы как и свойства имеют модификаторы доступа. Причем они работают идентично: публичные методы доступны для всех, приватные только для текущего класса и защищенные доступны всем наследникам как для вызова так и переопределения.

Переопределение не ограничивается одним уровнем наследования. Любой переопределенный метод можно снова переопределить в наследниках текущего класса. Главное соблюдать два условия:

У обоих методов должны совпадать имена
Они должны иметь одинаковое количество аргументов
*/

# Использование наследников

/*
Создать класс наследник и начать его использовать – это две большие разницы. В ситуациях, где эти классы создаются вами, все просто. Достаточно заменить вызовы старого класса на новый. Но если объекты этого класса создаются чужим кодом, то задача усложняется. Для подмены такого класса, от чужого кода требуется поддержка полиморфного поведения.

Например при работе с DOM, объекты этих классов иногда порождаются самим программистом, а иногда системой. Например:
*/

// Создаем сами
$element1 = new HTMLSelectElement();

// Где-то внутри создается объект HTMLSelectElement
$element2 = $document->querySelector('select');

/*
Можно ли подменить класс в примере с querySelector? Зависит от реализации библиотеки по работе с DOM. В тех библиотеках что мне известны, это сделать невозможно. Это значит что единственный выход использовать класс, конвертировать вернувшийся объект в объект нужного нам класса. Стоит ли оно того? Почти наверняка нет.

Другими словами, наследование для переопределения поведения хоть и кажется логичным шагом, но в действительности имеет серьезные ограничения по использованию.

# Дополнительные материалы
Принцип подстановки Лисков https://ru.wikipedia.org/wiki/Принцип_подстановки_Барбары_Лисков#Проектирование_по_контракту
*/

/**@@@
 * В стандартной библиотеке PHP есть класс SplFileInfo. Объекты этого класса описывают собой файлы. С их помощью можно получать любую метаинформацию о файле.
 */
$file = new SplFileInfo('/etc/hosts');
echo $file->getSize();

/*
src\SmartSplFileInfo.php
Реализуйте класс SmartSplFileInfo наследующийся от SplFileInfo. Этот класс должен расширять поведение метода getSize. В новом классе этот метод принимает на вход аргумент, который обозначает единицу измерения возвращаемых данных. По умолчанию это b, то есть байты, но можно передать и mb это мегабайты. В случае мегабайтов, переопределенный метод делит байты на 1024 и получившиеся значение возвращает наружу.

Метод должен обрабатывать ситуацию, когда на вход поступает что то кроме указанных значений. Обработка сводится к возбуждению исключения Exception.
*/

$file = new SmartSplFileInfo(__DIR__ . '/../Makefile');
$file->getSize();
$file->getSize('b');
$file->getSize('mb');


// FILE: /app/src/SmartSplFileInfo.php:
namespace App;

class SmartSplFileInfo extends \SplFileInfo
{
	 public function getSize($unit = 'b')
	 {
		  $size = parent::getSize();
		  switch ($unit) {
				case 'b':
					 return $size;
				case 'mb':
					 return $size / 1024;
				default:
					 throw new \Exception("Unkown unit name: {$unit}");
		  }
	 }
}


>>>>>>
Принцип подстановки Лисков <<<<<<<

/*
Переопределение методов на техническом уровне ни чем не ограничено. Класс наследник может изменить поведние любого метода настолько, насколько это вообще возможно. С одной стороны, может показаться что это здорово, так как открывается большая свобода действий, но с другой, некоторые изменения, могут повлечь за собой серьезные архитектурные проблемы. Самая главная из них – сломанный полиморфизм.

Рассмотрим пример. Допустим мы решили написать свой собственный логгер (объект, который записывает в журнал произвольные сообщения), базирующийся на PSR3.
*/

// Определение
class MyLogger implements LoggerInterface
{
	 // код
}

// Использование
$logger = new MyLogger();
$logger->log('debug', 'Doing work');
$logger->log('info', 'Usefull for debugging');

/*
Логгер позволяет записывать сообщения с разным уровнем важности, начиная от debug и до emergency. Сигнатура метода log устроена таким образом, что первым параметром всегда передается уровень сообщения, а сообщение вторым. Само сообщение это строка произвольного формата.

Предположим, что нам это не понравилось, и мы решили изменить сигнатуру так, чтобы уровень передавался вторым параметром. Это позволит задать нам дефолтное значение для того уровня, который чаще всего встречается в приложении. Для этого создадим подтип MyLoggerInterface, с переопределенной сигнатурой метода log, а затем реализуем его в классе MyLogger
*/

// PHP позволяет так сделать

interface MyLoggerInterface extends LoggerInterface
{
	 // В LoggerInterface: public function log($level, $message, array $context = []);
	 public function log($message, $level = 'info', array $context = []);
}

class MyLogger implements MyLoggerInterface
{
	 // Тут реализуем новую сигнатуру log
}

// Использование

$logger->log('Doing work'); // По умолчанию debug
$logger->log('Usefull for debugging', 'info');

/*
Что не так с этим кодом? Если вы прошли курс по полиморфизму, то ответ должен быть очевиден. Так как наш класс реализует интерфейс MyLoggerInterface, то он реализует и LoggerInterface. Это значит, что в любом месте где требуется последний, мы можем передать объект класса MyLogger:
*/

// Предположим что какой-то компонент системы хочет работать с логгером соответствующим стандарту PSR3
$logger = new MyLogger();
$database->setLogger($logger);
// Тут делаем что то с этим объектом, а он, в свою очередь, пишет в лог

/*
Этот код завершиться с ошибкой, так как объект $database будет использовать логгер в соответствии с требованиями LoggerInterface, что противоречит интерфейсу MyLoggerInterface. Фактически, это означает что структура типов построена неверно, даже не смотря на то, что PHP его пропустил.

В 1987 году, Барбара Лисков, сформулировала принцип подстановки (Liskov Substitution Principle – LSP), следование которому позволяет правильно строить иерархии типов:

Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T.

Звучит математично. Многие разработчики пытались переформулировать это правило так, чтобы оно было интуитивно понятным. Самое простая формулировка звучит так:

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

То что нужно. В примере выше функция setLogger($logger) ожидает на вход тип LoggerInterface, а мы передали ей подтип MyLoggerInterface. Согласно принципу, код должен продолжать работать как ни в чем не бывало, но этого не происходит из-за нарушения интерфейса.

Для любознательных. Этот принцип любят показывать на иерархиях наследования классов, но как вы видите из текста выше, этот принцип относится к интерфейсам, а не классам. Иерархии классов не обязаны следовать ему, хотя было бы неплохо.

Для еще более любознательных. Почему вообще понадобился этот принцип? Почему бы не поручить эту работу языку? К сожалению, технически невозможно убедиться в соблюдении принципа Лисков. Поэтому его выполнение ложится на плечи разработчиков
*/

# Правила проектирования иерархий типов

/*
Существует несколько правил, которые надо учитывать при работе с типами:

Предусловия не могут быть усилены в подклассе
Постусловия не могут быть ослаблены в подклассе
Исторические ограничения
Предусловия – это ограничения на входные данные, а постусловия – на выходные. Причем в силу ограничений систем типов, многие из таких условий невозможно описать на уровне интерфейсов. Их либо придется описывать просто текстом, как это сделано в документации PSR, либо добавлять проверки в код (проектирование по контракту).

Например в нашем логере (в интерфейсе LoggerInterface) предусловием является то, что метод log первым параметром принимает один из 8 уровней сообщений. Принцип Лисков утвержает, что мы не можем создать класс реализующий этот интерфейс, который может обрабатывать меньшее число уровней. Это и называется усилением предусловий, то есть требования становятся жестче. Вместо 8 уровней, например 5. Попытка использовать объект такого класса, закончится ошибкой, когда какая-то из систем попробует передать ему уровень, который не поддерживается. Причем не важно, приведет это к ошибке (исключению) или логгер молча проглотит это сообщение не записав его в журнал. Главное что поведение стало отличаться.

Встречаются ситуации, когда разработчики не видя причину такого поведения, начинают лечить следствия. В местах где используются подобные объекты добавляются проверки на типы. А это убивает полиморфизм

С постусловиями ситуация аналогичная, но наоборот. Допустимо если метод возвращает урезанный набор значений, так как этот набор все равно укладывается в требования интерфейса. А вот расширять возврат нельзя, так как появляются значения, которые не были предусмотрены интерфесом. Это относится и к исключениям.

И последнее, исторические ограничения. Подтипы не могут добавлять новые методы для изменения (мутации) данных базового типа. Способы изменения свойств определенных в базовом типе определяется этим типом.

# Дополнительные материалы
Circle-ellipse problem https://en.wikipedia.org/wiki/Circle-ellipse_problem
*/

/**@@@
 * В этом задании вам придется написать код, который нарушает принцип Лисков. Запомните его и никогда так больше не делайте :D
 *
 * Представьте себе библиотеку, которая предоставляет абстракции для работы с хранилищами ключ-значение. Все они расширяют интерфейс StorageInterface состоящий из трех методов:
 *
 * set($key, $value) – устанавливает значение
 * get($key) – возвращает значение
 * count() – возвращает количество ключей в хранилище
 * В директории src три таких хранилища: Redis, InMemory, GoogleStorage. Первые два умеют возвращать число ключей внутри них, а последней – нет.
 *
 * Для простоты реализации, каждое хранилище складывает значения во внутренний массив. В реальности, они бы выполняли запросы по сети, но для текущего задания это ненужное усложнение.
 *
 * src\GoolgeStorage.php
 * Реализуйте интерфейс StorageInterface в классе GoogleStorage.
 *
 * Так как GoogleStorage не поддерживает подсчет количества элементов, то сделайте так, чтобы этот метод кидал исключение Exception если его вызывают.
 */

$storage = new GoogleStorage();
$storage->set('one', 'two');
$storage->get('one'); // 'two'
$storage->count(); // Exception

// Подумайте как было бы правильно реализовать эту задачу. Ответ напишите в комментариях к уроку.

// FILE:
namespace App;

class GoogleStorage implements StorageInterface
{
	 private $elements = [];
	 
	 public function get($key)
	 {
		  return $this->elements[$key];
	 }
	 
	 public function set($key, $value)
	 {
		  return $this->elements[$key] = $value;
	 }
	 
	 public function count()
	 {
		  throw new \Exception('Cant be calculated');
	 }
}


>>>>>>
Исключения <<<<<<

/*
Исключения – один из немногих примеров удачного использования наследования. В этом уроке мы научимся создавать свои исключения и перехватывать их.

Обычно исключения используются так. Ближе к началу программы стоит конструкция try/catch, которая ловит исключения и показывает пользователю адекватное сообщение:
*/

try {
	 doSomethingDangerous();
} catch (\Exception $e) {
	 echo 'Something happens';
}

/*
Но как понять что случилось? Иногда это важно. Разные ошибки могут приводить к разному поведению программы. Кроме того, не все ошибки требуют обработки в текущем месте программы.

Разделять ошибки можно с помощью разных классов (или интерфейсов) наследующихся от класса Exception, который в свою очередь реализует интерфейс Throwable https://www.php.net/manual/ru/class.throwable.php. По техническим причинам, реализовать этот интерфейс напрямую нельзя, поэтому остается только один путь – наследование.
*/

namespace App;

class MyException extend \Exception {
}

/*
Причём в отличие от других примеров наследования, в исключениях редко нужно добавлять или изменять поведение. Основная цель использования наследования – описание всех возможных типов ошибок.

Теперь посмотрим как этим можно воспользоваться:
*/
try {
	 // какой-то код
} catch (MyException $e) { // Проверка instanceof
	 // делаем что-нибудь одно
} catch (\Exception $e) {
	 // делаем что-нибудь другое
}

/*
Конструкция try/catch работает очень похоже на switch, но только для исключений. С ее помощью можно описать обработку каждого типа исключений добавив новый блок catch. Во время срабатывания исключения, PHP проверяет каждый блок catch на instanceof начиная с верхнего. Поэтому порядок блоков catch имеет важное значение.

В самом PHP уже есть иерархия исключений, которая позволяет разделять реакцию на разные типы ошибок:

interface Throwable
  |- Error implements Throwable
      |- ArithmeticError extends Error
          |- DivisionByZeroError extends ArithmeticError
      |- AssertionError extends Error
      |- ParseError extends Error
      |- TypeError extends Error
          |- ArgumentCountError extends TypeError
  |- Exception implements Throwable
      |- ClosedGeneratorException extends Exception
      |- DOMException extends Exception
      |- ErrorException extends Exception
      |- IntlException extends Exception
      |- LogicException extends Exception
          |- BadFunctionCallException extends LogicException
              |- BadMethodCallException extends BadFunctionCallException
          |- DomainException extends LogicException
          |- InvalidArgumentException extends LogicException
          |- LengthException extends LogicException
          |- OutOfRangeException extends LogicException
      |- PharException extends Exception
      |- ReflectionException extends Exception
      |- RuntimeException extends Exception
          |- OutOfBoundsException extends RuntimeException
          |- OverflowException extends RuntimeException
          |- PDOException extends RuntimeException
          |- RangeException extends RuntimeException
          |- UnderflowException extends RuntimeException
          |- UnexpectedValueException extends RuntimeException

Перехват любого базового исключения, автоматически влечет за собой перехват всех наследников текущего класса. Например если использовать в catch RuntimeException, то этот блок catch поймает все ошибки, входящие в иерархию RuntimeException.

В PHP есть негласное правило о том, как работать с иерархиями исключений. Любая программа, должна определять свое собственное высокоуровневое исключение, которое наследуется от RuntimeException. Все остальные исключения библиотеки наследуются от него. Такой подход позволяет изолировать обработку ошибок конкретной библиотеки буквально одним блоком catch. Например в http-клиенте guzzle https://github.com/guzzle/guzzle, базовое исключение TransferException https://github.com/guzzle/guzzle/blob/master/src/Exception/TransferException.php. Это значит что мы можем вычленить среди всех ошибок, ошибки этого клиента:
*/

try {
	 $client = new \GuzzleHttp\Client();
	 $response = $client->get('https://ru.hexlet.io');
} catch (Guzzle\TransferException) {
	 // Сюда попадут все ошибки библиотеки guzzle
}

# Finally

/*
В некоторых ситуациях бывает нужно выполнять обработку независимо от того, возникло исключение или нет. Используя только try/catch, эту задачу нельзя выполнить без дублирования. Придётся размещать код как после всей конструкции try/catch, так и в каждом блоке catch.

Это привело к тому, что саму конструкцию расширили добавив в нее блок finally. Этот блок вызывается в самом конце и в любом случае:
*/

try {
	 // какой-то код
} catch (MyException $e) {
	 // делаем что-нибудь одно
} finally {
	 // вызовется в любом случае
}

/**@@@
 * src/File.php
 * Создайте класс File, который представляет собой абстракцию над файлом (упрощенная версия SplFileInfo). Реализуйте в этом классе метод read(). Этот метод проверяет можно ли прочитать файл и если да, то читает его, если нет, то бросает исключения двух видов:
 *
 * Если файла не существует – App\Exceptions\NotExistsException
 * Если файла нельзя прочитать (но он существует) – App\Exceptions\NotReadableException
 */

$file = new File('/etc/fstab');
$file->read();

/*
src/Exceptions/FileException
Реализуйте класс FileException, который наследуется от Exception. Это базовое исключение для данной библиотеки.

src/Exceptions/NotReadableException, src/Exceptions/NotExistsException
Реализуйте классы исключения. Они должны наследоваться от базового класса исключений для данной библиотеки.
*/

// FILE /app/src/Exceptions/NotExistsException.php:
namespace App\Exceptions;

class NotExistsException extends FileException
{

}


// FILE /app/src/Exceptions/NotReadableException.php:
namespace App\Exceptions;

class NotReadableException extends FileException
{

}


// FILE /app/src/File.php:
namespace App;

class File
{
	 protected $filepath;
	 
	 public function __construct($filepath)
	 {
		  $this->filepath = $filepath;
	 }
	 
	 public function read()
	 {
		  $filepath = $this->filepath;
		  
		  if (!file_exists($filepath)) {
				throw new Exceptions\NotExistsException();
		  }
		  if (!is_readable($filepath)) {
				throw new Exceptions\NotReadableException();
		  }
		  
		  return file_get_contents($filepath);
	 }
}


>>>>>>
Динамическая диспетчеризация <<<<<<

/*
В курсе "php: полиморфизм", мы разбирали как работает полиморфизм изнутри. Но тогда, мы еще не знали про наследование достаточно, чтобы раскрыть этот вопрос полностью. Теперь время пришло.

Перед тем как начать, нужно вспомнить что для полиморфизма наследование не нужно. С другой стороны, наследование участвует в процессе выбора метода и об этом тоже нужно знать. Посмотрите на код, который был в курсе посвященному полиморфизму:
*/

// Что происходит во время вызова: $obj->getName() => callMethod($obj, 'getName')
function callMethod($data, $methodName, $args) // функция диспетчер
{
	 $className = $data['className']
    // Специальная функция, которая хранит список классов и связанных с ними методов
    $methods = getClassMethods($className);
    // Берем нужный метод и вызываем его
    $method = $methods[$methodName]
    if ($method) {
		  $method($data, ...$args);
	 } else {
		  if (!$method && isset($methods['__call'])) {
				// Если метод $method не найден, но определен метод __call, то вызываем его
				$methods['__call']($data, ...$args);
		  }
	 }

    throw new \Exception('No method error');
}

/*
В этом коде, проверка останавливается если ничего не было найдено. Так было бы без наследования, но с наследованием поиск продолжается. Сначала выбирается базовый класс для текущего и метод ищется там. Если он не найден, то снова проверяется наличие __call. Затем процесс повторяется для родительского класса родителя текущего класса и далее до конца цепочки наследования.

# Late Binding vs Dynamic Dispatch
Программисты часто путают позднее связывание и динамическую диспетчеризацию. Ситуация усугубляется тем, что в некоторых языках (например Java), принято на уровне документации и сообщества подменять одно понятие другим.

Связывание, говорит нам о том, чем является идентификатор, какой у него тип. Если связывание раннее, то мы это знаем сразу, в случае позднего, только в момент вызова кода. Во многих языках можно определить функцию, после того, как где-то описано ее использование. Это тоже пример связывания (позднего). В случае $this в PHP, мы знаем что это объект текущей иерархии, но не знаем точно какой класс до момента срабатывания этого кода.

Диспетчеризация же, это процесс поиска и вызова необходимой функции (или метода, в зависимости от языка) для уже известного типа данных.

# Дополнительные материалы
What is early and late binding?
*/


>>>>>> Абстрактные классы <<<<<<

/*
Может ли нам понадобится когда-нибудь создавать объекты класса HTMLElement? Наверняка нет. Вся работа строится на базе конкретных элементов, а значит, на практике, всегда используются его наследники.

В PHP, классы, объекты которых не имеют смысла, принято помечать специальным ключевым словом abstract. Тогда никто не сможет создать объект этого класса напрямую. Только через наследников. В остальном, абстрактный класс такой же класс, со своими методами и свойствами.
*/

abstract class HTMLElement
{
	 public $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 public function getAttribute(string $key)
	 {
		  return $this->attributes[$key];
	 }
}

/*
Абстрактные классы имеют смысл только в связке с наследованием. В большинстве ситуаций, базовый класс не нуждается в объектах и его логично пометить как абстрактный.

Еще одна особенность абстрактных классов, связана с использованием интерфейсов. Абстрактный класс, в отличие от конкретного, не обязан реализовывать интерфейсы полностью. Все что не реализовывает абстрактный класс, должно быть реализовано в его наследнике. Например в нашей ситуации, можно добавить интерфейс Showable в абстрактный класс, но не реализовывать его. В таком случае PHP сам проверит что все наследники HTMLElement реализуют метод __toString().
*/

abstract class HTMLElement implements Showable // __toString
{
	 // ...
}

// Абстрактные классы могут иметь абстрактные методы, фактически это сигнатуры методов, а не сами методы. В этом смысле они становятся похожи на интерфейсы.

abstract class HTMLElement
{
	 abstract public function __toString();
}

/*
С появлением абстрактных классов возникает множество новых вопросов: когда они нужны а когда нет, можно ли использовать абстрактные классы вместо интерфейсов, как совмещать их с интерфейсами и так далее?

Абстрактные классы не фундаментальная концепция и не обязательная часть ООП. Более того, в большинстве ООП языках абстрактных классов нет. Однако нельзя сказать что код на них пишется хуже, скорее наоборот. Например в Ruby, JavaScript и Python абстрактных классов нет, но есть наследование и есть классы, которые можно было отметить как абстрактные, однако создатели этих языков не стали вводить это понятие в язык. Никогда нельзя забывать, что любые новые сущности, упрощая в одном месте, увеличивают общую сложность из-за возрастающего числа комбинаций этих сущностей друг с другом.

Общая рекомендация, не придавайте слишком много значения абстрактным классам. Используйте их тогда, когда класс имеет смысл пометить абстрактным, но не более того. Как вы увидите позже, абстрактные классы, вместе с наследованием, успешно заменяются трейтами. Причем последние гораздо более гибкий инструмент.
*/


/**@@@
 * src\HTMLElement.php
 * Определите абстрактный метод getTagName()
 *
 * src\HTMLPairElement.php
 * Реализуйте абстрактный класс HTMLPairElement с пустым содержимым.
 */


// FILE: /app/src/HTMLElement.php:
namespace App;

abstract class HTMLElement
{
	 public $attributes = [];
	 
	 public function __construct($attributes = [])
	 {
		  $this->attributes = $attributes;
	 }
	 
	 abstract public function getTagName();
}

// FILE: /app/src/HTMLPairElement.php:
namespace App;

abstract class HTMLPairElement extends HTMLElement
{
}


>>>>>>
Позднее статическое связывание <<<<<<

/*
В отличие от $this, обращение к статическим свойствам и метода через self работает по принципу раннего связывания (обратное позднему). Другими словами, self указыавет на тот класс, в котором идет обращение:
*/

class A
{
	 public static function who()
	 {
		  echo 'A';
	 }
	 
	 public static function test()
	 {
		  self::who();
	 }
}

class B extends A
{
	 public static function who()
	 {
		  echo 'B';
	 }
}

B::test();
// 'A'

/*
В этом примере, статический метод test(), вызывает self::who(), который находится внутри класса A. Поэтому self указывает на сам A. Никакая иерархия наследования не может изменить это поведение. Такой код равносилен прямому укзанию класса:
*/

A::who(); // 'A'

/*
Подобное поведение можно рассматривать как ограничение. Оно, фактически, игнорирует факт наследования. Позднее связывание же, открывает доступ к некоторым возможностям, которые широко эксплуатируются в некоторых других языках, таких как ruby. Прежде чем вдаваться в технические детали, нужно немного разобраться с тем, какую роль играют статические свойства и методы в классах.

Данные в статических свойствах относится к классу в целом. Они "описывают" его. Самый рапространенный пример из веба это связь сущности с таблицей в базе данных, где она хранится:
*/

class User
{
	 // Очень важно делать их неизменяемыми!
	 // protected чтобы было доступно из родителя
	 protected static $table = 'users';
}

/*
Почему эту информацию нужно хранить в статическом свойстве? Потому что она не принадлежит конкретному объекту. Представьте что вы просто хотите узнать из кода, в какую таблицу будут сохранятся пользователи. Если бы эта информация не была статической, то пришлось бы создавать объект только ради того, чтобы узнать ответ на наш вопрос. Это бесмысленно.

Для сохранения сущности в базу данных, обычно, используются ORM (Object-Relationship Mapping), это библиотеки которые, в том числе, знают как сохранять сущности в базу и как извлечь их. Большинство из них построено на наследовании. Любая сущность должна наследоваться от специального базового класса, который содержит в себе общую логику для работы с базой данных:
*/

class User extends BaseEntity
{
	 // Код
}

$user = new User();
// Сохранение в базу
$user->save();

// Для сохранения пользователя в базу, недостаточно знать что сохранять, нужно знать и куда сохранять. И эта информация записана в статическое свойство.

class User extends BaseEntity
{
	 protected static $table = 'users';
}

// Возникает вопрос, можно ли добраться до нее из базового класса BaseEntity ? Гипотетический код:

class BaseEntity
{
	 
	 public static function getTable()
	 {
		  return self::$table;
	 }
	 
	 public function save()
	 {
		  // Валидация данных
		  
		  // Подготовка запроса
		  // сработает ли этот код?
		  self::getTable();
	 }
}

User::getTable(); // Error

/*
Проблема в том что такой код не сработает. self сошлется на BaseEntity и вызов save() завершиться с ошибкой, так как в этом классе нет статического свойства $table. Из этой ситуации есть два выхода. Первый, отказаться от статического свойства. Это не правильно с точки зрения семантики, но хотя бы будет работать. Второй, добавить в язык позднее связывание и для статики.

Позднее статическое связывание было добавлено в PHP с версии 5.3.0. Но как это часто бывает, разработчикам языка пришлось найти компромисс. Просто так поменять self было нельзя, слишком много кода могло сломаться, поэтому они добавили новое ключевое слово static. Его поведение идентично self за исключением связывания.
*/

class BaseEntity
{
	 public static function getTable()
	 {
		  return static::$table;
	 }
	 
	 public function save()
	 {
		  // Какой-то код
		  self::getTable();
		  // Дальнейшая обработка
	 }
}

// Теперь вызов self::getTable() вернет значение статического свойства $table определенного в том классе, с объектом которого идет работа прямо сейчас.

User::getTable(); // 'users'

/*
Обратите внимание на то, что сам вызов self::getTable() остался старым. В данном случае static не обязателен, так как сам метод определен в базовом классе. Но если бы мы хотели дать возможность переопределять его в подклассах, то было бы логично поменять вызов на static::getTable().

# Дополнительные материалы
Позднее связывание (Wiki) https://en.wikipedia.org/wiki/Late_binding
*/


/**@@@
 * В DOM библиотеке, каждый класс наследник HTMLElement имеет определенный набор атрибутов, которые относятся ко всему типу в целом. Например имя тега, парность и другое. Эта информация хорошо ложится на статические свойства, а использоваться они будут в суперклассе для построения текстового представления тега.
 *
 * src\HTMLDivElement.php
 * Создайте класс HTMLDivElement и добавьте в него статическое свойство params с правильными значениями. Пример класса HTMLBrElement:
 */

class HTMLBrElement extends HTMLElement
{
	 protected static $params = [
		 'name' => 'br',
		 'pair' => false
	 ];
}


/*
src\HTMLElement.php
Реализуйте метод __toString(), который возвращает текстовое представление тега. Для этого он использует данные из статического свойства $params определенного в подклассах. Атрибуты в этой практике не предусмотрены. Если у объекта есть тело $this->body, то оно должно устанавливаться в между открывающим и закрывающим тегом.
*/

$element = new HTMLBrElement();
echo $element; // => '<br>'

$element = new HTMLDivElement();
$element->setTextContent('hello!');
echo $element // => '<div>hello!</div>'


// FILE: /app/HTMLBrElement.php:
namespace App;

class HTMLBrElement extends HTMLElement
{
	 protected static $params = [
		 'name' => 'br',
		 'pair' => false
	 ];
}


// FILE: /app/src/HTMLDivElement.php
namespace App;

// BEGIN (write your solution here)
class HTMLDivElement extends HTMLElement
{
	 protected static $params = [
		 'name' => 'div',
		 'pair' => true
	 ];
}


// FILE /app/src/HTMLElement.php:
namespace App;

class HTMLElement
{
	 private $body;
	 
	 public function setTextContent($body)
	 {
		  $this->body = $body;
	 }
	 
	 public function __toString()
	 {
		  $params = static::$params;
		  $openTag = "<{$params['name']}>";
		  if (!$params['pair']) {
				return $openTag;
		  }
		  $closeTag = "</{$params['name']}>";
		  
		  return "{$openTag}{$this->body}{$closeTag}";
	 }
}


>>>>>>
Композиция вместо наследования <<<<<<

/*
Наследование – одна из самых противоречивых вещей в ООП. Чем больше мы узнаем о нем, тем больше подводных камней встречается. Мало того, что оно добавляет в код невероятное количество новых понятий и особенностей поведения, так оно еще имеет фундаментальные изъяны. И если с первым все более менее понятно. На протяжении всех предыдущих уроков мы только и занимались тем, что переосмысливали работу с классами. То со вторым нужно разобраться.

Ключевая проблема с иерархиями в том что наш мир не иерархичен. Любая классификация всегда опирается на конкретный признак, который интересует нас в конкретный момент времени. И эта же классификация становится бесполезной, если берется другой признак. Это хорошо видно в интернет-магазинах, у которых навороченные фильтры для выбора товара: группировка по производителю, по применимости, по безопасности для детей и так далее. В каждой конкретной ситуации будет своя структура.

Возьмем понятие User. Статьи по наследованию часто любят показывать иерархии пользователей вызывая у разработчиков уверенность что мир так и устроен. Давайте попробуем прикинуть, по каким признакам можно построить иерархию пользователей:

По полу (MaleUser, FemaleUser)
На основе аутентиикации (User, Guest)
По роли (Admin, Member)
По типу должности (Marketer, SalesManager, Programmer, Tester, Player)
По принадлежности к какой-либо группе (UserFromRussia, UserWhoLikesSpartak)
По источнику (UserFromFacebook, UserFromGithub)
...
Все это может и будет встречаться в рамках даже одной программы. В зависимости от того, какую задачу мы решаем, может понадобитсья разное представление. Наследование не дает такой свободы, наоборот, оно гвоздями приколачивает нас к конкретной структуре, которую уже не поменять. Единственным выходом в рамках этой парадигмы становится еще большее число наследований. В итоге у нас будет комбинация всех возможных поведений, которые встречатся в программе, а это иерархии с десятками и сотнями классов. Не забудьте что все это какими-то образом должно согласовываться с интерфейсами, которые тоже могут расширять друг друга.

Выходом могло бы быть множественное наследование, но как показала жизнь некоторых языков (c++), множественное наследование делает все еще сложнее. Поэтому от него отказались все кто только могли.

В конечном итоге, у разработчиков сформировалась общая позиция по отношению к наследованию, которая звучит так: Композиция вместо наследования. Если попробовать загуглить эту фразу, то поисковик покажет невероятное количество статей по этой теме. Как ни странно, этот подход мы уже изучали в курсе PHP полиморфизм. Он сводится к более грамотному разделению зон ответственностей в приложении, делегированию функциональности другим объектам, нужным в конкретных ситуациях.

С этого момента начинаются сложности. В большинстве статей посвященных этому вопросу, приводятся либо ошибочные, либо слишком искусственные примеры, которые не дают особого понимания. Для начала отделим две разные причины использования наследования. Одна из них связана с прямым назначением, другая вытекает из неверного понимания принципов организации кода.

# Использование не по назначению

Необходимость наследования классов возникает там, где классы связаны общим кодом (это не отношение подтипов). В такой ситуации нужна какая-то альтернатива наследованию. И здесь появляются варианты.

В самом простом случае, общий код не публичный. Тогда хватит обычной функции, которую эти классы будут использовать внутри себя. А если общий код был публичным? Большинство руководств рекомендуют создать соответствующий интерфейс и реализовать его в каждом из классов. Основной недостаток такого подхода – дублирование кода в каждом классе. То есть мы пришли к тому, от чего пытались уйти.

Решение этой проблемы известно довольно давно и называется миксины. Миксины – настоящая альтернатива правильному использованию наследования. С ними пропадает любая необходимость использовать наследование включая абстрактные классы. В PHP концепция миксинов нашла отражение в виде конструкции Trait. Трейтам посвящен следующий урок.
*/


/**@@@
 * В программировании часто встречается задача очистки текста от мусора или потенциально опасных частей, например HTML тегов. В PHP для такой очистки подходят функции trim (отрезает концевые пробелы), strip_tags (удаляет теги) и другие.
 *
 * Представьте себе объекто-ориентированный интерфейс для очистки текста:
 */
$sanitizer = new Sanitizer();
$sanitizer->sanitize('text   '); // 'text'
$sanitizer->sanitize(' boom '); // 'boom'

/*
Это санитайзер очень простой, единственное что он умеет – удалять концевые пробелы. Представьте что появилась задача добавить в этот процесс очистку текста от тегов. Эту задачу можно решить несколькими путями:

Через прямое изменение класса сантизайзера. Такой способ иногда может сработать, но он не сработает если это чужая библиотека или она используется где-то, где нужно удалять только концевые пробелы.
Через наследование. Тут все понятно, создаем класс наследник в котором переопределяем метод sanitize. В этом методе делаем strip_tags($text) и передаем результат дальше в родительскую функцию. Результат возвращаем наружу.
Через композицию.
В этом задании нужно реализовать последний вариант. Он сводится к использованию полиморфизма через объект-обертку. Такой подход называется "шаблон проектирования декоратор".
*/

$baseSanitizer = new Sanitizer();
$sanitizer = new SanitizerStripTagsDecorator($baseSanitizer);
$sanitizer->sanitize('text   '); // 'text'
$sanitizer->sanitize(' boom '); // 'boom'

/*
src\Sanitizer.php
Создайте класс Sanitizer и реализуйте интерфейс SanitizerInteface. Метод sanitize($text) должен отрезать концевые пробелы и возвращать результат наружу.

src\SanitizerStripTagsDecorator.php
Создайте класс (декоратор) SanitizerStripTagsDecorator, который также реализует интерфейс SanitizerInteface. Он принимает в конструктор исходный санитайзер и дополнительно к его логике, выполняет очистку текста от тегов. Очистка текста от тегов должна идти раньше чем отрезание концевых пробелов.
*/

// FILE /app/src/Application.php:
namespace App;

class Application
{
	 private $sanitizer;
	 
	 public function __construct($santizer)
	 {
		  $this->sanitizer = $santizer;
	 }
	 
	 public function run($text)
	 {
		  return $this->sanitizer->sanitize($text);
	 }
}


// FILE: /app/src/SanitizerStripTagsDecorator.php:
namespace App;

class SanitizerStripTagsDecorator implements SanitizerInterface
{
	 private $sanitizer;
	 
	 public function __construct($sanitizer)
	 {
		  $this->sanitizer = $sanitizer;
	 }
	 
	 public function sanitize(string $text)
	 {
		  $strippedText = strip_tags($text);
		  return $this->sanitizer->sanitize($strippedText);
	 }
}





// FILE /app/src/Sanitizer.php:
namespace App;

class Sanitizer implements SanitizerInterface
{
	 public function sanitize(string $text)
	 {
		  return trim($text);
	 }
}


>>>>>>
Трейты <<<<<<

/*
Трейты, альтренативный механизм переиспользования общего кода в разных классах. Он устраняет ограничения, которыми обладает наследование и заменяет его.

Трейты похожи на абстрактные классы. Они реализуют какую-то общую функциональность и с ними нельзя работать напрямую. Единственный способ использовать их – включение в другие классы.
*/
// Magic.php

trait Magic
{
	 // Доступно только внутри трейта
	 private $properties;
	 
	 public function __get($key)
	 {
		  return $this->properties[$key] ?? null;
	 }
	 
	 public function __set($key, $value)
	 {
		  $this->properties[$key] = $value;
	 }
}


/*
Трейт, по большей части, выглядит как (абстрактный) класс и устроен как класс. Он подчиняется тем же правилам именования и расположения в иерархии неймспейсов (а следовательно и файловой структуре) что и классы. Отличия начинаются в момент использования:
*/

// Config.php

class Config
{
	 // Включение трейта в класс
	 use Magic;
}

$config = new Config();
$config->key = 'value';
echo $config->key;

/*
Трейт включается в другой класс с помощью инструкции use. С этого момента, в классе становится доступна вся функциональность определенная в трейте. По поведению трейты похожи на наследование, например приватные части трейта доступны только внутри методов самого трейта. Но, при этом, трейт не встраивается в цепочку наследования, это легко проверить:
*/
$config instanceof Magic; // false

/*
Из этого есть пара важных следствий:

Внутри класса, к методам трейта нельзя обратиться через parent, только через $this. При условии что эти методы не приватные.
Трейт не может реализовывать интерфейс. Это могут делать только классы, в том числе с помощью трейтов.

# Зачем?
Трейты в отличие от наследования, не фиксируют структуру классов. Любой класс может включать в себя любое количество трейтов:
*/

class MySuperClass
{
	 use FirstTrait;
	 
	 // При включении возможны конфликты имен. Подробнее про их разрешение:
	 // https://www.php.net/manual/ru/language.oop5.traits.php#language.oop5.traits.conflict
	 use SecondTrait;
}

/*
Эта структура располагает к выделению общих признаков из совершенно разнообразных классов. Пример с Magic, как раз хорошо демонстрирует такой подход. Многие классы одинаково работают с магическими методами и нет, смысла дублировать их код. И точно не стоит использовать наследование, так как оно свяжет совершенно несвязанные классы в общую (и жёсткую) иерархию.

Трейты позволяют реализовать многие интерфейсы PHP универсальным образом, например, ArrayAccess или Iterator

Пример: Итератор
Рассмотрим готовый пример трейта итератора. Ниже код самого трейта. Он реализует общую логику итерации по коллекции.
*/

trait IteratorTrait
{
	 protected $offset = 0;
	 
	 public function current()
	 {
		  return $this->getCollection()[$this->offset] ?? null;
	 }
	 
	 public function next()
	 {
		  $this->offset++;
	 }
	 
	 public function key()
	 {
		  return $this->offset;
	 }
	 
	 public function valid()
	 {
		  return \array_key_exists($this->offset, $this->getCollection());
	 }
	 
	 public function rewind()
	 {
		  $this->offset = 0;
	 }
	 
	 abstract public function getCollection();
}


/*
Обратите внимание на важную деталь, то каким образом трейт получает саму коллекцию. Трейт требует от класса, который его включает реализации метода getCollection() (помните что трейт похож на абстрактный класс, он может определять абстрактные методы). Этот метод используется внутри трейта для доступа к элементам коллекции по которой он итерирует.

Это очень важная концепция. Трейту нужны данные от класса, в который его включают. И трейт строит связь с этими классами через интерфейсный метод, а не через обращение к свойству с конкретным именем. А вот класс от трейта ничего не требует. Благодаря тому что связь строится в одну сторону (трейт зависит от метода класса, но класс не зависит от методов и свойств трейта), код остается модульным. Если бы и трейт требовал что-то от класса и класс от трейта, то почти наверняка в коде проблемы с архитектурой.
*/

// Обязательно расширять интерфейс Iterator, только тогда PHP поймет что это итератор
class Course implements Iterator
{
	 // для простоты свойство наполнено строками
	 private $lessons = ['one', 'two', 'three'];
	 use Enumerable;
}

// Использование

$course = new Course();
foreach ($course as $lesson) {
	 echo $lesson . "\n";
}
// 'one'
// 'two'
// 'three'

/**@@@
 * Один из самых красивых примеров использования трейтов – Enumerable. Он крайне популярен в языках с поддержкой миксинов (а трейты это разновидность миксинов).
 */
public function maxBy(callable $fn);
public function sortBy(callable $fn);
public function select(callable $fn);
public function map(callable $fn);
// и еще несколько десятков полезных методов

// Трейт требует от класса реализации функции getIterator.
// Это все что ему нужно для реализации своих методов.
abstract public function getIterator(): iterable;

/*
Представьте себе любой класс, который описывает собой коллекцию элементов. Как правило этой коллекции требуются разнообразные методы для работы, например сортировка или фильтрация. До трейтов, эта задача превращалась в бесконечную копипасту кода. Трейты же, позволяют выделить всю необходимую логику в одно место.
*/

$lessons = [
	 // Второй параметр это продолжительность урока в минутах
	new Lesson('react start', 3),
	new Lesson('react component', 9),
	new Lesson('react lifecycle', 2),
	new Lesson('redux', 4),
];

// use Enumerable;
$course = new Course($lessons);
$lesson = $course->maxBy(function ($l1, $l2) {
	 return $l1->getDuration() <=> $l2->getDuration();
});

print_r($lesson); // ('react component', 9)


/*
src/Course.php
Подключите трейт Enumerable

src/Enumerable.php
Реализуйте трейт, добавьте в него метод maxBy, работающий по примеру выше. Этот метод принимает на вход анонимную функцию, которая выполняет сравнение двух элементов коллекции по нужному признаку. Результатом этой функции будет элемент соответствующий критерию максимальности. Принцип работы такой же как и у usort
*/

// FILE: /app/src/Enumerable.php:
namespace App;

trait Enumerable
{
	 abstract public function getIterator(): iterable;
	 
	 public function maxBy(callable $fn)
	 {
		  $items = $this->getIterator();
		  if (!count($items)) {
				return null;
		  }
		  $result = array_reduce($items, function ($acc, $item) use ($fn) {
				$value = $fn($acc, $item);
				return $value >= 0 ? $acc : $item;
		  }, $items[0]);
		  return $result;
	 }
}


// FILE: /app/src/Course.php:
namespace App;

class Course
{
	 use Enumerable;
	 
	 private $lessons;
	 
	 public function __construct($lessons)
	 {
		  $this->lessons = $lessons;
	 }
	 
	 public function getIterator(): iterable
	 {
		  // Для простоты возвращает массив, вместо итератора
		  return $this->lessons;
	 }
}

// FILE /app/src/Lesson.php:
namespace App;

class Lesson
{
	 private $name;
	 private $duration;
	 
	 public function __construct($name, $duration)
	 {
		  $this->name = $name;
		  $this->duration = $duration;
	 }
	 
	 public function getName()
	 {
		  return $this->name;
	 }
	 
	 public function getDuration()
	 {
		  return $this->duration;
	 }
}
