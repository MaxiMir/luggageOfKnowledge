# INTERVIEW

+ [Замыкания (closures)](#closures)
+ [Отличие cookie, sessionStorage, localStorage](#cookie)
+ [TCP/IP, HTTP, HTTPS](#http)
+ [CORS / Cross-origin resource sharing](#cors)
+ [После ввода адреса в браузере](#browser)

После ввода адреса в браузере

### <a name="closures"></a> Замыкания (closures)

**Замыкание** – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.

В JS, все функции изначально являются замыканиями (исключение `new Function` в её `[[Environment]]` записывается ссылка не на внешний LexicalEnvironment, в котором она была создана, а на глобальный)

_LexicalEnvironment_ - внутренний (скрытый) объект у выполняемых функций | блока кода | скрипта. 

Состоит из 2 частей: 

_Environment Record_ - объект, в котором хранятся локальные переменные.

_[[Environment]]_ – ссылка на внешнее | глобальное окружение

### <a name="cookie"></a> Отличие cookie, sessionStorage, localStorage

**Cookies**:

* Имеют срок действия;
* Отравляются с каждым запросом;
* Max 4KB данных.
* Могут устанавливаться сервером через заголовок Set-Cookie (httpOnly запрет на манипулирование через JS).

**localStorage**:

* Без срока действия;
* Не отправляется на сервер;
* 5MB+ данных (в некоторых браузерах и больше).

**sessionStorage**:

* Данные сохраняются только на протяжении текущей сессии вкладки или окна браузера.
* Не отправляется на сервер;
* 5MB+ данных (в некоторых браузерах и больше).

### <a name="http"></a> TCP/IP, HTTP, HTTPS

* IP - протокол для доставки по адресу сетевых пакетов;
* TCP - протокол для установления надежного соединения и передачи данных;

### HTTP - HyperText Transfer Protocol

протокол передачи данных через TCP/IP-соединения

HTTP/2 кодирует запросы / ответы и разделяет их на более мелкие пакеты информации, что значительно повышает гибкость
передачи данных.

### HTTPS - HyperText Transfer Protocol Secur

HTTP + упаковка передаваемых данных в криптографический протокол SSL или TLS. Для HTTPS-соединений обычно используется
TCP-порт 443.

###	Отличие HTTP от HTTPS:

* HTTP не шифрует данные между клиентом и сервером, что означает, что эти данные можно перехватить и прочитать.
* HTTP использует порт 80, HTTPS использует порт 443.
* Для работы HTTPS требуется SSL-сертификат, который подтверждает идентичность веб-сайта;


### <a name="cors"></a> CORS / Cross-origin resource sharing

технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена.

Access-Control-Allow-Origin: * || https://developer.mozilla.org

### <a name="browser"></a> После ввода адреса в браузере

> Поиск IP адреса сайта:
Запрашивает IP в DNS(Domain Name System), если не нашел в:

* истории подключений браузера
* в операционной системе
* в кэше роутера

> Установка TCP соединения через систему "трёх рукопожатий":

* Браузер отправляет специальный запрос на установку соединения с сервером (SYN-пакет)
* Сервер в ответ отправляет запрос с подтверждением получения SYN-пакета — (SYN/ACK-пакет).
* В конце устройство пользователя при получении SYN/ACK-пакета отправляет пакет с подтверждением(ACK-пакет).

> Сервер обрабатывает запрос:

* Веб-сервер(nginx или Apache, ...) перенаправляет запрос к программе обработчику (PHP, Ruby, ...), она изучает
  содержимое запроса и собирает ответ

> Сервер отправляет ответ браузеру

* В ответе как правило контент для отображения страницы, способах кэширования, файлы cookie, и тд

> Браузер обрабатывает полученный ответ и «рисует» веб-страницу:

* Браузер распаковывает полученный ответ и постепенно начинает рендерить страницу;
* Последовательно проверяет все теги;
* Отправляет GET запросы для получения картинок, файлов, скриптов и таблицы стилей;

### TYPES

* boolean
* integer
* BigInt
* string
* null
* undefined
* object
* Symbol

### LIFECYCLE HOOKS REACT (OLD SCHOOL)

* componentWillMount - перед рендерингом, в основном для настройки компонента;
* render - процесс рендеринга;
* componentDidMount - уведомляет, про то, что компонент соединен с DOM деревом;
* componentWillReceiveProps - уведомляет, про то, что приходят новые входящие свойства в компонент;
* shouldComponentUpdate - решает, нужно ли делать ре-рендеринг;
* componentWillUpdate - уведомляет, что компонент будет обновлен;
* componentDidUpdate - уведомляет, что компонент был обновлен;
* componentWillUnmount - используется для удаления слушателей и очистки компонента;
* Вызывается перед удалением компонента.

### TESTS

> Подходы:

* TDD - Test Driven Development написание тестов, а потом на основании написанных тестов - создание логики;
* BDD - Behavior Driven Development TDD + описание тестировщиком или бизнес аналитоком пользовательских сценариев;

> Типы:

* End-to-End (E2E) - проверяется работа всего приложения или фактически описанные раннее бизнес кейсы;
* Integration Testing - проверка взаимодействия созданного модуля с другими;
* Unit Testing - проверка логики инкапсулированного модуля (или юнита);


## Redux
Контейнер предсказуемых состояний для JavaScript.

Основные понятия Redux — **Store** (Хранилище), **Actions** (действия), *Reducers* (обработчик действий) и **Subscription** (слушатель изменений хранилища).

## Структуры данных
> **Стек** - СД типа список LIFO, добавление и извлечение из начала. В JS используется для хранения статических данных, т.е. тех, чей размер известен во время компиляции (примитивы + ссылки на объекты и функции).

> **Списки** - СД, в которой каждый элемент связывается со следующим с помощью указателя. В JS использующаяся для динамического выделения памяти (объекты и функции).

> **Хэш-таблица** - СД, которая позволяет хранить пары ключ-значение и позволяющая выполнять 3 операции: добавление новой пары, поиск значения по ключу и удаление пары по ключу.
В JS: Object. Хеширование | Коллизии

> **Очередь** - СД типа список FIFO, добавление в конец, извлечение из начала.

> **Граф** - СД, которая состоит из набора узлов, которые имеют данные и связаны с другими узлами

> **Деревья** - СД, каждый элемент которой содержит информацию и ссылки на несколько (не менее двух) других таких же элементов.

## Алгоритмы работы со структурами данных
**Сложность алгоритма** - как будет расти расход ресурсов с увеличением размера входных данных.

**Big O** - функция, которая описывает рост сложности алгоритма

**O(1)** константная — 1 (одна) операция;

**O(log n)** логарифмическая (например, бинарный поиск) — ~13 (чуть более тринадцати) операций;

**О(n)** линейная — 10 000 (десять тысяч) операций;

**О(n^2)** квадратичная — 100 000 000 (сто миллионов) операций;

**O(n^3)** кубическая (если бы у нас был тройной вложенный цикл) — 1 000 000 000 000 (один триллион) операций;

**O(n!)** факториал от числа n (поиск всех перестановок, пример — наивное решение очень популярной

## Архитектура:

Все приложения состоят из 2-х частей: клиентской front-end и серверной back-end
> **Одностраничные** веб-приложения (без перезагрузки страницы | не индексируются)

> **Многостраничные** веб-приложения (с перезагрузкой страниц | индексируются)

> **Монолит** - БД + front + back, хранящиеся в одной одной кодовой базе

> **Микросервисы** - набор отдельных компонент, изменение каждого из короторых происходит без ущерба для других.

> **Микрофронтенд** - инциализация одного или нескольких приложений в другом.

> **Бессерверная архитектура** - использование облачных серверов (Amazon, Microsoft)

> **PWA** - веб-приложения, которые работают как собственные приложения (push-уведомления, установить приложение на главный экран)

## Веб-сокеты

Протокол для обмена сообщениями между браузером и веб-сервером в режиме реального времени.
Позволяет уйти от проблемы односторонней передачи данных.

## SOLID
Абревиатура подходов в ООП. Надо понимать что мы сейчас пишем приложения не на классах, а на функциях.

> **Single Responsibility Principle** - это про декомпозицию и связность

> **Open-closed Principle** - Думайте наперед о том, что будете делать, если появятся другие сущности

> **Liskov Substitution Principle** - Если ваш метод ожидает на вход тип к-л интерфейс, то ему должно быть все равно, какого наследника от него Вы ему подсунете

> **Interface Segregation Principle** - Если ваш интерфейс вынуждает вас создавать методы заглушки, то это плохой интерфейс и по нему стоит пройтись ножницами

> **Dependency inversion principle** - Больше абстракций богу абстракций

## REST
Representational State Transfer

Архитектурный стиль взаимодействия компонентов распределенной системы в компьютерной сети.

Компоненту, которая отправляет запрос называют клиентом.

Компоненту, которая обрабатывает запрос и отправляет клиенту ответ, называют сервером.

Запросы и ответы, чаще всего, отправляются по протоколу HTTP.

Сервер не должен хранить какой-либо информации о клиентах + каждый ответ должен быть отмечен является ли он кэшируемым или нет.

С точки зрения **RESTful-сервиса**, операция идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате на сервере.

Преимущества:
> **производительность** (за счёт использования кэша);

> **масштабируемость**;

> **прозрачность** системы взаимодействия;

## Webpack:
Сборщик модулей
* помогает собрать воедино ваши ресурсы
* следит за изменениями и повторно выполняет задачи
* может выполнить транспиляцию JavaScript следующего поколения до более старого стандарта JavaScript (ES5) с помощью Babel
* позволяет использовать require() для CSS файлов
* Tree Shaking
