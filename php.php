<?/*

############## PHP Basics ##############

Код-гайд:
https://www.php-fig.org/psr/psr-1/
http://www.php-fig.org/psr/psr-2/

Проверка кода:
https://github.com/squizlabs/PHP_CodeSniffer

Тестовые задания:
https://github.com/Hexlet/ru-test-assignments

Гайды:
https://guides.hexlet.io

Книги:
https://ru.hexlet.io/pages/recommended-books
+ Роберт Мартин идеальный программист
+ Адитьи Бхаргавы “Грокаем алгоритмы” -> ревпозиторий https://github.com/egonSchiele/grokking_algorithms
+ Томас Кормен “Алгоритмы. Вводный курс”
+ Эви Немет Unix и Linux. Руководство системного администратора  - использовать, как справочник, время от времени углубляясь в необходимые темы по мере возникновения вопросов.
+ Структура и интерпритация компьютерных программ
+ Книга Продуманная оптимизация http://optimization.guide
*/  


>>>>> Введение <<<<<<<

/*
PHP — динамический, слабо-типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.

# Интерпретируемый
У PHP отсутствует стадия компиляции, как у языков подобных Java или C. Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на PHP состоит из текстовых файлов.

Откровенно говоря, это не совсем так. У PHP все же есть стадия компиляции, но она скрыта от глаз пользователя и внешне PHP ведет себя именно как интерпретируемый язык программирования. 

# Динамический
В отличие от статических языков, проверка типов в PHP происходит в момент выполнения кода. Поэтому если, мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статические анализаторы кода (слово статический как раз означает что программа не выполняется). Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок. 

# Слабо типизированный
Слабая типизация означает то, что PHP автоматически приводит типы там, где считает нужным (описано в спецификации). С одной стороны, слабая типизация позволяет писать более короткий код, но с другой, количество ошибок резко возрастает, так как вместо падения, код продолжает работать там, где он не должен работать. Например, мы можем сложить число со строкой по ошибке и PHP молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Нужно стараться никогда не полагаться на эту особенность языка во избежания проблем.
*/


// Comment - однострочный комментарий

/*
 * Multi
 * Line
 * Comment
*/

### Statements (перев. инструкции)

/* namespace App; */

; // пустая инструкция

return 3; // выражение - вычисляется, инструкция выполняется
return 5 + 5; // выражение
$name = 'Max'; // инструкция с выражением



>>>>>  Арифметические операции <<<<<<<

// Operator, Operand

7 * 9; // infix - Инфиксный оператор
-1; // prefix - Префиксный оператор
$i++; // postfix - Постфиксный оператор

-1; // unary - Унарная операция - операция с 1 операндом
3 ** 4; // binary - Бинарная операция - операция с 2-мя операндами

sqrt(4); // => 2
sin(deg2rad(90)); // => 1
cos(pi()); // => -1



>>>>>  Функции <<<<<<<

function hypotenuse($cathetus1, $cathetus2) // $cathetus1, $cathetus2 - формальные параметры
{
    return sqrt($cathetus1 ** 2 + $cathetus2 ** 2);
}

echo hypotenuse(3, 4); // 3, 4 - фактические параметры => 25



>>>>>  Включение файлов <<<<<<<

namespace 'Theory';

echo include 'Example.php'; // При ошибке -> Warning => 1

require 'Example.php'; // При ошибке -> Fatal error
require_once 'Example.php'; // Предпочтительный способ, чтобы избежать ошибок при повторном подключении файла

set_include_path('/tmp'); // меняем директорию (*). PHP просмотривает всегда текущую директорию
echo get_include_path(); // возвращает список директорий.  
echo include 'Anather.php'; // без * будет ошибка, поскольку подкл. файл лежит в '/tmp' => Hello World


// Файл: theory/Example.php

return 1;

// Файл: tmp/Anather.php

return 'Hello World';




>>>>>  Пространство имен <<<<<<<

/*
 * Проблематика
 * Отстутсвие пространств имен подобно отсутствию директорий в файловой системе
 * - Все глобальные идентификаторы должны быть уникальны: константы, функции, классы...
 * - В свою очередь это ведет к подобным именам: PHPUnit_Framework_TestCase

 * Решение
 * Пространства имен предоставляют возможность для группировки определений php 
*/

namespace App\Template;

/*
 * Особенности
 * Могут быть вложенными
 * Не связаны с файловой структурой
 * В одном файле может быть несколько определений пространств
 * Определения находящихся в одном и том же пространстве имеют прямо доступ друг к другу
*/ 


/* 
Директории:
 * theory/
 *   Another.php
 *   Example.php
 *   main.php 
*/

// Файл main.php

namespace Theory; 

require_once 'Example.php';
require_once 'Another.php';

echo \Theory\Example\iam(); // с полным путем (абсолютный путь - а значит не смотрим относительно текущего namespace) 
echo \Another\iam();

echo Example\iam(); // относительно текущего namespace Theory


// Ниже задаются абсолютные пути, но без ведущего '/'
use function Theory\Example\iam; // импортирование функции. бэкслеш вначале можно ставить, а можно нет (*)
use function Theory\Example\iam as eiam; // задаем альтернативное имя функции
use function Another\iam as aiam; // без задания альтернативного имени -> конфликт имен с (*)
// => после этого можно обращаться к функции как-будто она была уже определена здесь:
echo iam();
echo eiam();
echo aiam();

// Файл Another.php

namespace Another;

function iam()
{
    return "another\n";
}

// Файл Example.php

namespace Theory\Example; // вложенный namespace

function iam()
{
    return "example\n";
}


// Настоятельно не рекомендуется при программировании комбинировать несколько пространств имен в один файл.  Основным применением этому может быть объединение нескольких PHP-файлов в один файл.

namespace MyProject {
    const CONNECT_OK = 1;
    class Connection { /* ... */ }
    function connect() { /* ... */  }
}

namespace { // глобальный код
    session_start();
    $a = MyProject\connect();
    echo MyProject\Connection::start();
}

/*
PHP-код не может находиться вне скобок конструкции пространства имен, кроме начального выражения declare.
Значение константы __NAMESPACE__ - это строка, которая содержит имя текущего пространства имен. В глобальном пространстве, вне пространства имен, она содержит пустую строку.
*/

// Неймспейс задается с помощью ключевого слова namespace, за которым следует имя неймспейса. По стандарту, один файл должен соответствовать одному неймспейсу. В случае когда внутри неймспейса определяются только функции (а не классы) имя неймспейса должно соответстовать имени файла с учетом регистра, то есть для нашего примера имя файла math.php, следовательно имя неймспейса math. Теперь посмотрим на то, как использовать функции определенные в неймспейсе:

// file: math.php:

namespace math;

function sum($a, $b)
{
    return $a + $b;
}

// file: index.php:

require_once('math.php');

\math\sum(5, 8); // 13


/*

Файловая структура практически любого проекта на PHP выглядит так:

src/
    Formatters/
        Pretty.php
        Generator.php

tests/
composer.json
composer.lock
.git
README.md
*/

// file: Pretty.php:

namespace Formatters\Pretty;

function render($data)
{
    // some code
}

// file: Generator.php

namespace Generator;

function generate($data)
{
    return \Formatters\Pretty\render($data);
}

// Каждый проект или пакет принято помещать в одно общее пространство и не загрязнять глобальное пространство множеством неймспейсов. Это название выбирается на основе названия самого проекта, той директории внутри которой лежит src. В нашей структуре директорий это my-site. Это значит, что общим пространством для всех файлов внутри src будет MySite:

// file: src/Formatters/Pretty.php

namespace MySite\Formatters\Pretty;

// some code


// C помошью механизма импорта функцию можно импортировать в текущий неймспейс так, как будто она определена прямо здесь:

namespace Generator;

use function Formatters\Pretty\render;

function generate($data)
{
    return render($data);
}


// Изредка случаются ситуации, когда хочется импортировать функцию, но в текущем пространстве либо уже определена функция с таким именем, либо функция с таким именем была импортирована ранее из другого неймспейса. Сделать это можно через алиасы (псевдонимы), механизм позволяющий переименовывать импортируемые функции: 

namespace Generator;

use function Formatters\Pretty\render;
use function Formatters\Simple\render as simpleRender;

function generate($data)
{
    return simpleRender($data);
}


>>>>>  Константы <<<<<<<

namespace Theory;

define('VERSION', 'version-1.5'); // global definition (глобальное определение) - игнорирует namespace, поэтому желательно использовать const
const FOO = 7 ** 10;

echo VERSION;
echo FOO;
echo \Theory\FOO;

defined('\Theory\FOO'); // проверяет определена ли данная константа true
// но!
defined('\Theory\VERSION'); // false

defined('\Theory\HI'); // false

// Предопределенные константы, примеры:
PHP_VERSION; // версия
PHP_OS; // ОС
PHP_BINDIR; // местонахождение исполняемого файла у PHP

// Magic constants:
__LINE__; // текущая строчка
__FILE__; // текущий файл
__DIR__; // текущая директория

// __FUNCTION__, __CLASS__, __TRAIT__, __METHOD__, __NAMESPACE__

constant('FOO'); //  возвратит значение константы, указанной параметром name. Используется, если вам необходимо запросить значение константы, но вам не известно её имя, если, например, она хранится в переменной или возвращается функцией.




>>>>>  Boolean <<<<<<<

/*
 ! - Отрицание
 && - И (Конънкция)
 || - Или (Дизъюнкция)
 == Совпадение
 != Не совпадение
 xor - исключающее или

 * Правила логики:
 true != false
 true == !false
 true && true == true
 true && false == false
 false && false == false
 true || true == true
 true || false == true
 false || false == false

 * Ассоциативность:
 (a && b) && c = a && (b && c)
 (a || b) || c = a || (b || c)
 (a XOR b) XOR c = a XOR (b XOR c)

 * Коммутативность:
 a && b = b && a
 a || b = b || a
 a XOR b = b XOR a

 * Дистрибутивность:
 a && (b || c) = (a && b) || (a && c)
 a || (b && c) = (a || b) && (a || c)

 * Двойное отрицание:
!!a = a

 * Законы Де Моргана:
 !(a && b) = (!a) && (!b)
 !(a || b || c) = (!a) || (!b) || (!c)

 Закон импликации:
 a->b = !b -> !a

 * and, or - ! имеют пониженный приоритет лучше не использовать

*/ 


function isOdd($num) // проверка на нечетность
{
    return $num % 2 != 0;
}



>>>>>  Условие if <<<<<<<

function lucky($num)
{
    if ($num == rand(1,3)) { //  генерирует случайное число
        return 'You are lucky!';
    } elseif ($num < 1 || $num > 3) {
        return 'Unexpected number';
    } else {
        return 'Sorry, you are not lucky!';
    }
}

function mod($num)
{
    return $mod >= 0 ? $num : -$num; // тернарный оператор
}


/*
Реализуйте функцию result, которая принимает на вход результат хоккейного матча и исход, который предполагался. Если счет был угадан верно, то функция должна вернуть 2, если исход был угадан верно (победа первой команды, ничья, поражение первой команды), то функция должна вернуть 1, во всех остальных случаях функция возвращает 0.
*/

function result($a, $b, $c, $d)
{
     if ($a == $c && $b == $d) {
          return 2;
     } elseif ($a > $b && $c > $d || $a < $b && $c < $d || $a == $b && $c == $d) {
          return 1;
     } else {
          return 0;
     }
}



>>>>>  Переменные <<<<<<<

function factorial($n)
{
    $result = 1;

    for ($i = 2; $i <= $n; $i++) {
        $result *= $i;
    }

    return $result;
}

function isPrime($n) // проверка на простое число
{
    for ($i = 2; $i = $n / 2; $i++) {
        if ($n % $i == 0) {
            return false;
        }
    }

    return true;
}

/*
Напишите функцию sumDouble, которая принимает на вход два числа: начало последовательности и конец последовательности, а возвращает сумму возведенных в квадрат чисел последовательности с шагом 2. То есть из последовательности от 3 до 7 будут взяты числа 3, 5, 7.
*/

function sumDouble($a, $b)
{
     $result = 0;

     for ($i = $start; $i <= $finish; $i += 2) {
          $result += $i ** 2;
     }

     return $result;
}




>>>>>  Именование в программировании  <<<<<<<

/*

Нотация:
* Верблюжья нотация (CamelCase): MyClass
* Змеиная нотация (snake_case): my_const
* Шашлычная нотация (kebab-case): my-data
* Венгерская нотация https://ru.wikipedia.org/wiki/Венгерская_нотация

# Сущность-Действие
Имя функции должно быть глаголом, переменной - существительным.

# Предикаты
Предикат это функция-проверка, она всегда возвращает либо true, либо false.

В большинстве языков предикаты предваряют префиксом is.
isEmpty();
isValid();
isBusy();

Но не все языки следуют этому правилу. В большинстве лиспов, а так же в ruby (который взял это из лиспов) используется знак ? в конце слова:
empty?
valid?
busy?

Если учесть что в указанных языках вызов функции не требует скобок в конце, то такая форма смотрится особенно естественной.

# Вхождение
Но не все предикаты можно выразить через is. Например, как задать вопрос если мы хотим узнать есть ли в списке чисел нечетное? В таких ситуациях принято использовать слово has:

node.hasChildren();

# Количество
Если вам нужна переменная, в которой содержится количество чего-либо, то используйте комбинацию: сущность во множественном числе + count.

symbolsCount
peopleCount

Это правило важнее даже в другом варианте, а именно, как не надо называть переменную обозначающую количество:
errors;

Такое именование гарантированно вводит в заблуждение. Сущность во множественном числе всегда должна обозначать только коллекцию.


Примеры

// Нормализация данных
normalizeDomainName('hexlet.io');

// Извлечение части данных
getName(user);
getDomainFromEmail('support@hexlet.io');

// Получение массива с ошибками
const errors = validate(user);
if (errors.length > 0) {
  // ...
}

// Подсчеты
calculateDiff(first, second)

// Допуск
canSwim(user)
canViewProfile(user)
*/



>>>>>  Variable Scope - Область видимости переменной <<<<<<<

// переменная доступна вне цикла for и if:

for ($i = 0; $i < 3; $i++) {
    echo $i . "\n";
}

if (true) {
    $val = 'cat'
}

echo $i; // => 2
echo $val; // => cat


# Чистая функция - зависит только от своих аргументов и не делает побочных эффектов.
# Детерминированная функция - функция, которая всегда производит тот же результат при одинаковых вводных даннных


// !!! Не использовать глобальные переменные в функции:

$increment = 1;

function increment($num)
{
    global $increment; // <-> $_GLOBALS['increment']
    return $num + $increment;
}



>>>>>  Строки <<<<<<<

$value = 'text';
echo "string \t with \n \\ escape sequence\n" . PHP_EOL; //  \\ - экранирование '\', PHP_EOL - константа конец  строки (в Unix системах - \n / в Windows \n\r)

echo "interpolation example: $value" . PHP_EOL; // интерполяция

function hereDoc($hello)
{
    return <<<EOD
        Example "of $hello string"
        spaning 'multiple lines
        using heredoc syntax.\n\n
EOD;

}

function nowDoc()
{
    return <<<'EOD'
        Example of string
        spaning 'multiple lines
        using nowdoc syntax. $hello.
EOD;
    
}   


$str = 'simple string';

echo $str[0]; // => s
echo $str[strlen($str) - 1]; // => g


// Реализуйте функцию reverse, которая переворачивает строку.

function reverse(String $str)
{
    $result = [];
     
    for($i = strlen($str) - 1; $i >= 0; $i--) {
        $result[] = $str[$i];
    }
             
    return implode('', $result);
}

// Для определения является ли слово палиндромом, достаточно сравнивать попарно символ с обоих концов слова. Если они все равны, то это палиндром. Решите задачу без использования реверса строки. Примеры использования:

isPalindrome('radar'); // true
isPalindrome('maam'); // true
isPalindrome('a');     // true
isPalindrome('abs');   // false

function isPalindrome(string $word)
{
    $charsCount = strlen($word) - 1;
    for ($i = 0; $i < ceil($charsCount / 2); $i++) {
        if ($word[$i] !== $word[$charsCount - $i]) {
            return false;
        }
    }
    return true;
}


// Реализуйте функцию reverse, которая переворачивает цифры в переданном числе:

use function Number\reverse;

reverse(13); // 31
reverse(-123); // -321

function reverse(int $num): int
{
    $reverse = (int) strrev((string) abs($num));
    return $num > 0 ? $reverse : -$reverse;
}



>>>>>  Массив <<<<<<<

[1, 2, 3, 5] + [8, 1, 2]; // [1, 2, 3, 5]
[] == []; // true
[1] != [2]; // true

sizeof($arr); // размер массива (кол-во элментов)
in_array('apple', $arr); // проверяет наличие элемента в массиве
empty($arr); // проверяет пустой ли массив
end($arr); // возвращает последний элемент
unset($arr[2]); // удаление элмента массива

function myMax(Array $arr)
{
    if (empty($arr)) {
        return;
    }

    $max = $arr[0];

    foreach ($arr as $val) {
        if ($max < $val) {
            $max = $val;
        }
    }

    return $max;
}


// Реализуйте функцию uniq, которая принимает, как аргумент, массив, и возвращает новый массив, в котором ни один элемент исходного массива не повторяется.

function uniq(Array $arr) {
    $res = [];
    foreach ($arr as $value) {
        if (!in_array($res, $value)) {
            $res[] = $val;
        }
    }

    return $res;
}



>>>>>  Ассоциативный массив <<<<<<<

array_key_exists('undefined', $map); // проверяет присутствует ли данный ключ в ассоц. массиве

$arr = [];
$arr[] = 'val1';
$arr['key'] = 'val2';
$arr[] = 'val3';
$arr['9'] = 'val4';
$arr[] = 'val5';

/* => 
[0] => val
[key] => val
[1] => val
[9] => val
[10] => val // !!! '9' - ключ был строкой
*/

// Реализуйте функцию wordsCount, которая считает количество одинаковых слов в предложении. Результатом функции является ассоциативный массив, в ключах которого слова из исходного текста, а значения это количество повторений.

function wordsCount(String $sentence)
{
    $words = explode(' ', $sentence);
    $countWords = [];

    foreach ($words as $word) {
        if (empty($word)) { continue; }
        array_key_exists($word, $countWords) ? $countWords[$word]++ : $countWords[$word] = 1;
    }

    return $countWords;
}



>>>>>  Аргументы <<<<<<<

round(10.61234, 2); // 10.61
round(1.55, 1); // 1.6
round(1.55, 1, PHP_ROUND_HALF_DOWN); // округление вниз 1.5 

// float, string, bool, int, array

function drop(Array $array, Int $count = 1) // возвращает обрезанный с начала массив на count элементов
{
    $result = [];
    for ($i = $count; $i < sizeof($array); $i++) {
        $result[$i] = $array[$i];
    }

    return $result;
}

function sumArgs()
{
    return array_sum(func_get_args()); // func_get_args() - возвращает массив переданных аргументов
}

function sumArgs1(...$numbers)
{
    return array_sum($numbers); // $numbers - массив переданных аргументов
}

function sumArgs2($arg, ...$numbers) // $arg - можно задавать обязательные параметры
{
    return array_sum($numbers); // $numbers - массив переданных аргументов
}

sumArgs2(10, 2, 4); // !!! => 6



// Реализуйте функцию multiArgs, которая возвращает произведение всех переданных аргументов. Вызванная без аргументов, должна вернуть null.

function multiArgs(...$numbers)
{
     return !empty($numbers) ? array_product($numbers) : null; // array_product - произведение элементов массива
}



>>>>>  Null <<<<<<<

$var = null; 
is_null($var); // true

$result = $var ?? 'nobody'; 
// <-> $result = isset($var) ? $var : 'noboby'


example(); // вызов пустой функции возвращает null

function example($var = null) // необязательный аргумент
{
    return; // <-> return null;
}


// Реализуйте функцию compact которая принимает на вход массив и возвращает новый, полученный удалением элементов со значением null. Ключи оставшихся элементов (тех которые не были null) должны сохраняться.

function compact(array $array)
{
     $newArray = [];
     foreach ($array as $key => $value) {
          if (!is_null($value)) {
            $newArray[$key] = $value;
          }
     }
     return $newArray;
}



>>>>>  Типы <<<<<<<

/*
Система типов - совокупность правил в языках программирования, назначающих свойства, именуемые типами, различным конструкциям, составляющих программу - таким как переменные, выражения, функции или модули

Основная роль системы типов заключается в уменьшении числа багов в программах посредством определения интерфейсов между различными частями программы и последующей проверки согласованности взаимодействия этих частей.

Виды типизации:
 * Статическая - указываем какого типа будут сущности языка. Например, если описываем переменную, то указываем, что переменная типа integer,записать туда можем число и работать можем только как с числом. Ошибки на стадии компиляции (преобр. в машинный код)

 * Динамическая - не надо указывать какого типа будут сущности языка. Тип будет вычисляться в момент операции над переменной. Ошибки на стадии runtime

 * Сильная (Строгая) - не преобразовывает автоматически типы данных (Python, Ruby)
 * Слабая (Не строгая) - автоматически преобразовывает типы данных (JS, PHP)
*/
 
[] + 1; // => Fatal Error
"" + []; // => Fatal Error

// Type Casting (приведение типов):
 
$foo = 100;
$bar = (bool) $foo;
 
/*
false:
 * 0;
 * '0';
 * 0.0;
 * '';
 * null;
 * [];
*/ 

// Comparison (сравнение):

0 !== false; // true
0 === '0'; // false;

// Functions:

gettype(true); // возвращает тип переданного аргумента - boolean
is_string('asfs'); // true
// is_numeric, is_int и т.д.

// Type Hinting

function drop(Array $array, Int $count = 1): array // float, string, bool, int, array
{
}


/* 
Дано неотрицательное целое число num. Итеративно сложите все входящие в него цифры до тех пор, пока не останется одна цифра.

Для числа 38 процесс будет выглядеть так:

3 + 8 = 11
1 + 1 = 2
Результат: 2
*/

function addDigits(Int $num)
{
    $sum = (string) $num;

    while (strlen($sum) > 1) {
      $sum = array_sum(str_split($sum));
    }

    return $sum;
}
 

/* Реализуйте функцию binarySum, которая принимает на вход два бинарных числа (в виде строк) и возвращает их сумму. Результат (вычисленная сумма) также должна быть бинарным числом в виде строки. Посмотрите примеры работы функции:

'11' == binarySum('10', '1');
'10010' == binarySum('1101', '101');
*/


function binarySum($num1, $num2)
{
    // decbin — переводит число из десятичной системы счисления в двоичную
    // bindec — переводит двоичное число в десятичное
    return decbin( bindec((int) $num1) + bindec((int) $num2) );
} 


/*
Реализуйте функцию isPrime определяющую, является ли число простым. Пример:
echo isPrime(1); // → false
echo isPrime(7); // → true
echo isPrime(10); // → false
*/

function isPrime($num)
{
    if ($num < 2) {
      return false;
    }

    for ($i = 2; $i <= $num / 2; $i++) {
      if ($num % $i == 0) {
            return false;
        }
    }

    return true;
}


/*
Реализуйте функцию isPowerOfThree которая определяет, является ли переданное число натуральной степенью тройки. Например число 27 это третья степень (33), а 81 это четвертая (34). Пример:

isPowerOfThree(1); // → true (3^0)
isPowerOfThree(3); // → true
isPowerOfThree(4); // → false
isPowerOfThree(9); // → true
*/

function isPowerOfThree(Int $num)
{
    $current = 1;
    while ($current <= $num) {
        if ($current === $num) {
            return true;
        }
        $current *= 3;
    }

    return false;
}


/*
Реализуйте функцию reverseInt, которая переворачивает цифры в переданном числе:
31 == reverseInt(13);
-321 == reverseInt(-123);
*/

function reverseInt($num)
{
    $reverse = (int) strrev((string) abs($num)); // strrev - переворачивает строку задом наперед / abs - модуль числа
    return $num > 0 ? $reverse : -$reverse;
}



>>>>>  HTTP <<<<<<<

/*
Что происходит после того, как в браузер ввели адрес сайта? https://habr.com/company/htmlacademy/blog/254825/

Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. http — это набор правил, который известен и вашему компьютеру и физически отдаленному компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передается информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
*/

$ curl --head -v code-basics.ru
* Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
* Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

http нужно не просто знать, но и уметь делать сырые http-запросы, то есть не косвенно через браузер, но и самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.
*/



>>>>>  Микрофреймворки <<<<<<<

/*
 Фреймворк(каркас) - общая логика, которая структурирует приложение:
 * Принять запрос.
 * Определить, какой обработчик должен выполниться.
 * Выполнить обработчик и подготовить ответ.
 * Вернуть ответ клиенту.
 Сам код на микрофреймворках простой и требует создания буквально одного файла. Микрофреймворки практически ничего не могут самостоятельно. Любая новая функциональность достигается сторонними библиотеками.
 
 Возможности, которыми обладают современные фреймворки:

 * Генерация кода. Любой полноценный фреймворк содержит утилиту cli, позволяющую генерировать код, например, тесты или миграции.
 * Встроенные механизмы для тестирования. Другими словами, фреймворк дает возможность начать писать тесты практически без необходимости что либо дополнительное ставить или конфигурировать.
 * ORM. Либо своя, либо популярная для языка в целом.
 * Шаблонизатор и хелперы (вспомогательные функции) для повторяющихся задач вывода информации.
 * Абстракции для работы с письмами.
 * Инструменты для интернационализации и локализации. 
 * Механизмы, обеспечивающие безопасность, например, CQRS.
 * Интеграция с frontend инструментами.
 * Кеширование.
*/



>>>>>  СУБД <<<<<<<

// Библиотека PDO

// PDO Connection to MySQL
$conn = new PDO('mysql:host=localhost;dbname=yourdbname', 'username', 'password');

// PDO Connection to PostgreSQL
$conn = new PDO('pgsql:host=localhost;dbname=yourdbname', 'username', 'password');

// A quick Select Query with For Loop
$result = $conn->query("SELECT * FROM profile");
foreach ($result as $row) {
     echo $row['id'];
     echo $row['title'];
     echo $row['telephone'];
}

// Slim-PDO. Для Slim /https://github.com/FaaPz/Slim-PDO/ существует проект Slim-PDO, который позволяет взаимодействовать с базой из фреймворка Slim.

$app->post('/ads', function(ServerRequestInterface $request) {
     $parsedBody = $request->getParsedBody(); // Данные пришедшие из формы

     // Соединение с базой должно выполняться на этапе старта приложения (как было с шаблонизатором), а не в конкретном обработчике.
     $dsn = 'mysql:host=your_db_host;dbname=your_db_name;charset=utf8';
     $usr = 'your_db_username';
     $pwd = 'your_db_password';

     $pdo = new \Slim\PDO\Database($dsn, $usr, $pwd);

     $insertStatement = $pdo->insert(['telephone', 'title'])
                              ->into('ads')
                              ->VALUES([$parsedBody['telephone'], $parsedBody['title']]);

     $insertId = $insertStatement->execute(false);
});

// Обратите внимание на то, что библиотека Slim-PDO позволяет выполнять SQL не в виде "сырых" запросов, где SQL писался бы как строка текста (как в репле), а предоставляет небольшой DSL (мини-язык) для написания запроса: insert()->into()->VALUES(). Библиотеку, позволяющую таким образом строить запросы, называют Query Builder. В отличие от сырого SQL в виде строчки, подход, описанный выше, удобен в случаях, когда SQL собирается по условиям. Такое часто бывает на страницах с фильтрами.

/*
Нормализация баз данных заключается в приведении структуры хранения данных к нормальным формам (NF). Всего таких форм существует 8, но часто достаточным является соблюдение первых трех.
 
 * В нормализованной структуре базы данных вы можете производить сложные выборки данных относительно простыми SQL-запросами.
 * Целостность данных. Нормализованная база данных позволяет надежно хранить данные.
 * Нормализация предотвращает появление избыточности хранимых данных. Данные всегда хранятся только в одном месте, что делает легким процесс вставки, обновления и удаления данных. Есть исключение из этого правила. Ключи, сами по себе, хранятся в нескольких местах потому, что они копируются как внешние ключи в другие таблицы.
 * Масштабируемость – это возможность системы справляться с будущим ростом. Для базы данных это значит, что она должна быть способна работать быстро, когда число пользователей и объемы данных возрастают. Масштабируемость – это очень важная характеристика любой модели базы данных и для РСУБД.

https://habr.com/post/193756/

# Денормализация - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных. 
Устранение аномалий данных в соответствии с теорией реляционных баз данных требует, чтобы любая база данных была нормализована, то есть соответствовала требованиям нормальных форм. Соответствие требованиям нормализации минимизирует избыточность данных в базе данных и обеспечивает отсутствие многих видов логических ошибок обновления и выборки данных.

Однако при запросах большого количества данных операция соединения нормализованных отношений выполняется неприемлемо долго. Вследствие этого в ситуациях, когда производительность таких запросов невозможно повысить иными средствами, может проводиться денормализация — композиция нескольких отношений (таблиц) в одну, которая, как правило, находится во второй, но не в третьей нормальной форме. Новое отношение фактически является хранимым результатом операции соединения исходных отношений.

За счёт такого перепроектирования операция соединения при выборке становится ненужной и запросы выборки, которые ранее требовали соединения, работают быстрее.

Следует помнить, что денормализация всегда выполняется за счёт повышения риска нарушения целостности данных при операциях модификации. Поэтому денормализацию следует проводить в крайнем случае, если другие меры повышения производительности невозможны. Идеально, если денормализованная БД используется только на чтение.

Кроме того, следует учесть, что ускорение одних запросов на денормализованной БД может сопровождаться замедлением других запросов, которые ранее выполнялись отдельно на нормализованных отношениях.  


# Нормальная форма - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных. Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение. 

Первая нормальная форма (1NF)
Переменная отношения находится в первой нормальной форме (1НФ) тогда и только тогда, когда в любом допустимом значении отношения каждый его кортеж содержит только одно значение для каждого из атрибутов.

В реляционной модели отношение всегда находится в первой нормальной форме по определению понятия отношение. Что же касается различных таблиц, то они могут не быть правильными представлениями отношений и, соответственно, могут не находиться в 1НФ.


Вторая нормальная форма (2NF)
Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо (функционально полно) зависит от её потенциального ключа.

Третья нормальная форма (3NF)
Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.
Нормальная форма Бойса — Кодда (BCNF)

Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
Четвёртая нормальная форма (4NF)

Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
Пятая нормальная форма (5NF)

Переменная отношения находится в пятой нормальной форме (иначе — в проекционно-соединительной нормальной форме) тогда и только тогда, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.
Доменно-ключевая нормальная форма (DKNF)

Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.

Шестая нормальная форма (6NF)
Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6НФ, также находится и в 5НФ. 


# Cериализация - процесс перевода какой-либо структуры данных в последовательность битов. 

# Десериализация - восстановление начального состояния структуры данных из битовой последовательности. 

# Идемпоте́нтность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.

Fluent Interface.
*/



>>>>>  ORM <<<<<<<

/*
На основе модели предметной области формируется модель данных в коде. Создаются сущности, определяются их связи. Затем строится рабочий код, который оперирует сущностями, исходя из требований (бизнес-правил). На этом этапе возникает вопрос: а как эти сущности отображаются («маппятся» от англ. "map") на базу данных, ведь именно там в конечном итоге все хранится.

Самый простой вариант — создавать по таблице на каждую сущность и связывать их через внешние ключи. Именно так и делают в большинстве проектов, но не руками, а используя ORM (object-relation mapper). По сути, ORM — фреймворк для данных. С помощью него описываются сущности и их связи, определяется то, как сущность отображается на базу данных (как правило в полуавтоматическом режиме). ORM берет на себя серьезную часть работы по генерации SQL-запросов, по извлечению данных и кастингу (преобразование типов базы данных в типы целевого языка и обратно), по автоматическому извлечению связей. В итоге получается, что ORM прячет всю работу с базой данных (требуя только правильного конфигурирования) и сама выполняет все необходимые запросы. В сложных случаях их все равно приходится писать самостоятельно, но, как минимум, ORM содержат в себе query builder, который упрощает генерацию sql.

В php таких ORM довольно много, некоторые из них разрабатывались под конкретные фреймворки и поставляются с ними. Посмотрим на пример с фреймворком Doctrine2.

Определение сущности Photo
*/

// src/Entity/Photo.php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
/**
 * @ORM\Entity
 * @ORM\Table(name="photos", uniqueConstraints={@ORM\UniqueConstraint(name="photo_slug", columns={"slug"})}))
 */
class Photo
{
     /**
      * @ORM\Id
      * @ORM\Column(name="id", type="integer")
      * @ORM\GeneratedValue(strategy="AUTO")
      */
     protected $id;
     /**
      * @ORM\Column(type="string", length=64)
      */
     protected $title;
     /**
      * @ORM\Column(type="string", length=150)
      */
     protected $image;
     /**
      * @ORM\Column(type="string", length=100)
      */
     protected $slug;

     /**
      * Get photo id
      *
      * @ORM\return integer
      */
     public function getId()
     {
          return $this->id;
     }

     /**
      * Get photo title
      *
      * @ORM\return string
      */
     public function getTitle()
     {
          return $this->title;
     }

     /**
      * Get photo slug
      *
      * @ORM\return string
      */
     public function getSlug()
     {
          return $this->slug;
     }

     /**
      * Get photo image
      *
      * @ORM\return string
      */
     public function getImage()
     {
          return $this->image;
     }
}

// Использование

$app->get('/photos', function() {
     // Получаем из базы список всех фотографий
     $photos = $this->entityManager->getRepository('App\Entity\Photo')->findAll();
     // Передаем их в шаблон
     return $this->renderer->render($response, "/photos.phtml", ['photos' => $photos]);
});

/*
 * Модель предметной области (или просто Модель) описана с помощью ORM (хотя это не обязательно, хранилище — вещь отдельная от модели).
 * Функция-обработчик обращается к модели для выполнения запрошенных операций и выводит необходимые данные в шаблон.
 * Шаблон описывает представление конкретной страницы и строится на основании данных переданных из функции-обработчика.
*/




>>>>>  MVC <<<<<<<

/*
Описанная выше структура носит гордое имя MVC или Model-View-Controller (обычно добавляют приписку version 2, так как первая версия MVC используется для толстых клиентов, в которых все работает немного по-другому), где M - модель предметной области, C - наша функция обработчик (в других фреймворках могут быть другие сущности), а V - шаблон. MVC разделяет приложение минимум на три слоя и определяет то, как они могут взаимодействовать друг с другом. Это важно для создания модульных приложений, то есть таких, которые легко развивать и модифицировать. При этом никто не запрещает добавлять новые и дробить текущие слои, все это уже зависит от сложности самого приложения.


* MODEL - хранение данных; целостность; консистентность; запросы; мутации
* CONTROLLER - получение, интерполяция и валидация информации; создание и обновление views; запросы в MODEL; изменение MODEL
* VIEW - презентация
 
MODEL -> CONTROLLER -> VIEW -> User
VIEW-> CONTROLLER -> MODEL
User-> CONTROLLER -> MODEL
 
* M — ядро приложения. В идеале — чистая бизнес-логика. M не знает ничего о других частях приложения и не может на них влиять.
* C - использует M для выполнения запрашиваемых операций и отвечает за генерацию V.
* V - получает данные от C и иногда от M, но такое не приветствуется. И уж точно V не должен знать ничего о базе данных. Кстати, этим грешат начинающие разработчики, которые выполняют SQL запросы прямо из шаблонов.
 
MVC является архитектурным шаблоном (или паттерном проектирования). Шаблон проектирования в разработке — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. В нашем случае контекст — обработка http-запросов.

Паттернов проектирования очень много на все случаи жизни. Некоторые из них очень простые и ближе к идиомам, то есть каким-то локальным участкам кода, которые принято писать тем или иным способом в конкретном языке. Некоторые паттерны — всеобъемлющие, подобные MVC. Они определяют глобальные ограничения, но ничего не говорят о способе реализации. В любом случае паттерны — не догма и не формальная спецификация, а значит всегда есть место для самостоятельного выбора.

В MVC заложена довольно простая, но важная идея разделения приложения на слои с четкими границами. Такой подход позволяет развивать каждый слой независимо от других, при условии, что у вас правильно выстроены зависимости между ними. Обратите внимание, что в MVC все связи однонаправленные. Другими словами, в MVC нет двух слоев, которые знают друг о друге одновременно. Если один слой знает о другом, то второй ничего не знает о первом и наоборот. Модульность (в общем случае — абстракция) — это один из ключевых факторов, делающих приложения по настоящему качественными с точки зрения разработки. 
*/




>>>>>  Коллекции <<<<<<<

/*
Например, в JavaScript канонический способ работы с коллекциями — функции высшего порядка. Посмотрите внимательно:

// Задача: извлечь имена пользователей, оканчивающиеся на `ya` без учета регистра, и привести имена к нижнему регистру
const users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];

const filteredUsers = users.map(n => n.toLowerCase()).filter(n => n.endsWith('ya'));

Возможность так писать доступна в js из коробки, но php — другое дело. Для эффективной работы вам придется «обмазаться» дополнительными библиотеками. Тогда код на php для той же задачи станет таким:
*/

use Stringy\Stringy as S;
use Illuminate\Support\Collection;

$users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];
$collection = collect($users);
$filteredUsers = $collection->map(function($n) {
     return strtolower($n);
})->filter(function($n) {
     return s($n)->endsWith('ya');
}



>>>>>  Другое <<<<<<<

/*
# Аутентификация и авторизация  
Аутентификация почти целиком построена на сессиях http, то авторизация требует понимания принципов построения списков контроля доступа (ACL). В наиболее продвинутых фреймворках подобная функциональность либо встроена в сам фреймворк, либо существует в виде дополнений, которые если и не покрывают все потребности, то, по крайней мере, дают основу для построения своей системы.

# OAuth
Аутентификация с помощью социальных сетей стала почти также распространена, как и аутентификация по паролю. Чисто технически её реализация значительно сложнее, она основана на протоколе oauth2, который включает в себя общение по API. Опять же, с нуля ничего писать не придется: для работы с OAuth написана не одна библиотека, но это не отменяет необходимости понимать, что творится под капотом.

# Валидация
Валидация — проверка данных на соответствие установленным требованиям (ограничениям). 

# Инфраструктура
Пилить фичи — только полдела. Чтобы начать разрабатывать нужно для начала настроить окружение разработчика, используя Docker Compose. Затем, чтобы было куда выкладываться, нужно настроить продакшен-окружение (то, где будет работать сайт) и в конце концов задеплоить (развернуть) туда сайт.

Современная инфраструктура — тоже код, и её нужно программировать. Вот список самых важных программ, созданных для этого: Ansible, Terraform, Docker.
*/



>>>>>  МАССИВЫ <<<<<<<

// Реализуйте функцию addPrefix, которая добавляет каждому элементу в массиве переданный префикс. Функция предназначена для работы со строковыми элементами. После префикса автоматически добавляется пробел.

#1:
function addPrefix($names, $prefix)
{
     $result = [];
    
     for ($i = 0; $i < sizeof($names); $i++) {
          $result[$i] = "{$prefix} {$names[$i]}";
     }

     return $result;
}

#2:
function addPrefix($names, $prefix)
{
     return array_map(function($name) use ($prefix)  {
        return "{$prefix} {$name}";
     }, $names);
}



// Реализуйте функцию reverse, которая располагает значения в обратном порядке без создания нового массива

function reverseArray($coll) 
{
     $size = sizeof($coll); 
     $maxIndex = floor($size / 2);  // округляет дробь в меньшую сторону
    
     for ($i = 0; $i < $maxIndex; $i++) {
          $mirrorIndex = $size - $i - 1;
          $temp = $coll[$i];
          $coll[$i] = $coll[$mirrorIndex];
          $coll[$mirrorIndex] = $temp;
     }
     
     return $coll;
}



// Реализуйте функцию swap, которая меняет местами два элемента относительно переданного индекса. Например, если передан индекс 5, то функция меняет местами элементы, находящиеся по индексам 4 и 6. 

function swap($coll, $center) // hexlet
{
     $prevIndex = $center - 1;
     $nextIndex = $center + 1;
     $isSwappable = array_key_exists($prevIndex, $coll) && array_key_exists($nextIndex, $coll);

     if ($isSwappable) {
          $temp = $coll[$prevIndex];
          $coll[$prevIndex] = $coll[$nextIndex];
          $coll[$nextIndex] = $temp;
     }

     return $coll;
}


/*
Работая на таких высокоуровневых языках как php, позволительно не знать устройство массивов для решения повседневных задач. С другой стороны, подобное понимание делает код менее магическим и дает возможность заглядывать чуть дальше.

Реальные массивы лучше всего рассматривать на языке C, который, с одной стороны, достаточно простой и понятный, с другой - очень близок к железу и не скрывает от нас практически ничего. Когда мы говорим про примитивные типы данных, такие как "строка" или "число", то, на интуитивном уровне, все довольно понятно. Под каждое значение выделяется некоторый размер памяти (в соответствии с типом), в которой и хранится само значение. А как должна выделиться память под хранение массива? И что такое массив в памяти? На уровне хранения, понятия массив - не существует. Массив представляется цельным куском памяти, размер которого вычисляется по формуле "количество элементов * количество памяти под каждый элемент". Из этого утверждения есть два интересных вывода:

Размер массива - фиксированная величина. Те динамические массивы, с которыми мы имеем дело во многих языках, реализованы уже внутри языка, а не на уровне железа.
Все элементы массива имеют один тип и занимают одно и тоже количество памяти. Благодаря этому появляется возможность простым умножением (по формуле, описанной выше) получить адрес той ячейки, в которой лежит нужный нам элемент. Именно это происходит под капотом, при обращении к элементу массива под определенным индексом.

Фактически индекс в массиве - смещение относительно начала куска памяти содержащего данные массива. Высчитывается он так: "индекс * количество памяти занимаемое одним элементом (для данного типа данных)". Пример на C:

// Инициализация массива из пяти элементов типа int
int mark[] = {19, 10, 8, 17, 9};
mark[3]; // 17

Если предположить, что тип int занимает в памяти 2 байта (зависит от архитектуры), то адрес элемента, соответствующего индексу 3, высчитается так: "начальный адрес + индекс * объем памяти для одного элемента типа int".

Теперь должно быть понятно почему индексы в массиве начинаются с нуля. 0 - означает отсутствие смещения.

# Безопасность
В отличие от высокоуровневых языков, в которых код защищен от выхода за границу массива, в таком языке как C, выход за границу не приводит к ошибкам. Обращение к элементу, индекс которого находится за пределами массива, вернет данные, которые лежат в той самой области памяти, куда его попросили обратиться (в соответствии с формулой выше). Чем они окажутся - никому не известно (но они будут проинтерпретированы в соответствии с типом массива. Если массив имеет тип int, то вернется число). Благодаря отсутствию какой-либо защиты выход за границу массива активно эксплуатируется хакерами для взлома программ.

Еще один распространенный вариант использования циклов на массивах — агрегация. Агрегацией являются любые вычисления, которые строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее.
*/

function calculateMax($coll)
{
     if (empty($coll)) {
          return null;
     }

     $max = $coll[0];
     for ($i = 1; $i < sizeof($coll); $i++) {
          if ($coll[$i] > $max) {
                $max = $coll[$i];
          }
     }

     return $max;
}

print_r(calculateMax([]));
print_r(calculateMax([3, 2, -10, 38, 0]));

/*
Если массив пустой, то возвращаем null. Это классический пример использования идиомы guard expression.

Нейтральный элемент бинарной операции — элемент, который ничего не меняет в результате его использования в бинарной операции. По простому, сложение любого числа с нулем всегда дает это же число. Тогда любую сумму, например 3 + 2 + 8, можно вычислить как 0 + 3 + 2 + 8
*/


// Реализуйте функцию calculateAverage, которая высчитывает среднее арифметическое элементов массива. В случае пустого массива функция должна вернуть значение null (используйте в коде для этого guard expression)

function calculateAverage($arr) // my
{
    return empty($arr) ? null : array_sum($arr) / sizeof($arr);
}

function calculateAverage($coll) // hexlet
{
     if (empty($coll)) {
          return null;
     }

     $sum = 0;
     foreach ($coll as $item) {
          $sum += $item;
     }

     return $sum / sizeof($coll);
}


// Реализуйте функцию isContinuousSequence, которая проверяет, является ли переданная последовательность целых чисел - возрастающей непрерывно (не имеющей пропусков чисел). Например, последовательность [4, 5, 6, 7] - непрерывная, а [0, 1, 3] - нет. Последовательность может начинаться с любого числа, главное условие - отсутствие пропусков чисел.

function isContinuousSequence($coll)
{
     if (empty($coll)) { return false; }

     $start = $coll[0];

     foreach ($coll as $i => $item) {
          if ($start + $i !== $item) {
                return false;
          }
     }

     return true;
}



>>>>>  Удаление элементов массива <<<<<<<

/* 
Несмотря на то, что из массива можно удалить элемент, лучше так никогда не делать. Особенно плохо изменять массив во время обхода. Правильный выход из ситуации — создание нового массива. Такой код проще и для понимания и для отладки.

В стандартную библиотеку большинства языков программирования входит функция compact, которая удаляет все null из массива. Вот ее реализация:
*/

function mycompact($coll)
{
     $result = [];
     foreach ($coll as $item) {       
          if (!is_null($item)) {
                $result[] = $item;
          }
     }
     
     return $result;
}

print_r(mycompact([0, 1, false, null, true, 'wow', null])); 

/*
Главное, на что нужно обратить внимание, не происходит никаких удалений и модификаций исходного массива. Вместо этого инициализируется новый массив, который наполняется только подходящими под условие значениями. Именно так нужно воспринимать фразу "удалить из массива что-то". Код с созданием нового массива меньше подвержен ошибкам, проще в отладке и оставляет больше возможностей для анализа. Вы всегда можете посмотреть исходный массив, если что-то пошло не так. Вы всегда можете наблюдать за процессом наполнения результирующего массива, что позволит четко отследить правильность поставленных условий.

По сути, код выше — пример агрегации. Только в отличие от предыдущих примеров, в которых  результатом был примитивный тип, здесь результат — массив. Это совершенно нормально. Сама операция прореживания массива обычно называется фильтрацией.
*/



>>>>>  Генерация строки в цикле <<<<<<<

// Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример в вебе, функция-хелпер, помогающая генерировать html списки в шаблонах. Она принимает на вход коллекцию элементов и возвращает список из них:

$coll = ['milk', 'butter', 'eggs', 'bread'];
buildList($coll); // => <ul><li>milk</li><li>butter</li><li>eggs</li><li>bread</li></ul>

// Самый примитивный алгоритм, который приходит в голову. Пройтись циклом по элементам коллекции и дописать в результирующую строку очередной li элемент. В начале и конце добавить ul и вернуть строчку наружу.

$result = '';

foreach ($coll as $item) {
     $result .= "<li>{$item}</li>";
     // либо так
     // $result = "{$result}<li>{$item}</li>";
}

$result = "<ul>{$result}</ul>";

// Такой способ вполне рабочий, но для большинства языков программирования максимально не эффективный. Дело в том, что конкатенация и интерполяция порождают новую строчку вместо старой и подобная ситуация повторяется на каждой итерации. Причем строка становится все больше и больше. Копирование строк приводит к серьезному расходу памяти и может влиять на производительность. Конечно, для большинства приложений данная проблема не актуальна из-за малого объема прогоняемых данных, но более эффективный подход не сложнее в реализации и обладает дополнительными плюсами. Поэтому стоит сразу приучить себя работать правильно и никогда больше не возвращаться к этому вопросу. В статических языках для подобной цели используется так называемый String Buffer. В динамических — обычный массив. Перепишем программу выше, используя новое знание:

$coll = ['milk', 'butter', 'eggs', 'bread'];
$parts = []; // переименовал для того, чтобы не менять значения переменной

foreach ($coll as $item) {
     $parts[] = "<li>{$item}</li>";
}

$innerValue = implode("\n", $parts);
$result = "<ul>{$innerValue}</ul>";

/*
Как видите, код не сильно поменялся. Разница в том, что теперь собирается массив вместо строки, и в конце он собирается в строку с помощью implode. Помимо эффективности у такого подхода есть дополнительные плюсы:
 * Такой код проще отлаживать и анализировать внутренности
 * Массив можно дообработать, если надо, а строчку — уже нет
*/ 


/*
Реализуйте функцию buildDefinitionList, которая генерирует html список определений (теги dl, dt и dd) и возвращает получившуюся строку.

Параметры функции:
Список определений следующего формата:
*/
$definitions = [
  ['definition1', 'description1'],
  ['definition2', 'description2']
];

// Пример:


$definitions = [
     ['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
     ['Бобр', 'Животное из отряда грызунов'],
];

buildDefinitionList($definitions); // => '<dl><dt>Блямба</dt><dd>Выпуклость, утолщение на поверхности чего-либо</dd><dt>Бобр</dt><dd>Живтоное из отряда грызунов</dd></dl>'; 


function buildDefinitionList(Array $definitions)
{
     $parts = [];
     foreach ($definitions as $definition) {
          $name = $definition[0];
          $description = $definition[1];
          $parts[] = "<dt>{$name}</dt><dd>{$description}</dd>";
     }
     $innerValue = implode('', $parts);
     $result = "<dl>{$innerValue}</dl>";

     return $result;
}




>>>>>  Обработка строк через преобразование в массив <<<<<<<

/*
Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. На любые хитрые вопросы «а есть ли в строке знаки препинания» ответ — выбирайте самый простой случай для обработки.

Решить её можно достаточно большим количеством способов. Чем больше называет человек, тем лучше. К ним относятся:

* Посимвольный перебор строки. Эта задачка может быть решена двумя способами. Один из которых связан с использованием конечных автоматов.
* Регулярные выражения. 
* Через преобразование в массив. Этот способ тоже распадается на два. Одно решение через функции высших порядков или решение через цикл.
 
*/ 

function capitalizeWords($sentence)
{
     $words = explode(' ', $sentence);
     
     for ($i = 0; $i < sizeof($words); $i++) {
        $words[$i] = ucfirst($words[$i]);
     }
    
    return implode(' ', $words);
}


// В случае, если строчку нужно разбить по символам, а не по словам, можно воспользоваться функцией str_split. 

$chars = str_split($text);
foreach ($chars as $char) {
     print_r($char);
}

// str_split принимает второй параметр, в котором можно указать количество символов в каждой группе (элементе получившегося массива). По умолчанию используется число 1, поэтому мы получаем массив, в котором каждый элемент — один символ. Но, если указать, например, 3, то в каждом элементе массива будет по три символа.

$text = 'Hello Friend';
$arr2 = str_split($str, 3); // -> 
/*
[0] => Hel
[1] => lo
[2] => Fri
[3] => end
*/


/*
Реализуйте функцию makeCensored, которая заменяет каждое вхождение указанного слова в предложении на последовательность $#%! и возвращает полученную строку. Аргументы:
Текст / Слово
Словом считается любая непрерывная последовательность символов, включая любые спецсимволы.
*/

function makeCensored(string $text, $stopWord) // hexlet
{
     $words = explode(' ', $text);
     $result = [];
     foreach ($words as $word) {
          $result[] = ($word === $stopWord) ? '$#%!' : $word;
     }

     return implode(' ', $result);
}



>>>>>  Вложенные циклы <<<<<<<

// Во многих языках программирования есть очень полезная функция flatten. В определенных задачах она сильно упрощает жизнь и сокращает количество кода. flatten принимает на вход массив и выправляет его: если элементами массива являются массивы, то flatten сводит все к одному массиву, раскрывая каждый вложенный. Посмотрим на пример:

flatten([[3, 2], 5, 3, [3, [4, 2]], 10]); // => [3, 2, 5, 3, 3, 4, 2, 10]


// Давайте напишем функцию flatten. В общем случае эта функция раскрывает массивы на всех уровнях вложенности. Но мы для простоты сделаем вариант функции, в котором происходит раскрытие только до первого уровня. То есть, если элемент основного массива — массив, то он раскрывается без просмотра его внутренностей (там тоже могут быть массивы).

function flatten($coll)
{
     $result = [];

     foreach ($coll as $item) {      
          if (is_array($item)) {
                foreach ($item as $subitem) {
                     $result[] = $subitem;
                }
          } else {
                $result[] = $item;
          }
     }
     
     return $result;
}

/*
Вложенные циклы коварны. Их наличие может резко увеличить сложность кода и в особо тяжелых случаях значительно замедлить его. В тех местах, где можно от них избавиться, лучше от них избавляться.

Для реализации функции flatten лучше использовать слияние массивов, которое мы рассмотрим в одном из следующих уроков. Если же от вложенных массивов уйти не получается, то с высокой вероятностью вложенный цикл можно вынести в отдельную функцию.
*/

function concat($result, $items)
{
     foreach ($items as $item) {
          $result[] = $item;
     }
     return $result;
}

function flatten($coll)
{
     $result = [];
     foreach ($coll as $item) {
          if (is_array($item)) {
                $result = concat($result, $item)
          } else {
                $result[] = $item;
          }
     }

     return $result;
}


// Реализуйте функцию getSameCount, которая считает количество общих уникальных элементов для двух массивов. Аргументы: Первый массив / Второй массив

function getSameCount($coll1, $coll2) 
{
     $count = 0;
     $uniqColl1 = array_unique($coll1);
     $uniqColl2 = array_unique($coll2);

     foreach ($uniqColl1 as $item1) {
          foreach ($uniqColl2 as $item2) {
                if ($item1 === $item2) {
                     $count++;
                }
          }
     }

     return $count;
}



>>>>>  Теория Множеств <<<<<<<

/*
Множеством обозначают совокупность объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество арабских цифр включает в себя 10 элементов и является конечным. Понятие конечности носит интуитивный характер и обозначает, что в множестве конечное число элементов.

Пример бесконечного множества — натуральные числа. В свою очередь множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее.

«Подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством (по отношению к подмножеству).

Главное для нас в теории множеств — операции над ними. К ним относятся: дополнение, объединение, пересечение, разность, декартово произведение и некоторые другие.

Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

Переходя к программированию, можно заметить, что массив очень похож на множество, и его действительно можно так рассматривать. Почему это так важно? Понимая принципы, на которых основаны некоторые операции, вы сможете реализовывать их наиболее быстрым и эффективным способом. Например, зная, что вам нужна операция пересечения множеств в php, вы можете попытаться найти функцию, которая делает поставленную задачу. Для этого достаточно ввести в гугл запрос: php set intersect (set — множество, intersect — пересечение). Первая (по крайней мере, у меня) ссылка в поисковой выдаче ведет на нужную функцию array_intersect. Тоже самое вас ждет и с другими операциями.

Отдельно стоит сказать, что реляционные базы данных построены на идеях реляционной алгебры, в которой теория множеств играет центральную роль.

Рассказы о множествах книга: http://ilib.mccme.ru/pdf/rasomn.pdf
*/


// Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

array_intersect($friends1, $friends2); // => ['vasya', 'petya'] // Эта функция принимает любое количество массивов. То есть вы можете находить пересечение любого количества массивов за один вызов.

// Объединением множеств называется множество, в которое входят элементы всех данных множеств. Объединение множеств в php нельзя сделать одним вызовом, но его можно имитировать, соединив две функции:

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

// merge выполняет слияние двух массивов, в отличие от объединения, в нем повторяются элементы которые встречаются там и там (а не должны)
$friends = array_merge($friends1, $friends2);
// => ['vasya', 'kolya', 'petya', 'igor', 'petya', 'sergey', 'vasya', 'sasha'];

// unique удаляет дубли
$sharedFriends = array_unique($friends);
// => ['vasya', 'kolya', 'petya', 'igor', 'sergey', 'sasha']

// Дополнение (разность). Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется diff.

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];
array_diff($friends1, $friends2); // => ['kolya']

// Принадлежность множеству. Проверку принадлежности элемента множеству можно выполнить с помощью функции in_array:
$terribleNumbers = [4, 13];

if (in_array(10, $terribleNumbers)) {
     print_r('woah!');
}


// Реализуйте функцию countUniqChars, которая считает количество уникальных символов в переданной строке. Если передана пустая строка, то функция должна вернуть 0, т.к. пустая строка вообще не содержит символов. Задание необходимо выполнить без использования функции array_unique.

function countUniqChars($text)
{
     if ($text === '') {
          return 0;
     }

     $uniqChars = [];
     $chars = str_split($text);
     
     foreach ($chars as $char) {
          if (!in_array($char, $uniqChars)) {
                $uniqChars[] = $char;
          }
     }

     return count($uniqChars);
}



>>>>>  Сортировка массивов <<<<<<<

// пузырьковая сортировка
function bubbleSort(array $arr)
{
     $size_arr = sizeof($arr);

     do {
          $flag = false;

          for ($i = 0; $i < $size_arr - 1; $i++) {
                if ($arr[$i] > $arr[$i + 1]) {
                      $curr_val = $arr[$i];
                      $arr[$i] = $arr[$i + 1];
                      $arr[$i + 1] = $curr_val;
                      $flag = true;
                } 
          }
          $size_arr--;
     } while($flag);

     return $arr;
}

/*
Весь код делится на два уровня:

* Внутренний цикл for, который проходит по массиву от начала до конца, меняя элементы попарно, если нужно сортировать.
* Внешний цикл while..do, определяющий, когда нужно остановиться. Обратите внимание, что в худшем случае этот цикл выполнится sizeof($arr) раз, что совпадает с теоретическим худшим случаем этого алгоритма, при котором самый большой или маленький элемент находятся в противоположных конце массива от сортированного варианта.
*/



>>>>>  Ссылки <<<<<<<

// Большинство функций, работающих с массивами, после обработки возвращают новый массив. Но некоторые работают по-другому. В этих функциях, как правило, не используется возврат. Они меняют исходный массив напрямую за счет использования ссылок. К таким функциям, например, относится функция сортировки:

$arr = [3, 8, 1];

sort($arr);
print_r($arr);

// Несмотря на то, что подход, меняющий массивы напрямую, сложнее в отладке, его используют в некоторых языках для увеличения эффективности работы. Если массив достаточно большой, то полное копирование окажется дорогой операцией. В реальной жизни (веб разработчика) это почти никогда не проблема, но знать об этом полезно.



>>>>>  Стек <<<<<<<

/*
Структура данных — это конкретный способ хранения и организации данных. В зависимости от решаемых задач, удобным оказывается либо один способ организации данных, либо другой. Как минимум, одну структуру данных вы уже знаете достаточно хорошо — это массив. С точки зрения организации, массив представляет собой совокупность элементов, к которым имеется индексированный доступ (доступ по индексу), а вот с точки зрения хранения — все сложнее. Массивы бывают разные и внутри языка реализуются тоже по-разному.

Каноническая организация хранения массива — непрерывный блок памяти. А индекс в таком случае играет роль смещения по ней. Именно поэтому индексация в массивах начинается с нуля, так как указывает на начало этого блока, а индекс под номером 1 уже является смещением. Но на практике все сложнее. В PHP нет настоящих массивов. 

Кроме массивов существует множество других структур данных, таких как списки, хеш-таблицы, деревья, графы, стек, очередь и другие. Использование структуры данных, подходящей под решаемую задачу, позволяет кардинально упростить код, устраняя запутанную логику.

Стоит разделять три понятия:

 * Структура данных
 * Конкретный тип данных (или просто «тип данных»)
 * Абстрактный тип данных
 
Со структурой данных все понятно, выше было определение. С типом данных тоже все просто. Например, массив в PHP — это тип данных. Понятие «тип данных» всегда привязано к конкретному языку и может быть абсолютно чем угодно в зависимости от предпочтений разработчиков языка. Другими словами если бы разработчики PHP решили, что числа надо назвать типом данных Array, то никто бы им этого не запретил, несмотря на абсурдность такого имени для чисел. Кроме встроенных типов данных, бывают и пользовательские.

А вот АТД — теоретическое понятие. АТД целиком и полностью определяется набором операций, которые можно выполнять над ним. АТД абстрактный потому, что он ничего не говорит о способе хранения и существует лишь на бумаге и в головах. А вот уже в конкретных языках существуют конкретные типы, реализующие АТД.

АТД нередко путают с понятием «структура данных», более того, часто, структуры данных и АТД имеют одно и тоже название.


# Стек
Стек — упорядоченная коллекция элементов, в которой добавление новых и удаление старых элементов всегда происходит с одного конца коллекции. Обычно его называют вершиной стека.

У стека есть аналоги из реальной жизни. Слово stack, с английского, переводится как «стопка». По сути, любая стопка может рассматриваться как стек. Если не применять грубую физическую силу, то со стопками мы работаем двумя способами. Либо кладем новый элемент (например, книгу) на верхушку стопки, либо снимаем элемент с верхушки. Еще более показательный пример — магазин в огнестрельном оружии. Первый заложенный патрон выйдет из магазина последним. Поэтому стек еще называют "Last In First Out" (LIFO), то есть "последний зашел, первый вышел".

Перед тем, как разбирать конкретную задачу, я покажу вам, что стек играет огромную роль в программировании. Вспомните, как исполняется любая программа. Одни функции вызывают другие, которые, в свою очередь, вызывают третьи, и так далее. После того, как выполнение заходит в самую глубокую функцию, та возвращает значение, и начинается обратный процесс. Сначала идет выход из наиболее глубоких функций, затем из тех, что уровнем выше, и так далее до тех пор, пока не дойдет до самой внешней функции. Вызов функций — ничто иное, как добавление элемента в стек, а возврат — снятие со стека. Именно так всё устроено на аппаратном уровне. К тому же, если в процессе выполнения программы происходит ошибка, то её вывод часто называют Stack Trace (трассировка стека).

Другой пример, связанный с программированием — кнопка «назад» в браузере. История посещений представляет собой стек, каждый новый переход по ссылке добавляет её в историю, а кнопка «назад» извлекает из стека последний элемент.


Стек — абстрактный тип данных со следующим набором операций:

 * Добавить в стек (push)
 * Взять из стека (pop)
 * Вернуть элемент с вершины стека без удаления (peek)
 * Проверить на пустоту (isEmpty)
 * Вернуть размер (size)
 
 В PHP стек можно построить на основе массивов. Для этого используется следующий набор функций: array_push, array_pop, empty, sizeof.
 
 Обратите внимание, что array_pop и array_push изменяют исходный массив. array_pop не только изменяет его, но и возвращает элемент, снятый со стека.
 
 Рассмотрим задачку, решение которой тривиально при использовании стека. 

Задача:

 Необходимо реализовать функцию, которая проверяет, что парные символы сбалансированы. То есть каждый открывающий символ имеет закрывающий, и они не перекрываются, например так [{]}. К таким символам в нашем случае относятся <>, {}, () []. Входом в функцию может быть ()<>{}. Такой пример проходит проверку, а вот этот уже нет: [({)}]. Здесь происходит перекрытие фигурных и круглых скобок.

 Решение со стеком выглядит так:

 Если перед нами открывающий элемент, то заносим его в стек
 Если закрывающий, то достаем из стека элемент (очевидно, последний добавленный) и смотрим, что он открывающий для данного закрывающего. Если проверка провалилась, значит выражение не соответствует требуемому формату.
 Если мы дошли до конца строки и стек пустой, то все хорошо. Если в стеке остались элементы, то проверка не прошла. Такое может быть, если в начале строки были открывающие элементы, но в конце не было закрывающих.
 Разберем его построчно:
*/

function checkIfBalanced(string $expression): boolean
{
     
     $stack = [];
     
     $startSymbols = ['{', '(', '<', '['];
     
     $pairs = ['{}', '()', '<>', '[]'];

     
     for ($i = 0; $i < strlen($expression); $i++) {
          $curr = $expression[$i];
          
          if (in_array($curr, $startSymbols)) {
                array_push($stack, $curr);
          } else { 
                $prev = array_pop($stack);
                
                $pair = "{$prev}{$curr}";
                
                
                if (!in_array($pair, $pairs)) {
                     return false;
                }
          }
     }
    
     return sizeof($stack) == 0;
}

/*
 Предположим, что на вход функции попала следующая строка: [{]. Ниже описание ключевых шагов при выполнении функции проверки:

 * Первый символ [ заносится в стек, так как он входит в список открывающих
 * Символ { также заносится в стек по той же самой причине
 * Символ ] относится к закрывающим, поэтому со стека забирается последний символ {. Из них составляется пара {], которая не проходит проверку.
 

 # Семантика
 Может возникнуть соблазн использовать эти функции в повседневной практике. Например, чтобы извлечь из массива последний элемент. Несмотря на то, что array_pop действительно позволяет это сделать, такой вариант использования крайне нежелателен по нескольким причинам:

 Побочный эффект данной операции — изменение исходного массива. Даже если далее массив не используется, такой код вносит потенциальные проблемы и заставляет его переписывать в будущем.
 Нарушается семантика. Инструменты нужно использовать по назначению, иначе рождается код, который декларирует одно, но в реальности делает другое. Любой опытный программист, который видит array_pop или array_push сразу считает, что массив в данной части программы используется как стек, но на самом деле он этого не делает. Подобный код заставляет напрягаться и анализировать его лишний раз для понимания сути.
 */
 
 // Реализуйте функцию checkIfBalanced, которая проверяет балансировку круглых скобок в арифметических выражениях.
 
function checkIfBalanced(string $expression): bool
{
     // инициализируем стек
     $stack = [];

     for ($i = 0; $i < strlen($expression); $i++) {
          $curr = $expression[$i];
          if ($curr == '(') {
                array_push($stack, $curr);
          } elseif ($curr == ')') {
                if (empty($stack)) {
                     return false;
                }
                array_pop($stack);
          };
     }

     // !Если стек оказался пустой после обхода строки, то значит все хорошо
     return sizeof($stack) == 0;
}



>>>>>  Big O <<<<<<<

/*
Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» и нотация О-большое (Big O notation). Она не только полезна при прохождении собеседований, но и даёт понимание того, как вообще оценивать эффективность кода (очень относительно).

Как вы помните, алгоритмов сортировок существует много, я бы сказал очень много. Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом (или классифицируются) по их вычислительной (или алгоритмической) сложности. Сложность оценивается по количеству выполняемых операций. Понятно, что конкретное количество операций зависит от входных данных, например, если массив отсортирован, то количество операций будет минимальным (но они все равно будут, потому что алгоритм должен убедиться в том, что массив отсортирован). Если не отсортирован, то для каждого алгоритма можно подобрать такие входные данные, при которых он будет работать максимально долго и не эффективно. Эти случаи называют соответственно верхней и нижней границей.

Нотация Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Вот некоторые примеры того, как записывается сложность: O(1), O(n), O(nlog(n)).

O(1) описывает так называемую константную сложность. Например обращение к элементу массива по индексу оценивается константой, другими словами оно не зависит от размера массива, поэтому внутри O записывается единица, символизирующая константу. А вот функция, которая печатает на экран все элементы переданного массива используя обычный перебор имеет сложность O(n) (линейная сложность). То есть количество выполняемых операций будет равно количеству элементов массива. Именно это количество символизирует символ n в скобках.

Еще один простой пример — вложенные массивы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью функции in_array, чья сложность O(n), ведь в худшем случае она просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны n, то получается, что поиск пересечений имеет квадратичную сложность или O(n^2) (n в квадрате). Существуют как очень эффективные, так и абсолютно не эффективные алгоритмы. Первые, как правило имеют логарифмическую сложность, последние — степенную, такую, при которой n находится в степени. Скорость работы подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов.

Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность паралеллиться (и если это происходит, то работают крайне эффективно). Как и все в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

Big O, во многом, теоретическая оценка, на практике всё может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых, архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет, потому что работает с небольшим объемом памяти, а где-то в это время есть другой кусок, который вызывается тысячи раз, и приводит к реальному замедлению.

Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд Кнут
*/
 
// Поиск пересечения двух неотсортированных массивов, операция в рамках которой выполняется вложенный цикл с полной поверкой каждого элемента первого массива, на вхождение во второй. Сложность данного алгоритма O(nm) (проивезедение n и m), где n и m размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше. Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идет проверка элементов находящихся под этими индексами в обоих массивах. Если они совпадают то значение заносится в результирующий массив, а оба индекса инкрементируются, если значение в первом массиве больше чем во втором, то инкрементируется указатель второго массива, иначе первого.


function getIntersectionOfSortedArray($arr1, $arr2)
{
    $result = [];
    $i1 = 0;
    $i2 = 0;
    $size1 = sizeof($arr1);
    $size2 = sizeof($arr2);

    if ($size1 == 0 || $size2 == 0) {
        return [];
    }

    do {
      if ($arr1[$i1] == $arr2[$i2]) {
        $result[] = $arr1[$i1];
        $i1++;
        $i2++;
      } elseif ($arr1[$i1] > $arr2[$i2]) {
        $i2++;
      } else {
        $i1++;
      }
    } while ($i1 < $size1 && $i2 < $size2);

    return $result;
}



>>>>>  Destructuring <<<<<<<

/*
В программировании часто встречается понятие «синтаксический сахар». Им обозначают конкретные конструкции в языках программирования, которые упрощают часто используемые операции, делая их синтаксически проще.

PHP не богат на подобные конструкции, но кое-что все же имеется. 

Самый простой пример сахара — обмен переменных местами. Обычно для этого используют третью переменную (хотя те, кто сильны в теории, скажут и о XOR варианте обмена):
*/

$a = 5;
$b = 8;

$temp = $a;
$a = $b;
$b = $temp;

// Довольно утомительное занятие. А вот как можно сделать короче:

$a = 5;
$b = 8;

list($b, $a) = [$a, $b]; 
[$b, $a] = [$a, $b]; // c версии 7.1

// Не так круто, как в других языках, где можно писать a, b = b, a, но уже что-то.

// Другой интересный пример синтаксического сахара — destructuring (дестракчеринг или деструктуризация). Представьте, что у нас есть массив из двух элементов, которыми мы хотим оперировать в нашей программе. Самый простой вариант использования — постоянное обращение по индексу $arr[0] и $arr[1]. Такой код не очень хорошо читается, потому что надо понять, что это такое. Поэтому гораздо лучше сначала присвоить эти значения переменным с хорошими именами. Тогда код будет выглядеть так:

$firstName = $arr[0];
$lastName = $arr[1];

// Как видно, код стал значительно понятнее без лишних слов. Дестракчеринг позволяет извлекать элементы из составной структуры, используя особый синтаксис:

[$firstName, $lastName] = $arr;

/*
Получилось и короче и понятнее (особенно если привыкнуть к этому способу записи). Пример с обменом переменных тоже построен на дестракчеринге. Обратите внимание, что справа от = фактически был создан массив [$a, $b]. Дестаркчеринг работает для любого количества элементов и не только с массивами.

Разложение массива можно использовать не только как отдельную инструкцию в коде, но и, например, в циклах:
*/

$points = [ [4, 3], [0, -3] ];

foreach ($points as [$x, $y]) {
    print_r([$x, $y]);
}

// =>
Array
(
     [0] => 4
     [1] => 3
)
Array
(
     [0] => 0
     [1] => -3
)


// Напишем функцию, считающую количество вхождений каждого слова в предложение. Результатом работы этой функции является ассоциативный массив, в котором ключ — "слово", а значение — "количество вхождений". Пример:

function getWordsCount($content)
{
    $result = [];
    $words = explode(' ', $content);  // Разбиваем на слова

    foreach ($words as $word) {
        if (!array_key_exists($word, $result)) {
            $result[$word] = 1; // Инициализация при первом упоминании
        } else {
            $result[$word]++;
        }
    }

     return $result;
}


// Реализуйте функцию getIn, которая извлекает из массива (который может быть любой глубины вложенности) значение по указанным ключам. Аргументы: Исходный массив / Массив ключей, по которым ведется поиск значения. В случае, когда добраться до значения невозможно, возвращается null.

function getIn(array $data, array $keys)
{
    $current = $data;

    foreach ($keys as $key) {
        if (!is_array($current) || !array_key_exists($key, $current)) {
            return null;
        }

        $current = $current[$key];
    }

    return $current;
}


// Реализуем функцию findKeys, которая возвращает список ключей массива, значение которых равно переданному значению:

$lessonMembers = [
  'syntax' => 3,
  'using' => 2,
  'foreach' => 10,
  'operations' => 10,
  'destructuring' => 2,
  'array' => 2,
];

$result = findKeys($lessonMembers, 10);
// => ['foreach', 'operations']

$result = findKeys($lessonMembers, 3);
// => ['syntax']

function findKeys(array $data, $expectedValue)
{
     $result = [];
     foreach ($data as $key => $value) {
          if ($value === $expectedValue) {
                $result[] = $key;
          }
     }

     return $result;
}


// Реализуйте функцию pick, которая извлекает из переданного массива все элементы по указанным ключам и возвращает новый массив. Аргументы: Исходный массив / Массив ключей, по которым должны быть выбраны элементы (ключ и значение) из исходного массива, и на основе выбранных данных сформирован новый массив

function pick(array $arr, array $keys)
{
    $res = [];
    
    foreach ($keys as $key) {
        if (array_key_exists($key, $arr)) {
            $res[$key] = $arr[$key];
        }
    }
    
    return $res;
}



>>>>>  Популярные функции для работы с ассоциативными массивами <<<<<<<

// Функция array_keys извлекает из ассоциативного массива ключи и создает из них массив.

$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data); // => ['first_name', 'last_name']

// Типичное применение данной функции в языках отличных от PHP — обход ассоциативного массива:

$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data);
foreach($keys as $key) {
     print_r($data[$key]);
}

// В PHP то же самое самое делается прямым обходом ассоциативного массива, но знать про функцию все равно полезно. Например, в JSON (как и в языках, отличных от PHP) массив и ассоциативный массив — разные типы данных.

{
  "autoload": {
     "files": [
        "src/Arrays.php"
     ]
  },
  "config": {
     "vendor-dir": "/composer/vendor"
  }
}

// Выше files — обычный массив, а config — ассоциативный.


// Функция array_VALUES извлекает из ассоциативного массива значения и создает из них массив.


$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_VALUES($data); // => ['Mark', 'Smith']

/*
array_merge
Наиболее интересная функция — array_merge или так называемое слияние. Слияние двух массивов порождает новый массив, в котором поверх первого массива накладывается второй по следующим правилам:

* Если в первом массиве есть ключ, которого нет во втором, то он остается
* Если в первом и во втором массиве есть один и тот же ключ, то его значением становится значение из второго массива
* Если в первом массива нет ключа, который есть во втором, то он добавляется.

Операция слияния не коммутативна, так же, как и вычитание. Изменение порядка аргументов (перемена массивов) приведет к другому результату.
*/

$data1 = [
     'first_name' => 'Mark',
     'last_name' => 'Polo',
];

$data2 = [
     'last_name' => 'Brin',
     'age' => 15,
];

$result = array_merge($data1, $data2);
// => [
//     'first_name' => 'Mark',
//     'last_name' => 'Brin',
//     'age' => 15,
// ]

// Иногда в программировании возникает задача поиска разницы между двумя наборами данных, такими как ассоциативные массивы. Например, при поиске различий в json файлах. Для этого даже существуют специальные сервисы, например, http://www.jsondiff.com/ (попробуйте нажать на ссылку sample data и затем кнопку Compare).

/*
Реализуйте функцию genDiff, которая возвращает ассоциативный массив, в котором каждому ключу из исходных массивов соответствует одно из четырех значений: added, deleted, changed или unchanged. Аргументы:

* Ассоциативный массив
* Ассоциативный массив
* Расшифровка:

* Added - ключ отсутствовал в первом массиве, но был добавлен во второй
* Deleted - ключ был в первом массиве, но отсутствует во втором
* Changed - ключ присутствовал и в первом и во втором массиве, но значения отличаются
* Unchanged - ключ присутствовал и в первом и во втором массиве с одинаковыми значениями

$result = genDiff(
     ['one' => 'eon', 'two' => 'two', 'four' => true],
     ['two' => 'own', 'zero' => 4, 'four' => true]
);

// => [
//     'one' => 'deleted',
//     'two' => 'changed'
//     'zero' => 'added',
//     'four' => 'unchanged',
// ];

*/

function union(array $data1, array $data2)
{
     return array_unique(array_merge($data1, $data2));
}

function genDiff(array $data1, array $data2)
{
     $keys = union(array_keys($data1), array_keys($data2));
     $result = [];

     foreach ($keys as $key) {
          if (array_key_exists($key, $data1) && array_key_exists($key, $data2)) {
                if ($data1[$key] === $data2[$key]) {
                     $result[$key] = 'unchanged';
                } else {
                     $result[$key] = 'changed';
                }
          } elseif (array_key_exists($key, $data2)) {
                $result[$key] = 'added';
          } elseif (array_key_exists($key, $data1)) {
                $result[$key] = 'deleted';
          }
     }

     return $result;
}



>>>>>  Destructuring <<<<<<<

// Напомню, что деструктуризация (дестракчеринг) — специальный синтаксис, позволяющий извлекать части из составных данных. Самый простой пример, который мы рассмотрели, заключается в извлечении значений массива состоящего из двух элементов.

[$firstName, $lastName] = $arr;

// На части можно раскладывать не только индексированные, но и ассоциативные массивы, извлекая из них значения по определенным ключам.

$person = ['first' => 'Rasmus', 'last' => 'Lerdorf', 'manager' => true];

// Порядок извлечения не важен

['last' => $lastname, 'first' => $firstname] = $person;

// Теперь переменные $lastname и $firstname содержат соответствующие значения. Имена самих переменных выбираются произвольно, главное — совпадение по ключам.
// PHP допускает вложенный дестракчеринг. С помощью него можно получать значения не только внешнего массива, но и вложенных.

$options = ['enabled' => true, 'compression' => ['algo' => 'gzip']];

[
     'enabled' => $enabled,
     'compression' => [
          'algo' => $compressionAlgo
     ]
] = $options;

// Дестракчеринг ассоциативного массива можно комбинировать с дестракчерингом индексированного.

$x = ['o' => [1, 2, 3]];
['o' => [$a, $b, $c]] = $x;

$y = ['o' => [[1, 2, 3], ['what' => 'WHAT']]];
['o' => [[$one, $two, $three], ['what' => $what]]] = $y;

// Дестракчеринг допустим и в циклах:

$persons = [
     ['first' => 'Rasmus', 'last' => 'Lerdorf'],
     ['first' => 'Fabien', 'last' => 'Potencier'],
     ['first' => 'Taylor', 'last' => 'Otwell']
];

foreach ($persons as ['first' => $firstname, 'last' => $lastname]) {
     var_dump($firstname, $lastname);
} // =>
/*
string(6) "Rasmus"
string(7) "Lerdorf"
string(6) "Fabien"
string(9) "Potencier"
string(6) "Taylor"
string(6) "Otwell"
*/

// Extract
// Кроме описанного выше, в PHP существует еще один способ дестракчеринга, который на первый взгляд кажется проще. Вызов функции extract с переданным ассоциативным массивом приводит к тому, что создаются переменные с именами ключей, в которые записываются значения из массива.


$vars = [
  'color' => 'blue',
  'size'  => 'medium',
  'shape' => 'sphere'
];
extract($vars);

var_dump($color, $size, $shape); // => string(4) "blue" string(6) "medium" string(6) "sphere"

/*
Ни в одном другом популярном языке нет возможности создать переменные без явного определения переменных. Данный способ обладает массой недостатков и не рекомендуется к использованию. Перечислим их:

* Переменные всегда создаются для всех ключей массива. Они засоряют локальное окружение и могут приводить к ошибкам если пересекутся с названиями уже существующих переменных.
* Безопасность. Если содержимое массива приходит извне (из формы или базы данных), то есть потенциальная вероятность попадания в массив ключа, который приведет к перезаписыванию значения существующей переменной.
* Неявное создание переменных вообще само по себе странная вещь (и нигде не встречается!). Такой код значительно сложнее в анализе.
*/ 



>>>>>  Хеш-таблицы <<<<<<<

/*
Ассоциативный массив — абстрактный тип данных. У него есть и другие названия: «словарь», «мап». В разных языках ему соответствуют разные типы данных, названия которых имеют мало общего с названием ADT. Например:

Ruby - Hash
Lua - Table
Python - Dictionary
JS - Object
Elixir/Java - Map

Ассоциативный массив, в отличие от индексированного массива, нельзя положить в память «как есть». Непонятно, как хранить ключи и связывать их со значениями. Для реализации ассоциативных массивов используют, так называемые, хеш-таблицы.

Хэш-таблица — это структура данных, реализующая интерфейс ассоциативного массива. Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. Независимо от выбранного варианта, основа любой хеш-таблицы — индексированный массив, в котором и хранится вся информация и хеширование, о котором мы поговорим ниже. Остальная логика сводится к разрешению коллизий.

Хеширование
Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс массива. Именно так производятся все операции. Сначала вычисляется индекс на основе ключа, дальше туда либо записываются данные, либо читаются.

Преобразование ключа в индекс массива выполняется с помощью хеширования. Хеширование — операция, которая преобразует любые входные данные в строку фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой».

С хешированием мы встречаемся в разработке крайне часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 ни что иное, как хеш, полученный в результате хеширования.

Самый простой способ хешировать данные на PHP — использовать функцию crc32:
*/

$checksum = crc32('The quick brown fox jumped over the lazy dog.'); // => 2191738434
    
/*
И хотя хеширование позволяет отображать ассоциативный массив на обычный массив, оно не лишено недостатков, с которыми нужно уметь работать.

Коллизии
Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и состава). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат любой хешируемой функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

Из этого факта следует, что не для всех входных данных найдется уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.

Коллизии не так редки, как может показаться. Убедиться в этом можно изучив парадокс дней рождений (https://ru.wikipedia.org/wiki/Парадокс_дней_рождения).
*/



>>>>>  Массив и Ассоциативный Массив <<<<

/*
В PHP есть только один тип данных для массивов — Array. Его уникальность заключается в том, что с одной стороны он работает как обычный массив, а с другой — как ассоциативный. Зависит от того, как его используют.

Поначалу такой подход может подкупить своей кажущейся простотой, особенно тех, кто не имел дела с другими языками. Но чем дальше в код, тем больше проблем он приносит.

Самый простой пример — JSON. В JSON массив и ассоциативный массив — разные сущности. Если конвертировать JSON в массив, то эта информация теряется. Если мы не знаем структуру JSON, то у нас нет простого способа понять, что перед нами — массив или ассоциативный массив. В интернете с подобным сталкиваются постоянно и предлагают такой способ, как анализ ключей. Если они все числовые, то считаем, что массив, иначе — ассоциативный массив. Конвертация из массива в JSON сопряжена с такими же проблемами. Как понять, во что конвертировать переданный массив?

Другая проблема заключается в том, что достаточно легко ошибиться с типом массива и начать его использовать не по назначению:
*/

$data = [];
$data[] = 10;
$data['key'] = 'value';
$data[] = 'hi!';

// Первое удивление — код работает! Теперь попробуйте догадаться, что находится внутри $data.
 
print_r($data);

// => Array
// (
//     [0] => 10
//     [key] => value
//     [1] => hi!
// )

// Из этого вывода должно быть понятно, что индексированных массивов в PHP нет. Есть упорядоченные ассоциативные массивы, с операцией [] =: добавить элемент с автоматическим присвоением ключа.

$data = ['key' => 'value'];
$data[] = 'console';

// => Array
// (
//     [key] => value
//     [0] => console
// )

// Но самое неудобное — функции которые могут сохранять, а могут не сохранять ключи. Обычно в таких функциях есть дополнительный параметр флаг preserve_keys, который меняет описанное поведение. По сути в описании каждой функции, которая принимает на вход массив (или массивы) и возвращает массив, есть секция с пояснением, сохраняет ли ключи функция или нет, и как это поведение можно изменить.


// Реализуйте функцию, которая принимает на вход массив, состоящий из массивов-пар, и возвращает ассоциативный массив, полученный из этих пар.

fromPairs([['fred', 30], ['barney', 40]]); // → ['fred' => 30, 'barney' => 40]

function fromPairs(array $data)
{
     $result = [];
     foreach ($data as [$key, $value]) {
          $result[$key] = $value;
     }

     return $result;
}


// Реализуйте функцию, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

buildQueryString(['per' => 10, 'page' => 1 ]);
// → page=1&per=10

// Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).

function buildQueryString(array $array)
{
     $result = []; 
     ksort($array);
     
     foreach($array as $key => $value) {
          $result[] = "{$key}={$value}";
     }

     return implode('&', $result);
}


// Реализуйте функцию findWhere, которая принимает на вход массив (элементы которого - ассоциативные массивы) и пары ключ-значение (тоже в виде массива), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам.

findWhere(
     [
          ['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
          ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
          ['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
          ['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
          ['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
          ['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
     ],
     ['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]


function findWhere($data, $where) 
{
     foreach ($data as $item) {
          $find = true;
          foreach ($where as $key => $value) {
                if ($item[$key] !== $value) {
                     $find = false;
                }
          }
          if ($find) {
                return $item;
          }
     }
}


/*
Чанкованием (от англ. Chunk — ячейка, кусок, осколок) в программировании называют разбиение коллекции (массива) на несколько более мелких коллекций. Например, разобьём массив на чанки, так чтобы в каждом чанке было не более двух элементов: ['a', 'b', 'c', 'd'] -> [['a', 'b'], ['c', 'd']].

src\Arrays.php
Реализуйте функцию getChunked, которая принимает на вход массив и число, задающее размер чанка (куска). Функция должна вернуть массив, состоящий из чанков указанной размерности.
*/

getChunked(['a', 'b', 'c', 'd'], 2); // → [['a', 'b'], ['c', 'd']]
getChunked(['a', 'b', 'c', 'd'], 3); // → [['a', 'b', 'c'], ['d']]
getChunked( ['a', 'b', 'c', 'd', 'e', 'f'], 2)); // → [['a', 'b'] ['c', 'd'], ['e', 'f']]

// PS: Попробуйте реализовать это упражнение без использования встроенной в PHP функции array_chunk. То есть вам нужно написать свою реализацию данной функции.


function getChunked(Array $array, Int $size) 
{
     $result = [];
     for ($i = 0; $i < ceil(sizeof($array) / $size); $i++) { // ceil - округляет дробь в большую сторону
          $result[] = array_slice($array, $i * $size, $size);
     }

     return $result;
}


/*
Реализуйте функцию compareVersion, которая сравнивает переданные версии version1 и version2. Если version1 > version2, то функция должна вернуть 1, если version1 < version2, то - -1, если же version1 = version2, то - 0.

Версия - это строка, в которой два числа (мажорная и минорные версии) разделены точкой, например: 12.11. Важно понимать, что версия - это не число с плавающей точкой, а несколько чисел не связанных между собой. Проверка на больше/меньше производится сравнением каждого числа независимо. Поэтому версия 0.12 больше версии 0.2.
Пример порядка версий:
0.1 < 1.1 < 1.2 < 1.11 < 13.37
*/
compareVersion("0.1", "0.2"); // → -1
compareVersion("0.2", "0.1"); // → 1
compareVersion("4.2", "4.2"); // → 0

function compareVersion(String $first, String $second)
{
     $version1 = explode('.', $first);
     $version2 = explode('.', $second);

     if ($version1 > $version2) {
          return 1;
     } elseif ($version1 === $version2) {
          return 0;
     } else {
          return -1;
     }
}


/*
Вес Хэмминга это количество единиц в двоичном представлении числа.
Реализуйте функцию hammingWeight, которая считает вес Хамминга.
*/

hammingWeight(0); // → 0
hammingWeight(4); // → 1
hammingWeight(101); // → 4



function hammingWeight(int $num) // my
{
    // decbin — переводит число из десятичной системы счисления в двоичную
    // bindec — переводит двоичное число в десятичное
    $bin_str = (string) decbin($num);
    return substr_count($bin_str, '1'); // substr_count - возвращает число вхождений подстроки

}

function hammingWeight(Int $num) // hexlet
{
     $weight = 0;
     $digits = str_split(decbin($num));
     foreach ($digits as $value) {
          if ($value === '1') {
                $weight += 1;
          }
     }

     return $weight;
}


// Реализуйте функцию lengthOfLastWord, которая возвращает длину последнего слова переданной на вход строки. Словом считается любая последовательность, не содержащая пробелов.

lengthOfLastWord(''); // → 0

lengthOfLastWord('man in BlacK'); // → 5

lengthOfLastWord('hello, world!  '); // → 6

function lengthOfLastWord(String $str)
{
     $words = explode(' ', trim($str));
     return strlen(end($words));
}


// Реализуйте функцию summaryRanges, которая находит в массиве непрерывные возрастающие последовательности чисел и возвращает массив с их перечислением.

summaryRanges([1, 2, 3])); // → ["1->3"]
summaryRanges([0, 1, 2, 4, 5, 7]); // → ["0->2", "4->5"]
summaryRanges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5]); // → ['110->112', '-5->-4']


function summaryRanges(array $arr) // my
{
    $resOp = [];
    $rec = false;
    
    foreach ($arr as $key => $val) {
        if($key == 0) { continue; }
        if (!$rec && $arr[$key - 1] == $val - 1) {
            $beginningOfSequence = $arr[$key - 1];
            $rec = true;
        } elseif ($rec && $arr[$key - 1] != $val - 1) {
            $resOp[] = "$beginningOfSequence->".$arr[$key - 1];
            $rec = false;   
        } elseif($rec && $key == sizeof($arr) - 1) {
            $resOp[] = "$beginningOfSequence->{$val}";
        }
    }
    return $resOp;
}


function summaryRanges(Array $array) // hexlet
{
     $result = [];

     if (empty($array)) {
          return $array;
     }

     $firstValue = $array[0];
     $firstIndex = 0;
     foreach ($array as $index => $value) {
          if ($index === 0) {
                continue;
          }
          $expectedValue = $array[$index - 1] + 1;
          if ($expectedValue !== $value) {
                if ($firstIndex !== $index - 1) {
                     $result[] = "$firstValue->{$array[$index - 1]}";
                }
                $firstValue = $value;
                $firstIndex = $index;
          } elseif ($index === sizeof($array) - 1 && $expectedValue === $value) {
                $result[] = "$firstValue->{$array[$index]}";
          }
     }

     return $result;
}


// Реализуйте функцию getMirrorMatrix, которая принимает двумерный массив (матрицу) и возвращает массив, изменённый таким образом, что правая половина матрицы становится зеркальной копией левой половины, симметричной относительно вертикальной оси матрицы. Для простоты условимся, что матрица всегда имеет чётное количество столбцов и количество столбцов всегда равно количеству строк.

getMirrorMatrix([
  [11, 12, 13, 14],
  [21, 22, 23, 24],
  [31, 32, 33, 34],
  [41, 42, 43, 44],
]);

// → [
//     [11, 12, 12, 11],
//     [21, 22, 22, 21],
//     [31, 32, 32, 31],
//     [41, 42, 42, 41],
//   ]

function getMirrorMatrix(array $array)
{
     $size = sizeof($array);
     $mirrorArray = [];

     for ($i = 0; $i < $size; $i ++) {
          for ($j = 0; $j < $size / 2; $j ++) {
                $mirrorArray[$i][$j] = $array[$i][$j];
                $mirrorArray[$i][$size - $j - 1] = $array[$i][$j];
          }
     }

     return $mirrorArray;
}


/*
ДНК и РНК это последовательности нуклеотидов.
Четыре нуклеотида в ДНК это аденин (A), цитозин (C), гуанин (G) и тимин (T).
Четыре нуклеотида в РНК это аденин (A), цитозин (C), гуанин (G) и урацил (U).
Цепь РНК составляется на основе цепи ДНК последовательной заменой каждого нуклеотида:
G -> C
C -> G
T -> A
A -> U

Напишите функцию toRna, которая принимает на вход цепь ДНК и возвращает соответствующую цепь РНК (совершает транскрипцию РНК).
*/
toRna('ACGTGGTCTTAA'); // → 'UGCACCAGAAUU'

function toRna(String $nucleotide) 
{
     $map = [
          'G' => 'C',
          'C' => 'G',
          'T' => 'A',
          'A' => 'U',
     ];

     $length = strlen($nucleotide);
     $result = [];

     for ($i = 0; $i < $length; $i++) {
          $result[] = $map[$nucleotide[$i]];
     }

     return implode('', $result);
}


/*
Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов, имеющая треугольную форму. В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел. Строки треугольника симметричны относительно вертикальной оси.

0:      1
1:     1 1
2:    1 2 1
3:   1 3 3 1
4:  1 4 6 4 1

Напишите функцию generate, которая возвращает указанную строку треугольника паскаля в виде массива
Пример:
*/
generate(1); // → [1, 1]
generate(4); // → [1, 4, 6, 4, 1]

function generate(Int $rowNumber) // hexlet
{
    $currentRow = [1];
     
     for ($i = 0; $i < $rowNumber; $i++) {      
          $newRow = [];
          
          for ($j = 0; $j <= $rowNumber; $j++) {
                $first = isset($currentRow[$j - 1]) ? $currentRow[$j - 1] : 0;
                $second = isset($currentRow[$j]) ? $currentRow[$j] : 0;
                $newRow[$j] = $first + $second;
          }

          $currentRow = $newRow;
     }

     return $currentRow;
}


/*
В данном упражнении необходимо реализовать стековую машину, то есть алгоритм, проводящий вычисления по обратной польской записи.

Обратная польская нотация или постфиксная нотация — форма записи математических и логических выражений, в которой операнды расположены перед знаками операций. Выражение читается слева направо. Когда в выражении встречается знак операции, выполняется соответствующая операция над двумя ближайшими операндами, находящимися слева от знака операции. Результат операции заменяет в выражении последовательность её операндов и знак, после чего выражение вычисляется дальше по тому же правилу. Таким образом, результатом вычисления всего выражения становится результат последней вычисленной операции.

Например, выражение (1 + 2) * 4 + 3 в постфиксной нотации будет выглядеть так: 1 2 + 4 * 3 +, а результат вычисления: 15. Другой пример - выражение: 7 - 2 * 3, в постфиксной нотации: 7 2 3 * -, результат: 1.

Реализуйте функцию calcInPolishNotation, которая принимает массив, каждый элемент которого содержит число или знак операции (+, -, *, /). Функция должна вернуть результат вычисления по обратной польской записи.
*/

calcInPolishNotation([1, 2, '+', 4, '*', 3, '+']); // → 15
calcInPolishNotation([7, 2, 3, '*', '-']); // → 1



function calcInPolishNotation(Array $expr)
{
     $stack = [];
     foreach ($expr as $val) {
          if (is_int($val)) {
                array_push($stack, $val);
          } else {
              $endElemDel = array_pop($stack);
              $indexLastElem = sizeof($stack) - 1;
              switch ($val) {
                     case '*':
                          $stack[$indexLastElem] *= $endElemDel;
                          break; 
                     case '/':
                          $stack[$indexLastElem] /= $endElemDel;
                          break;
                     case '+':
                          $stack[$indexLastElem] += $endElemDel;
                          break;
                     case '-':
                          $stack[$indexLastElem] -= $endElemDel;
                          break;        
                }
          }
     }   
     return $stack[0];
}




>>>>>  Функции <<<<<<<

// Ранее, я показывал пример того, как в PHP работают с современными фреймворками:

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;

require 'vendor/autoload.php';

$app = new \Slim\App;
$app->get('/hello/{name}', function (Request $request, Response $response, array $args) {
     $name = $args['name'];
     $response->getBody()->write("Hello, $name");

     return $response;
});
$app->run();

// В этом коде еще много новых синтаксических конструкций, но я хочу заострить внимание только на одной. Обратите внимание на странное определение функции. Во-первых, у нее нет имени, а во-вторых, функция определяется в том месте, куда должен передаваться второй параметр функции get. Это так называемая анонимная или лямбда функция. Лямбда функции в PHP являются объектами первого рода. В свою очередь, функция get представляет из себя функцию высшего порядка.

/*
Основные понятия данного курса:
 * Детерминированность
 * Побочные эффекты
 * Splat operator
 * Объекты первого рода
 * Функции высшего порядка (map/filter/reduce)
 * Функциональное программирование

Не все из перечисленных тем и возможностей используются в повседневной жизни PHP разработчика (в других языках может быть совсем по-другому), но знать про них нужно. Во-первых, подходы, разбираемые в этом курсе, не являются специфичными для PHP. Зная их, вы гораздо легче сможете переключаться на другие языки. Особенно это касается JS, в котором используется сильно отличающийся от PHP стиль программирования. Во-вторых, работа с функциями, сильно прокачивает общий уровень разработчика.
*/



>>>>>  Чистые функции <<<<<<<

# Детерминированность

// Стандартная функция rand, вызванная без аргументов, возвращает некоторое случайное число.
rand(); // => 151273074
rand(); // => 1129177627

// Функция нужная и полезная, но неудобная в отладке и тестировании. Связано это с тем, что для одних и тех же входных аргументов (отсутствие аргументов так же попадает под это понятие), она может возвращать разные значения. Функции с таким поведением называются недетерминированными. К ним, в том числе, относятся функции, оперирующие системным временем.

// возвращает текущий год
date('Y'); // => 2018

/*
Хотя прямо сейчас повторный запуск вернет точно такое же значение, через год оно уже будет другим (2019). То есть недетерминированной функция считается в том случае, когда она ведет себя так хотя бы единожды.

Детерминированные функции, напротив, ведут себя предсказуемо. Для одних и тех же входных данных, они всегда выдают один и тот же результат. Именно такими являются функции в математике. Для одного и того же x результат работы функции y = f(x) будет один и тот же. Интересно то, что, например, функция print_r детерминированная. Дело в том, что она всегда возвращает одно и тоже значение для любых входных данных. Это значение true, а не то, что печатается на экран, как можно было бы подумать. Печать на экран - побочный эффект, о нем мы поговорим чуть позже.
*/

var_dump(print_r('lala')); // => bool(true)

/*
Понятие детерминированности играет огромную роль в администрировании, в задачах связанных с программной настройкой серверов (configuration managmenet), выкладкой ПО и обновлениями. Ключевые слова: docker, immutable infrastructure, ansible.

Функция становится недетерминированной и в том случае, если она обращается не только к своим аргументам, но и некоторым внешним данным, например глобальным переменным, переменным окружения и так далее. Так происходит потому, что внешние данные могут измениться, и функция начнет выдавать другой результат даже если в нее передаются одни и те же аргументы
*/

function getCurrentShell()
{
     // Функция getenv обращается к указанной переменной окружения
     return getenv('SHELL'); // => /bin/bash 
}

# Побочные эффекты 


// Вторая ключевая характеристика функций - наличие побочных эффектов. Побочным эффектом называют любые действия изменяющие среду выполнения. К ним относятся любые файловые операции, такие как запись в файл, отправка или прием данных по сети, даже вывод в консоль или чтение файла. Кроме того, побочными эффектами считаются обращения к глобальным переменным (как на чтение, так и запись) и изменение входных аргументов в случае, когда они передаются по ссылке. Вызов функции с побочными эффектами также считается побочным эффектом.

function sayHiTo($name)
{
     print_r("Hi, {$name}");
}

// С другой стороны, любые вычислительные операции не являются побочными эффектами. Например, функция, суммирующая два переданных аргументами числа.

function sum($num1, $num2)
{
     return $num1 + $num2;
}


// Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам.

print_r(2 ** 5);

/*
Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет тестирование и отладку. Приводит к возникновению огромного числа ошибок (только при работе с файлами количество возможных ошибок измеряется сотней, начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла). Для их предотвращения код обрастает большим числом проверок и защитных механизмов.

Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе, побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце.

Например, программа, которая конвертирует файл из текстового формата в pdf, в идеале выполняет ровно два побочных эффекта:

 * Читает файл в самом начале работе программы.
 * Записывает результат работы программы в новый файл.

Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Следовательно, побочные эффекты будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.

Инкремент и декремент — единственные базовые арифметические операции в PHP, которые обладают побочными эффектами (изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотловимым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет), а в JS стандарты кодирования предписывают их не использовать.
*/

# Чистые функции

/*
Идеальная функция с точки зрения удобства работы с ней называется чистой (pure). Чистая функция — это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведет себя предсказуемо. Такие функции на 100% соответствуют своим математическим аналогам и могут рассматриваться как математические функции.

Чистые функции обладают рядом ключевых достоинств:

 * Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
 * Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
 * Их легко комбинировать получая новое поведение без необходимости переписывать программу.

В хорошо спроектированных программах, побочные эффекты стараются изолировать в небольшой части приложения так, чтобы большая часть кода была чистой.
*/


// Реализуйте функцию sayPrimeOrNot, которая проверяет переданное число на простоту и печатает на экран yes или no.

sayPrimeOrNot(5); // => yes
sayPrimeOrNot(4); // => no


function isPrime(int $num)
{
     for ($i = 2; $i < $num; $i++) {
          if ($num % $i == 0) {
                return false;
          }
     }

     return true;
}

function sayPrimeOrNot($num)
{
     $text = isPrime($num) ? 'yes' : 'no';
     print_r($text);
}




>>>>>  Разделение команд и запросов <<<<<<<

/*
Command-query Separation (CQS) - принцип программирования, изобретенный Бертандом Майером, создателем языка Eiffel.

Он утвеждает, что каждая функция является либо командой которая выполняет действие (action), либо запрос (query) который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.
*/

# Команда

// Возвращает true или false как результат своего выполнения
save($user);


/*
Согласно принципу CQS, функция save является командой. Единственное что она может возвращать (опять же согласно принципу) - успешность своего выполнения, то есть true или false, либо null, как, например, в случае с print_r. Возврат этой функцией любых осмысленных данных, рассматривается как нарушение CQS. Однако, стоит сказать, что существуют ситуации в которых невозможно соблюсти этот принцип. Например открытие файла на запись возвращает файловый дескриптор (идентификатор через который происходят манипуляции с файлом).

Отделение команд от запросов тесно связано с идеями, описанными в уроке про чистые функции. Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторому выполнению действия (хотя их и можно сделать детерминированными, но как правило, такой код скрывает логические ошибки). Следовательно выделение запроса (возврата данных) из команды в отдельную функцию, помогает разделить более чистый код от не чистого. Запросы, как мы увидим позже, можно выполнять множество раз не боясь чего-либо сломать.
*/

$file = fopen('/etc/hosts', 'r');


# Запрос

// Возвращает true или false
isAdmin($user);

/*
Функция isAdmin - предикат, типичный запрос (query) или, можно даже сказать, вопрос, который звучит так "Пользователь администратор?" Такая функция, с точки зрения CQS, не может изменять состояние системы, например, поменять дату проверки на администоратора внутри пользователя или даже сделать пользователя администратором. Это противоречит не только CQS, но и здравому смыслу. В отличие от предыдущего примера, true и false в случае предкатов, это не успешность выполнения функции, а ответ на заданный вопрос. CQS имеет альтернативную формулировку, которая отлично характеризует код выше: "Задавая вопрос, не изменяй ответ". К запросам относятся и любые вычисления.
*/

$max = max([1, 30, 4]);


/*
Этот код не создает никаких побочных эффектов и детерминирован. Его можно вызывать сколько угодно раз без риска получить ошибку или неверный результат.

Отсутствие изменения в вопросах, очень важный принцип, который нужно соблюдать всегда. Даже на интуитивном уровне, ни один человек не ожидает, что проверка isAdmin или вычисление максимального числа в массиве, может выполнить какое-то деструктивное действие. С другой стороны, на практике, такой код иногда попадается и теперь вы знаете как правильно его исправить.
*/



>>>>> Упаковка аргументов <<<<<<<

// Сигнатура функции array_merge в документации определяется так:

array array_merge( array $array1 [, array $... ] )

// Она говорит нам о том, что в array_merge можно передать любое количество массивов:

array_merge([1]);
# => Array
# (
#     [0] => 1
# )
array_merge([1], [1]);
# => Array
# (
#     [0] => 1
#     [1] => 1
# )
array_merge([1], [1], [3, 4]);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )
array_merge([1], [1], [3, 4], []);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )

// С точки зрения вызова - ничего необычного, просто разное число аргументов. А вот определение функции с переменным числом аргументов выглядит необычно и использует незнакомый для нас синтаксис:

function sum(...$numbers)
{
     return array_sum($numbers);
}

echo sum(9, 4); // => 13
echo sum(-3, 0, 3, 1); // => 1

/*
Три точки представляют собой Splat Operator. В PHP на текущий момент он может использоваться только в определениях и вызовах функций (в других языках его можно использовать значительно шире, в том числе при дестракчиринге). Основная сложность для понимания состоит в том, что Splat Operator выполняет различные действия в зависимости от того, где он применяется. В определении функции он выполняет "упаковку" параметров, а при вызове - наоборот, "распаковку". Про упаковку параметров будем говорить в этом уроке. В следующем же уроке рассмотрим Splat Operator в роли распаковщика.

Итак, назначение Splat Operator в определении функции состоит в том, чтобы собрать в массив все переданные аргументы. Если в функцию не передается ни одного аргумента, то массив будет пустым.
*/

echo sum(); // => 0

// Обратите внимание на то, что этому оператору не важен тип аргументов, они все станут элементами массива, даже если мы передаем на вход функции массивы.

function show(...$arguments)
{
     print_r($arguments);
}

show([]);
# Array
# (
#     [0] => Array
#         (
#         )
#
# )

show([1, 3], [], 3);
# => Array
# (
#     [0] => Array
#         (
#             [0] => 1
#             [1] => 3
#         )
#
#     [1] => Array
#         (
#         )
#
#     [2] => 3
# )

// Теперь взглянем на сигнатуру array_merge еще раз:

array array_merge ( array $array1 [, array $... ] )

// Видно, что функция array_merge ждет на вход как минимум один массив, опциональны только следующие. Такого поведения можно добиться следующим кодом:

function sum($a, ...$numbers)
{
     return $a + array_sum($numbers);
}

echo sum();
// => PHP Fatal error:  Uncaught ArgumentCountError: Too few arguments to function sum(), 0 passed

echo sum(10); // => 10
echo sum(10, 4); // => 14
echo sum(8, 10, 4); // => 22

// Тоже можно сделать и для двух аргументов:

function sum($a, $b, ...$numbers)
{
     # ...
}

// Эту идею можно продолжать и дальше, делая обязательными то количество аргументов, которое требуется. Единственное ограничение: Splat Operator может быть использован только для последнего аргумента. То есть такой код синтаксически не верен:

function sum(...$numbers, $a)
{
     # ...
}

// и такой тоже:

function sum($a, ...$numbers, $a)
{
     # ...
}


// Реализуйте функцию average, которая возвращает среднее арифметическое всех переданных аргументов. Функция принимает на вход от одного числа и больше.

average(0); // => 0
average(0, 10); // => 5
average(-3, 4, 2, 10); // => 3.25

function average($num1,...$numbers)
{
    return (array_sum($numbers) + $num1) / (sizeof($numbers) + 1);
}



>>>>> Распаковка аргументов <<<<<<<

// Splat Operator в вызовах функций синтаксически идентичен Splat Operator в определениях, но выполняет обратное действие:

$arrayOfArrays = [
     [1, 2],
     [2, 3]
];

array_merge(...$arrayOfArrays);
# => Array
# (
#     [0] => 1
#     [1] => 2
#     [2] => 2
#     [3] => 3
# )

// Другими словами, Splat Operator раскладывает массив на аргументы. Количество аргументов, полученных Splat Operator, равно количеству элементов массива. По сути код выше преобразуется в вызов:

array_merge($arrayOfArrays[0], $arrayOfArrays[1]); // array_merge([1, 2], [2, 3]);

// Как и в случае с определением функций, Splat Operator может использоваться совместно с позиционными аргументами:

array_merge([3], ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 1
#     [2] => 2
#     [3] => 2
#     [4] => 3
# )


// Тоже самое справедливо и для большего количества аргументов:

$array = [3, 2];
array_merge([3], $array, ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 3
#     [2] => 2
#     [3] => 1
#     [4] => 2
#     [5] => 2
#     [6] => 3
# )

// И точно так же должен всегда оказываться последним аргументом.

array_merge(...$arrayOfArrays, [3, 2]); // => Fatal error: Cannot use positional argument after argument unpacking

// В PHP Splat Operator применяется не каждый день, но иногда бывает нужен, если аргументы оказываются записаны в массив.


// Реализуйте функцию union, которая находит объединение всех переданных массивов. Функция принимает на вход от одного массива и больше. Ключи исходных массивов не сохраняются (т.е. все значения итогового массива заново индексируются: 0, 1, 2, ...).

union([3]); // => [3]
union([3, 2], [2, 2, 1]); // => [3, 2, 1]
union(['a', 3, false], [true, false, 3], [false, 5, 8]); // => ['a', 3, false, true, 5, 8]

function union($first,...$rest)
{
    return array_values(array_unique(array_merge($first, ...$rest)));
} 



>>>>> Полезные функции для работы с коллекциями <<<<<<<

/*
Стандартная библиотека в PHP небогата функциями для работы с коллекциями, строками или датами. Этот недостаток можно восполнить, подключив стороннюю библиотеку. Например, в мире JS, есть стандарт де-факто, без которого не обходится практически ни один проект - lodash (https://lodash.com/). В PHP нет единого устоявшегося решения, но есть пачка небольших, которые используются в разных проектах. 

Объектные:

     Collect https://github.com/tightenco/collect
     Stringy https://github.com/danielstjules/Stringy
     Carbon https://github.com/briannesbitt/Carbon

Использующие только функции:

     Funct https://github.com/phpfunct/funct
     Bottomline https://github.com/maciejczyzewski/bottomline

Скажу сразу, что необходимость использования такой библиотеки в реальной работе возникает практически сразу. Те, кто не знает про них, постоянно пишут велосипеды. Еще не так давно программисты в PHP создавали файлики с полезными функциями и таскали их из одного проекта в другой. Хорошо, что эти времена уже прошли и можно не тратить время на то, что уже делалось тысячу раз до нас. Однако, мы не сможем разобрать все возможные функции в рамках наших курсов. Кое-что рассмотрим, но в дальнейшем не забывайте периодически просматривать их на наличие чего-либо полезного.

Обратите внимание на документацию указанных библиотек. Зачастую они повторяют те функции, которые уже встроены в сам язык. Делается это по разным причинам. Вот некоторые из них:

 * Консистентность (согласованность). Функции делают для того, чтобы библиотека была полной.
 * Исправление ошибок PHP. Некоторые функции в PHP по историческим причинам иногда ведут себя неверно.
 * Улучшение. Другой порядок аргументов, расширенные возможности, убранные ограничения или просто понятное имя.
*/


// Итак, поехали. Библиотека Funct.

# Collections

/*
last

Такая простая и нужная функция почему-то отсутствует в самом PHP.
*/

Collection\last([1, 2, 3]); // => 3

/*
rest

Принимает на вход массив и возвращает новый массив, в котором отсутствует первый элемент исходного.
*/

Collection\rest([5, 4, 3, 2, 1]); // => [4, 3, 2, 1]


/*
without

Возвращает копию массива, из которого удалены все значения, переданные в функцию вторым и последующими параметрами.
*/

Collection\without([1, 2, 1, 0, 3, 1, 4], 0, 1); // => [2, 3, 4]


/*
flattenAll

"Выпрямляет" вложенный массив, делая его плоским.
*/

Collection\flattenAll(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', 'c', 'd']

/*
union

Находит объединение множеств.
*/

Collection\union([1, 2, 3], [101, 2, 1, 10], [2, 1]); // => [1, 2, 3, 101, 10]


/*
findWhere($collection, $value)

Просматривает массив и возвращает первое значение, совпадающее по всем парам «ключ-значение», переданным вторым параметром.
*/

Collection\findWhere(
     [
          ['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
          ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
          ['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
          ['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
          ['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
          ['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
     ],
     ['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]



# Strings

/*
camelize

Принимает на вход строку и возвращает ее версию, записанную в camelCase нотации.
*/

Strings\camelize('data_rate'); //'dataRate'
Strings\camelize('background-color'); //'backgroundColor'
Strings\camelize('-moz-something'); //'MozSomething'
Strings\camelize('_car_speed_'); //'CarSpeed'
Strings\camelize('yes_we_can'); //'yesWeCan

/*
contains

Проверяет, включает ли строчка подстроку.
*/

Strings\contains('PHP is one of the best languages!', 'one'); // true

/*
endsWith

Проверяет, оканчивается ли строчка на подстроку.

*/

Strings\endsWith("hello jon", 'jon'); // => true


// функции для работы с массивами: http://php.net/manual/ru/ref.array.php


/*
Реализуйте функцию getSentenceType, которая принимает на вход текст, определяет его тип и возвращает наружу его название. Тип предложения определяется по последнему символу в тексте.

     ? - question
     ! - shouting
     Все остальное - common

Если передана пустая строчка, то функция должна вернуть null.
*/

getSentenceType(''); // => null;
getSentenceType('what?'); // => question
getSentenceType('wow!'); // => shouting
getSentenceType('haha'); // => common

$ composer require funct/funct // in Terminal - installation library 'funct'

function getSentenceType($sentence)
{
     if ($sentence === '') {
          return null;
     }

     $types = [
          '?' => 'question',
          '!' => 'shouting'
     ];
     $symbol = \Funct\Strings\right($sentence, 1);
     return array_key_exists($symbol, $types) ? $types[$symbol] : 'common';
}




>>>>> Объекты первого класса  <<<<<<<

/*
В языках программирования существует понятие «объекты первого рода (или класса)». Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным. К таким элементам относятся любые данные, например числа, строки, массивы или логические значения. Переменная под это понятие не попадает, объектом первого рода считаются те данные, которые лежат в переменной.
*/

$num = 5; // 5 - объект первого рода

$result = pow($num, 2) // 2 - объект первого рода, $result, $num - содержимое переменных объекты первого рода

// Описанное выше вы проделывали множество раз, и эту тему можно было бы не поднимать, если бы не одно «но». Функции тоже могут быть объектами первого рода:

$func = function () {
  echo "For hands of gold are always cold. But a woman's hands are warm";
};

$func();

// Мы привыкли к такому определению функций:

function greeting()
{
     // ...
}

// У функции есть имя, которое указывается после ключевого слова function, а сама конструкция является инструкцией (кстати, поэтому в конце нет точки запятой). Мы не можем написать так:

// переменная содержащая определение функции?
$fn = function greeting()
{
     // ...
}

// Так как определение функции - инструкция, то оно не может подставляться в те места, где ожидаются выражения. Присваивание как раз подразумевает то, что в правой части находится именно выражение. Соответственно, такой код падает с ошибкой. А следующий код уже работает.

$func = function () {
     echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Даже не вникая в синтаксис можно делать вывод о том, что конструкция справа от «равно» - выражение. И это выражение порождает функцию. В PHP подобные функции называют анонимными, потому что у них нет имени. Глядя на код выше нужно понимать, что определение функции и ее присваивание переменной - две разных операции. Чистое определение выглядит так:

function () {
     echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Очень похоже на обычную функцию за исключением отсутствия имени. Правда, есть еще и стилевые отличия, закрепленные стандартом PSR-2. В других языках анонимные функции нередко называют лямбда-функциями. В принципе, и в PHP их иногда зовут также.

$func();

/*
Имя переменной можно выбирать произвольно, в этом смысле анонимные функции никак не влияют на ситуацию. Более того, в отличие от именованных функций, которые будучи единожды созданными - никуда не изчезают в процессе жизни программы, анонимные функции постоянно создаются и пропадают вместе с переменными, в которые они записаны. Другими словами, анонимные функции всегда локальны относительно контекста и доступны там, где они были созданы если не предпринимать специальных мер по их возврату.

Анонимные функции подобно именованным могут принимать аргументы. В этом отношении поведение абсолютно идентично. Всё, что мы изучали до этого момента для именованных функций один в один работает и для анонимных.
*/

$sum = function ($a, $b) {
     return $a + $b;
}; // Определение анонимной функции должно заканчиваться символом ;, так как это выражение.

$sum(1, 4); // => 5

// А раз анонимная функция — выражение, мы можем определять ее в любом месте программы, допускающем использование выражений, например в теле другой функции!

function sum($a, $b)
{
     // определяем анонимную функцию
     $sum = function ($a, $b) {
          return $a + $b;
     };
     // вызываем анонимную функцию и возвращаем результат ее выполнения
     return $sum($a, $b);
}

sum(1, 4); // => 5

/*
Главное в коде выше не забыть поставить return и помнить, что $a и $b снаружи анонимной функции не связаны с переменными, имеющими те же имена внутри анонимной функции.

Думаю что сейчас в вашей голове возник вопрос «зачем все это? жили же как-то раньше и сейчас проживем». Анонимные функции появились в PHP не сразу, но все же появились. Их использование значительно повышает выразительные возможности языка, и в этом вы скоро убедитесь. Если же взять JS, то там анонимные функции составляют костяк любой программы. Функции, создающие функции, возвращающие функции и принимающие функции как аргументы - основной способ разрабатывать в JS.
*/

$square = function($num) {
    return $num ** 2;
};

$sumOfSquares = function($num1, $num2) use ($square) {
    return $squares($num1) + $squares($num2);
};


# Передача обычных функций

// Несмотря на то, что обычные функции в PHP не являются объектами первого рода, PHP может имитировать соответствующее поведение с помощью строк. Достаточно записать имя функции в переменную и вызвать ее.

$fn = 'strlen';
print_r($fn('clojure for brave')); // => 17

// Точно так же можно осуществить "передачу" функции в функцию.

function call(string $fn, $argument)
{
     return $fn($argument);
}

$result = call('strlen', 'haskell is power!');
print_r($result); // => 16


// Реализуйте анонимную функцию, которая принимает на вход строку и возвращает ее последний символ (или null если строка пустая). Запишите созданную функцию в переменную $last.

function run(string $text)
{
     $last = function (string $text) {
          if ($text === '') {
                return null;
          }
          return $text[strlen($text) - 1];
     };

     return $last($text);
}

// Анонимные функции: http://php.net/manual/ru/functions.anonymous.php



>>>>>  Функции высшего порядка  <<<<<<<

/*
Пока мы рассмотрели только одну возможность объектов первого рода применительно к функциям — присвоение переменной. Самое интересное начинается, когда мы передаем одни функции в другие функции.

За примерами далеко ходить не придется. Вспомним сортировку. В PHP есть функция sort, которая принимает на вход массив и сортирует его. Казалось бы, все отлично, и не о чем больше мечтать, но давайте вообразим себе ситуацию: на вход в программу приходит список пользователей, который нужно отсортировать по возрасту и вывести на экран.
*/

$users = [
     ['name' => 'Igor', 'age' => 19],
     ['name' => 'Danil', 'age' => 1],
     ['name' => 'Vovan', 'age' => 4],
     ['name' => 'Matvey', 'age' => 16],
];

/*
При таких условиях функция sort становится абсолютно бесполезной, потому что она может сортировать только списки примитивных типов данных. Но выше я описал только лишь одну из тысяч возможных ситуаций. Мы можем захотеть сортировать по любому параметру (или даже по набору параметров) и в любом порядке. Сортировки нужны часто, и многие из них довольно сложны. Худшее, что можно начать делать — реализовывать функцию sort под каждую ситуацию. Так что же делать? Если покопаться в документации PHP, то можно обнаружить функцию usort. Ее определение звучит так:

Сортирует массив по значениям, используя пользовательскую функцию для сравнения элементов
*/ 

bool usort ( array &$array , callable $value_compare_func )

/*
Эта функция сортирует элементы массива, используя для сравнения значений callback-функцию, предоставленную пользователем. Используйте эту функцию, если вам нужно отсортировать массив по какому-нибудь необычному признаку. Слово callback означает то, что наша задача — передать функцию (но не вызывать!), а вызывать ее будет функция usort.

Общая идея состоит в том, что нам не нужно реализовывать алгоритм сортировки каждый раз для каждой ситуации, ведь он не меняется. Все, что меняется — элементы, которые сравниваются между собой в процессе сортировки. И функция usort делегирует взаимодействие с этими элементами нам посредством анонимной функции.
*/

$users = [
  ['name' => 'Igor', 'age' => 19],
  ['name' => 'Danil', 'age' => 1],
  ['name' => 'Vovan', 'age' => 4],
  ['name' => 'Matvey', 'age' => 16],
];

usort($users, function ($a, $b) {
     if ($a['age'] == $b['age']) {
          return 0;
     }
     return $a['age'] > $b['age'] ? 1 : -1;
});

print_r($users);
// => [
//      ['name' => 'Danil', 'age' => 1],
//      ['name' => 'Vovan', 'age' => 4],
//      ['name' => 'Matvey', 'age' => 16],
//      ['name' => 'Igor', 'age' => 19],
//    ];

/*
Если элементы равны, то вы должны вернуть 0, если первый элемент больше второго, то считается, что они отсортированы правильно, и вы должны вернуть 1, иначе возвращается -1, а usort производит их сортировку.

Из кода выше видно, что внутри функции сравнение идет по свойству age переданных пользователей. Нетрудно догадаться, что эта функция вызывается внутри usort множество раз (а именно на каждое сравнение). Как только она начнет возвращать 1 для каждой пары элементов — сортировка завершена.

Функция usort относится к так называемым функциям высшего порядка (high order functions). Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают все сразу. Такие функции, как правило, реализуют некий обобщенный алгоритм (например, сортировку), а ключевую часть логики делегируют вам через анонимную функцию. Главный плюс от применения таких функций — серьезное повышение коэффициента повторного использования кода.
*/

function say(callable $fn) {
     echo $fn();
}

say(function () {
     return 'hi!';
}); // => hi!

/*
Функция say делает вызов функции, находящейся внутри переменной $fn. В нашем примере функция возвращает строку, которая тут же выводится на экран.

Функции высшего порядка настолько удобны в большинстве языков, что практически целиком могут заменить использование тех же циклов. Например, канонический код на JS выглядит так:
*/

const getJsFiles = dir => fs.readdirSync(dir)
  .filter(file => file.endsWith('js'))
  .map(file => path.resolve(dir, file));

/*
В этом коде присутствует 2 функции высшего порядка (filter и map), 3 анонимные функции и два прохода (это делают функции высшего порядка) по содержимому директории dir. Подобный код на PHP, с циклами и без, займет примерно в 4 раза больше строк даже при использовании специальных библиотек, упрощающих использование функций высшего порядка (это те же библиотеки, которые мы рассматривали в курсе). Связано это с многословностью синтаксиса PHP.

В следующих уроках мы рассмотрим три самые главные функции высшего порядка, которыми можно решать практически любые задачи. Две из них используются в примере выше, это map и filter, а третья — reduce (ее еще называют fold). Они все доступны в стандартной библиотеке PHP.
*/ 


// Реализуйте функцию takeOldest, которая принимает на вход список пользователей и возвращает самых взрослых. Количество возвращаемых пользователей задается вторым параметром, который по-умолчанию равен единице.

$users = [
     ['name' => 'Tirion', 'birthday' => '1988-11-19'],
     ['name' => 'Sam', 'birthday' => '1999-11-22'],
     ['name' => 'Rob', 'birthday' => '1975-01-11'],
     ['name' => 'Sansa', 'birthday' => '2001-03-20'],
     ['name' => 'Tisha', 'birthday' => '1992-02-27']
];

takeOldest($users);
# => Array (
#   ['name' => 'Rob', 'birthday' => '1975-01-11']
# )

// Для преобразования даты в unixtimetamp используйте функцию strtotime

// Описание:
firstN($collection, $n = 1)
Collection\firstN([1, 2, 3]); // => [1]
Collection\firstN([1, 2, 3], 2); // => [1, 2]


function takeOldest(array $users, int $count = 1)
{
     usort($users, function ($user1, $user2) {
          return strtotime($user1['birthday']) >= strtotime($user2['birthday']) ? 1 : -1; // strtotime - преобразует текстовое представление даты на английском языке в метку времени
     });

     return firstN($users, $count);
}



>>>>>  Отображение (map)  <<<<<<<
 
/*
Первая функция из золотой тройки называется map. Ее название переводится на русский как "отображение", что точно отражает суть выполняемой операции. Если в программировании говорят об отображении, то всегда подразумевают функцию map. Ее можно найти практически в любом языке, и везде это будет одна и та же операция. В PHP она имеет немного отличающееся название - array_map.

Попробуем прийти к этой функции через примеры. Возьмем список пользователей из предыдущего урока и извлечем из него имена всех пользователей.
*/

$users = [
     ['name' => 'Igor', 'age' => 19], 
     ['name' => 'Danil', 'age' => 1],
     ['name' => 'Vovan', 'age' => 4],
     ['name' => 'Matvey', 'age' => 16],
];

$result = [];
foreach ($users as ['name' => $name]) {
     $result[] = $name;
}
print_r($result); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

// Здесь мы видим обычную агрегацию с использованием foreach. А что, если нам понадобится извлечь возраст? Повторяем:

$result = [];
foreach ($users as ['age' => $age]) { // destructuring
     $result[] = $age;
}
print_r($result); // => [19, 1, 4, 16]

/*
В примерах выше легко увидеть закономерность. Выполняется один и тот же проход по циклу, и результат собирается в переменную $result. Единственное, что меняется — значение, которое мы извлекаем из элементов исходного массива. Именно этот паттерн называется отображением.

Теперь посмотрим как выполнить ту же самую операцию, используя array_map:
*/

$names = array_map(function ($user) {
     return $user['name'];
}, $users);

print_r($names); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

/*
array_map принимает первым параметром анонимную функцию и вторым — коллекцию, которая будет отображаться. Дальше внутри себя array_map делает перебор элементов переданной коллекции и для каждого элемента вызывает ту самую анонимную функцию. На вход этой функции передается элемент исходного массива, а ее результат записывается в новый массив, который и возвращается наружу. Некоторые замечания относительно функции array_map (они относятся в принципе к операции отображения):

 * Возвращаемый массив всегда такого же, размера как и исходный. array_map "отображает" каждый элемент исходного массива в элемент возвращаемого.
 * Внутри анонимной функции можно выполнять любые вычисления, а не только возвращать часть исходного элемента.
 * array_map полностью скрывает от нас наличие обхода и процесс сборки нового массива.
Типичный пример, который любят приводить в документации функции к map разных языков программирования, применение некоторой арифметической операции к каждому элементу коллекции.
*/

$numbers = [5, 2, 3];

$newNumbers = array_map(function ($number) {
     // возводим в квадрат каждое число
     return $number ** 2;
}, $numbers);

print_r($newNumbers); // => [25, 4, 9]


# Реализация

function myMap(callable $callback, $coll)
{
     $result = [];
     foreach ($coll as $item) {
          $result[] = $callback($item);
     }
     return $result;
}

/*
Главное отличие кода функции myMap от ручного обхода массива заключается в том, что функция myMap не знает, что нужно сделать с каждым элементом массива, поэтому она принимает первым аргументом функцию, которую вызывает для каждого элемента исходного массива, а результат вызова записывается в выходной массив. Чем будет этот результат, функция myMap не знает, и ей этого знать не нужно. Ответственность за обработку лежит на пользователях.


Реализуйте функцию getChildren, которая принимает на вход список пользователей и возвращает плоский список их детей. Дети каждого пользователя хранятся в виде массива в ключе children
*/

$users = [
     ['name' => 'Tirion', 'children' => [
          ['name' => 'Mira', 'birdhday' => '1983-03-23']
     ]],
     ['name' => 'Bronn', 'children' => []],
     ['name' => 'Sam', 'children' => [
          ['name' => 'Aria', 'birdhday' => '2012-11-03'],
          ['name' => 'Keit', 'birdhday' => '1933-05-14']
     ]],
     ['name' => 'Rob', 'children' => [
          ['name' => 'Tisha', 'birdhday' => '2012-11-03']
     ]],
];

getChildren($users);
// [
//     ['name' => 'Mira', 'birdhday' => '1983-03-23'],
//     ['name' => 'Aria', 'birdhday' => '2012-11-03'],
//     ['name' => 'Keit', 'birdhday' => '1933-05-14'],
//     ['name' => 'Tisha', 'birdhday' => '2012-11-03']
// ]


// Описание:
Collection\flatten(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', ['c', ['d']]]
Collection\flatten(['a', ['b', ['c', ['d']]]], 2); // => ['a', 'b', 'c', ['d']]
Collection\flatten(['a', ['b', ['c', ['d']]]], 3); // => ['a', 'b', 'c', 'd']



function getChildren(array $users)
{
     $children = array_map(function ($user) {
          return $user['children'];
     }, $users);

     return flatten($children);
}

// без flatten:
[ 
   [['name' => 'Mira','birdhday' => 1983-03-23]],
   [[]],
   [
      ['name' => 'Aria', 'birdhday' => '2012-11-03'],
      ['name' => 'Keit', 'birdhday' => '1933-05-14']
   ],
   [['name' => 'Tisha', 'birdhday' => '2012-11-03']] 
]



>>>>>  Фильтрация (filter) <<<<<<<

// Следующая операция называется "фильтрация" и выполняется она в PHP с помощью функции array_filter (в других языках ее называют просто filter или select). Операция "фильтрация", по отношению к коллекции, означает что мы удаляем из нее нежелательные элементы.

$users = [
     ['name' => 'Igor', 'age' => 19],
     ['name' => 'Danil', 'age' => 1],
     ['name' => 'Vovan', 'age' => 4],
     ['name' => 'Matvey', 'age' => 16],
];

$result = [];
foreach ($users as $user) {
     if ($user['age'] > 10) {
          $result[] = $user;
     }
}
print_r($result);
// => Array
// (
//     [0] => Array
//         (
//             [name] => Igor
//             [age] => 19
//         )
//
//     [1] => Array
//         (
//             [name] => Matvey
//             [age] => 16
//         )
//
// )


/*
Фильтрация встречается так же часто как отображение, а возможно и чаще. Общая схема кода при фильтрации практически один в один как и в отображении, кроме пары ключевых моментов:

 * Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано) либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошел.
 * Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил список пользователей, то список пользователей будет и на выходе.

Теперь посмотрим как выглядит фильтрация при использовании функции высшего порядка array_filter.
*/

// Порядок аргументов обратный. Сначала коллекция, затем функция.
$users = array_filter($users, function ($user) {
     return $user['age'] > 10;
});

// В отличие от array_map, функция, которая передается в array_filter должна быть предикатом. То есть ее задача вернуть либо true либо false для каждого элемента коллекции. Ее возврат никак не используется, он всего лишь говорит о том, включать ли текущий элемент в итоговый массив либо нет. Новички часто делают ошибку на этом этапе и начинают возвращать из фильтра то, что они бы хотели увидеть в результирующем массиве (для этого надо применять array_map).

#Реализация

function myFilter($coll, callable $callback)
{
     $result = [];
     foreach ($coll as $key => $item) {
          if ($callback($item)) { // Предикат используется только для проверки
                $result[$key] = $item; // В результат всегда добавляется элемент исходной коллекции
          }
     }
     return $result;
}

// Обратите внимание на то, что array_filter сохраняет ключи. При работе с индексированными массивами такое поведение нежелательно, поэтому придется использовать функцию !!! array_values для сброса порядка.



/**
Реализуйте функцию getGirlFriends, которая принимает на вход список пользователей и возвращает плоский список подруг всех пользователей (без сохранения ключей). Друзья каждого пользователя хранятся в виде массива в ключе friends. Пол доступен по ключу gender и может принимать значения male или female.
**/

$users = [
     ['name' => 'Tirion', 'friends' => [
          ['name' => 'Mira', 'gender' => 'female'],
          ['name' => 'Ramsey', 'gender' => 'male']
     ]],
     ['name' => 'Bronn', 'friends' => []],
     ['name' => 'Sam', 'friends' => [
          ['name' => 'Aria', 'gender' => 'female'],
          ['name' => 'Keit', 'gender' => 'female']
     ]],
     ['name' => 'Rob', 'friends' => [
          ['name' => 'Taywin', 'gender' => 'male']
     ]],
];

getGirlFriends($users);
# => Array (
#      ['name' => 'Mira', 'gender' => 'female'],
#      ['name' => 'Aria', 'gender' => 'female'],
#      ['name' => 'Keit', 'gender' => 'female']
# )


function getGirlfriends(array $users)
{
     $friends = array_map(function ($user) {
          return $user['friends'];
     }, $users);

     $friends = flatten($friends);

     $girlfriends = array_filter($friends, function ($user) {
          return $user['gender'] === 'female';
     });
     return array_values($girlfriends);
}



>>>>>   Агрегация (reduce)  <<<<<<<

/*
Последняя функция из нашей тройки - array_reduce используется для агрегации (название в других языках accumulate, fold или, по-русски, "свертка"). Она устроена немного сложнее, чем map и filter, но, в целом, сохраняет общий подход с передачей функции.

Как обычно, начнем с примера на циклах. Реализуем код, находящий самого взрослого пользователя.
*/

$users = [
     ['name' => 'Igor', 'age' => 19],
     ['name' => 'Danil', 'age' => 4],
     ['name' => 'Vovan', 'age' => 4],
     ['name' => 'Matvey', 'age' => 16],
];

$oldest = $users[0];
foreach ($users as $user) {
     if ($user['age'] > $oldest['age']) {
          $oldest = $user;
     }
}

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может быть любой тип данных, как примитивный так и составной, например, массив. Кроме того, агрегация нередко подразумевает инициализацию начальным значением. В примере выше она выполняется на строчке $oldest = $users[0];.

Посмотрим еще один пример агрегации: группировка имен пользователей по возрасту.
*/

$users = [
     ['name' => 'Igor', 'age' => 19],
     ['name' => 'Danil', 'age' => 4],
     ['name' => 'Vovan', 'age' => 4],
     ['name' => 'Matvey', 'age' => 16],
];

$usersByAge = [];
foreach ($users as $user) {
     if (!array_key_exists($user['age'], $usersByAge)) {
          $usersByAge[$user['age']] = [];
     }
     $usersByAge[$user['age']][] = $user['name'];
}

print_r($usersByAge);
# => Array
# (
#     [19] => Array
#         (
#             [0] => Igor
#         )
#
#     [4] => Array
#         (
#             [0] => Danil
#             [1] => Vovan
#         )
#
#     [16] => Array
#         (
#             [0] => Matvey
#         )
#
# )

/*
В этом примере результатом агрегации становится массив массивов, который в самом начале инициируется пустым массивом. Значение, которое накапливает результат агрегации, принятно называть словом "аккумулятор". В примерах выше это $oldest и $usersByAge.

Реализуем первый пример используя array_reduce.
*/

$oldest = array_reduce($users, function ($acc, $user) {
     return $user['age'] > $acc['age'] ? $user : $acc;
}, $users[0]);  

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Функция array_reduce принимает на вход три параметра. Два из них уже традиционны - это коллекция и функция-обработчик, а вот третьим выступает начальное значение аккумулятора. Поиск самого взрослого пользователя аналогичен поиску максимального (или минимального) числа в массиве. Соответственно, аккумулятор должен быть инициализирован первым пользователем. Этот же аккумулятор возвращается наружу.

Анонимная функция, передаваемая в array_reduce - самая важная часть и ключ к пониманию работы всего механизма агрегации. Она принимает на вход два значения. Первый - текущее значение аккумулятора, второй - текущий обрабатываемый элемент. Задача функции - вернуть новое значение аккумулятора. array_reduce никак не анализирует содержимое аккумулятора. Всё, что она делает, передает его в каждый новый вызов до тех пор, пока не будет обработана вся коллекция, и в конце концов вернет его наружу. Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.

Второй пример с использованием array_reduce выглядит так:
*/

$usersByAge = array_reduce($users, function ($acc, $user) {
     if (!array_key_exists($user['age'], $acc)) {
          $acc[$user['age']] = [];
     }
     $acc[$user['age']][] = $user['name'];

     return $acc;
}, []);
print_r($usersByAge);

function getMensCountByYear($users) 
{
    $dates = array_reduce($users, function ($acc, $user) {
        $year = date('Y', strtotime($user['date']));

        if (!array_key_exists($year, $acc)) {
            $acc['year'] = 1;
        } else {
            $acc['year']++;
        }

        return $acc;
    }, []);
    
}

// Код практически не изменился, за исключением того, что ушел цикл и появился возврат аккумулятора из анонимной функции.


# Реализация

function getMensCountByYear(array $users)
{
     $menfolk = array_filter($users, function ($user) {
          return $user['gender'] === 'male';
     });

     $years = array_map(function ($user) {
          return date('Y', strtotime($user['birthday']));
     }, $menfolk);

     return array_reduce($years, function ($acc, $year) {
          if (!array_key_exists($year, $acc)) {
                $acc[$year] = 1;
          } else {
                $acc[$year] += 1;
          }

          return $acc;
     }, []);
}

function myReduce($coll, callable $callback, $init = null)
{
     $acc = $init;
     foreach ($coll as $item) {
          $acc = $callback($acc, $item); // Заменяем старый аккумулятор новым
     }
     return $acc;
}


// array_reduce - очень мощная функция. Формально, можно работать, используя одну лишь ее, так как она может заменить и отображение и фильтрацию. Но делать так не стоит. Агрегация управляет состоянием (аккумулятором) явно. Такой код всегда сложнее и требует больше действий. Поэтому, если задачу возможно решить отображением или фильтрацией, то так и нужно делать.



// Реализуйте функцию getMensCountByYear, которая принимает на вход список пользователей и возвращает массив, в котором ключ это год рождения, а значение это количество мужчин, родившихся в этот год.

$users = [
     ['name' => 'Bronn', 'gender' => 'male', 'birthday' => '1973-03-23'],
     ['name' => 'Reigar', 'gender' => 'male', 'birthday' => '1973-11-03'],
     ['name' => 'Eiegon',  'gender' => 'male', 'birthday' => '1963-11-03'],
     ['name' => 'Sansa', 'gender' => 'female', 'birthday' => '2012-11-03'],
     ['name' => 'Jon', 'gender' => 'male', 'birthday' => '1980-11-03'],
     ['name' => 'Robb','gender' => 'male', 'birthday' => '1980-05-14'],
     ['name' => 'Tisha', 'gender' => 'female', 'birthday' => '2012-11-03'],
     ['name' => 'Rick', 'gender' => 'male', 'birthday' => '2012-11-03'],
     ['name' => 'Joffrey', 'gender' => 'male', 'birthday' => '1999-11-03'],
     ['name' => 'Edd', 'gender' => 'male', 'birthday' => '1973-11-03']
];

getMensCountByYear($users);
# => Array (
#     1973 => 3,
#     1963 => 1,
#     1980 => 2,
#     2012 => 1,
#     1999 => 1
# );

function getMensCountByYear($users) // my
{

    return array_reduce($users, function ($acc, $user) {
        $year = date('Y', strtotime($user['birthday']));

        if ($user['gender'] == 'male') {
            array_key_exists($year, $acc) ? $acc["$year"]++ : $acc["$year"] = 1;
        }

        return $acc;
    }, []);
}

function getMensCountByYear(array $users) // hexlet
{
     $menfolk = array_filter($users, function ($user) {
          return $user['gender'] === 'male';
     });

     $years = array_map(function ($user) {
          return date('Y', strtotime($user['birthday']));
     }, $menfolk);

     return array_reduce($years, function ($acc, $year) {
          if (!array_key_exists($year, $acc)) {
                $acc[$year] = 1;
          } else {
                $acc[$year]++;
          }

          return $acc;
     }, []);
}



>>>>>  Сигналы  <<<<<<<

/*
Пример с usort хорошо демонстрирует важность и удобство функций высшего порядка для решения повседневных задач. Описав алгоритм один раз, мы можем получать различные варианты поведения специфицируя их функциями. Тоже самое относится к рассмотренным функциям map, filter и reduce. Но есть еще один важный аспект, который требует рассмотрения.

Типичный код на PHP выглядит так. Делается один цикл внутри которого выполняются сразу все операции и в конце получается некоторый интересующий нас результат. Ничего криминального, но такой код может быть сложен для анализа, потому что требует держать в голове сразу все операции. С другой стороны, при использовании функций высшего порядка принято разделять задачу на подзадачи и выполнять их последовательно друг за другом выстраивая в цепочку операций.

Предположим что мы пишем функцию, которая принимает на вход список путей файловой системы, находит среди них файлы с расширением php без учета регистра и возвращает имена этих файлов. Для решения этой задачи нам понадобятся следующие функции:


 * is_file - проверяет что переданный путь это реально существующий файл
 * pathinfo - позволяет извлекать расширение из имени файла
 * basename - извлекает имя файла из полного пути
*/

function getPHPFileNames(array $paths)
{
     $result = [];
     foreach ($paths as $path) {
          $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
          if (is_file($path) && $extension === 'php') {
                $result[] = basename($path);
          }
     }

     return $result;
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
print_r($names);
# => Array
# (
#     [0] => index.php
#     [1] => wop.PHP
# )

/*
В примере выше типовое решение с использованием цикла. Его алгоритм можно описать так:

 * Просматриваем каждый путь
 * Если текущий путь файл и его расширение php без учета регистра то добавляем в результирующий массив

Если попытаться тоже самое реализовать используя функцию array_reduce, то на выходе получится код идентичный решению на циклах. Но если хорошо подумать, то можно увидеть что эта задача распадается на две: фильтрацию и отображение.
*/

function getPHPFileNames(array $paths)
{
     // фильтруем оставляя только подходящие пути
     $phpFiles = array_filter($paths, function ($path) {
          $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
          return is_file($path) && $extension === 'php';
     });

     // извлекаем из оставшихся путей имена файлов и возвращаем их наружу
     return array_map(function ($path) {
          return basename($path);
     }, $phpFiles);
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
print_r($names);


/*
Код получился чуть короче (без учета комментариев), но и многословнее (это исключительно особенность php), но главное не его размер. С увеличением количества операций и их сложности, код разбитый таким образом читается и анализируется значительно проще, так как каждая операция выполняется независимо для всего набора сразу. В голове приходится держать меньше деталей и можно сразу увидеть то, как операция влияет на все данные. Однако, научиться правильно разбивать задачу на подзадачи не так просто, как может показаться в начале. 

Сама возможность такого разбиения основывается на простой идее, которую иногда называют "стандартные интерфейсы". Заключается он в том, что на входе и выходе из функций ожидается один и тот же тип данных, в нашем случае, массив. Это позволяет соединять функции и строить цепочки выполняющие большое количество разных задач, без необходимости реализовывать новые функции. Рассмотренные ранее операции: отображение, фильтрация и агрегация, комбинируясь друг с другом позволяют решать подавляющее число задач по обработке коллекций. С чем-то подобным мы все встречались в своей жизни, когда собирали конструкторы Lego. Небольшое число примитивных деталей за счет одинаковых соединений позволяют строить конструкции практически неограниченной сложности.

Кстати, подобные цепочки нередко заканчиваются на агрегации, так как агрегация почти всегда выполняется в конце и сводит коллекцию к некоторому значению.

Для сравнения я покажу задачу выше, реализованную на JS.
*/

const getPHPFileNames = paths => paths
  .filter(filepath => fs.lstatSync(fullPath).isFile())
  .filter(filepath => path.extname(filepath).toLowerCase() === '.php')
  .map(filepath => path.basename(filepath));

const names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
console.log(names); 


// Понятно, что он слишком непривычный, но ухватить фильтры и мапы внутри него не так сложно, да и в целом понять смысл того что происходит. Заметьте, что здесь я разбил фильтр на два. Учитывая лаконичность определения функции в js, гораздо лучше разбивать проверки на большее число фильтров чем делать один сложный фильтр.

# Производительность

/*
За кадром остался вопрос производительности. Возможно, кто-то из вас догадался, что на каждый вызов функции, обрабатывающей коллекцию, мы получаем проход по всему списку. Чем больше таких функций, тем больше проходов. Казалось бы код замедляется, зачем так делать? На практике дополнительные проходы практически никогда не проблема. Задачи, в которых требуется одномоментная обработка десятков и сотен тысяч элементов, встречаются крайне редко. Большая часть операций происходит со списками до тысяч элементов. А для такого списка одним проходом больше одним меньше - разницы, можно сказать, никакой.

Но это не вся правда. На самом деле, существуют специальные коллекции, которые в момент вызова функций фильтрации, отображения и т.п. не выполняют операции сразу. Они накапливают необходимые действия, а во время первого использования выполняют сразу все одним проходом. Это так называемые «ленивые коллекции».
*/

// Реализуйте функцию getFreeDomainsCount, которая принимает на вход список емейлов, а возвращает количество емейлов, расположенных на каждом бесплатном домене. Список бесплатных доменов хранится в константе FREE_EMAIL_DOMAINS.

$emails = [
     'info@gmail.com',
     'info@yandex.ru',
     'info@hotmail.com',
     'mk@host.com',
     'support@hexlet.io',
     'key@yandex.ru',
     'sergey@gmail.com',
     'vovan@gmail.com',
     'vovan@hotmail.com'
];

const FREE_EMAIL_DOMAINS = [
     'gmail.com', 'yandex.ru', 'hotmail.com'
];

getFreeDomainsCount($emails);
# => Array (
#     'gmail.com' => 3
#     'yandex.ru' => 2
#     'hotmail.com' => 2
#  )


function getFreeDomainsCount(Array $mails) // my
{
    return array_reduce($emails, function ($acc, $mail) {
        $domen = explode('@', $mail)[1];
        if (in_array($domen, FREE_EMAIL_DOMAINS) ) {
            array_key_exists($domen, $acc) ? $acc[$domen]++ : $acc[$domen] = 1;
        }

        return $acc;
    }, []);
}

function getFreeDomainsCount(array $emails) // hexlet
{
     $domains = array_map(function ($email) {
          return explode('@', $email)[1];
     }, $emails);

     $freeDomains = array_filter($domains, function ($domain) {
          return in_array($domain, FREE_EMAIL_DOMAINS);
     });


     return array_reduce($freeDomains, function ($acc, $domain) {
          if (!array_key_exists($domain, $acc)) {
                $acc[$domain] = 1;
          } else {
                $acc[$domain] += 1;
          }

          return $acc;
     }, []);
}




>>>>>  Полезные функции высшего порядка  <<<<<<<

// Библиотека Funct, которую мы рассматривали ранее, кроме обычных функций содержит функции высшего порядка. В этом уроке мы рассмотрим некторые из них, которые могут быть полезными в будущем. 


# partition($collection, callable $callback)

// Разбивает массив на два на основании предиката. Те элементы, которые удовлетворяют предикату, попадают в первый массив, другие - во второй.

[$first, $second] = Collection\partition([1, 2, 3, 4, 5, 6, 7, 8, 9], function ($num) {
  return $num % 2 === 0;
}); // => [[2, 4, 6, 8], [1, 3, 5, 7, 9]]

print_r($first); // => [2, 4, 6, 8]
print_r($second); // => [1, 3, 5, 7, 9]


# every($collection, callable $callback = null)

// Возвращает true если каждый элемент коллекции удовлетворяет предикату. По умолчанию проверяет на истинность (== true).

Collection\every([true, 1, null, 'yes']); // => false
Collection\every([true, 1, 'yes']); // => true
Collection\every(
     [2, 4, 6],
     function ($value) {
          return ($value % 2) === 0;
     }
); // => true


# groupBy($collection, callable $callback)

// Группирует элементы коллекции в множества на основании ключа, полученного в результате вызова колбека.

Collection\groupBy([1.3, 2.1, 2.4], function($num) {
     return floor($num);
}); // => [1 => [1.3], 2 => [2.1, 2.4]]


# minValue($collection, callable $callback)

// Возвращает минимальный элемент коллекции на основании результата переданной функции.

Collection\minValue(
     [
          10 => [
                'title' => 'a',
                'size'  => 1
          ],
          20 => [
                'title' => 'b',
                'size'  => 2
          ],
          30 => [
                'title' => 'c',
                'size'  => 3
          ]
     ],
     function ($item) {
          return $item['size'];
     }
);

# => Array (
#    'title' => 'a',
#    'size'  => 1
# )



 
>>>>>  Замыкание <<<<<<<

// Начнем урок с небольшого повторения пройденного материала. Каждая функция создает так называемую область видимости. Внутри этой области доступны только те переменные, которые были определены там же. Все что снаружи - по-умолчанию невидимо.

$age = 5;

function generate()
{
     print_r($age);
}

generate();

// Этот код выдаст предупреждение PHP Notice: Undefined variable: age. Переменная $age определена вне контекста функции и невидима внутри. Точно такое же поведение и у анонимных функций.

$age = 5;

$generate = function () {
     print_r($age);
};

$generate(); // PHP Notice:  Undefined variable: age

// Но передача аргументов все же возможна, и делается она благодаря "замыканию". С помощью этого механизма можно "захватить" переменные из внешнего окружения и использовать их внутри. Правда, только для анонимных функций. Термином "замыкание", нередко называют и саму функцию, которая осуществила захват внешних переменных.

$age = 5;

$generate = function () use ($age) {
     print_r($age);
};

$generate(); // 5

// Захват переменных осуществляется с помощью ключевого слова use и списка переменных, который идет после этого слова. Крайне важно осознать, что use используется при определении функции, а не ее вызове. Может возникнуть закономерный вопрос, зачем это делать, если переменные можно передать в сам вызов.

$age = 5;

$generate = function ($age) {
     print_r($age);
};

$generate($age); // 5

/*
Замыкания полезны в тех случаях, когда функция определяется в одном месте, а используется в совершенно другом. Замыкание позволяет не таскать за собой гору переменных. А в некоторых ситуациях без них просто не обойтись. Вспомните функцию without из пакета Funct. Эта функция принимает на вход массив и значение, а возвращает новый массив полученный фильтрацией старого по переданному значению. Его реализация, построенная на функциях высшего порядка, подразумевает фильтрацию. Сложность возникает при описании предиката, ведь внутри анонимной функции нужно сравнивать текущее значение и переданный элемент. Замыкание позволяет решить эту задачу просто.
*/

function without(array $items, $value)
{
     $filtered = array_filter($items, function ($item) use ($value) {
          return $item !== $value;
     });
     // !!! Сбрасываем ключи
     return array_values($filtered);
}

without([3, 4, 10, 4, 'true'], 4); // => [3, 10, 'true']

/*
Без добавления use ($value) ничего не получится. $value не виден внутри анонимной функции.
В замыкание можно передать данные по ссылке, что позволит их менять внутри. Но делать так никогда не стоит. Подобное использование создает невероятно сложный в отладке и сопровождении код. Единственная причина, по которой можно использовать передачу по ссылке - рекурсия внутри анонимной функции. 
*/



>>>>> Парадигмы программирования <<<<<<<

/*
В программировании часто используется термин "парадигма".

Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Парадигма — это больше, чем просто другой алгоритм решения задачи. Как правило, структура кода при использовании разных парадигм отличается очень значительно и требует знаний, выходящих за рамки только синтаксиса языка (например, автоматное программирование требует хотя бы базового понимания теории автоматов). Причем подавляющее большинство современных (и не очень) языков программирования являются мультипарадигменными и позволяют писать код используя множество стилей. Иногда эти стили взаимоисключающие, иногда они дополняют друг друга. К текущему моменту мы писали код используя две парадигмы: императивную и декларативную.


# Императивная парадигма

Императивная парадигма - стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных. Возможно, данное определение звучит страшно, но на практике императивный стиль является доминирующим. Не считая этого курса, весь остальной код мы писали именно в императивном стиле.

Императивная (КАК) Программа - набор инструкций изменяющих состояние (данные). Примеры: Процедурное, ООП

> Циклы
> Присваивание

Декларативная (ЧТО) Программа - спецификация описывающая решение задачи. Примеры: Логическое, Функциональное

> Функции как объекты первого класса
> Рекурсия
> Неизменяемые данные

Функции первого класса можно передавать в качестве аргументов другим функциям, возвращать их как результат других функций, присваивать их переменным или сохранять в структурах данных. Функция высшего порядка — функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

Мультипарадигменные Scala, F#, Ocaml
Императивные Ruby, PHP, Python, C, C++, C#, Perl, Java, Kotlin, Swift, Javascript
Функциональные Haksell, Erlang
Логические Prolog

Лямбда-исчисление - формальная система, разработнная американским математиком Алонзло Чёрчем, для формализации и анализа понятия вычисляемости. Первоначально было реализовано на языке Lisp (1958г.)

Литерал - значение, указанное в коде программы
*/

// Поиск максимального числа
$numbers = [10, 20, 52, 105, 56, 89, 96];
$max = $numbers[0];
foreach ($numbers as $number) {
     if ($number > $max) {
          $max = $number;
     }
}
print_r($max); // => 105

/*
В императивном стиле широко используется присваивание (а, значит, и переменные) и циклы. Эта парадигма популярна потому, что она в точности соответствует тому, как работает компьютер: последовательно выполняет инструкции и использует память для хранения промежуточных результатов. Обычно говорят, что императивная программа отвечает на вопрос КАК («как достичь нужного результата»).

PHP как, впрочем, и java/ruby/python/c#/perl/javascript/go относится к императивным языкам. То есть языкам, в которых доминирующей является императивная парадигма (язык толкает к ее использованию). Что, однако, не мешает использовать и другие парадигмы в рамках этих языков.

# Декларативная парадигма

Императивному стилю противопоставляют декларативный, который нередко называют функциональным. Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос ЧТО («что мы хотим получить»). Эту грань довольно трудно уловить сразу, но, например, вся математика, по своей сути, декларативна.
*/

$numbers = [10, 20, 52, 105, 56, 89, 96];
$max = array_reduce($numbers, function ($acc, $number) {
     return $number > $acc ? $number : $acc;
}, $numbers[0]);
print_r($max); // => 105

/*
Главное отличие декларативной парадигмы от императивной на практике - отсутствие присваивания. Вы можете мне возразить, что в коде выше переменные есть и чисто технически это правда. Присмотритесь к коду внимательнее, вы заметите что переменная создана ровно один раз и больше не меняется. По сути, она рассматривается как константа или, если копнуть глубже, как логическое высказывание. В математике это звучало бы так: допустим "A это множество чисел". Что бы мы дальше не делали, "A" остается всегда тем же чем было во время определения.

Дело в том, что в математике доказательства строятся с помощью логических цепочек. Из одних утверждений следуют другие, и таким образом мы можем прийти к решению задачи. Все это возможно только в том случае, когда утверждения не изменяются. Иначе, следствия могут оказаться неверными уже после того, как они были получены, а значит мы не сможем рассуждать логически.

Тоже самое касается и $acc с $number. Эти параметры всегда определяются ровно один раз, так как каждый вызов функции при таком определении (без использования ссылок) не зависит от другого вызова (спасибо чистым функциям). В мире функциональных языков такую операцию называют связывание. Визуально оно выглядит как присваивание, но это не оно. Попытка связать уже связанный идентификатор (в функциональных языка нет переменных) завершится ошибкой. Ниже пример на языке erlang:
*/

1> A = 4.
4
2> A = 'hey'.
** exception error: no match of right hand side value hey

/*
Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия. Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода. В основном в функциях высшего порядка. Причем они способны заменить рекурсию в подавляющем большинстве задач, в чем мы уже убедились в предыдущих уроках (убедились так, что даже не рассматривали рекурсию). Любая задача из представленных решалась основной тройкой функций высшего порядка.

Функциональных языков довольно много. Они, в своей массе, менее популярны чем императивные, но прочно занимают определенные ниши и активно используются в промышленном программировании. К таким языкам относятся: haskell/erlang/elixir/ocaml/f#. В этих языках нет присваивания и циклов. Императивный код на них написать просто невозможно. Немного особняком стоят такие языки как scala и clojure (и другие из семейства lisp). В этих языках основная парадигма — функциональная, и язык толкает к тому, чтобы писать в таком стиле, но при необходимости на них можно написать самый настоящий императивный код с присваиванием и циклами. А вот, почти все, императивные языки позволяют писать функционально. Причем, если одни языки имеют довольно слабую поддержку функциональной парадигмы, то другие настолько мощную, что в них можно писать только функционально (если хочется). К последним относится и современный JavaScript.

В php поддержка функционального программирования слабее, чем в большинстве других языков, но все же она достаточно серьезная. С каждой новой версией PHP вбирает в себя все больше и больше возможностей, взятых из функциональных языков, многие из которых достаточно быстро становятся популярными и начинают использоваться повсеместно, например, лямбда-функции. С другой стороны, в PHP невозможно обновить массив не используя присваивания (говорят, «в иммутабельном стиле»). Поэтому любой код на PHP использующий функциональные возможности, так или иначе имеет императивные куски.

# Другие парадигмы

Большинство других парадигм являются разновидностями функциональной или императивной парадигм. Из наиболее значимых я бы выделил следующие:

     Логическое программирование
     Автоматное программирование
     Объекто-ориентированное программирование
     Метапрограммирование
*/




>>>>>  Абстракция с помощью функций <<<<<<<

/*
Главная причина создания функций - повышение уровня абстракции, а не сокращения дублирования кода, как вы могли бы подумать. Второе является следствием первого. И действительно, вместо того чтобы реализовывать сортировку самостоятельно в каждом месте где это требуется, можно воспользоваться функцией sort, которая прячет реализацию внутри себя и позволяет программисту не отвлекаться на ненужные детали (вид сортировки, код для ее выполнения).

# Abstraction

В этом заключается суть абстракции, мы игнорируем несущественные стороны, свойства и связи рассматриваемого объекта или процесса, что позволяет представить сложную концепцию в более простой форме. Умение абстрагировать - одно из важнейших свойств нашего мозга. Маленькие дети очень быстро учатся классифицировать предметы нашего мира. Без особого труда понимая, что дерево это дерево, даже если конкретную породу дерева они видят впервые. А два разведенных пальца обозначают зайчика (потому что уши).

Несмотря на это, понимание того, как грамотно строить абстракции (в нашем случае выделять функции) не появляется само по себе. Оно приходит с опытом, при условии, что есть другой человек сильнее вас, который может вам указать на допущенные ошибки, и вы сами отслеживаете проблемы вашей абстракции в процессе эксплуатации (рефлексируете). С другой стороны, излишнее абстрагирование скорее вредно, чем полезно. За награмождением новых сущностей можно потерять суть и тратить больше время на понимание происходящего. Построение абстракции — всегда компромисс. Слишком низкий уровень абстракции приводит к дублированию кода, слишком высокий - может быть очень трудным для понимания (Попробуйте понять Теорию Категорий) и усложняющим решение простых задач.

# Huge Java Call Stack

Функции высшего порядка выводят абстрагирование с помощью функций на новый уровень. Благодаря делегированию поведения внешнему коду (используя анонимные функции), резко расширяется возможность повторного использования кода (алгоритма) в разных ситуациях. И вместо десяти функций для десяти разных участков кода появляется одна функция, которая специфицируется 10 раз разным поведением.

Но не забывайте, что абстракции почти всегда текут.

Пример дырявой абстракции

В первом проекте Хекслета наши ученики совершают одну (совершают много, но сейчас нас интересует одна) ошибку, связанную с неверным выделением абстракций. Если отбросить детали (абстрагироваться!), то задача сводится к написанию функции, которая принимает на вход число, и должна напечатать на экран yes если оно четное и no в обратном случае.

Первое решение выглядит примерно так:
*/

function check($number)
{
  $result = $number % 2 === 0 ? 'yes' : 'no';
  echo $result;
}

// Оно рабочее, но сама концепция четности не выделена в свою абстракцию, что, например, затрудняет тестирование и понимание кода. Здесь он простой, но в более сложных случаях догадаться до того, что за операция выполняется - проблематично. Правильно было бы выделить четность в отдельную функцию (абстракцию).

function isEven($number)
{
     return $number % 2 === 0 ? 'yes' : 'no';
}

function check($number)
{
  $result = isEven($number);
  echo $result;
}

/*
Посмотрите на код выше внимательно. Все ли с ним нормально?

На самом деле, этот код даже хуже чем первая версия, потому что создана неверная абстракция. Понятие четности числа никак не связано ни с выводом на экран, ни со строчками yes или no. Оно существует в вакууме как математическая концепция и не может знать о том, как её собираются использовать. Я уже не говорю про то, что имя isEven начинается с is, а это значит, что функция - предикат. Такие функции могут возращать только логическое значение и никак иначе (исключений не существует!). Правильный вариант выглядит так:
*/

function isEven($number)
{
     return $number % 2 === 0;
}

function check($number)
{
  $result = isEven($number) ? 'yes' : 'no';
  echo $result;
}

/*
И это самый примитивный вариант создания абстракций. В реальном коде обычно все значительно сложнее.

Реализуйте функцию findIndexOfNearest, которая принимает на вход массив чисел и искомое число. Задача функции — найти в массиве ближайшее число к искомому и вернуть его индекс в массиве.
*/

findIndexOfNearest([], 2); // => null
findIndexOfNearest([15, 10, 3, 4], 0); // => 2


function findIndexOfNearest(array $items, $value)
{
     if (sizeof($items) === 0) {
          return null;
     }

     return array_reduce(array_keys($items), function ($acc, $i) use ($items, $value) {
          return abs($items[$i] - $value) < abs($items[$acc] - $value) ? $i : $acc;
     }, 0);
}


// Реализуйте функцию getFirstMenWithLessFriends, которая принимает список пользователей и возвращает пользователя у которого меньше всего друзей. Если список пользователей пустой, то возвращается null.

$users = [
     ['name' => 'Tirion', 'friends' => [
          ['name' => 'Mira', 'gender' => 'female'],
          ['name' => 'Ramsey', 'gender' => 'male']
     ]],
     ['name' => 'Bronn', 'friends' => []],
     ['name' => 'Sam', 'friends' => [
          ['name' => 'Aria', 'gender' => 'female'],
          ['name' => 'Keit', 'gender' => 'female']
     ]],
     ['name' => 'Keit', 'friends' => []],
     ['name' => 'Rob', 'friends' => [
          ['name' => 'Taywin', 'gender' => 'male']
     ]],
];

getFirstMenWithLessFriends($users); // => ['name' => 'Bronn', 'friends' => []];

use Funct\Collection;

function getFirstMenWithLessFriends(Array $users) 
{
    return minValue($users, function ($user) {
        return sizeof($user['friends']);
    });
}


// Реализуйте функцию enlargeArrayImage, которая принимает изображение в виде двумерного массива и увеличивает его в два раза.

$arr = [
     ['*','*','*','*'],
     ['*',' ',' ','*'],
     ['*',' ',' ','*'],
     ['*','*','*','*']
];
// ****
// *  *
// *  *
// ****

enlargeArrayImage($arr);
// ********
// ********
// **    **
// **    **
// **    **
// **    **
// ********
// ********

function enlargeArrayImage($arr)
{
     $result = [];

     foreach($arr as $child) {
          $childArray = [];
          foreach($child as $symbol) {
                $childArray[] = $symbol;
                $childArray[] = $symbol;
          }
          $result[] = $childArray;
          $result[] = $childArray;

     }

     return $result;
}


/*
NRZI код (Non Return to Zero Invertive) — один из способов линейного кодирования. Код формируется путем инверсного состояния при поступлении на вход кодирующего устройства логической единицы, при поступлении логического нуля состояние потенциала не меняется.
https://ru.wikipedia.org/wiki/NRZI
*/

// Реализуйте функцию decode принимающую в качестве параметра строку в виде линейного сигнала и возвращающую строку с бинарным кодом. Пример использования:

$signal = '_|¯|____|¯|__|¯¯¯';
decode($signal); // => '011000110100'

$signal_2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_2); // => '110010000100111'

$signal_3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_3); // => '010010000100111'

/*
Подсказки
* Символ | в строке разделяет разные такты и означает, что уровень сигнала в следующем такте, был изменён на противоположный по сравнению с предыдущим тактом.

* К сожалению, str_split умеет работать только с ASCII символами, поэтому для разделения строки на символы используйте конструкцию preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);, где $str - строка.

*/

function decode($str)
{
     $symbols = preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);

     $mapped = array_map(function ($key) use ($symbols) {
          if ($symbols[$key] === '|') {
                return '|';
          }
          if ($key === 0) {
                return 0;
          }
          return $symbols[$key - 1] === '|' ? 1 : 0;
     }, array_keys($symbols));

     $filtered = array_filter($mapped, function ($item) {
          return $item !== '|';
     });

     return implode('', $filtered);
}



// Реализуйте функцию getSameParity, которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же четность, как и у первого элемента входного массива.

 function getSameParity($coll)
{
     $result = [];
     
     if (!empty($coll)) {
        $reminder = $coll[0] % 2;
        foreach ($coll as $item) {
             if ($item % 2 == $reminder) {
                   $result[] = $item;
             }
        }
     }   
     return $result;
}


/*
Реализуйте функцию getIndexOfWarmestDay, которая находит самый тёплый день (тот, в котором была зарегистрирована максимальная температура) и возвращает индекс этого дня в исходном массиве. Если на вход поступил пустой массив, то функция должна вернуть null

$data = [
     [-5, 7, 1],
     [3, 2, 3],
     [-1, -1, 10],
]

*/

function getIndexOfWarmestDay(array $data)
{
     if (empty($data)) {
          return null;
     }

     $index = 0;
     $max = $data[0][0];
     foreach ($data as $key => $temperatures) {
          $current = max($temperatures);
          if ($current > $max) {
                $max = $current;
                $index = $key;
          }
     }
     return $index;
}




################ PHP: Построение абстракций ################


>>>>>  Линейно-рекурсивный процесс <<<<<<<

function Mypow($base, $exp) // Возведение в степень
{
    if ($exp == 1) { return 1; }
    return $base * Mypow($base, $exp-1);
}

/*
Пусть функция fun вычисляет факториал переданного числа используя рекурсию, тогда ее вызов будет работать так:

fun(4)
4 * func(3)
4 * 3 * func(2)
4 * 3 * 2 * func(1)
4 * 3 * 2 * 1
4 * 3 * 2
4 * 6
=> 24

Там где * 1 рекурсия прерывается, потому что стоит условие в начале функции. И после этого начинается сворачивание.
*/

function rFunc($x) {
    if ($x == 0) { return 1; }
    return $x + rFunc($x - 1);
}

echo rFunc(5); // 5+4+3+2+1+1 => 16


/*
Реализуйте рекурсивную функцию factorial, используя линейно-рекурсивный процесс.

Факториал числа можно выразить следующим образом:
factorial(0) -> 1
factorial(1) -> 1
factorial(n) -> n * factorial(n - 1)
*/

function factorial($num)
{
    return $num <= 1 ? 1 : $num * factorial($num - 1);
}


/* Реализуйте рекурсивную функцию fib, находящую числа Фибоначчи, используя древовидно-рекурсивный процесс.

Формула:
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
*/

function fib($num) 
{
    if ($num <= 1 ) { return $num; }
    return fib($num - 1) + fib($num - 2);
}





######################### ДЕКЛАРАТИВНОЕ ПРОГРАММИРОВАНИЕ #########################

    
>>>>>  Линейно-итеративный процесс <<<<<<<

function myPow($base, $exp) { // возведение в степень
    $powIter = function ($exp, $acc) use ($base, &$powIter) { // блочная структура - использование внутри функции локальной функции. & - т.к. функцию используем в самой себе и во время определения.
        if ($exp == 1) { return $acc; }
        return $powIter($exp - 1, $acc * $base);
    }; 

    return $powIter($exp, 1); // задаем $acc = 1
}

/*
powIter 4,4,1
powIter 4,3,4
powIter 4,2,16
powIter 4,1,64
=> 64
*/


// Реализуйте рекурсивную функцию factorial 2 способами: 


function factorial($num) 
{
    # линейно-рекурсивный процесс #
    return $num <= 1 ? 1 : $num * factorial($num - 1); 
    
    # линейно-итеративный процесс #
    $iter = function ($num, $acc) use (&$iter) {
        return $num <= 1 ? $acc : $iter($num - 1, $num * $acc);
    };
    return $iter($num, 1);
}


// Реализуйте рекурсивную функцию smallestDivisor, используя линейно-итеративный процесс. Функция должна находить минимальный делитель переданного числа. Минимальный делитель числа - это наименьшее число, на которое делится исходное без остатка.


function smallestDivisor($num)
{

     $iter = function ($acc) use ($num, &$iter) {
          if ($num <= $acc) { return $num; }            
        return $num % $acc == 0 ? $acc : $iter($acc++); 
     };

     return $iter(2);   
}




>>>>>  Функции первого класса. Передача как аргументов <<<<<<<


$sumIntegers = function ($a, $b) use (&$sumIntegers) {
    if ($a > $b) { return 0; }
    return $a + $sumIntegers($a + 1, $b);
};

$sumCubes = function ($a, $b) use (&$sumCubes) {
    if ($a > $b) { return 0; }
    return ($a * $a * $a) + $sumCubes($a + 1, $b);
};


function sum($a, $b, $func) // Функция высшего порядка. Суммирует от a до b, применяя доп. функцию
{
    if ($a > $b) { return 0; }
    return $func($a) + sum($a + 1, $b, $func));
}

echo sum(1, 5, function ($x) { return $x; }); // => 15


// можно описать функцию заранее:

$identity = function ($x) { return $x ** 2; };
echo sum(1, 5, $identity); // => 55


// Реализуйте функцию sum из видео, используя итеративный процесс.

function sum($start, $finish, $func) 
{
     $iter = function ($current, $acc) use ($finish, $func, &$iter) {
          if ($current > $finish) {
                return $acc;
          }

          return $iter($current + 1, $acc + $func($current));
     };

     return $iter($start, 0);
}


/*
Реализуйте функцию product, которая сворачивает последовательность с помощью переданной функции. Последовательность задается первыми двумя аргументами. Первый это начало последовательности, второй это окончание. Например, последовательность [1, 4] это 1, 2, 3, 4. Свертка это сведение последовательности к какому-то значению. Само значение зависит от того, какая операция применяется при свертке. Обратите внимание, что последовательность, типа [$x, $x], состоит из одного числа $x и свертке не подлежит, функция в этом случае должна вернуть само число $x.

'С помощью переданной функции' означает то, что мы применяем эту функцию к элементам последовательности и используем ее результат, как аккумулятор (накопитель результата).

Примеры:
*/
// f(1, 2) => 1 + 2
3 == product(1, 2, function ($first, $second) { return $first + $second; }) // sum

// f(f(3, 4), 5) => f(-1, 5) => -1 - 5
-6 == product(3, 5, function ($first, $second) { return $first - $second; }) // minus

/*
По последнему примеру видно, что операция является левоассоциативной. Рассмотрим данное свойство подробнее на последовательности [1, 4]:

Последовательность: 1, 2, 3, 4. Операция: f - внутренности не важны, главное, что это некая функция.

Разложим операцию с учетом ее левоассоциативности:
*/

f($left1, $right1); // $right1 = 4
f(f($left2, $right2), $right1); // $right2 = 3
f(f(f($left3, $right3), $right2), $right1); // $right3 = 2

// f = function ($first, $second) { return $first - $second; };
f(f(f(1, 2), 3), 4);
f(f(-1, 3), 4);
f(-4, 4); // -8

function product($num1, $num2, $func) 
{
     if ($num1 == $num2) { return $num2; }
     
     return $func(product($num1, $num2 - 1, $func), $num2);
}

echo product(3, 5, function ($first, $second) { return $first - $second; }); // => -6


product(1,3, $func) // ->
$func(product(1, 2, $func), 3); // ->
$func($func(product(1, 1, $func), 2), 3); // ->
$func($func(1,2),3); 



>>>>>  Функции первого класса. Возврат как значения <<<<<<<

/*
Что дает нам возможность возвращать функции как значения?
 * Возможность повышать уровень абстракции
 * Возможность задавать алгоритмы в более обобщенном виде, без спецификации деталей.
*/

function sumGenerator($func)
{
    return function($a, $b) use ($func) { // определение лямбда функции и возврат ее как значения
        return sum($a, $b, $func);
    };
}

function sum($a, $b, $func)
{
    if ($a > $b) { return 0; }
    return $func($a) + sum($a + 1, $b, $func);
}

$sumIntegers = sumGenerator(function($x) { return $x ** 2 }); // лямбда-функция
$sumCubs = sumGenerator(function($x) { return $x * $x * $x; }) // -//-
echo $sumIntegers(1, 5); // => 55
echo $sumCubs(1, 5); // => 255

/*
Ниже приведен пример определения функции, которая возводит свой аргумент в переданную степень (как замыкание). Один пример через прямое определение лямбды, второй через функцию, которая внутри себя определяет точно такую же лямбду и возвращает ее. Результат эквивалентен.
Определение напрямую:
*/

$exponent = 3;
$func = function ($number) use ($exponent) {
     return $number ** $exponent; // операция возведения в степень
};

8 == $func(2); // 2^3

// Определение через вызов функции:

function power($exponent)
{
     return function ($number) use ($exponent) {
          return $number ** $exponent; // операция возведения в степень
     };
}

$func = power(3);
8 == $func(2); // 2^3


// Реализуйте функцию factor, которая принимает на вход число (множитель) и возвращает функцию. Получившаяся функция принимает на вход один аргумент и возвращает результат умножения этого аргумента на множитель.

Пример:

$multiTwo = factor(2); // 2 - множитель

4 == $multiTwo(2); // 2 * 2
20 == $multiTwo(10); // 10 * 2



function factor($multiplier)
{
     return function ($arg) use ($multiplier) {
          return $multiplier * $arg;
     };
}


/*
Реализуйте функцию double, которая принимает как аргумент функцию с одним аргументом и возвращает функцию, которая применяет исходную функцию дважды.
Пример:
Исходная функция с одним аргументом:
*/

2 == $increment(1); // функция увеличивает свой аргумент на единицу

// double вернул новую функцию, которая применяет inc дважды:

$increment2 = double($increment);
3 == $increment2(1) // эквивалентно $increment($increment(1));

// Тут мы применяем double дважды и в итоге increment выполняется 4 раза:

$increment4 = double(double($increment));
5 == $increment4(1);

function double($func)
{
     return function ($arg) use ($func) {
          return $func($func($arg));
     };
}



>>>>> Что такое данные? <<<<<<<

$pair = cons(1, 2); // pair - структура данных 'пара', пришла из лиспа. В PHP не реализована. cons - функция-конструтор

print_r($pair); // =>
/*
Closure Object
(
     [static] => Array
          (
                [x] => 1
                [y] => 2
          )

     [parameter] => Array
          (
                [$method] => <required>
          )

)
*/

echo car($pair); // метод селектор - выбор первого значения из пары => 1
echo cdr($pair); // метод селектор - выбор второго значения из пары => 2

function cons($x, $y)
{
     return function ($method) use ($x, $y) {
          switch ($method) {
                case "car":
                     return $x;
                case "cdr":
                     return $y;
                default:
                     throw new \InvalidArgumentException("Invalid method $method.");
          }
     };
}

function car(callable $pair)
{
    return $pair('car');
}

function cdr(callable $pair)
{
    return $pair('cdr');
}

echo $pair("car"); // так нарушаем абстракцию, просто для понимания. 'car' - называется сообщением, а способ программирования - 'передачей сообщений' => 1

function isPair($pair)
{
     return is_callable($pair);
}

function toString($list)
{
     if (!isPair($list)) {
          return $list;
     }
 
     $iter = function ($items, array $acc = []) use (&$iter) {
          if ($items == null) {
                return $acc;
          }
          return $iter(cdr($items), array_merge($acc, [toString(car($items))]));
     };
     $arr = $iter($list);
 
     return "(" . implode(", ", $arr) . ")";
}




/*
В текущем задании представлен другой способ реализации пар.
    Допишите функцию car основываясь на том как работает функция cons.
    Допишите функцию cdr основываясь на том как работает функция cons.

*/

function cons($x, $y)
{
     return function ($func) use ($x, $y) {
          return $func($x, $y);
     };
}

function car(callable $pair)
{
     return function ($x, $y) use ($pair) {
        return $x;
     };
}

function cdr(callable $pair)
{
     return function ($x, $y) use ($pair) {
        return $y;
     };
}


function makeList(...$elements)
{
     return array_reduce(array_reverse($elements), function ($acc, $item) {
          return cons($item, $acc);
     });
}



 
>>>>>  Абстракция данных  <<<<<<<

/*
Абстра́кция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

Это важный инструмент ООП наряду с полиморфизмом, наследованием и инкапсуляцией.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации. Это утверждение неверно, сокрытие особенностей реализации это инкапсуляция.

Абстракция данных — популярная и в общем неверно определяемая техника программирования. Фундаментальная идея состоит в разделении несущественных деталей реализации подпрограммы и характеристик, существенных для корректного её использования. Такое разделение может быть выражено через специальный «интерфейс», сосредотачивающий описание всех возможных применений программы. 
*/

$rat = makeRat(1, 2); //  1 - числитель, 2 - знаменатель
printRat($rat); // => 1/2
numer($rat); // достает числитель -> 1
denom($rat); // достает знаменатель -> 1
printRat(addRat($rat, makeRat(2,3))); // addRat - сложение рациональных чисел => 7/6


function makeRat($numer, $denom)
{
    return cons($numer, $denom);
}

function numer($rat)
{
    return car($rat);
}


function denom($rat)
{
    return cdr($rat);
}

function cons($x, $y)
{
     return function ($method) use ($x, $y) {
          switch ($method) {
                case "car":
                     return $x;
                case "cdr":
                     return $y;
                default:
                     throw new \InvalidArgumentException("Invalid method $method.");
          }
     };
}


function addRat($rat1, $rat2)
{
    // n1/d1 + n2/d2 == (n1 * d2 + n2 * d1) / (d1 * d2)
    $numer = numer($rat1) * denom($rat2) + numer($rat2) * denom($rat1)
    $denom = denom($rat1) * denom($rat);

    return makeRat($numer, $denom);
}

function printRat($rat)
{
    printf("%d/%d", numer($rat), denom($rat));
}

// ПРИНЦИП ОДНОГО УРОВНЯ АБСТРАКЦИИ:

// Рациональные числа в предметной области:
# addRat subRat equaksRat

// Рациональные числа как числители со знаменателями:
# makeRat numer denom

// Рациональные числа как пары:
# cons car cdr

// То, как реализуются пары
# ...


/*
Программа работает с географическими координатами для вычисления расстояний между точками. Координаты передаются в виде специальных структур данных, так, что широту и долготу можно получить с помощью специальных функций. Широта и долгота представлены в виде чисел, и программе необходимо знать, на каком компьютере были сохранены данные: на 32-битном или 64-битном. Для этого в структуре данных записан специальный флаг, а в программе реализованы две функции для обработки двух форматов чисел.

Нарушается ли в этом случае концепция абстракции данных?

- Да
Ключевое здесь описание уровня абстракции (и зоны ответственности) программы: Программа работает с географическими координатами для вычисления расстояний между точками.

Т.е. на уровне программы происходит работа с такими абстракциями, как географические координаты. Программа не должна знать (и зависеть) о подробностях внутренней реализации этих координат (как, к примеру, код работающий с такими абстракциями как геометрическая точка, не должен знать внутреннее устройство этой точки (пара это или же массив)).

Попытка внутри программы преобразовать значение координат в зависимости от разрядности системы - это уже не зона ответственности программы. Такая абстракция, как географическая координата, не должна зависеть от разрядности системы ("снаружи", с точки зрения кода, который пользуется этой абстракцией) и должна скрывать эти подробности внутри себя, а не перекладывать на использующую программу.
*/

/*
Реализуйте функцию subRat, которая производит вычитание рациональных чисел. При этом (с точки зрения внутренней реализации) функция возвращает в качестве результата новую пару (т.е. исходные пары, являющиеся параметрами функции, не изменяются).
Реализуйте функцию equalRat, которая делает проверку двух рациональных чисел на равенство.
*/

function subRat($rat1, $rat2)
{
     $numer = numer($rat1) * denom($rat2) - numer($rat2) * denom($rat1);
     $denom = denom($rat1) * denom($rat2);

     return makeRat($numer, $denom);
}

function equalRat($rat1, $rat2)
{
     return numer($rat1) * denom($rat2) == numer($rat2) * denom($rat1);
}




>>>>>  Замкнутые множества  <<<<<<<

/*
Список - это абстрактный тип данных, представляющий собой упорядоченный набор значений, в котором некоторое значение может встречаться более одного раза. Экземпляр списка является компьютерной реализацией математического понятия конечной последовательности.

В списке нет индексированного доступа и невозможно получить напрямую доступ к произвольному элементу. В программе у нас есть доступ к голове списка через которую мы можем продвигаться дальше вглубь к хвосту списка.
*/

cons(10, cons(1, 30)); // алгебраическое замыкание 
$list = cons(1, cons(2,cons(3, null))); // структура данных "список"(или "последовательность"). null - показывает конец списка
makeList(1, 2, 3); // аналогично коду выше
// В списке (1, 2, 3) 1 является головой head списка, а (2, 3) хвостом tail списка.

function listRef($list, $n) // показывает элемент определенной позиции (n)
{
    if ($n == 0) {
        return car($list);
    } else {
        return listRef(cdr($list), $n - 1);
    }
}

$l = makeList(1, 2, 5, 7);
echo listRef($l, 0); // => 1
echo listRef($l, 1); // => 2


$l = cons(1, cons(3, cons(5, null)));
echo car(cdr($l)); // cdr возвращает список без головы. (5, 2, 3) -> (2, 3)     => 3

$l = cons(1, cons(3, cons(5, null)));
echo car(cdr(cdr($l)));// => 5

$l = cons(1, cons(3, cons(5, null)));
echo cdr(cdr(cdr($l))); // => null


/*
В видео говорится, что в PHP нет готовой реализации списков, но разве массивы из предыдущего курса не делают ровным счётом то же самое? Получается что мы реализуем массив, только с помощью пар? И есть ли какая-то объективная причина причина использовать пары, в таком ключе, ведь с массивами всё проще? Или это всё просто обучающий пример чтобы поработать головой?

=>
Массивы и списки это разные вещи. Массив, как АТД предоставляет возможность произвольного доступа к элементом и их изменение, а список включает в себя буквально две операции: добавить элемент в голову списка и снять голову.

С помощью пар мы реализуем именно список. А цель всего этого курса научить вас абстракциям, показать как из более простых элементов можно строить более сложные за счет композиции. О том что первично, а что является следствием. 

* Абстра́ктный тип да́нных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций. 
*/


// Реализуйте функцию length, которая считает длину списка;

$list = cons(1, cons(2, cons(3, null)));


namespace App\Length;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function length($items)
{
    if ($items === null || !is_callable($items)) {
          return 0;
     } else {
          return 1 + length(cdr($items));
     }
}


// Реализуйте функцию append, которая соединяет два списка; Подсказка: Попробуйте сначала представить как работала бы функция copy, которая принимает на вход список и возвращает его копию.

namespace App\Append;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function append($list1, $list2)
{
     if ($list1 === null) {
          return $list2;
     } else {
          return cons(car($list1), append(cdr($list1), $list2));
     }
}


// Реализуйте функцию reverse, которая переворачивает список;

namespace App\Reverse;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function reverse($list)
{
     $iter = function ($list, $acc) use (&$iter) {
          return is_null($list) ? $acc : $iter(cdr($list), cons(car($list), $acc));
     };
 
     return $iter($list, null);
}



>>>>>  Map   <<<<<<<

/*
map — функция высшего порядка, используемая во многих языках программирования, которая применяет данную функцию к каждому элементу списка, возвращая список результатов. При рассмотрении в функциональной форме она часто называется «применить-ко-всем». https://ru.wikipedia.org/wiki/Map 
// https://codeclimate.com/github/hexlet-components/php-pairs/
*/
     
$scaleList = function ($list, $factor) use (&$scaleList) {
    if ($list == null) {
        return null;
    } else {
        $rest = $scaleList(cdr($list), $factor);
        return cons(car($list) * $factor, $rest);
    }
};


$list = makeList(1, 2, 3);
echo listToString($scaleList($list, 2)); // => 2,4,6

$map = function ($func, $list) use (&$map) { // повышаем уровень абстракции
    if ($list == null) {
        return null;
    } else {
        $rest = $map($func, cdr($list));
        return cons($func(car($list), $rest));
    }
};

$func = function($item) { return $item * 3; }
echo listToString($map($func, $list)); // => 3,6,9


// Реализуйте map используя итеративный процесс.

require_once 'Pair.php';

use function App\Pair\cons;
use function App\Pair\car;
use function App\Pair\cdr;
use function App\Pair\reverse;
use function App\Pair\listToString;

function map($func, $list)
{
     $iter = function ($list, $acc) use (&$iter, $func) {
        return is_null($list) ? reverse($acc) : $iter(cdr($list), cons($func(car($list)), $acc));
     };
    return $iter($list, null);
}




>>>>>  Фильтрация   <<<<<<<

$removeOdds = function ($list) use (&$removeOdds) { // по четным числам
    if ($list == null) {
        return null;
    } else {
        $curr = car($list);

        $rest = $removeOdds(cdr($list));
        if ($curr% 2 == 0) {
            return cons($curr, $rest);  
        } else {
            return $rest;
        }
    }
};

$list = makeList(1,2,3,5,101,100);
echo listToString($removeOdds($list)); // => (2, 10, 100)


// Реализуйте функцию filter, используя итеративный процесс.

function filter($func, $list)
{
    $iter = function ($list, $acc) use (&$iter, $func) {
        if ($list === null) {
            return reverse($acc);
        }

        $newAcc = $func(car($list)) ? cons(car($list), $acc) : $acc;
          return $iter(cdr($list), $newAcc);
     };

     return $iter($list, null);
}




>>>>>  Свертка   <<<<<<<
 
function sum($list)
{
    $iter = function ($list, $acc) use (&$iter) {
        if ($list == null) {
            return $acc;
        }

        return $iter(cdr($list, $acc + car($list)));
    }; 

    return $iter($list, 0);
}

function accumulate($list, $func, $acc)
{
    $iter = function ($list, $acc) use (&$iter, $func) {
        if ($list == null) {
            return $acc;
        }

        return $iter(cdr($list), $func(car($list), $acc));
    }

    return $iter($list, $acc);
}

$list = makeList(1, 5, 9);
$func = function ($item, $acc) { return $acc + $item; }
echo accumulate($list, $func, 0); // => 15
$func = function ($item, $acc) { return cons($item * 2, $acc); } 
echo listToString(accumulate($list, $func, null)); // => (18, 10, 2)


/*
Реализуйте функцию solution которая принимает на вход список чисел и выполняет следующие действия:
 округляет все числа в списке до верхней границы.
 удаляет нечетные числа.
 возвращает произведение оставшихся элементов.

Подсказки
 Округление до верхней границы: ceil.
 Используйте функции map, filter, reduce из пакета hexlet/pairs, определение которых можно подсмотреть тут https://github.com/hexlet-components/php-pairs.
*/

solution(l(1.3, 3.01, 5.5, 100.9, 2.5)); // → 48.0
solution(l(1.49, 1.99, 9.9, 9.0, -1.2, -2.5)); // → -80.0


namespace App\Solution;

use function Lists\map;
use function Lists\filter;
use function Lists\reduce;

function solution($list) 
{ 
    $ceilNums = map(function ($num) {
        return ceil($num); 
    }, $list);

    $evenNums = filter(function ($num) { 
        return $num % 2 == 0; 
    }, $ceilNums); 

    return reduce(function ($num, $acc) {
        return $num * $acc; 
    }, $evenNums, $acc = 1);
}




>>>>>  Деревья  <<<<<<<

/* 
Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы. Большинство источников также добавляют условие на то, что рёбра графа не должны быть ориентированными. В дополнение к этим трём ограничениям, в некоторых источниках указывается, что рёбра графа не должны быть взвешенными. https://ru.wikipedia.org/wiki/Дерево_(структура_данных)

Дерево можно назвать рекурсивной структурой данных, потому что каждая его часть по сути является деревом само по себе.
https://ru.hexlet.io/blog/posts/recursive
*/

l(2, 3, 4); // => cons(2, cons(3, cons(4, null)));
l(2, 3, l(4, 5)) // => cons(2, cons(3, cons(cons(4, cons(5, null)), null)));
     

function treeMap($list, $func, $acc)
{
    $iter = function ($list, $acc) use (&$iter, $func) {
        if ($list == null) {
            return $acc;
        }
    
        $element = car($list);
        if (isPair($element)) { // isPair - метод проверяет является ли элемент парой
            $newAcc = treeMap($element, $func, $acc);
        } else {
            $newAcc = $func($element, $acc);
        }
        return $iter(cdr($list), $newAcc);
    };
    return $iter($list, $acc);  
}

$list = l(1,3,l(1,l(2,3),2),9); // l == makeList()

$result = treeMap($list, function($item, $acc) { // считает кол-во элементов
    return $acc + 1;
}, 0); // => 7


// Реализуйте функцию reverse, которая переворачивает переданный на вход список рекурсивно.
    
l(1, l(3, 2), 5, l(6, l(5, 4))) => (((4, 5), 6), 5, (2, 3), 1)
l(l(3, l(4, 100), 5, 6, l(7))) => (((7), 6, 5, (100, 4), 3))

require 'Pair.php';

use function App\Pair\car;
use function App\Pair\isPair;
use function App\Pair\cdr;
use function App\Pair\cons;
use function App\Pair\listToString;


function reverse($list)
{
     $iter = function ($list, $acc) use (&$iter) {
        if (is_null($list)) {
            return $acc;
        }

        $elem = car($list);

        if(isPair($elem)) {
             $newAcc = cons(cons(car($elem), $iter(cdr($elem), null)), $acc);
        } else {
            $newAcc = cons($elem, $acc);
        }

        return $iter(cdr($list), $newAcc);
     };
     
     return $iter($list, null);
}



    
>>>>>  Стандартные интерфейсы  <<<<<<<
    
    
$list = l(1, 4, 5, 8, 9, 100);

function sumOfDoubleOdds($list) // сумма нечетных чисел * 2
{
     return accumalate($list, function ($item, $acc) {
          if ($item % 2 === 1) {
                return $item * 2 + $acc;
          } else {
                return $acc;
          }
     }, 0);
}

// Принцип "Разделай и властвуй":
     
$result = filter($list, function ($item) {
     return $item % 2 === 1;
});

$result2= map($result, function ($item) {
     return $item * 2;
});
     
$result3 = accumulate($result2, function ($item, $acc) {
     return $acc + $item;
}, 0);
     
echo ($result3); // => 30    

// В других языках реализованы "ленивые коллекции", которые не производят вычислений до их использования.   
    

/*
Реализуйте функцию solution, которая принимает на вход список чисел и выполняет следующие действия:

удаляет все числа, не кратные трем. 
возводит оставшиеся числа в квадрат.
возвращает среднее арифметическое списка полученного после предыдущей операции.

Пример:

22.5 == solution(l(1, 3, 8, 6)) // (3 * 3 + 6 * 6) / 2

Подсказки:

Для подсчета числа элементов в списке используйте функцию length
*/

function solution ($list)
{
    $multiplicityNums = filter($list, function ($item) {
        return $item % 3 === 0;
    });

    $squareNums = map($multiplicityNums, function ($item) {
        return $item ** 2;
    });

    $sumNums = accumulate($squareNums, function ($item, $acc) {
        return $item + $acc;
    }, 0);

    return $sumNums/length($squareNums);
}
     

>>>>>  Оператор присваивания  <<<<<<<

# Процедурный стиль :
    
// Демонстрация - так не делать!
function deposit(&$balance, $amount)
{
    $balance += $amount;
}
    
$balance = 100;
deposit($balance, 10);
echo $balance; // => 100

    
function newDeposit($balance) // инкапсуляция   
{
    return function ($amount) use (&$balance) {
        $balance += $amount;
        return $balance;
    };
}

$d = newDeposit(100);   
echo $d(10); // => 110  
$d2 = newDeposit(100);  
echo $d2(10); // => 110     
    


/*  
Напишите функцию newWithdraw, которая снимает деньги со счета. При попытке снять больше денег, чем есть на счете, она должна возвращать too much.
Пример:

$withdraw = newWithdraw(100);
$withdraw(1000); // 'too much'
$withdraw(50); // 50
$withdraw(45); // 5
*/
    
function newWithdraw($balance) // my
{
     return function ($amount) use (&$balance) {
          $newBalance = $balance - $amount; 
          return ($newBalance >= 0) ? $balance = $newBalance : 'too much';
     };
}   
    
function newWithdraw($balance) // hexlet
{
     return function ($amount) use (&$balance) {
          if ($balance < $amount) {
                return "too much";
          } else {
                $balance -= $amount;
                return $balance;
          }
     };
}


    
>>>>>  Объекты  <<<<<<<
        
function newAccount($balance)
{
    $withdraw = function ($amount) use (&$balance) {
        $balance -= $amount;
        return $balance;
    };
    
    $deposit = function ($amount) use (&$balance) {
        $balance += $amount;
        return $balance;
    }
    
    return function ($funcName, $amount) use ($withdraw, $deposit) { // стиль "передача сообщений"
        switch ($funcName) {
            case "withdraw":
                    return $withdraw($amount);
                    break;
            case "deposit":     
                    return $deposit($amount);
                    break;
        }
    };
}
    
    
$a = newAccount(100);
echo $a("deposit", 50); // 110
echo $a("deposit", 100); // 10  
    
    
/*  
Измените функцию newAccount из видео так, чтобы она создавала счета, защищенные паролем.

Пример:

$acc = newAccount(100, "secret password");
110 == $acc("deposit", 10, "secret password");
60 == $acc("withdraw", 50, "secret password");
"wrong password!" == $acc("deposit", 10, "wrong password"); 
*/  

namespace App;

function newAccount($balance, $password)
{
    $isPass = function($pass) use ($password) {
        return $pass === $password ? true : false;
    };

    $withdraw = function($amount) use (&$balance) {
        $balance -= $amount;
        return $balance;
    };
    
    $deposit = function($amount) use (&$balance) {
        $balance += $amount;
        return $balance;
    };
    
    return function ($funcName, $amount, $pass) use ($isPass, $withdraw, $deposit) { 
        if (!$isPass($pass)) { return "wrong password!"; }

        switch ($funcName) {
            case "withdraw":
                    return $withdraw($amount);
                    break;
            case "deposit":     
                    return $deposit($amount);
                    break;
        }
    };
}   



>>>>>  Преимущества присваивания   <<<<<<<
 

function random($seed) // псевдослучайные  числа
{
    return function () use (&$seed) { // число, являющееся базовым значением для вычисления следующего случайного числа
        $a = 45;
        $c = 21;
        $m = 67;
        $seed = ($a * $seed + $c) % $m;

        return $seed;
    };
}

$a = random(10);
echo $a(); // => 44 
echo $a(); // => 58
echo $a(); // => 27
echo $a(); // => 30

    
/*
Измените функцию random из видео так, чтобы можно было обнулять сгенерированную последовательность.
Пример:
*/

$seq = random(3);
$result = $seq(); // 22
$seq(); // 6
$seq(); // 23

$seq("reset");

$result == $seq(); // 22
    
function random($seed) // псевдослучайные  числа
{
    $start = $seed;
    
    $reset = function() use (&$start, $seed) {
        $start = $seed;
    };
    

    return function($func = null) use ($reset, $generate) {
        switch ($func) {
            case null:
                return $generate();
            case 'reset':
                $reset();
        }
    };
}



>>>>>  Недостатки присваивания   <<<<<<<

function makeDecrementer($balance) // чистая функция
{
    return function ($amount) use ($balance) {
        return $balance - $amount;
    };
}

$d = makeDecrementer(100);
echo $d(10); // 90
echo $d(10); // 90
echo $d(10); // 90

$d2 = makeDecrementer(100); // $d и $d2 - являются одним и тем же объектом


function makeWithdraw($balance) // нечистая функция
{
    return function ($amount) use (&$balance) { 
        $balance -= $amount;
        return $balance;
    };
}

$w = makeWithdraw(100); // $w и $w2 разные объекты
$w2 = makeWithdraw(100);
$w(10); // => 90
$w(10); // => 80
$w2 = makeWithdraw(100); // => 90

# референциальная (ссылочная) прозрачность

function factorial($n) // функция в полуимперативном стиле
{
    $product = 1;
    $counter = 1;
    $iter = function () use ($n, &$iter, &$product, &$counter) {
        if ($counter > $n) {
            return $product;    
        } else {
            $product *= $counter;
            $couner += 1;
            return $iter();
        }   
    };

    return $iter;
}


/*
Реализуйте функцию fib находящую числа Фибоначчи используя рекурсивно-итеративный процесс, но вместо аккумулятора параметров для вложенной функции $iter используйте переменные.

Формула:

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)

Пример:

2 == fib(3);
5 == fib(5);
55 == fib(10);
*/


/*
[0, 0]
[1, 1]
[1, 2]
[2, 3]
[3, 4]
[5, 5]
[55, 10]
*/



/*
Реализуйте функцию fringe, которая берет в качестве аргумента дерево (представленное в виде списка) и возвращает список, элементы которого - все листья дерева, упорядоченные слева направо.

Пример:
*/
l(4, 3, 2, 1) == fringe(l(l(4, 3), l(2, 1)));


/*
l() => l()
l(1, 2) => l(1, 2)
l(4, 3, 2, 1) => l(l(4, 3), l(2, 1))
l(4, null, 5, 7, 9, 1, 1) => l(l(4, l(null, 5)), l(l(7, 9), 1), 1)
*/




/*
Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и g есть функция x → f ( g (x) ).
Solution.php

Определите функцию compose которая реализует композицию.

Пример:
*/
$square = function ($num) {
     return $num ** 2;
};

$half = function ($num) {
     return $num / 2;
};

$func1 = compose([$square, $half]);
$func1(10); // 25

$func2 = compose([]);
$func2(3); // 3




/*
[3, 3, []],
[1, 0, [$inc]],
[25, 10, [$square, $half]],
[25, -11, [$square, $half, $inc]]
*/



/*
Определите функцию sameParity, которая принимает список построенный на парах и возвращает отфильтрованный список у которого четность каждого элемента совпадает с четностью первого элемента этого списка.
Пример:
*/

l(1, 3) == l(1, 10, 3, 2)


// Подсказки: Функция l это сокращенная запись для вложенных cons. Подробнее https://github.com/hexlet-components/php-pairs

/*
l(), l()
l(1), l(1)
l(1, 5), l(1, 2, 5, 0)
l(10, 2, 0), l(10, 2, 5, 0)]
*/



/*
Реализуйте функцию deepReverse, которая принимает список в качестве аргумента и возвращает в качестве значения список, где порядок элементов обратный и подсписки также обращены.

Пример:
*/
l(l(1, 2), l(3, 4)) == deepReverse(l(l(4, 3), l(2, 1)));



/*
[l(), l()],
[l(2, 1), l(1, 2)],
[l(l(1, 2), l(3, 4)), l(l(4, 3), l(2, 1))],
[l(1, l(1, l(9, 7)), l(l(5, null), 4)), l(l(4, l(null, 5)), l(l(7, 9), 1), 1)]
*/

/*
Реализуйте функцию fib находящую положительные числа Фибоначчи. Аргументом функции является порядковый номер числа.

Формула:

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)

Пример:

2 == fib(3)
5 == fib(5)
55 == fib(10)
*/



/*
[0, 0]
[1, 1]
[1, 2]
[2, 3]
[3, 4]
[5, 5]
[55, 10]
*/


/*
Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f — функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение которой в точке x есть среднее между f(x − dx), f(x) и f(x + dx).
Solution.php

Напишите функцию smooth, которая в качестве ввода принимает два аргумента: функцию, вычисляющую f, и малое число dx, а возвращает функцию, вычисляющую сглаженную версию f.

Пример:
*/

$smoothFunc = smooth(function ($sum) {
  return sin(rad2deg($sum));
}, 15);

$smoothFunc(10) // ~ 0.438


/*
 public function testSmooth($expected, $x, $dx, $func)
     {
          $smoothFunc = Solution\smooth($func, $dx);
          $this->assertEquals($expected, $smoothFunc($x), '', 0.01);
     }

     public function additionProvider()
     {
        return [
                [0.438, 10, 15, function ($num) {
                     return sin(rad2deg($num));
                }],
                [5, 0, 5, function ($num) {
                     return $num + 5;
                }],
                [4, 2, 0.00001, function ($num) {
                     return $num ** 2;
                }],
                [9, 3, 0.00001, function ($num) {
                     return $num ** 2;
                }]
          ];
     }
}            
*/



>>>>>  Веб-разработка на PHP <<<<<<<  

/*
Переход от написания скриптов (то что мы делали ранее) к созданию полноценных сайтов, сопровождается необходимостью знакомиться с большим числом понятий и инструментов выходящих далеко за рамки языка. Взаимодействие с внешним миром вовлекает в себя знание операционных систем, в частности сетей, работу с регистраторами, хостингом, деплоем сайта. На собеседованиях веб-программистов часто задают вопрос "Что происходит после того как в адресной строке браузера набирается сайт www.google.com и нажимается enter?". Очень подробный ответ на этот вопрос доступен здесь (https://github.com/alex/what-happens-when). Спрашивающий, в этот момент, хочет услышать от вас ключевые понятия связанные с веб-разработкой.

1. Выполнение DNS запроса для получения IP адреса по имени домена.
2. Соединение с веб-сервером находящемся по этому адресу на порту 443 (или 80) по TCP.
3. Выполнение HTTP запроса на содержимое сайта по указанному домену
4. Получение ответа и рендеринг содержимого во вкладке браузера

Каждый из этих пунктов неявно подразумевает знание следующих тем:

* Протокол HTTP. Понятие виртуальных хостов. Желательно понимание принципов работы HTTPS.
* Принципы работы DNS.
* Знание TCP/IP. Понятия: порт, маска, подсети. Модель OSI. Сетевые сокеты.
* Веб-сервер. Что это такое, как работает и зачем нужен.

Фреймворки, микрофреймворки, роутинг, куки, сессии, безопасность, шаблонизация, взаимодействие с базой данных и многое другое. И даже когда вы научитесь готовить сайт, это еще не конец. Сайт доступен пользователям только находясь на удаленном сервере, а значит в разработку включается понятие "деплой", то есть процесс разворачивания сайта на хостинге. Причем чтобы сайт развернуть, для начала нужно настроить удаленную машину (или машины) используя инструмент наподобие Ansible. Кстати сам хостинг бывает очень разный: IaaS (aws), PaaS (heroku), Shared Hosting, VPS/VDS.

Данный курс посвящен, в первую очередь, разработке веб-сайтов с использованием микрофреймворков и темы указанные выше включает в себя лишь поверхностно (и то не все). Поэтому крайне рекомендуется выполнять задачи не только в среде Хекслета, но и локально, паралелльно выкатывая код на сервис подобный https://www.heroku.com/

Дополнительные материалы
Что такое протокол HTTPS, и как он защищает вас в интернете https://yandex.ru/blog/company/77455
Как работает DNS https://habr.com/post/137587/
Что такое веб-сервер? https://developer.mozilla.org/ru/docs/Learn/Что_такое_веб_сервер


# Архитектура Веба

Современные сайты разрабатываются на множестве языков используя совершенно разные технологии, но принципы их устройства одинаковые. То почему сайты внутри устроены похожим образом, определяется архитектурой веба. В его основе лежит протокол HTTP, с которым вы уже знакомы по одноименному курсу.

Современный веб несколько сложнее благодаря Websockets, что существенно влияет на принципы построения сайтов активно их использующих.

Принцип взаимодействия с любым сайтом сводится к следующим шагам:

1. Пользователь запрашивает страницу сайта
2. Браузер выполняет HTTP запрос к веб-серверу
3. Веб-сервер возвращает содержимое страницы в HTTP ответе
4. Браузер отрисовывает страницу сайта
5. Пользователь кликает по ссылке на сайте и весь процесс повторяется снова.

Каждый такой цикл включает в себя HTTP сессию: HTTP запрос и HTTP ответ. Проще всего увидеть HTTP сессию используя утилиту curl:
*/

$ curl -v --head http://code-basics.ru
* Rebuilt URL to: http://code-basics.ru/
*   Trying 100.102.175.148...
* TCP_NODELAY set
* Connected to code-basics.ru (100.102.175.148) port 80 (#0)
> HEAD / HTTP/1.1
> Host: code-basics.ru
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Date: Wed, 04 Jul 2018 08:38:22 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 7902
< Connection: keep-alive
< Server: nginx/1.15.1

<
* Connection #0 to host code-basics.ru left intact

/*
Как видно, принцип взаимодействия не зависит от того на чем написан сайт. С точки зрения сайта, всегда есть запрос который нужно обработать и вернуть ответ в виде, например, HTML. То каким будет HTML для конкретного запроса, определяется самим запросом, то есть запрошенной страницей и различными параметрами HTTP, такими как заголовки. В конечном итоге код сайта представляет из себя набор обработчиков разных страниц, которые принимают входящие запросы, формируют ответ и возвращают его. Ниже вы увидите примеры на разных языках. Даже не зная синтаксиса достаточно легко уловить общую структуру всех примеров кода: функция обработчик привязанная к конкретной странице.
*/

// PHP

$app = new Slim\App();

$app->get('/', function ($request, $response) {
    $response->write('Welcome to Slim!');
    return $response;
});

$app->get('/about', function ($request, $response) {
    $response->write('About My Site');
    return $response;
});

$app->run();


// Ruby

require 'sinatra'
get '/frank-says' do
  'Put this in your pipe & smoke it!'
end

// Python

from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello World!"

// Java

import static spark.Spark.*;

public class HelloWorld {
    public static void main(String[] args) {
        get("/hello", (req, res) -> "Hello World");
    }
}

// JavaScript

import Express from 'expressjs';
const app = new Express();

app.get('/', (req, res) => {
  res.send('Hello World!');
});

/*
Конечно реальные сайты устроены значительно сложнее, но в основе лежит та связка запрос-ответ, которая была описана в этом уроке.
*/



>>>>> Веб-сервер <<<<<
/*
# Процессы

Давайте теперь посмотрим для чего нужен веб-сервер. Ответ на этот вопрос требует небольшой подготовки.

Единицей исполнения в операционных системах является процесс. Это некоторая абстракция внутри ОС (имеется ввиду, что процесс невозможно представить визуально). Любая запущенная программа представляет собой либо один процесс, либо набор процессов. Например, в браузерах одна вкладка, как правило, — это один процесс. Особенность процессов в том, что они изолированы друг от друга. Например, сбой в одном процессе не влечет за собой остановку работы других. Такое свойство процессов можно наблюдать в тех ситуациях, когда одна из вкладок браузера начинает тормозить и в конце концов зависает (и её не всегда удаётся закрыть!). В это время можно без проблем продолжать использовать другие вкладки.

Внутри себя процесс может делиться на потоки, но эта деталь не влияет на описываемую тему, поэтому я её опускаю. Подробнее о менеджменте процессов можно прочитать в книгах по операционным системам.

Посмотреть список процессов в Linux можно командой ps aux либо top

Понимание процессов тесно связано с сетевым взаимодействием. Взаимодействие между двумя компьютерами в сети — всегда сводится к взаимодействию двух процессов. Другими словами, нельзя взять и подключиться к компьютеру в целом — можно подключиться только к конкретному процессу конкретной программы. Происходит это так: одна программа, которая хочет, чтобы к ней можно было подключаться по сети, при запуске начинает слушать сетевой сокет. Такая программа называется сервером. Другая программа к ней подключается. Такая программа называется клиентом. В случае веба, сервер — это конкретный веб-сервер, например, nginx, а клиент — это браузер.

Здесь нужно сделать небольшую ремарку насчет "слушать сетевой сокет". Сетевое взаимодействие между программами двух компьютеров осуществляется с помощью протокола TCP, поверх которого уже работает HTTP. Для обращения к другому комьютеру нужно знать два параметра: IP адрес и порт. Так вот "слушать сетевой сокет" означает занять определённый порт (на определённом сетевом интерфейсе) и дать возможность обращаться к процессу через него. Именно по номеру порта операционная система понимает, к какому процессу пытаются обратиться.

Браузер, благодаря DNS, получает IP адрес компьютера, на котором расположен сайт указанного домена (например, google.com). А вот откуда он знает порт, на котором висит веб-сервер в ожидании входящих запросов? Ответ на этот вопрос очень простой: существует соглашение, согласно которому веб-сервер, обслуживающий сайт по протоколу HTTP, слушает порт 80, а протокол HTTPS обслуживается на порту 443. Но так бывает не всегда. Во время локальной разработки, обычно, используются другие порты, например, 3000, или 4000. Сам номер не принципиален, главное, что он доступен для веб-сервера, и вы обращаетесь через браузер именно к нему. Порт указыавется через двоеточие после названия сайта, например www.google.com:80.

# Веб-сервер
Веб-сервер — специализированная программа для обслуживания сайтов. Один веб-сервер может обрабатывать практически любое число сайтов (благодаря Virtual Hosts). В общем случае он перенаправляет входящие сетевые запросы на код сайтов, получает от них ответ и возвращает его браузеру. Кроме главной функции, у веб-серверов огромное число вспомогательных. Среди них кеширование, перезапись запросов, раздача статики (например, картинки), reverse proxy, балансировка нагрузки и многое другое. Веб-сервера ничего не знают про то, на чём написан сайт. Все способы взаимодействия веб-сервера и сайта на любом языке стандартизированы. Благодря этому веб-серверов существует не так много и все они могут работать с сайтами, написанными на чём угодно.

Первым и самым простым способом взаимодействия веб-сервера с сайтом был CGI (Common Gateway Interface - интерфейс, который описывает способ взаимодействие сайта и веб-сервера. Благодаря этому стандарту, веб-сервер не зависит от того на чем написан сайт.). Этот стандарт сразу разрабатывался с учётом того, что сервер не должен зависеть от того, на чём написан сайт. Он основан на переменных окружения. По сути, сайт представляет из себя исполняемый файл, который запускается веб-сервером во время обработки входящего запроса и передает в него все параметры запроса через переменые окружения. Всё, что требуется от скрипта, — это вернуть HTTP ответ в стандартный вывод (STDOUT). Общий алгоритм работы выглядит так:

1. Клиент запрашивает страницу сайта.
2. Веб-сервер принимает запрос и устанавливает переменные окружения (через них приложению передаются данные и служебная информация).
3. Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
4. CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5. Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
6. Веб-сервер передаёт результаты запроса клиенту.

Дополнительные материалы
Сетевые сокеты https://ru.wikipedia.org/wiki/Сокет_(программный_интерфейс)
CGI https://ru.wikipedia.org/wiki/CGI
FastCGI https://ru.wikipedia.org/wiki/FastCGI
*/



>>>>> Встроенный в PHP веб-сервер <<<<<
/*
PHP единственный язык программирования, в котором работа в CGI режиме встроена прямо в сам язык. А благодаря наличию встроенного веб-сервера, можно сразу видеть результат своей работы.

Разработка сайтов, с точки зрения организации кодовой базы, мало отличается от разработки обычных программ. Первым делом необходимо создать директорию внутри которой будет вестись разработка, а затем ее следует добавить в git репозиторий. Если проект учебный, то лучше сразу создать репозиторий на гитхабе и выкладывать все эксперименты туда.

Затем нужно создать внутри этой директории файл index.php. По соглашению это главный входной файл в PHP, который автоматически ищется веб-серверами. Создайте такой файл в директории проекта со следующим содержимым:
*/

// Печатает год в STDOUT
echo date('Y');

// Затем запустите веб сервер, например, на порту 8000.

$  php -S localhost:8000
PHP 7.2.7 Development Server started at Wed Jul  4 15:28:08 2018
Listening on http://localhost:8000
Document root is /private/tmp
Press Ctrl-C to quit.

/*
После того как сервер будет запущен, он полностью забирает управление. Вкладка терминала больше не доступна для ввода команд. В отличии от обычных скриптов, которые выполняют свою задачу и заканчиваются, веб-сервера должны слушать порт непрерывно и сразу реагировать на входящие соединения. Поэтому однажды запустив сервер, он продолжит работать до тех пор пока его не остановят. Остановить сервер можно набрав Ctrl-C.

Такой способ запуска удобен в разработке, но в реальном окружении сервера запускают в виде Демонов. Демон - процесс операционной системы работающий в фоне.

Если в это время попытаться запустить еще один веб-сервер в соседней вкладке на том же порту, то запуск завершиться с такой ошибкой:

Failed to listen on localhost:8000 (reason: Address already in use)

В своей программисткой жизни вы встретитесь с этой ошибкой не раз. Она означает что какой-то процесс занял соответствующий порт (в данном случае 8000). В такой ситуации нужно либо остановить процесс который вам мешает, либо стартовать на другом порту.

Посмотреть какой процесс занял порт 8000 можно командой sudo lsof -i :8000

После этого откройте браузер и введите http://localhost:8000. На экран выведется текущий год. В терминале, где запущен веб-сервер, появятся записи (лог) показывающие входящие запросы.

[Wed Jul  4 15:28:16 2018] ::1:51214 [200]: /
[Wed Jul  4 15:28:17 2018] ::1:51215 [404]: /favicon.ico - No such file or directory

Теперь снова откройте файл index.php и добавьте ниже вывод echo 'Hello, world!';. Если теперь сделать f5 в браузере, то вы увидите что изменения применились автоматически. Так происходит потому что веб-сервер запускает файл на выполнение каждый раз заново.

Дополнительные материалы
Встроенный в PHP веб-сервер http://php.net/manual/ru/features.commandline.webserver.php
Демон https://ru.wikipedia.org/Демон_(программа)
*/



>>>>> PHP CGI <<<<<
/*
В предыдущем уроке мы создали сайт буквально из одного PHP файла, печатающего в STDOUT текущий год. Все необходимые HTTP заголовки ответа PHP отправил автоматически.
*/

$ curl -v localhost:8000
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8000 (#0)
> GET / HTTP/1.1
> Host: localhost:8000
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Host: localhost:8000
< Date: Thu, 05 Jul 2018 06:20:10 +0000
< Connection: close
< X-Powered-By: PHP/7.2.7
< Content-type: text/html; charset=UTF-8
<
* Closing connection 0


/*
PHP об этом говорит прямо: X-Powered-By: PHP/7.2.7. Заголовки можно менять и добавлять используя функцию header.
*/

// file: index.php

header('X-My-Header: hi!');
echo date('Y');

// Теперь запрос

$ curl --head localhost:8000
HTTP/1.1 200 OK
Host: localhost:8000
Date: Thu, 05 Jul 2018 06:26:29 +0000
Connection: close
X-Powered-By: PHP/7.2.7
X-My-Header: hi!
Content-type: text/html; charset=UTF-8

/*
Как видно, заголовок появился в ответе. Помните, что функцию header можно вызывать только если клиенту еще не передавались данные. То есть она должна идти первой в выводе, перед ее вызовом не должно быть никаких HTML-тегов, пустых строк и т.п.
*/  

<p>hi</p>

/* Этот пример приведет к ошибке. Обратите внимание
 * на тег вверху, который будет выведен до вызова header()
 */
header('Location: http://www.example.com/');

/*
Все что мы обсудили выше, касается HTTP ответа, но не менее важно уметь работать с данными HTTP запроса: посмотреть текущие заголовки, адрес, параметры запроса и его тело. Для этого в PHP реализованы суперглобальные переменные (массивы). Суперглобальность означает то, что они доступны из абсолютно любого места программы. К ним относятся:

$GLOBALS
$_SERVER
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_REQUEST
$_ENV

И хотя чисто технически это обычные массивы которые можно изменять, большинство из них, все же, предназначены только для чтения. Например массив $_SERVER содержит в себе все заголовки запроса:
*/

Array
(
    [DOCUMENT_ROOT] => /private/tmp
    [REMOTE_ADDR] => ::1
    [REMOTE_PORT] => 58667
    [SERVER_SOFTWARE] => PHP 7.2.7 Development Server
    [SERVER_PROTOCOL] => HTTP/1.1
    [SERVER_NAME] => localhost
    [SERVER_PORT] => 8000
    [REQUEST_URI] => /
    [REQUEST_METHOD] => GET
    [SCRIPT_NAME] => /index.php
    [SCRIPT_FILENAME] => /private/tmp/index.php
    [PHP_SELF] => /index.php
    [HTTP_HOST] => localhost:8000
    [HTTP_USER_AGENT] => curl/7.54.0
    [HTTP_ACCEPT] => */*
    [REQUEST_TIME_FLOAT] => 1530772973.7628
    [REQUEST_TIME] => 1530772973
)

/*
Обратите внимание на формат ключей. PHP автоматически переводит все имена заголовков в верхний регистр. Кроме заголовков этот массив содержит некоторые дополнительные параметры, например имя запущенного скрипта и версию PHP. Практически главный ключ в этом массиве REQUEST_URI. Он содержит адрес запрошенной страницы и на основе него выбирается подходящее действие.

$_POST содержит данные отправленные методом POST. А вот $_GET вопреки своему названию, содержит Query Params, которые, если вы помните, можно отправить с любым глаголом. Кстати не все PHP программисты это знают и думают что существует понятие "гет параметры". Массив $_REQUEST содержит объединенные данные массивов $_POST и $_GET.

С одной стороны, поддержка CGI внутри самого языка позволяет начать делать сайт буквально на коленке без особых знаний программирования и HTTP, что многие и делают. С другой, PHP толкает к созданию абсолютно не поддерживаемого кода, который не может никто прочитать кроме автора. Посмотрите сами:
*/

<!DOCTYPE html>
<html>
<head>
  <title>Upload your files</title>
</head>
<body>
  <form enctype="multipart/form-data" action="upload.php" method="POST">
    <p>Upload your file</p>
    <input type="file" name="uploaded_file"></input><br />
    <input type="submit" value="Upload"></input>
  </form>
</body>
</html>

//php
  if (!empty($_FILES['uploaded_file'])) {
    $path = "uploads/";
    $path = $path . basename( $_FILES['uploaded_file']['name']);
    if (move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $path)) {
        echo "The file " .  basename( $_FILES['uploaded_file']['name']) . " has been uploaded";
    } else{
        echo "There was an error uploading the file, please try again!";
    }
  }
//php
<!DOCTYPE html>
<html>
<head>
  <title>Upload your files</title>
</head>
<body>
  <form enctype="multipart/form-data" action="upload.php" method="POST">
    <p>Upload your file</p>
    <input type="file" name="uploaded_file"></input><br />
    <input type="submit" value="Upload"></input>
  </form>
</body>
</html>

//php
  if (!empty($_FILES['uploaded_file'])) {
    $path = "uploads/";
    $path = $path . basename( $_FILES['uploaded_file']['name']);
    if (move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $path)) {
        echo "The file " .  basename( $_FILES['uploaded_file']['name']) . " has been uploaded";
    } else{
        echo "There was an error uploading the file, please try again!";
    }
  }
//php

/*
Такой способ программирования возможен только в PHP. Весь сайт начинает представлять из себя мешанину HTML и кода. Если количество разных страниц сайта достигнет хотя бы десятка (а их обычно сотни и больше), то поддержка уже станет невероятно сложной.

Поэтому несмотря на наличие встроенных механизмов (к слову неудачных), в PHP как и в других языках, принято работать поверх программных абстракций, с которыми мы познакомимся в следующих уроках.
*/


/**
Реализуйте микросайт, со следующими страницами:

/. Содержимое:

<a href="/welcome">welcome</a>
<br>
<a href="/not-found">not-found</a>
/welcome. Содержимое:

<a href="/">main</a>
Все остальные обращения считаются не найденными страницами. На такие запросы должен возвращаться код ответа 404 и содержимое:

Page not found. <a href="/">main</a>
**/

$address = $_SERVER['REQUEST_URI'];
switch ($address) {
    case '/':
        echo '<a href="/welcome">welcome</a>';
        echo '<br>';
        echo '<a href="/not-found">not-found</a>';
        break;
    case '/welcome':
        echo '<a href="/">main</a>';
        break;
    default:
        header("HTTP/1.0 404 Not Found");
        echo 'Page not found. <a href="/">main</a>';
        break;
}

/*
Что значит фраза "PHP имеет встроенную поддержку CGI"?
> Любой PHP скрипт сразу может работать как CGI скрипт, всю работу по анализу входящего окружения (параметры запроса) и возврат ответа, берет на себя рантайм (то что исполняет PHP код).
*/


# Микрофреймворк Slim


/*
Цикл запрос-обработка-ответ включает множество элементов, которые идентичны для всех сайтов. Поэтому возникли, так называемые, фреймворки, специализированные библиотеки, которые определяют структуру программы. В этом их отличие от обычных библиотек. Благодаря фреймворкам можно сосредоточиться на логике сайта, а не на продумывании базовой архитектуры или кодированию вспомогательных инструментов.

Веб-фреймворки подразделяются на две больших группы одна из которых так и называется Фреймворки, а другая - Микрофреймворки. Микрофреймворки устроены значительно проще и содержат внутри себя только минимально необходимую обвязку для комфортной работы в архитектуре HTTP запрос-ответ. Они идеально подходят для обучения, потому что просты в эксплуатации и не отвлекают от главного. С одним микрофреймворком мы уже знакомились ранее - Slim. Теперь, обладая гораздо более глубоким пониманием происходящих процессов, мы сможем изучить его вдоль и поперек, попутно разбирая типичные задачи и их способы решения в вебе.

Slim

.
├── hexlet-slim-example
│   └── public

Создайте репозиторий внутри hexlet-slim-example и добавьте его на github. Не забудьте создать файл .gitignore и поместите туда директорию vendor. 
hexlet-slim-example теперь называется корневой директорией проекта (root directory).

Зайдите в корневую директорию проекта и установите Slim:

composer require slim/slim "^3.0"

Добавьте файл hexlet-slim-example/public/index.php со следующим содержимым:
*/

require __DIR__ . '/../vendor/autoload.php';

$configuration = [
    'settings' => [
        'displayErrorDetails' => true,
    ]
];

$app = new \Slim\App($configuration);

$app->get('/', function ($request, $response) {
    return $response->write('Welcome to Slim!');
});
$app->run();

/*
Создайте файл Makefile в корне проекта и добавьте туда задачу start:
*/
start:
    php -S localhost:8000 -t public public/index.php

/* 
Теперь выполните запуск:
$ make start

Вывод должен быть примерно таким:
php -S localhost:8000 -t public public/index.php
PHP 7.2.7 Development Server started at Thu Jul  5 11:44:03 2018
Listening on http://localhost:8000
Document root is /private/var/tmp/hexlet-slim-example/public
Press Ctrl-C to quit.   

И последний шаг, откройте в браузере localhost:8000. Если все хорошо, то на экране появится надпись Welcome to Slim!.
*/

#  Обработчики запросов

// Главная содержательная часть в файле index.php - обработчик запроса:

$app = new \Slim\App();

$app->get('/', function ($request, $response) {
    return $response->write('Welcome to Slim!');
});

/*
Общий принцип работы любого веб-фреймворка отражает архитектуру HTTP. На каждый адрес задается обработчик, который выполняет необходимые действия и возвращает ответ. В Slim, все приложение (сайт) представлено объектом класса Slim\App. Этот объект содержит методы на каждый глагол HTTP: get, post, put и так далее. Эти методы принимают на вход два параметра, первый - адрес (говорят маршрут) для которого вызовется обработчик и второй, собственно сам обработчик. Лямбда-функция с двумя параметрами $request и $response.

Во фреймворках принято (и это соответствует идеям REST - https://ru.wikipedia.org/wiki/REST) определять маршрут как комбинацию глагола HTTP и адреса. То есть GET /users и POST /users с точки зрения большинства фреймворков - разные маршруты с разными обработчиками. В этом достаточно просто убедиться если определить соответствующие маршруты и выполнить к ним запросы с помощью curl.
*/

$app = new \Slim\App;

$app->get('/users', function ($request, $response) {
    return $response->write('GET /users');
});

$app->post('/users', function ($request, $response) {
    return $response->write('POST /users');
});

$app->run();

/*
$ curl localhost:8000/users
GET /users
$ curl -XPOST localhost:8000/users
POST /users

$response по стандарту - неизменяемый, это значит, что каждый метод, который выглядит как мутирующий (изменяющий) $response, на самом деле, возвращает новый $response. Не зная этого, очень легко допустить такую ошибку:
*/

$app->post('/users', function ($request, $response) {
    // Метод withStatus устанавливает код ответа HTTP
    $response->withStatus(302);
    return $response;
});

/*
В этом коде withStatus возвращает новый $response, который никак не используется, а наружу возвращается старый. Если попробовать выполнить запрос к этому обработчику, то он не вернет никаких данных.

Query Params не являются частью маршрута и не влияют на выбор обработчика. Связано это с тем, что такие параметры используются для различных вспомогательных целей, например, параметр page, обозначает страницу просматриваемого списка. Обработчик в такой ситуации всегда один и тот же, а вот данные показываются разные.

$ curl 'localhost:8000/users?page=4&per=3'
GET /users

Параметры извлекаются из объекта $request методом getQueryParam($name, $defaultValue):
*/

$app->post('/users', function ($request, $response) {
    $page = $request->getQueryParam('page', 1); // 1 - значение по умолчанию
    $per = $request->getQueryParam('per', 10);
    return $response;
});

/*
Количество обработчиков и маршрутов которые можно добавить ничем не ограничено. При этом микрофреймворки не задают никакой структуры. Если кода становится много, то разделять код по файлам придется самостоятельно.

Во фреймворках не подразумевается прямая работа с PHP в режиме CGI. Данные запроса берутся из объекта $request, ответ вместе с заголовками записывается в объект в $response. Конкретно для отправки тела вызывается функция write. Ее можно использовать множество раз в рамках одного обработчика.


/**
Пейджинг — механизм, позволяющий итерироваться по большим коллекциям небольшими порциями. Очень часто встречается в Интернете, например, в результатах запросов поисковых систем. Пейджинг с точки зрения пользователя выглядит как параметры запроса: page определяет текущую страницу, а per — количество элементов на страницу. Имена могут быть и другими, но обычно их называют так как показано выше. Запрос c page, равным 1, аналогичен запросу без указания page вообще.

Реализуйте маршрут /companies, по которому отдаётся список компаний в виде json. Компании отдаются не все сразу, а только соответствующие текущей запрошенной странице. По умолчанию выдаётся 5 результатов на запрос.

Подсказки
 Список компаний лежит в массиве $companies
 Чтобы получить его внутри обработчика, воспользуйтесь замыканием
 Возможно, вам пригодится функция array_slice

**/

// file: src/Generator.php:

namespace App;

class Generator
{
    public static function generate($count)
    {
        $numbers = range(1, 100);
        shuffle($numbers);

        $faker = \Faker\Factory::create();
        $faker->seed(1);
        $companies = [];
        for ($i = 0; $i < $count; $i++) {
            $companies[] = [
                'id' => $numbers[$i],
                'name' => $faker->company,
                'phone' => $faker->phoneNumber
            ];
        }

        return $companies;
    }
}

// file: public/index.php:

namespace App;

require '/composer/vendor/autoload.php';

$companies = Generator::generate(100);

$configuration = [
    'settings' => [
        'displayErrorDetails' => true,
    ],
];

$app = new \Slim\App($configuration);

$app->get('/companies', function ($request, $response) use ($companies) {
    $page = $request->getQueryParam('page', 1);
    $per = $request->getQueryParam('per', 5);
    $offset = ($page - 1) * $per;

    $sliceOfCompanies = array_slice($companies, $offset, $per);
    return $response->write(json_encode($sliceOfCompanies));
});

$app->run();



# HTTP Сессия 

/*
Каждая HTTP сессия определяется двумя вещами - запросом и ответом. Запрос формируется клиентом, ответ кодом обработчика соответствующего маршрута. И запрос и ответ, в Slim представлены двумя объектами, которые передаются в каждый обработчик.
*/

$app->get('/', function ($request, $response) {
    return $response->write('Hello, world!');
});

/*
$response по стандарту - неизменяемый, это значит, что каждый метод, который выглядит как мутирующий (изменяющий) $response, на самом деле, возвращает новый $response. Не зная этого, очень легко допустить такую ошибку:
*/

$app->post('/users', function ($request, $response) {
    // Метод withStatus устанавливает код ответа HTTP
    $response->withStatus(302);
    return $response;
});

/*
В этом коде withStatus возвращает новый $response, который никак не используется, а наружу возвращается старый. Если попробовать выполнить запрос к этому обработчику, то он не вернет никаких данных.

Query Params не являются частью маршрута и не влияют на выбор обработчика. Связано это с тем, что такие параметры используются для различных вспомогательных целей, например, параметр page, обозначает страницу просматриваемого списка. Обработчик в такой ситуации всегда один и тот же, а вот данные показываются разные.
*/

$ curl 'localhost:8000/users?page=4&per=3'
GET /users

// Параметры извлекаются из объекта $request методом getQueryParam($name, $defaultValue):

$app->post('/users', function ($request, $response) {
    $page = $request->getQueryParam('page', 1); // 1 - значение по умолчанию
    $per = $request->getQueryParam('per', 10);
    return $response;
});

/*
Количество обработчиков и маршрутов которые можно добавить ничем не ограничено. При этом микрофреймворки не задают никакой структуры. Если кода становится много, то разделять код по файлам придется самостоятельно.

Во фреймворках не подразумевается прямая работа с PHP в режиме CGI. Данные запроса берутся из объекта $request, ответ вместе с заголовками записывается в объект в $response. Конкретно для отправки тела вызывается функция write. Ее можно использовать множество раз в рамках одного обработчика. Подробнее об этих объектах мы поговорим в следующих уроках.

Дополнительные материалы
Request https://www.slimframework.com/docs/v3/objects/request.html
Response https://www.slimframework.com/docs/v3/objects/response.html
*/



>>>>> Динамические маршруты <<<<<

/*
До сих пор мы встречались только со статическими маршрутами. В статическом маршруте нет изменяемых частей: адрес точно совпадает с маршрутом и не меняется (поэтому называется "статический"). На практике чаще встречаются динамические маршруты. Проанализируем адреса курсов на Хекслете.

https://ru.hexlet.io/courses/php-introduction-to-oop
https://ru.hexlet.io/courses/php-object-oriented-design
https://ru.hexlet.io/courses/js-react

Нетрудно заметить, что в этих адресах прослеживается определенная структура /courses/<имя курса>. Можно предположить, что на каждый такой адрес создается свой собственный маршрут и обработчик, но тогда представьте себе процесс наполнения сайта. При добавлении нового курса придется программировать. И хотя курсов у нас не тысячи, такой процесс все равно крайне трудоемок. Тоже самое можно сказать и про профили пользователей /u/<никнейм пользователя>. Причем пользователей сотни тысяч и добавляются они на сайт непрерывно без нашего участия.

В примерах выше мы столкнулись с так называемыми динамическими маршрутами. Такие маршруты имеют внутри себя изменяемые части, но обработчик у маршрута только один. Например, все указанные выше адреса курсов соответствуют одному маршруту, который можно записать так /courses/:id. Где секция :id означает, что на это место подставляется конкретный идентификатор (уникальная запись, отличающая одну сущность от другой) курса. Имя изменяемой части можно выбирать произвольно, вместо :id можно написать :lala. Сам способ записи (в данном случае имя с ведущим двоеточием) зависит от конкретного фреймворка. В Slim для этого используются фигурные скобки, что создает ощущение использования интерполяции.
*/

$app->get('/courses/{id}', function ($request, $response, array $args) {
    $id = $args['id'];
    return $response->write("Course id: {$id}");
});

/*
Любая изменяемая часть маршрута называется плейсхолдером (заполнитель). В маршруте выше только один плейсхолдер id. Доступ к значению конкретного плейсхолдера осуществляется по имени через массив $args, передающийся третьим параметром в функцию-обработчик.

Для удобства пользователей в адресах стараются использовать не числовые идентификаторы, а человекочитаемые названия. Например, вместо /courses/332 показывают /courses/php-mvc. Эту часть адреса называют словом slug. Slug должен быть уникален и его формат обязан соответствовать требованиям формирования адресов. Как правило, эти имена делают, используя символы латинского алфавита с дефисом между ними: this-that-other-outre-collection.

Подведем промежуточный итог. Понятия адрес и маршрут обозначают разные вещи. Если маршрут статический, то он всегда совпадает с адресом, например, /about. Если маршрут динамический, то ему могут соответствовать бесконечное число адресов (даже если таких страниц на сайте нет), например, /courses/:id.

Количество плейсхолдеров в маршруте может быть больше одного. Обычно такие маршруты используются для вложенных ресурсов.
*/

$app->get('/courses/{courseId}/lessons/{id}', function ($request, $response, array $args) {
    $courseId = $args['courseId'];
    $id = $args['id'];
    return $response->write("Course id: {$courseId}")
      ->write("Lesson id: {$id}");
});


/*
Документация:
https://www.slimframework.com/docs/v3/objects/router.html
*/


/**
Реализуйте Маршрут /companies/{id}, по которому отдается json представление компании. Компания извлекается из списка $companies. Каждая компания представлена массивом у которого есть текстовый (то есть тип данных - строка) ключ id.
 **/

namespace App;

require '/composer/vendor/autoload.php';

use Illuminate\Support\Collection;

$companies = Generator::generate(100);

$configuration = [
    'settings' => [
        'displayErrorDetails' => true,
    ],
];

$app = new \Slim\App($configuration);

$app->get('/companies/{id}', function($request, $response, array $args) use ($companies) {
    $id = $args['id'];
    $companiesColl = collect($companies);
    $company = $companiesColl->firstWhere('id', '==', $id);
    return $response->write(json_encode($company));
});
$app->run();



# Шаблонизатор

/*
Формирование HTML во фреймворках — отдельная нетривиальная тема. Конечно, никто не запрещает создавать HTML напрямую в виде строки, но такой способ просто перестает работать на реальных сайтах, где HTML одной страницы — это сотни строк.
*/

$app->get('/courses/{name}', function ($request, $response, array $args) {
    $slug = $args['name'];
    $course = $courses[$slug];
    return $response->write("<h1>{$course->name}</h1>")
      ->write("<div>{$course->body}</div>");
});

/*
У такого подхода масса недостатков:
* Он небезопасен и может привести к взлому. Подробнее эта тема рассматривается в конце курса.
* С ростом количества HTML поддерживать такой код станет практически невозможно из-за неудобства анализа и редактирования.
* В таком коде будут возникать постояные проблемы с необходимостью экранировать одинарные или двойные кавычки.
* В таком коде крайне легко допустить ошибку в HTML и крайне сложно ее обнаружить.
* В типичных сайтах большая часть HTML общая для разных страниц. Выделить, ее используя подход выше — очень сложно.
Для решения подобных задач придумали шаблонизаторы — специализированные библиотеки, позволяющие описывать шаблон отдельно от остальной части кода. Здесь можно вспомнить, что сам по себе PHP уже шаблонизатор. Но так как мы работаем с фреймворком, то использовать шаблонизацию напрямую не получится, прежде его нужно правильно сконфигурировать.

Для начала необходимо установить пакет slim/php-view. Выполните соответствующую команду в корне проекта:

$ composer require slim/php-view

Добавьте в public/index.php после строчки, где создается переменная $app следующие строки:
*/

$container = $app->getContainer();
$container['renderer'] = new \Slim\Views\PhpRenderer(__DIR__ . '/../templates');

/*
В этих строчках происходит подключение шаблонизатора к Слиму, используя DI container. Наши шаблоны будут храниться в папке templates в корне проекта.

Далее добавьте еще один обработчик:
*/
$app->get('/users/{id}', function ($request, $response, $args) {
    $params = ['id' => $args['id']];
    return $this->renderer->render($response, 'users/show.phtml', $params);
});


/*
Метод render выполняет рендеринг указанного шаблона и добавляет результат в ответ. Сама функция принимает на вход три параметра:

 * Объект ответа
 * Путь до нужного шаблона внутри папки templates
 * Набор параметров, которые будут доступны внутри шаблона. Сюда можно передавать все, что угодно.
И последний шаг, добавьте файл templates/users/show.phtml со следующим содержимым:

<h1>Hello, <?= $id ?></h1>

Теперь откройте браузер и попробуйте загрузить страницу http://localhost:8000/users/nick

$ curl localhost:8000/users/nick
<h1>Hello, nick</h1>
Кажется, что мы снова начинаем мешать вывод (HTML) вместе с кодом, но это не совсем так. Шаблон — конечная точка обработки запроса. Он не содержит логики обработки. Единственная его цель — по входящим данным отрисовать готовый HTML. Подробнее об этом — в уроке, посвященном MVC.

Расширение phtml используют тогда, когда хотят показать что внутри файла содержится шаблон на PHP, в остальном файл рассматривается как обычный файл с кодом на PHP. Для удобства вставки кода в HTML, PHP предлагает альтернативный синтаксис для стандартных конструкций языка. Например, для вставки значения используется сокращенная версия тега начала PHP кода: <?= <код на php> ?>, она отличается от полной тем что вместо <?php echo ... используется <?= ....


If

<?php if ($a == 5): ?>
  A is equal to 5
<?php endif; ?>

Switch

<?php switch ($foo): ?>
    <?php case 1: ?>
    ...
<?php endswitch ?>


Foreach

<?php foreach ($actions as $action): ?>
    <option value="<?= $action ?>"><?= $action ?>
<?php endforeach; ?>

Несмотря на то, что PHP уже готовый шаблонизатор, его использование сопряжено с определенными неудобствами. Например, безопасность такой шаблонизации находится на нуле (см XSS). Так же PHP не поддерживает макеты, то есть специализированые шаблоны, содержащие обвязку сайта, в которую вставляется HTML конкретного обработчика. По этой причине в PHP, как и в других языках, используют шаблонизаторы, написанные на самом PHP. Наиболее популярные среди них Blade и Twig. Лично мне больше импонируют шаблоны на основе Slim, но в PHP они не так популярны, как в JS или Ruby.
*/


/**
Реализуйте обработчики для списка пользователей /users и вывода конкретного пользователя /users/{id}. Список пользователей генерируется в начале скрипта. Используйте пейджинг для вывода пользователей. По-умолчанию показывается 5 пользователей.

templates/users/index.phtml
Реализуйте вывод списка пользователей со ссылкой на просмотр каждого из них. Вывод должен содержать пейджинг.

templates/users/show.phtml
Реализуйте вывод всех полей пользователя
**/








# Безопасность

/*
Безопасность сайтов, тема о которой редко говорят с новичками, но от которой зависит судьба любого бизнеса. Проблемы с безопасностью могут привести к утечеке данных пользователей и даже к полному уничтожению сайта. Исследования показывают, что подавляющее большинство сайтов имеют проблемы с безопасностью и подвержены атакам. Время от времени случаются громкие взломы и утечки данных сотен тысяч и миллионов пользователей.

Главное правило касающееся безопасности звучит так: "Никогда не доверяйте пользователям". В первую очередь это правило касается данных вводимых пользователями. Возьмем практику пример из предыдущего урока, в которой выводилось имя пользователя взятое из адреса: /users/nick. Код который реализует эту функциональность, рассчитывает на то, что в адресе используются только допустимые имена. Но что если попытаться открыть такой адрес:

# Запустите сервер для приложения созданного в предыдущем уроке
# Попробуйте открыть этот адрес в FireFox, потому что Chrome и Safari блокируют его,
# они знают про то что такой код вредоносный.
http://localhost:8000/users/%3Cscript%3Ealert('attack!')%3B%3C%2Fscript%3E

В этом адресе закодирован код на JavaScript, который в оригинале выглядит так:

<script>
  alert('attack!');
</script>


Проблема в том, что этот код не отобразился, а был вставлен в HTML как часть этого HTML и соответствовано выполнился. Для браузера такой JS выглядит как часть страницы. Если попробовать открыть получившийся HTML, то он будет выглядеть так:

<h1><script>alert('attack!');</script></h1>
Совсем не то что мы ожидали. Такая атака называется XSS или Межсайтовый скриптинг. Она заключается в том что на страницу внедряется вредоносный код, который выполняется в браузере пользователя и отправляет информацию о пользователе на сервер злоумышленника. Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя. XSS относится к одному из самых распространенных типов атак из-за большого количества уязвимостей даже на сайтах больших и серьезных компаний таких как Facebook.

Уязвимость возникает из-за доверия пользовательским данным. В нашем коде вывод слага делается, без какой-либо предварительной обработки, это в корне неверно. Дело в том, что браузер пытается интерпретировать как HTML все что похоже на HTML. Если в исходном коде встречается конструкция <текст>, то браузер автоматически считает ее тегом. Для вывода данных, которые не рассматриваются как HTML, обязательно использовать специализированные функции превращающие теги в html entities.
*/
$str = "A 'quote' is <b>bold</b>";

// Outputs: A 'quote' is &lt;b&gt;bold&lt;/b&gt;
echo htmlspecialchars($str);

/*
Получившаяся строка содержит безопасное описание тегов в виде html entities. Например &lt; отобразиться как <, а &gt; как >. Возвращаясь к нашему примеру, правильный вывод в шаблоне должен пропускаться через функцию htmlspecialchars.

<h1><?= htmlspecialchars($id) ?></h1>
Теперь мы получим тот вывод, который изначально ожидали.

Тоже самое касается любого другого вывода. В следующих уроках мы начнем активно использовать формы в которых подобная уязвимость встречается очень часто.

К сожалению PHP никак не защищает нас от подобных уязвимостей. Необходимо постоянно держать в голове такую возможность и не забывать вызывать функцию htmlspecialchars. На практике вы обязательно забудете), таков человеческий фактор. Это одна из причин почему популярны другие шаблонизаторы. В большинстве из них любые выводимые данные автоматически пропускаются через функцию подобную htmlspecialchars, что гарантирует безопасность без необходимости задумываться о ней.

Кроме XSS часто встречаются и другие виды атак, например SQL Injection, но для их понимания нужно владеть самим инструментом. В будущих уроках и курсах я буду эпизодически затрагивать тему безопасности с примерами типичных ошибок и способах защиты.

Дополнительно:
Безопасность приложений (Хоть и написано что в Rails, но подходит для всех)

http://rusrails.ru/ruby-on-rails-security-guide
*/


>>>>>  Поисковые формы <<<<<<< 
 
/*
HTML Формы - основной инструмент для создания интерактивных сайтов. Через них происходит регистрация пользователя, добавление в друзья, оплата покупок, фильтрация товара в магазине и тому подобное. Самые простые формы - поисковые. Они ничего не изменяют и не создают, а используются только для фильтрации данных. Такой поиск реализован на Хекслете на странице курсов https://ru.hexlet.io/courses. Аналогичная строка поиска используется и в поисковых системах.


<form action="/courses" method="get">
  <input type="search" required name="term">
</form>

Основной элемент формы тег <form>. Все элементы формы должны быть вложены в него. У этого тега один обязательный аттрибут action, в котором нужно указать адрес на который отправятся данные формы. Второй необязательный, но часто используемый аттрибут - method. Он принимает два возможных параметра get или post, что соответствует HTTP глаголам. Напомню что семантика этих глаголов в том, что GET используется для чтения информации и неизменяет состояние системы, а POST неидемпотентный глагол, который используется при отправке форм изменяющих состояние системы, например, во время регистрации нового пользователя. По умолчанию значение этого аттрибута get. После отправки формы этим методом, ее данные передаются как параметры запроса. Если в форму выше ввести строчку sql и нажать Enter, то браузер откроет страницу по адресу https://ru.hexlet.io/courses?term=sql. Такой страницей можно поделиться с другими людьми и они увидят те же данные (если выдача не персонализированная).

Интересный факт. Поисковые боты (программы индексирующие контент в интернете) распознают поисковые формы (смотрят что метод отправки GET) и пытаются их использовать для того чтобы добавить в индекс поисковых систем как можно больше данных.

Для элементов формы используются теги input, button, select и textarea.

В свою очередь тег <input> благодаря аттрибуту type может принимать множество различных форм:

Множественный выбор (checkbox)
Одиночный выбор (radio)
Кнопка отправки формы (submit)
Поле для ввода пароля (password)
Множество других таких как: tel, email, range и т.п.
У всех элементов формы есть как общие, так и специфические аттрибуты. К общим аттрибутам относится имя. Его указание обязательно для всех элементов формы кроме кнопок, так как имя используется для доступа к содержимому. В примере выше используется текстовое поле с типом search и именем term. Именно поэтому после отправки формы в адресе появляется запись ?term=sql. Кроме того во всех формах почти всегда присутствует кнопка с типом submit, она отвечает за отправку данных. Имя кнопки задается через аттрибут value.

<input type="submit" value="Search">
Наличие кнопки отправки не обязательно. По умолчанию достаточно нажать Enter и браузер отправит форму на сервер.

К общим аттрибутам относится аттрибут required. Его наличие включает проверку обязательности заполнения на клиенте (в браузере). Попытка отправить форму с незаполненными элементами помеченными этим аттрибутом, приведет к показу сообщения о том что требуется заполнение. Не забывайте что клиентская проверка данных легко обходится посылкой данных в обход браузера (например через Curl). Поэтому проверка на клиенте не может быть основной, она лишь дублирует серверные проверки.

С точки зрения серверной части - никакой формы не существует. Выполняется обычный обработчик в который приходит типичный запрос с дополнительным набором параметров.
*/

$app->get('/courses', function ($request, $response) {
    $term = $request->getQueryParam('term', ''); // второй параметр - значение по-умолчанию
    $courses = /* filter courses by term */;
    $params = ['courses' => $courses];
    return $this->renderer->render($response, "./courses/index.phtml", $params);
});

/*
Параметры хранятся в объекте запроса и могут быть извлечены либо все сразу getQueryParams либо по одиночке getQueryParam. Дальнейшая логика целиком и полностью зависит от программиста.

Последняя деталь в работе поисковых форм - подстановка текущих значений. Обычно форма поиска продолжает отображаться на странице результатов, причем ее поля заполнены значениями введенными пользователем. Для реализации этой возможности нужно выполнить два действия. Во-первых передать данные из объекта запроса в шаблон $params = ['term' => $term]. Во-вторых, подставить их в саму форму:

<form action="/courses" method="get">
  <input type="search" name="term" value="<?= htmlspecialchars($term) ?>" />
  <input type="submit" value="Search" />
</form>
Для подобного поля ввода нужно указать аттрибут value и подставить туда текущее значение не забыв его преобразовать в безопасную форму.
*/



>>>>>  Персистентность <<<<<<< 
  
/*
Среди сайтов выделяют такую категорию сайтов как "статические". Их особенность в том что такие сайты, по сути, представляют собой готовый набор HTML страничек. Например так сделаны наши гайды http://guides.hexlet.io/. Удобно, быстро, дешево. Статическим сайтам не нужна возможность куда-то сохранять информацию, его данные хранятся прямо в HTML.

Для создания статических сайтов используют специальные генераторы сайтов https://jekyllrb.com/

Остальным сайтам повезло меньше. Все что создается пользователем, нужно куда-то сохранять. Самый простой способ сохранять - использовать файлы. Насколько он простой, настолько же нерабочий. Блокировки файловой системы не позволят работать с файлом в конкурентной среде, какой является веб, когда с сайтом могут одновременно работать сотни тысяч пользователей.

Здесь мы снова приходим к необходимости понимать устройство операционных систем. 
https://ru.hexlet.io/pages/recommended-books

Для постоянного (персистентного) хранения данных принято использовать специализированные программы - базы данных. Взаимодействие с ними строят двумя способами. Либо работая напрямую через библиотеку предназначенную для данной базы данных. Либо через ORM, которая в большинстве случаев прячет базу данных за горой абстракций.
*/

// Doctrine ORM

$user = new User();
$user->setName($newUsername);

$entityManager->persist($user);
$entityManager->flush();


/*
Тема хранения данных очень глубока и требует определенной подготовки, которая пока нами не рассматривалась. Это сделанно намеренно. Профессия построена так, чтобы мы как можно быстрее добрались до веба и научились с ним работать. Работа с базой данных рассматривается в следующих курсах. По этой причине в следующих уроках данные пользователя будут сохраняться в сессии (механизм работающий поверх Cookie), через предоставленную абстракцию.
*/


$repo = new Repository();
$repo->save($entity);
$repo->save($entity2);

$repo->find($entity['id']); // $entity

$repo->all(); // [$entity, $entity2]



>>>>>  Модифицирующие формы <<<<<<< 

/*
Формы изменяющие данные, устроены сложнее как с клиентской стороны, так и с серверной. Для уверенной работы с ними необходимо разбираться в следующих вопросах:

Знание соответствующих HTML тегов.
Понимание того как отправляются формы по HTTP.
Обработка на стороне сервера.
Валидация и вывод ошибок.
Начнем с того что за вывод формы и ее обработку должны отвечать два разных обработчика (а значит это разные маршруты). Ниже пример маршрутов для создания нового пользователя:

GET /users/new - страница с формой, которую заполняет пользователь. Эта форма отправляет POST запрос на адрес /users указанный в аттрибуте action.

POST /users - маршрут обрабатывающий данные формы
Я выбрал именно такие маршруты не случайно. Подобная схема именования рекомендуется и автоматически создается многими фреймворками, такими как Rails. Она хорошо ложится на REST архитектуру, о которой мы еще поговорим.

# Форма

<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
    <label>
        Имя
      <input type="text" name="user[name]">
    </label>
  </div>
  <div>
    <label>
      Email
      <input type="email" required name="user[email]">
    </label>
    </div>
  <div>
    <label>
        Пароль
    <input type="password" required name="user[password]">
    </label>
    </div>
  <div>
    <label>
        Подтверждение пароля
    <input type="password" required name="user[passwordConfirmation]">
    </label>
  </div>
  <div>
    <label>
      Город
      <select name="user[city]">
        <option value="3">Москва</option>
        <option value="13">Пенза</option>
        <option  value="399">Томск</option>
      </select>
    </label>
  </div>
  <input type="submit" value="Sign Up">
</form>


В отличии от поисковой формы, форма изменяющая состояние, всегда отправляется методом POST. С точки зрения семантики HTTP это не совсем верно. POST предназначен для создания нового. Для изменения правильно использовать PATCH или PUT в зависимости от того как происходит обновление, а для удаления DELETE. К сожалению, тег <form> не поддерживает возможности указывать глаголы отличные от GET и POST. Фреймворки обходят это ограничение довольно хитро. 

Еще один интересный момент в форме выше, то как задаются имена. Каждое имя определяется как ключ в массиве user. Такой способ определения имен не является обязательным, но он очень удобен для массовой обработки значений формы. Их изоляция в одном массиве позволяет избежать потенциальных пересечений с другими данными. В поисковых форма эта схема тоже удобна если количество элементов больше одного.

Здесь стоит сказать, что с точки зрения HTTP не существует способа передавать массивы. Если не указано иного, то данные формы кодируются в теле запроса как application/x-www-form-urlencoded. Чисто технически это выглядит как query string, пары ключ-значения объединенные символом &.
*/

POST /users HTTP/1.1
Host: example.com
Content-type: application/x-www-form-urlencoded
Content-length: 42

key=value&key2=value2&user%5Bname%5D%3Djon

/*
В конце тела закодирован ключ user[name]. Превращение таких ключей в массив идет на уровне интерпретатора, в случае PHP, либо самого фреймворка в случае остальных языков.  
*/

# Обработка данных

*/
$repo = new Repository();

$app->post('/users', function ($request, $response) use ($repo) {
    $validator = new Validator();
    $user = $request->getParsedBodyParam('user');
    $errors = $validator->validate($user);
    if (count($errors) === 0) {
        $repo->save($user);
        return $response->withRedirect('/');
    }
    $params = [
        'user' => $user,
        'errors' => $errors
    ];
    return $this->renderer->render($response, "users/new.phtml", $params);
});

/*
Обработка данных формы начинается с извлечения данных из тела запроса. Для этого используется метод getParsedBodyParam, который позволяет достать значение по конкретному ключу. Если нужно получить сразу все, то подойдет метод getParsedBody.
*/

$user = $request->getParsedBodyParam('user');$user = $request->getParsedBodyParam('user');

/*
Далее нужно убедиться в том что данные введены верно. Процесс проверки корректности данных называется валидацией. Slim, как и большинство микрофреймворков не предоставляет никаких механизмов для валидации. Ее можно получить из сторонних библиотек. В простейшем случае валидация реализуется простой функцией, которая проверяет данные формы и формирует специальный массив $errors, в котором ключ это название поля, а значение это текст ошибки, который нужно вывести в форме.
*/

$errors = validate($user);

// function validate($user)
// {
//     $errors = [];
//     if (empty($user['name'])) {
//         $errors['name'] = "Can't be blank"
//     }
//
//     // ...
//
//     return $errors;
// }


/*
Если ошибок нет, то данные формы сохраняются, например, в базу данных. Об этом подробнее в следующем уроке. После сохранения выполняется перенаправление (HTTP redirect), как правило, на главную страницу. За перенаправление отвечает метод withRedirect объекта $response. Результат вызова withRedirect необходимо вернуть из обработчика, только тогда Slim поймет что нужно делать перенаправление.
*/

if (count($errors) === 0) {
    $repo->save($user);
    return $response->withRedirect('/');
}


/*
Если в процессе обработки возникли ошибки, выполняется рендеринг формы из того же шаблона что мы использовали для /users/new. В этот шаблон передаются как данные формы так и список ошибок. Редиректа не проиcходит, в адресной строке остается адрес /users. Если попробовать в этот момент нажать f5, то браузер выдаст предупреждение о том что вы пытаетесь повторно отправить данные. Это сообщение предупреждает о том что метод POST не идемпотентен, и повторная отправка формы может привести к повторному созданию пользователя.
*/


$params = [
    'user' => $user,
    'errors' => $errors
];
return $this->renderer->render($response, "users/new.phtml", $params);

/*
Теперь давайте вернемся к нашей форме и изменим ее так чтобы в нее подставлялись как возникающие ошибки, так и значения полей введеные пользователем.
*/


<!-- templates/users/new.phtml -->
<form action="/users" method="post">
  <div>
    <label>
        Имя
      <input type="text" name="user[name]" value="<?= isset($user['name']) ? htmlspecialchars($user['name']) : '' ?>">
    </label>
    <?php if (isset($errors['name'])): ?>
      <div><?= $errors['name'] ?></div>
    <?php endif ?>
  </div>
  <div>
    <label>
        Email
      <input type="email" required name="user[email]" value="<?= isset($user['email']) ? htmlspecialchars($user['email']) : '' ?>">
    </label>
    <?php if (isset($errors['email'])): ?>
      <div><?= $errors['email'] ?></div>
    <?php endif ?>
  </div>
  <div>
    <label>
        Пароль
      <input type="password" required name="user[password]" value="<?= isset($user['password']) ? htmlspecialchars($user['password']) : '' ?>">
    </label>
    <?php if (isset($errors['password'])): ?>
      <div><?= $errors['password'] ?></div>
    <?php endif ?>
  </div>
  <div>
    <label>
        Подтверждение пароля
      <input type="password" required name="user[passwordConfirmation]" value="<?= isset($user['passwordConfirmation']) ? htmlspecialchars($user['passwordConfirmation']) : '' ?>">
    </label>
  </div>
  <div>
    <label>
      Город
      <select name="user[city]">
        <option value="">Select</option>
        <option <?= isset($user['city']) && $user['city'] === '3' ? 'selected' : '' ?> value="3">Москва</option>
        <option <?= isset($user['city']) && $user['city'] === '13' ? 'selected' : '' ?> value="13">Пенза</option>
        <option <?= isset($user['city']) && $user['city'] === '399' ? 'selected' : '' ?> value="399">Томск</option>
      </select>
    </label>
    <?php if (isset($errors['city'])): ?>
      <div><?= $errors['city'] ?></div>
    <?php endif ?>
  </div>
  <input type="submit" value="Sign Up">
</form>

/*
В свою очередь такое изменение формы требует изменения обработчика /users/new. Необходимо передать в шаблон пустые массивы $errors и $user во избежании ошибок.
*/


$app->get('/users/new', function ($request, $response) {
    $params = [
        'user' => [],
        'errors' => []
    ];
    return $this->renderer->render($response, "users/new.phtml", $params);
}

/*
Обратите внимание на то, как увеличилась в размерах форма. На практике она будет еще больше из-за дополнительного оформления, например, отступов и подсветки ошибок. Сделав десяток форм вы быстро поймете что так жить нельзя. Ради простейшей обработки придется писать много практического идентичного кода в HTML. Эта работа требует автоматизации и, к счастью, давно автоматизирована. Для генерации форм используются специальные билдеры. По традиции, микрофреймворки не имеют встроенных билдеров, поэтому придется искать их самостоятельно. Довольно популярны формы (https://symfony.com/doc/current/components/form.html) из фреймворка Symfony. В этом компоненте каждая форма представлена своим собственным классом. Компонент поддерживает валидацию имеет встроенные механизмы защиты от некоторых атак и многое другое.


Какое типичное поведение у страниц с формами, если ее данные не прошли валидацию?
> Сервер возвращает страницу с формой и подставленными ошибками. В идеале отдает код 422, который как раз и предназначен для таких ситуаций.

Какое типичное поведение у страниц с формами, если данные формы успешно обработаны?
> Происходит редирект на какую-то страницу, на которой пишут об успешности операции
*/



>>>>>  Стандарт PSR7 <<<<<<< 

/*
Объекты запроса и ответа во фреймворке Slim имеют интерфейс соответствующий стандарту PSR7 (https://www.php-fig.org/psr/psr-7/). Пример на главной странице фреймворка как раз демонстрирует это.
*/

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;

require 'vendor/autoload.php';

$app = new \Slim\App;
$app->get('/hello/{name}', function (Request $request, Response $response, array $args) {
    $name = $args['name'];
    return $response->getBody()->write("Hello, $name");
});
$app->run();

/*
Сам стандарт довольно объемный и не имеет смысла его дублировать. Здесь мы поговорим только о ключевых особенностях.

Request и Response, с точки зрения стандарта, представляют собой абстракцию поверх механизмов встроенных в сам PHP. Например они полностью заменяют собой суперглобальные массивы, механизм загрузки файлов и многое другое.
*/

// Возвращает значение заголовка Host
$request->getHeaderLine('Host');

// Возвращает массив заголовков, в котором значения заголовков разделены по элементам массива
foreach ($request->getHeaders() as $name => $values) {
  echo $name . ': ' . implode(', ', $values);
}

/*
Главная отличительная черта этого интерфейса в том, что он построен в иммутабельном (неизменяемом) стиле и реализует fluent interface. Ни запрос ни ответ поменять невозможно. Вместо этого всегда возвращается новый объект.
*/

// response не меняется!
$newResponse = $response->withStatus(302);
$newResponse == $response; // false

// По этой причине, во фреймворках поддерживающих стандарт PSR7, обработчик запроса всегда должен вернуть объект ответа, только в этом случае фреймворк узнает о том как надо ответить на запрос.

return $response->withStatus(500)
    ->withHeader('Content-Type', 'text/html')
    ->write('Something went wrong!');



>>>>> Flash  <<<<<<< 
 
/*
Работая на Хекслете вы не раз видели сообщение о результатах выполнения любого действия — будь то аутентификация, регистрация или вступление в курс.

В веб-разработке такое сообщение называют Flash. Оно обычно используется после перенаправления для индикации успешности или неуспешности предыдущего действия. Flash сообщения используют механизм сессий, который мы пока не рассматривали. Этот механизм позволяет хранить информацию между разными запросами одного и того же пользователя. В свою очередь механизм сессий работает благодаря кукам и встроен в PHP.
*/

// Старт PHP сессии
session_start();

$app = new \Slim\App();

// Контейнеры в этом курсе не рассматриваются (это тема связанная с самим ООП), но если вам интересно, то посмотрите DI Container
$container = $app->getContainer();

$container['flash'] = function () {
    return new \Slim\Flash\Messages();
};

$app->get('/foo', function ($req, $res) {
    // Добавление flash сообщения. Оно станет доступным на следующий HTTP запрос.
    $this->flash->addMessage('Test', 'This is a message');

    // Redirect
    return $res->withStatus(302)->withHeader('Location', '/bar');
});

/*
Если используется шаблонизатор, то сообщения передаются в шаблон и там выводятся. После их извлечения хранилище обнуляется. При следующем запросе getMessages вернёт пустой массив.

Под капотом у флеш сообщений используются сессии. Благодаря этому механизму, сайт запоминает конкретного пользователя и его сообщение.
*/

$app->get('/bar', function ($req, $res, $args) {
    // Извлечение flash сообщений установленных на предыдущем запросе
    $messages = $this->flash->getMessages();
    print_r($messages);
});

$app->run();



>>>>> CRUD  <<<<<<< 

/*
Несмотря на огромное число разнообразных сайтов, практически всю веб разработку можно свести к CRUD https://ru.wikipedia.org/wiki/CRUD операциям. CRUD широко распространенный термин, означающий 4 стандартные операции над любой сущностью (ресурсом): создание, чтение, обновление и удаление. Например в случае с пользователем можно составить такое соответствие:

Create
    Регистрация

Read
    Просмотр профиля пользователями сайта
    Просмотр пользователя в административном интерфейсе

Update
    Обновление личных данных
    Смена емейла
    Смена пароля

Delete
    Удаление

Создание полного круда включает в себя следующие действия:

Создание сущности в коде (как правило класса)
Добавление таблицы в базу
Написание тестов на обработчики
Добавление обработчиков
Прикручивание верстки
Новички тратят на создание такого круда не один день. У опытного разработчика, в прокаченном фреймворке, этот процесс занимает максимум часы. Slim, как и другие микрофреймворки, не предоставляет никаких средств автоматизации, поэтому придется многое делать руками. В целях обучения это оправданно, но в промышленной разработке, то что может быть автоматизировано, должно быть автоматизировано.

Ниже мы пройдемся по всему процессу создания круда пользователя за исключением работы с базой данных и тестов. Начнем с роутинга. Полный круд пользователя включает минимум 7 маршрутов. Их может быть больше, так как любое из действий может повторяться не один раз.

Глагол      Маршрут             Шаблон          Описание
GET         /users              index.phtml     Список пользователей
GET         /users/new          new.phtml       Форма создания нового пользователя
POST        /users                              Создание нового пользователя
GET         /users/:id          show.phtml      Профиль пользователя
GET         /users/:id/edit     edit.phtml      Форма редактирования пользователя
PATCH/PUT   /users/:id                          Обновление пользователя
DELETE      /users/:id                          Удаление пользователя

Такое соглашение изначально появилось в Rails и затем было адаптировано во многих фреймворках на языках отличных от Ruby.

С первыми тремя маршрутами мы уже знакомы и умеем с ними работать. Осталось разобрать отображение, обновление и удаление.
*/

# Отображение (SHOW)

$app->get('/users/{id}', function ($request, $response, array $args) use ($repo) {
    $id = $args['id'];
    $user = $repo->find($id);

    $params = [
        'user' => $user
    ];

    return $this->renderer->render($response, "users/show.phtml", $params);
});

/*
Чтение любой сущности происходит по одному и тому же сценарию

1. Из адреса извлекается идентификатор
2. Выполняется поиск сущности
3. Она передается в шаблон
*/

$app->get('/users/{id}', function ($request, $response, array $args) use ($repo) {
    $id =  $args['id'];
    $user = $repo->find($id);

    if (!$user) {
        return $response->withStatus(404)->write('Page not found');
    }
});

/*
Но обычно механизм обработки таких ошибок построен через исключения.
*/

# Удаление (DELETE)

$app->delete('/users/{id}', function ($request, $response, array $args) use ($repo) {
    $id = $args['id'];
    $repo->destroy($id);
    $this->flash->addMessage('success', 'User has been deleted');
    return $response->withRedirect('/users');
});

/*
Удаление устроено даже проще чем вывод, но включает в себя много ньюансов. Вместо привычных GET и POST удаление делается по глаголу DELETE. По спецификации HTTP этот глагол идемпотентный. Это означает, что поведение, в случае наличия или отсутствия сущности, должно быть одинаковое, другими словами HTTP ответ этого обработчика не зависит от того удалена уже сущность или еще нет.

А что насчет безопасности? Удаление пользователя крайне опасная операция, которую нельзя выполнять всем подряд. Даже те кто могут это делать, должны проходить через процедуру подтверждения чтобы случайно не удалить пользователя. Имеет ли пользователь доступ к конкретным действиям определяется авторизацией.

Авториза́ция — предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий. Авторизацию не следует путать с аутентификацией — процедурой проверки легальности пользователя или данных, например, проверки соответствия введённого пользователем пароля к учётной записи паролю Wiki.

То есть перед выполнением действия необходимо проверить авторизован ли пользователь на выполнение данного действия или нет. Авторизация, отдельная большая тема со своей теоретической базой. Как правило вопрос авторизации решается в каждом конкретном фреймворке самостоятельно, хотя на гитхабе можно найти обобщенные библиотеки.

И последний вопрос который осталось рассмотреть - отправка запроса на удаление. Как вы помните, HTML формы не поддерживают отправку методами отличными от GET и POST. Фреймворки выкручиваются из этой ситуации следующим образом. Если в форме задать скрытое поле с именем _METHOD и значением того глагола который нам нужен, то внутри фреймворка, до входа в обработчик, глагол будет заменен на то что был указан. Таким нехитрым способом фреймворки позволяют посылать любые запросы.

<form action="/users/<?= $user['id'] ?>" method="post">
  <input type="hidden" name="_METHOD" value="DELETE">
  <input type="submit" value="Remove">
</form>

Отдельно стоит сказать, что крайне важно соблюдать семантику HTTP. Ни в коем случае нельзя создавать HTML в котором удаление происходит GET запросом, например, по ссылке. Браузеры, их плагины и поисковые системы действуют в соответствии с семантикой HTTP. Если они видят обычную ссылку, то подразумевается что она не может выполнить деструктивных действий, а значит ее можно посетить. Даже если мы работаем в закрытой от поисковиков части сайта, в браузерах встроен механизм предзагрузки страниц, который с удовольствием вызовет все ссылки до которых сможет дотянуться на открытой странице. А плагины могут делать вообще все что угодно.
*/

# Обновление (UPDATE/PATCH)

$app->get('/users/{id}/edit', function ($request, $response, array $args) use ($repo) {
    $id = $args['id'];
    $user = $repo->find($id);
    $params = [
        'user' => $user,
        'errors' => []
    ];
    return $this->renderer->render($response, 'users/edit.phtml', $params);
});

$app->patch('/users/{id}', function ($request, $response, array $args) use ($repo) {
    $id = $args['id'];
    $user = $repo->find($id);
    $data = $request->getParsedBodyParam('user');

    $user['name'] = $data['name'];

    $validator = new Validator();
    $errors = $validator->validate($user);

    if (count($errors) === 0) {
        $this->flash->addMessage('success', 'User has been updated');
        $repo->save($user);
        return $response->withRedirect("/users/{$user['id']}/edit");
    }

    $params = [
        'user' => $user,
        'errors' => $errors
    ];

    return $this->renderer->render($response, 'users/edit.phtml', $params);
});


/*
Обновление самое сложное действие из всех по объему действий. С точки зрения кода новое здесь только одно - процесс заполнения сущности данными формы: $user['name'] = $data['name'];. Этот процесс сильно изменится при использовании ORM, а пока мы будем проставлять каждое значение руками. Теоретически можно сделать и так $user = array_merge($user, $data), но у этого подхода есть один фатальный недостаток. Такой способ абсолютно не безопасен, так как пользователь может послать данные в обход формы, например количество денег на счету и array_merge изменит их значение. Эту проблему решают те же пакеты, которые предоставляют Form Builder и, обычно, они сразу встроены во фреймворки.
*/



>>>>>  Именованные маршруты  <<<<<<< 

/*
<form action="/users/<?= $user['id'] ?>" method="post">
  <input type="hidden" name="_METHOD" value="DELETE">
  <input type="submit" value="Remove">
</form>

В примере выше ссылка "зашита" прямо в шаблон. В принципе, ничего криминального, но дальше возможны осложнения. Что если маршрут изменится с /uses/{id} на /u/{id}? Придется пройтись по всем шаблонам и изменить все ссылки. А если этот маршрут удалить? Сайт продолжит работать (и не приемочные тесты тоже), хотя будет лучше если страницы с такими ссылками начнут выдавать ошибки. Тогда выявить подобные ссылки станет крайне просто особенно если есть тесты.

Для решения этой задачи придумали именовать маршруты. Далеко не все микрофреймворки поддерживают именованные маршруты, но Slim здесь отличился в правильную сторону.
*/

$app->get('/users', function ($request, $response) {
    // ...
})->setName('users');

$app->get('/users/{id}', function ($request, $response) {
    // ...
})->setName('user');

// Метод setName задает имя маршрута. Построить маршрут по имени можно используя метод pathFor объекта Router.

$app->get('/', function ($request, $response) {
    $this->router->pathFor('users'); // /users
    $this->router->pathFor('user', ['id' => 4]); // /users/4
});


// К сожалению, PHP-View, который мы используем, не прокидывает этот метод в шаблоны, в отличие от Twig-View https://github.com/slimphp/Twig-View. Мой совет: используйте в своих приложениях последний.



>>>>>  Model-View-Controller (MVC)   <<<<<<< 

/*
Архитектура веб-приложений, в первую очередь, определяется самой природой веба, тем, как работает HTTP. Последовательность запрос-обработка-ответ — базис, на который нанизывается все остальное. Фреймворки идут дальше и разделяют приложение на дополнительные слои уже внутри самого процесса обработки запроса. Такое разделение напрашивается само собой, без него код быстро превращается в мешанину из запросов к базе данных, формирований html и логики обработки данных.

Из обработки запроса естественным образом выделяется слой шаблонов, на основе которых генерируется HTML. Этот слой принято называть View. Кроме него, как минимум, выделяют еще два слоя: Model и Controller. Остальное добавляется по мере роста сложности приложения. Аббревиатура MVC (Model-View-Controller) — тема нашего урока.

Существует две разных версии MVC. Та, которая была придумана изначально (в сообществе SmallTalk программистов), создавалась под толстые клиенты, а они представляют собой событийные системы, как современные фронтенд приложения. На сервере используется другая вариация MVC, которая называется MVC v2. Буквы в ней те же, но означают местами другое, и самое главное, что совсем по-другому строится взаимодействие.

Архитектурный шаблон MVC задает основную структуру приложения и позволяет коду достаточно долго развиваться, оставаясь удобным в поддержке. MVC, с некоторыми модификациями, реализуется всеми веб-фреймворками. И если с View все понятно, то с Model и Controller нужно разбираться отдельно. Под контроллерами понимаются обработчики запросов. Они принимают объект запроса и возвращают объект ответа. В случае Slim, контроллеры представлены анонимными функциями, но это не обязательно: в больших фреймворках контроллер — это класс, а обработчики — его методы. Эти методы обычно именуют действиями (actions). В принципе, на этом наше разделение можно было бы и закончить. При таком подходе вся логика сосредоточена в самих контроллерах, что вполне допустимо в самых примитивных случаях.

Во всех остальных ситуациях выделяют еще один слой, который называют Model. Сразу хочу оговориться, что понятие Model не включает в себя персистентность (постоянное хранение, базы данных). Среди разработчиков распространено заблуждение, что модель — это база данных и данные внутри нее. Но это не так.

Слой Model отвечает за бизнес-логику приложения и данные, связанные с ней. Чисто технически, этот слой может быть представлен большим количеством разных способов, которые еще сильно зависят от конкретного языка программирования и используемых библиотек. Самый распространенный вариант — это ORM, но так бывает не всегда. Более того, довольно часто, даже при наличии отдельного слоя Model, часть логики все же проникает в контроллеры.

Зачем понадобилось выделять слой Model? Достаточно давно мне попалась на глаза интересная статья, которая называлась Rails is not your application http://blog.firsthand.ca/2011/10/rails-is-not-your-application.html (Rails - популярный веб фреймворк, который стал прообразом для большинства современных фреймворков на разных языках программирования). Идея статьи заключается в том, что предметная область, которую мы реализуем внутри нашего сайта, никак не связана ни с сайтом ни тем более с фреймворком, который используется внутри. Посудите сами, могут ли поменяться правила бухгалтерии в зависимости от выбранного фреймворка и вообще, как связана бухгалтерия и фреймворк? Очевидно, никак и бизнес-правила этой области не зависят от существования программирования. Посредством программирования мы можем их выразить в коде, но этот код снова не будет связан с используемым фреймворком. В идеале, код который описывает предметную область и позволяет с ней работать, можно взять и перенести в другой фреймворк без модификаций. Как видно, на логическом уровне есть граница между кодом, моделирующим предметную область, и кодом, обслуживающим веб запросы. Но эту границу иногда провести трудно. Например, к чему относится отправка письма при регистрации, а авторизация, а восстановление пароля? Если закапываться дальше, то на горизонте возникают понятия Application Logic и Business Logic, а затем и Service Layer. Если вам интересно, то прочитайте про них самостоятельно.

Самая большая сложность в коде находится именно в этой части приложения. Модель не имеет никакой четкой структуры, это не классическое запрос-обработка-ответ. Моделирование предметной области довольно сложная тема, на почве которой родится еще не мало холиваров.

Взаимоотношения между слоями в MVC не менее важны, чем наличие самих слоев. Model, как мы уже выяснили, живет своей жизнью и не знает (и не может знать) ничего про существование Controller или View. Последние, в свою очередь, используют модель для запуска бизнес логики или для формирования HTTP ответа. Controller инициирует различные процессы и запуск бизнес-логики. Кроме того, Controller отвечает за формирование ответа и запускает рендеринг шаблонов. Шаблоны не знают про существование слоя Controller, но используют данные, предоставленные им для формирование HTML (или JSON, или чего-то еще).
*/


>>>>> Cookies  <<<<<<<   

/*
Cookies - это механизм хранения данных браузером удаленной машины для отслеживания или идентификации возвращающихся посетителей. По сути единственный надежный способ понять что перед нами тот же самый пользователь (хотя если угнать чужие куки, то можно подделать запрос от другого пользователя). Куки использует не только сам сайт, но и всемозможные виджеты, которые встраиваются на разные странички. Именно благодаря кукам, гугл узнает вас и преследует рекламой того что вы недавно искали, на сайтах, которые вроде бы не должны знать о ваших предпочтениях.

PHP прозрачно поддерживает работу с куками. Куки приходящие в HTTP запросе становятся доступны через суперглобальный массив $_COOKIES. Этот массив используется только для чтения, писать в него бесполезно. Установка кук осуществляется функцией setcookie(). Так как куки отправляются вместе с заголовками, то вызов этой функции должен происходит до любой отправки данных в браузер.

В PSR7 определены только два метода работающих с куками и оба этих метода извлекают куки.

getCookieParams() - возвращает все куки
getCookieParam($name, $default = null) - возвращает указанную куку
Для установки кук придется воспользоваться более низкоуровневым методом withHeader($name, $value), добавляющим любые заголовки в ответ:
*/

$app->post('/example', function ($request, $response) {
    // Set-Cookie: <cookie-name>=<cookie-value>
    return $response->withHeader('Set-Cookie', "foo=bar")
});


// Типичный вариант использования кук - корзина в интернет-магазине. Во время добавления товара, код магазина формирует куку, в которую начинает заносить данные о заказе.

$app->post('/cart-items', function ($request, $response) {
    // Информация о добавляемом товаре
    $item = $request->getParsedBodyParam('item');

    // Данные корзины
    $cart = json_decode($request->getCookieParam('cart', json_encode([])));

    // Добавление нового товара
    $cart[] = $item;

    // Кодирование корзины
    $encodedCart = json_encode($cart);

    // Установка новой корзины в куку
    return $response->withHeader('Set-Cookie', "cart={$encodedCart}")
        ->withRedirect('/');
});

/*
Обратите внимание на необходимость кодирования данных корзины. Кука с точки зрения HTTP содержит значение в виде строки, а значит для хранения составных структур нужно проводить ручное кодирование в строку и декодирование при извлечении. Иногда простого кодирования недостаточно, особенно если данные имеют повышенную важность и их желательно защитить. В таких случаях дополнительно применяют шифрование на стороне сервера.

У кук существует ограничение на количество данных которые в них можно хранить, оно равно 4кб. Для корзины интернет магазины этого хватит с головой, но в других ситуациях может понадобится больше места и тогда придется воспользоваться сессией.
*/



>>>>> Сессия  <<<<<<<   

/*
Сессия, в отличие от кук, как понятие, не существует ни в браузере ни в HTTP. Это абстракция, созданная для удобной работы с индивидуальными пользователями. Сессии реализуются на уровне конкретных фреймворков и только в PHP сессии встроены в язык. Общий принцип работы сессии сводится к трем операциям:

 * Старт сессии. Так мы говорим системе что хотим начать следить за пользователем. Во многих фреймворках эта операция выполняется неявно, при попытке чтения или записи в сессию.
 * Запись данных в сессию.
 * Чтение данных из сессии.
Set-Cookie: _hexlet_session=CM5DvfXch6M3uPJHyfLDpv52wBe4iu3og domain=.hexlet.io; path=/; expires=Sun, 12 Aug 2018 12:56:51 -0000; secure; HttpOnly

Старт сессии на техническом уровне означает установку специальной куки в браузер. Обычно эта кука содержит идентификатор сессии, который уникален для каждого пользователя. Данные же сессии, могут хранится где угодно, это зависит от конкретной реализации. В этом одно из ключевых отличий работы с пользователями напрямую через куки или через сессию. Сессия более высокоуровневая абстракция. Например в PHP, по-умолчанию, данные сессии хранятся в файлах. Из этого следует сразу два вывода. Во-первых сессия ограничена только физическим пространством дисков, во-вторых данные хранятся на сервере что безопаснее. Если этого недостаточно, например серверов больше чем один, то буквально парой строк кода в конфигурации, можно изменить тип хранилища с файлов на базу данных.

Другое преимущество заключается в том что работая с сессией не надо думать про имена кук, про сеариализацию и десереализацию составных данных. Все это происходит автоматически.
*/

// Операция идемпотентна. Не важно была ли инициализирована сессия раньше, старт сессии выполняется всегда
session_start();

if (!isset($_SESSION['count'])) {
    $_SESSION['count'] = 0;
} else {
    $_SESSION['count']++;
}

print_r($_SESSION['count']);

/*
Этот простой скрипт демонстрирует работу сессий в PHP. В отличии от всех остальных суперглобальных массивов для работы с HTTP, массив $_SESSION мутабельный. Все что добавится в него, автоматически попадает в сессию и сохраняется между запросами до тех пор, пока кука не будет удалена (или изменена). Даже из этого простого примера видно что сессия упрощает работу с пользователем. Кроме того, значением массива $_SESSION может быть любая составная структура, массив или объект. Механизм сессий автоматически беспокоится о сериализации и десереализации.

Внутри Slim нет никакого особенного механизма для работы с сессиями, так как они не являются частью стандарта PSR7. Работа с сессией происходит напрямую. Перепишем наш пример добавления товаров в корзину используя сессию.
*/

session_start();

$app->post('/cart-items', function ($request, $response) {
    // Информация о добавляемом товаре
    $item = $request->getParsedBodyParam('item');

    // Добавление нового товара
    $_SESSION['cart'][] = $item;

    return $response->withRedirect('/');
});


/*
По сравнению с версией на куках, ушла значительная часть кода. Кодирование и декодирование в json, извлечение куки и перезапись куки.

Иногда возникает задача уничтожать сессию, например при выполнении выхода из системы. Полное уничтожение сессии включает в себя три шага:

Обновление куки с установкой даты в прошлое
Обнуление массива $_SESSION - session_unset()
Обнуление хранилища сессий - session_destroy()
Только в этом случае сессия уничтожится полностью. Первый шаг можно не делать, но второй и третий желательно.

В целом, у сессий в PHP очень много тонкостей и механизмов для управления ими. Если вам интересно разобраться глубоко в том как устроена ее работа, добро пожаловать в официальную документацию.


*/






############## PHP: Ввод и вывод ##############

>>>>> Пути  <<<<<<< 

echo __FILE__ . PHP_EOL; // абсолютный путь к текущему файлу
echo __DIR__ . PHP_EOL; // абсолютный путь к текущему каталогу <-> dirname(__FILE__)
echo basename(__FILE__) . PHP_EOL; // возвращает название файла 
print_r(pathinfo(__FILE__)); // массив с данными о файле: директория, название файла, расширение, название файла без расширения
echo getcwd(); // возвращает директорию в которой был запущен скрипт

// build path
$pathParts = ['var', 'tmp', 'hexlet'];
$path = implode(DIRECTORY_SEPARATOR, $pathParts);
echo DIRECTORY_SEPARATOR . $path . PHP_EOL;

$file = new \SplFileInfo(__FILE__); // класс для работы с файлами
echo $file->getPathInfo() . PHP_EOL;
echo $file->getFileName() . PHP_EOL;
echo $file->getExtansion() . PHP_EOL;


/***
Реализуйте функцию cd, принимающую на вход два параметра: текущую директорию и путь для перехода. Функция должна вернуть директорию, в которую необходимо перейти.

Пример использования:
***/

cd('/current/path', '/etc'); // /etc
cd('/current/path', '.././anotherpath'); // /current/anotherpath
/*
Правила перехода
Если путь для перехода начинается с /, то он же и является конечным путем (так как абсолютный путь).
.. - на уровень выше
. - та же директория
*/

namespace App\FileUtils;

function cd($current, $move)
{
    // BEGIN (write your solution here)
    $paths = explode('/', $current);
    $stack = array_filter($paths, function($path) {
       return $path == ''; 
    });
    foreach ($move as $item) {
        if ($item == '..' || $item == '../') {
            array_pop($stack);
        } elseif ($item == '.') {
            continue;
        }
    }
    return $stack;
    // END
}

// Tests:

namespace App\Tests;

use PHPUnit\Framework\TestCase;
use function App\FileUtils\cd;

class FileUtilsTest extends TestCase
{
    /**
     * @dataProvider additionProvider
     */
    public function testCd($actual, $current, $move)
    {
        $this->assertEquals($actual, cd($current, $move));
    }

    public function additionProvider()
    {
        return [
            ['/', '/current/path', '/'],
            ['/current', '/current/path', '..'],
            ['/current', '/current/path', '../'],
            ['/current', '/current', '.'],
            ['/current/anotherpath', '/current/path', '.././anotherpath'],
            ['/etc', '/current/path', '/etc'],
            ['/current/anotherpath/path', '/current/anotherpath', '../anotherpath/path'],
        ];
    }
}



>>>>> Файловая система  <<<<<<< 

namespace Theory;

if (!file_exists($path)) { // проверяет существование файла/директории(в unix директория тоже файл). Проверить на директорию: is_dir($path) 
    mkdir($path, 0755, $recursive); // создать директорию
} 

rmdir($path); // удаление директории

if (!file_exists($path)) { // проверить на файл: is_file($path)
    touch($path); // создать файл
}

unlink($path); // удаление файла

rename($old, $new); // переименование файла
copy($old, $new); // копирование файлов

print_r(glob("/var/tmp/*"));
print_r(scandir("/var/tmp"));


// DirectoryIterator FilesystemIterator RecursiveDirectoryIterator
$iterator = new \GlobIterator('../*');
foreach ($iterator as $item) {
    print_r($item);
}

$info = new \SplFileInfo(__FILE__);
echo $info->isFile();


/***

Реализуйте функцию rrmdir, удаляющую директорию рекурсивно, то есть вместе со всем своим содержимым.

Подсказка
Одна из возможных реализаций может использовать итераторы.
Воспользуйтесь функцией scandir вместо функции glob.

***/

namespace App\FileUtils;

function rrmdir($dir)
{
    $dirIterator = new \RecursiveDirectoryIterator($dir, \FilesystemIterator::SKIP_DOTS);
    $iterator = new \RecursiveIteratorIterator($dirIterator, \RecursiveIteratorIterator::CHILD_FIRST);
    foreach ($iterator as $filename => $fileInfo) {
        if ($fileInfo->isDir()) {
            rmdir($filename);
        } else {
            unlink($filename);
        }
    }
    rmdir($dir);
}



>>>>> Чтение файла  <<<<<<< 

namespace Theory;

$file = __FILE__;

if (file_exists($file) && is_readable($file)) {
    #1
    $lines = file(__FILE__); 
    foreach($lines as $line) {
        echo $line;
    }

    #2
    $content = file_get_content(__FILE__);
    echo $content;

    // #1, #2 - подходят для маленьких файлов (тк. эти функции загружают все в память). Поэтому для больших файлов надо делать это потоково:

    #3
    $handle = fopen($filename, "rb"); // rb - чтение без модификации. r+
    if ($handle) { // $handle - файловый дискриптор. Файл получилось открыть
        try {
            $contents = fread($handle, filesize($filename)); // 2-й параметр сколько байт прочитать
        } finally {
            fclose($handler);
        }
    }

    #4
    $handler = fopen($file, "rb"); 
    if ($handler) {
        try {
            while (!feof($handler)) { // проверяет не достигли ли мы конца файла.
                echo fgets($handler, 1024); // 2-й параметр сколько байт прочитать
            }
        } finally { // потому что во время работы могут быть выброшены исключения
            fclose($handler);       
        }
    }

    #5
    $handler = fopen($filename);
    if ($handler) {
        try {
            /* javier   argonout    pe */
            /* hiroshi  sculptor    jp */
            /* robert   slacker us*/
            while ($userinfo = fsconf($handle, "%s\t%s\t%s\n")) { // возвращает массив значений соотствующий этому паттерну
                list($name, $profession, $countrycode) = $userinfo;
            }
        } finally {
            fclose($handler);
        }
    }
}

#6
$file = new SplFileObject('file.txt');
while(!$file->eof()) {
    echo $file->fgets();
}

#7
foreach ($file as $lineNumber => $content) {
    printf("Line %d: %s", $lineNumber, $content);
}

#8:
$linesTenToTwentyIterator = new LinitIteratir(
    $file,
    9, // start at line 10
    10 // iterate 10 lines
);

foreach ($linesTenToTwentyIterator as $line) {
    echo $line; // outputs line 10 to 20
}



>>>>> Запись в файл  <<<<<<<  

namespace Theory;
$file = __DIR__ .DIRECTORY_SEPARATOR . 'temp';
$data = "my data\n";

file_put_contents($file, $data); // FILE_APPEND - не перезаписывать, добавлять в конец. 

if (is_writable($file)) {
    $handle = fopen($file, 'ab'); // ab - добавление данных в конец; r - перезаписывать; a+ c
    if ($handle) {
        try {
            fwrite($handle, $data);
        } finally {
            fclose($handler);
        }
    }
}

$file = new \SplFileObject($file, 'ab');
$file->fwrite($data);



>>>>> Манипуляция с файловыми указателями  <<<<<<< 

namespace Theoty;

$data = 'ehu';
$handle = fopen('temp', 'wb');
fwrite($handle, $data);
echo ftell($handle) . PHP_EOL; // возвращает позицию указателя => 3
fseek($handle, 0); // rewind($handle); // перемещение указателя; 0 - в начало <-> rewind($handle)
echo ftell($handle) . PHP_EOL; // => 0

// SplFileObject



>>>>> Временный файл  <<<<<<< 

$dir = sys_get_temp_dir(); // возращает временную системную директорию

$tmpfname = tempnam(sys_get_temp_dir(), "HEXLET"); // создает пустой временный файл. В первом аргументе передается директория (здесь временная системная директория)

$temp = tmpfile(); // создает файловый дискриптор временного файла
try {
    fwrite($temp, 'my data');
    fseek($temp, 0);
    echo fread($temp, 1024);
} finally {
    fclose($temp);
}

// SplTempFileObject


/***
Реализуйте функцию tmpdir, принимающую на вход лямбда-функцию. tmpdir при этом должна создать временную директорию, а потом вызвать лямбду с переданным туда путем до директории. После вызова tmpdir должна удалить эту временную директорию. Функция tmpdir должна вернуть результат выполнения лямбда-функции.

Пример:
***/

$path = FileUtils\tmpdir(function ($dir) {
    is_dir($dir); // true
    return tempnam($dir, 'hexlet');
});

file_exists($path); // false


namespace App\FileUtils;

function tmpdir($func)
{
    $dir = sys_get_temp_dir() . DIRECTORY_SEPARATOR . uniqid();
    mkdir($dir);
    try {
        return $func($dir);
    } finally {
        rrmdir($dir);
    }
}

function rrmdir($dir)
{
    $iterator = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($dir, \FilesystemIterator::SKIP_DOTS), \RecursiveIteratorIterator::CHILD_FIRST); // RecursiveIteratorIterator - делает рекурсивное перемещение по всем файлам и каталогам
    foreach ($iterator as $filename => $fileInfo) {
        if ($fileInfo->isDir()) {
            rmdir($filename);
        } else {
            unlink($filename);
        }
    }
    rmdir($dir);
}

// Tests:

class FileUtilsTest extends TestCase
{
    public function testTmpdir1()
    {
        $exists = false;
        $path = tmpdir(function ($dir) use (&$exists) {
            $exists = is_dir($dir);
            return tempnam($dir, 'hexlet');
        });

        $this->assertTrue($exists);
        $this->assertFalse(file_exists($path));
    }

    public function testTmpdir2()
    {
        $exists = false;
        $isEmpty = tmpdir(function ($dir) use (&$exists) {
            $exists = is_dir($dir);
            return !(new \FilesystemIterator($dir))->valid();
        });

        $this->assertTrue($exists);
        $this->assertTrue($isEmpty);
    }
}

$files = new RecursiveIteratorIterator($dir);

echo "[$path]\n";
foreach ($files as $file) {
    echo " ├ $file\n";
}

/*
[tree]
 ├ tree\.
 ├ tree\..
 ├ tree\dirA\.
 ├ tree\dirA\..
 ├ tree\dirA\dirB\.
 ├ tree\dirA\dirB\..
 ├ tree\dirA\dirB\fileD
 ├ tree\dirA\fileB
 ├ tree\dirA\fileC
 ├ tree\fileA


Удаляем записи точек (. и ..), также режим рекурсии будет изменен, чтобы сначала взять родительский элемент (подкаталог) (SELF_FIRST) перед дочерними элементами (файлы и под-поддиректории в подкаталоге):

LEAVES_ONLY (по умолчанию): только файлы списка, нет каталогов.
SELF_FIRST: Перечислите каталог, а затем файлы там.
CHILD_FIRST: сначала укажите файлы в подкаталоге, затем каталог.
*/

$dir  = new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS);
$files = new RecursiveIteratorIterator($dir, RecursiveIteratorIterator::SELF_FIRST);

echo "[$path]\n";
foreach ($files as $file) {
    $indent = str_repeat('   ', $files->getDepth());
    echo $indent, " ├ $file\n";
}

/*
[tree]
 ├ tree\dirA
    ├ tree\dirA\dirB
       ├ tree\dirA\dirB\fileD
    ├ tree\dirA\fileB
    ├ tree\dirA\fileC
 ├ tree\fileA
*/






############## «PHP: Функциональное программирование» ##############


>>>>>   Map: Отображение списков  <<<<<<<

$result = array_map(function ($key, $value)) {
    return $key . $value;
}, array_keys($map), $map); // передаем ключи массива в array_map
// не поддерживает итерируемые объекты

// Functional\map - поддерживает:
$iterator = new \DirectoryIterator('..'); // .. - директория выше
$result = map($iterator, function ($info) {
    return $info->getFilename();
});




>>>>>  Фильтрация коллекций  <<<<<<<

$result = array_filter($array, function ($key) {
    return $key > 5
}, ARRAY_FILTER_USE_KEY); // передаем ключи в array_filter. ARRAY_FILTER_USE_BOTH - передать ключ и значение
// не поддерживает итерируемые объекты

// Functional\select:
$iterator = new \DirectoryIterator('..');
$result = select($iterator, function ($item) {
    return $item->isDir();
});

/*
Ссылки
Итераторы - http://php.net/manual/en/language.oop5.iterations.php

/**
«Мощность строки» — выдуманное нами понятие, которое показывает ее силу ;-). Вычисляется оно как сумма ASCII кодов букв строки.
Реализуйте функцию powerOfString, которая находит мощность строки.

Подсказки:
Сумма элементов массива — array_sum.
Преобразование строки в массив — str_split.
Получить ASCII код символа — ord.
**/
namespace App\Solution;

require getenv('COMPOSER_HOME') . '/vendor/autoload.php';

use function Functional\select;
use function Functional\map;

function powerOfString($str)
{
    $result = map(str_split($str), function ($item) {
        return ord($item);
    });

    return array_sum($result);
}

/**
Реализуйте функцию evenSquareSum, которая принимает на вход массив и возвращает сумму квадратов четных чисел.
[1, 2, 3, 8]; // 2^2 + 8^2 = 68
**/
namespace App\Solution;

require getenv('COMPOSER_HOME') . '/vendor/autoload.php';

use function Functional\select;
use function Functional\map;

function evenSquareSum($array)
{
    $evenNumbers = select($array, function ($item) {
        return $item % 2 == 0;
    });

    $squaredNumbers = map($evenNumbers, function ($item) {
        return $item ** 2;
    });

    return array_sum($squaredNumbers);
}




>>>>>  Zip  <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\zip;

// [1, 2] zip with [3, 4]  (по индексам) => [[1, 3], [2, 4]]

// array_map
$result = array_map(null, range(1, 3), range(11, 13)); // если первый аргумент null array_map работает как zip

print_r($result); // => [[1, 11], [2, 12], [3, 13]]

// Functional\zip
$result = zip(range(1, 3), range(11, 13));

print_r($result); // => [[1, 11], [2, 12], [3, 13]]

// array_map
$result = array_map(function ($a, $b) { // <-> array_map(null, range(1, 3), range(11, 13))
    return [$a, $b];
}, range(1, 3), range(11, 13);

print_r($result);


// Returns [['one', 1], ['two', 2], ['three', 3]]
zip(['one', 'two', 'three'], [1, 2, 3]);

// Returns ['one|1', 'two|2', 'three|3']
zip(
    ['one', 'two', 'three'],
    [1, 2, 3],
    function ($one, $two) {
        return $one . '|' . $two;
    }
);




>>>>>   Функция reduce  <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\reduce_left;

$array = [1, 3, 2, 9, 8, 4];


// as array

$result = array_reduce($array, function ($acc, $item) { // наибольший элемент массива
    return $item > $acc ? $item : $acc;
}, $array[0]);

print_r($result);

// Functional\reduce_left

$result = reduce_left($array, function ($item, $index, $collection, $acc) { // left обход коллекции слева, right - справа
    return $item > $acc ? $item : $acc;
}, $array[0]);

print_r($result);

/**
Реализуйте функцию wordsCount, которая принимает на вход массив слов и возвращает массив, в котором ключ это слово, а значение это количество раз, которое это слово встречалось в исходном массиве.
Пример:
**/
['cat' => 1, 'dog' => 1, 'fish' => 2] == wordsCount(['cat', 'dog', 'fish', 'fish'])


function wordsCount($array)
{
    $result = reduce_left($array, function ($item, $index, $collection, $acc) {
        if (!array_key_exists($item, $acc)) {
            $acc[$item] = 0;
        }
        $acc[$item]++;
        return $acc;
    }, []);

    return $result;
}



>>>>>   Функция sort  <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'User.php';

use function Functional\sort as fsort;

$collection = ['first' => 'dog', 'second' => 'cat', 'third' => 'bird'];

// Sorts a collection alphabetically
// uksort, uasort - сохраняет ключи

usort($collection2, function ($left, $right) { // usort - не сохраняет ключи
    return strcmp($left, $right); // возвращает отрицательное число, если str1 меньше str2, положительное число, если str1 больше str2, и 0, если строки равны.
});

print_r($collection);

// Sorts a collection alphabetically
$result = fsort($collection, function ($left, $right) {
    return strcmp($left, $right);
});

print_r($collection);

$users = [new User(10), new User(3), new User(4)];

// Functional\sort. Sorts a collection of users by age

$result = fsort($users, function ($user1, $users2) {
    if ($user->getAge() == $user2->getAge()) {
        return 0;
    }
    return ($user1->getAge() < $user2->getAge()) ? -1 : 1;
});


/**
Реализуйте функцию sortByBinary, которая сортирует переданную коллекцию и возвращает новую коллекцию. Сортировка происходит следующим образом:

Сортируем по количеству единиц в бинарном представлении (порядок следования не важен).
Если количество единиц одинаково, то сортируем на основе десятичного представления.
Пример:
**/
[1, 2, 4, 3] == sortByBinary([3, 4, 2, 1]);

function sortByBinary($collection)
{
    return fsort($collection, function ($left, $right) {
        $countBinOneL = substr_count(decbin($left), '1');
        $countBinOneR = substr_count(decbin($right), '1');
        if ($countBinOneL == $countBinOneR) {
           return $left < $right ? -1 : 1;
        }
        return $countBinOneL < $countBinOneR ? -1 : 1;
    });
}

# 2 

function sortByBinary($collection)
{
    $onesCount = function ($number) {
        $binary = decbin($number);
        $bitsArray = str_split($binary);
        return sizeof(array_filter($bitsArray, function ($bit) {
            return $bit == "1";
        }));
    };

    $sorted = fsort($collection, function ($prev, $next) use ($onesCount) {
        $result = bccomp($onesCount($prev), $onesCount($next));
        if ($result === 0) {
            if ($prev > $next) {
                return 1;
            } else if ($prev < $next) {
                return -1;
            }
            return 0;
        }
        return $result;
    });

    return $sorted;
}



>>>>>   Частичное применение функции  <<<<<<<


namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

use function Functional\select;
use function Functional\partial_left;
use function Functional\partial_any;
use const Functional\...;


$substractor = function ($a, $b) {
    return $a - $b;
};

echo substractor(10, 20); // -> -10

// closure 
$substractor2 = function ($a) {
    return function ($b) use ($a) { // $a - замыкание
        return $a - $b;
    };
};

$partiallyAppliedSubstractor = $substractor2(10); //  подход - частичное применение функции
echo $partiallyAppliedSubstractor(20); // => -10

// Functional\partial

$partiallyAppliedSubstractor = partial_left($substractor, 10);
echo $partiallyAppliedSubstractor(20); // => -10

$elements = [
    'john',
    'joe',
    'joanna',
    'patric'
];

$selected = select($elements, partial_any('substr_count', ..., 'jo')); // фильтр по substr_count, в подстроке есть 'jo'. ... - заполнитель

print_r($selected); //  => ['john', 'joe', 'joanna'];

/**
Реализуйте функцию mapWithPower, которая принимает на вход массив и степень, и возвращает новый массив, в котором каждое значение возведено в переданную степень.

Пример:
**/
[1, 1, 9, 100, 0] == mapWithPower([-1, 1, 3, 10, 0], 2)

function mapWithPower($nums, $exp)
{
    $func = partial_any('pow', …, $exp);
    return map($nums, $func);
}



>>>>>   Partition  <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'Admin.php';
require 'User.php';

use function Functional\partition; 

$collection = [new User(), new Admin(), new User()];

list($admins, $users) = partition($collection, function ($user) { // разбивает на 2 или более коллекций
    return $user->isAdmin();
});

print_r($admins);
print_r($users);


/**
Реализуйте функцию separateEvenAndOddNumbers, которая принимает на вход массив чисел и возвращает массив, в котором первый элемент - это массив четных чисел, а второй элемент - это массив нечетных чисел, полученных из исходного массива.
**/

function separateEvenAndOddNumbers($numbers)
{
    return partition($numbers, function ($num) {
        return $num % 2 == 0;
    });
}


>>>>>   Группировка  <<<<<<<

namespace Theory;

require getenv("HOME") . '/.composer/vendor/autoload.php';

require 'User.php';

use function Functional\group;

$array = [
    new User('english'), new User('spanish'), new User('russian'), new User('english');
]; 

$grupUser = group($array, function ($user) {
    return $user->getLang();
});

print_r($groupUser); // 'english' => ..., 'spanish' => ... , ...



/**
Реализуйте функцию ages, которая принимает на вход список пользователей и возвращает массив, в котором пользователи одинакового возраста расположены рядом. Порядок появления возрастов в массиве должен совпадать с порядком появления в исходном массиве.

Пример:


**/
$u1 = User\make(4);
$u2 = User\make(3);
$u3 = User\make(5);
$u4 = User\make(4);
$u5 = User\make(5);

[$u1, $u4, $u2, $u3, $u5] == ages([$u1, $u2, $u3, $u4, $u5]);


function ages($users)
{
    $grouped = group($users, function ($user) {
        return getAge($user);
    });

    return flatten($grouped);
}


/**
Реализуйте функцию flatten, которая делает плоским массив любой вложенности.
**/

flatten([]); // []
flatten([[1], ['key' => 'value', [4]]]); // [1, 'value', 4]


function flatten($arr)
{
    $iterator = new \RecursiveIteratorIterator(new \RecursiveArrayIterator($arr));
    return iterator_to_array($iterator, false);
}

# 2

function flatten($value)
{
    if (!is_array($value)) {
        return [$value];
    } elseif (sizeof($value) == 0) {
        return [];
    } elseif (sizeof($value) == 1) {
        return flatten(end($value));
    }
    return array_merge(flatten(array_slice($value, 0, 1)), flatten(array_slice($value, 1)));
}


############## PHP: Автоматическое тестирование ##############

/*
PHP Unit
В одном тестовом методе желательно тестировать только одну функцию (в юнит тестировании)
Разные виды assert функций нужны для более удобного автоматического вывода сообщений об ошибках
*/


>>>>> Ассерты <<<<<<<

/* factrorial() */
assert(6) = factrorial(3)); // assert - утверждение

// file: teory/Solution.php:

namespace App\Solution;

function isOdd($var)
{
    return $var % 2 != 0;
}

// file: teory/tests/SolutionTest.php:

namespace App;

require_once 'Solution.php';

class SolutionTest extends \PHPUnit_Framework_TestCase  // Название файла + Test
{
    public function testIsOdd() // test + название функции для теста
    {
        $this->assertTrue(Solution\isOdd(1));
        $this->assertFalse(Solition\isOdd(8), "Error!"); // Добавлением дополнительное сообщение в случае ошибки
    }
}

// assertTrue(mixed $value)
$this->assertTrue(isEven(6));

// assertEquals(mixed $expected, mixed $actual)
$this->assertEquals(6, factorial(3));

// assertCount(int $size, array $haystack)
$this->assertCount(1, getChildren());

// assertContains(mixed $needle, Iterator|array $haystack)
$this->assertContains('john', getNames());

$ phpunit tests/    // запуск тестов из консоли. Каждый тест "." - все ок, F - резльтат о и д не совпадают. :11 - номер строчки с ошибкой


/**
Напишите тесты на функцию isEven, которая принимает на вход целое число и возвращает true, если это число четное, и false в обратном случае.
**/

namespace App;

class TestSolution extends \PHPUnit_Framework_TestCase
{
    public function testIsEven()
    {
        $this->assertTrue(isEven(-2));
        $this->assertFalse(isEven(7));
        $this->assertTrue(isEven(8));
    }
}


>>>>> Структура тестов <<<<<<<

// file: teory/Leaf.php

namespace Theory;

class Leaf
{
    private $value;

    public function __construct($value = null)
    {
        $this->value = $value;
    }

    public function getValue()
    {
        return $this->value;
    }
}

// file: teory/tests/LeafTest.php

namespace Treory;

require_once 'Leaf.php';

class TestLeaf extends \PHPUnit_Framework_TestCase
{
    public function testGetValue()
    {
        $value = 100;
        $leaf = new Leaf($value);
        $this->assertEquals($value, $leaf->getValue());
    }
}


// file: teory/Node.php

namespace Theory;

class Node
{
    private $children;

    public function addChild($child)
    {
        $this->children[] = $child;
    }

    public function getChildren()
    {
        return $this->children;
    }

    public function removeChildren()
    {
        return $this->children = [];
    }
}


// file: teory/tests/NodeTest.php

namespace Treory;

require_once 'Node.php';

class TestNode extends \PHPUnit_Framework_TestCase
{
    public function testGetChildren()
    {
        $tree = new Node();
        $leaf = new Leaf();
        $node = new Node();

        $childen = $tree->getChildren();
        $this->assertCount(0, $children);

        $tree = addChild($leaf);
        $children = $three->getChildren();
        $this->assertCount(1, $children);
        $this->assertContains($leaf, $children); // $children содержит $leaf

        $tree->addChild($node);
        $childen = $tree->getChildren();
        $this->assertCount(2, $children);
        $this->assertContains($leaf, $children);
        $this->assertContains($node, $children);
    }

    public function testRemoveChildren()
    {
        $tree = new Node();
        $leaf = new Leaf();

        $tree->addChild($leaf);
        $tree->removeChildren();
        $children = $tree->getChildren();
        $this->assertEmpty($children);
    }
}

/**
QueryBuilder это специальный класс для конструирования sql запросов. Подобная функциональность есть практически во всех ORM. Пример использования:

    QueryBuilder::from('members')->toSql();
    // SELECT * FROM members

    QueryBuilder::from('members')->where('id', 12)->toSql();
    // SELECT * FROM members WHERE id = '12'

    QueryBuilder::from('photos')->select('author', 'id')
        ->where('views_count', null)->where('state', 'archived')->toSql();
    // SELECT author, id FROM photos WHERE views_count IS NULL AND state = 'archived'

Реализуйте тесты для QueryBuilder основываясь на примере выше.
**/


<?php

namespace App;

class QueryBuilder
{
    private $selectPart = '*';
    private $tablePart;
    private $whereParts = [];

    public static function from($table)
    {
        $builder = new QueryBuilder($table);
        return $builder;
    }

    public function __construct($table)
    {
        $this->tablePart = $table;
    }

    public function select(...$args)
    {
        if (!empty($args)) {
            $this->selectPart = implode(", ", $args);
        }
        return $this;
    }

    public function where($key, $value)
    {
        $this->whereParts[$key] = $value;
        return $this;
    }

    public function toSql()
    {
        $sqlParts = [];
        $sqlParts[] = "SELECT {$this->selectPart} FROM {$this->tablePart}";

        if ($this->whereParts) {
            $whereParts = array_map(function ($key, $value) {
                if (is_null($value)) {
                    return "$key IS NULL";
                } else {
                    return "$key = '$value'";
                }
            }, array_keys($this->whereParts), $this->whereParts);

            $wheres = implode(' AND ', $whereParts);
            $sqlParts[] = "WHERE $wheres";
        }

        return implode(' ', $sqlParts);
    }
}


namespace App\Tests;

use PHPUnit\Framework\TestCase;

class QueryBuilderTest extends TestCase
{
    public function testSelect()
    {
        // BEGIN (write your solution here)
        
        // END
    }

    // BEGIN (write your solution here)
    
    // END
}

    QueryBuilder::from('members')->toSql();
    // SELECT * FROM members

    QueryBuilder::from('members')->where('id', 12)->toSql();
    // SELECT * FROM members WHERE id = '12'

    QueryBuilder::from('photos')->select('author', 'id')
        ->where('views_count', null)->where('state', 'archived')->toSql();
    // SELECT author, id FROM photos WHERE views_count IS NULL AND state = 'archived'