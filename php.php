<?

############## PHP ##############

/*
Код-гайд:
https://www.php-fig.org/psr/psr-1/
http://www.php-fig.org/psr/psr-2/

Проверка кода:
https://github.com/squizlabs/PHP_CodeSniffer

Тестовые задания:
https://github.com/Hexlet/ru-test-assignments

Гайды:
https://guides.hexlet.io

Книги:
https://ru.hexlet.io/pages/recommended-books
+ Роберт Мартин идеальный программист
+ Адитьи Бхаргавы “Грокаем алгоритмы” -> ревпозиторий https://github.com/egonSchiele/grokking_algorithms
+ Томас Кормен “Алгоритмы. Вводный курс”
+ Эви Немет Unix и Linux. Руководство системного администратора  - использовать, как справочник, время от времени углубляясь в необходимые темы по мере возникновения вопросов.
+ Структура и интерпритация компьютерных программ

+ Книга Продуманная оптимизация http://optimization.guide

Шифрование:
https://youtu.be/mE_s-R5wvpw
https://www.youtube.com/watch?v=-YyVEgb5wII
https://www.youtube.com/watch?v=vFjq9pID4-E

https://theoryandpractice.ru/posts/14203-crypto-security
https://intsystem.org/security/asymmetric-encryption-how-it-work/
http://www.netcode.ru/cpp/?artID=4010
https://urbanculture.in/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F
https://m.habrahabr.ru/post/188042/

GIT Project: https://github.com/jougene
*/	


>>>>> Введение <<<<<<<

/*
PHP — динамический, слабо-типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.

# Интерпретируемый
У PHP отсутствует стадия компиляции, как у языков подобных Java или C. Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на PHP состоит из текстовых файлов.

Откровенно говоря, это не совсем так. У PHP все же есть стадия компиляции, но она скрыта от глаз пользователя и внешне PHP ведет себя именно как интерпретируемый язык программирования. 

# Динамический
В отличие от статических языков, проверка типов в PHP происходит в момент выполнения кода. Поэтому если, мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статические анализаторы кода (слово статический как раз означает что программа не выполняется). Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок. 

# Слабо типизированный
Слабая типизация означает то, что PHP автоматически приводит типы там, где считает нужным (описано в спецификации). С одной стороны, слабая типизация позволяет писать более короткий код, но с другой, количество ошибок резко возрастает, так как вместо падения, код продолжает работать там, где он не должен работать. Например, мы можем сложить число со строкой по ошибке и PHP молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Нужно стараться никогда не полагаться на эту особенность языка во избежания проблем.
*/


// Comment - однострочный комментарий

/*
 * Multi
 * Line
 * Comment
*/

### Statements (перев. инструкции)

/* namespace App; */

; // пустая инструкция

return 3; // выражение - вычисляется, инструкция выполняется
return 5 + 5; // выражение
$name = 'Max'; // инструкция с выражением




>>>>>  Арифметические операции <<<<<<<

// Operator, Operand

7 * 9; // infix - Инфиксный оператор
-1; // prefix - Префиксный оператор
$i++; // postfix - Постфиксный оператор

-1; // unary - Унарная операция - операция с 1 операндом
3 ** 4; // binary - Бинарная операция - операция с 2-мя операндами

sqrt(4); // => 2
sin(deg2rad(90)); // => 1
cos(pi()); // => -1




>>>>>  Функции <<<<<<<

function hypotenuse($cathetus1, $cathetus2)	// $cathetus1, $cathetus2 - формальные параметры
{
	return sqrt($cathetus1 ** 2 + $cathetus2 ** 2);
}

echo hypotenuse(3, 4); // 3, 4 - фактические параметры => 25




>>>>>  Включение файлов <<<<<<<

namespace 'Theory';

echo include 'Example.php'; // При ошибке -> Warning => 1

require 'Example.php'; // При ошибке -> Fatal error
require_once 'Example.php'; // Предпочтительный способ, чтобы избежать ошибок при повторном подключении файла

set_include_path('/tmp'); // меняем директорию (*). PHP просмотривает всегда текущую директорию
echo get_include_path(); // возвращает список директорий.  
echo include 'Anather.php'; // без * будет ошибка, поскольку подкл. файл лежит в '/tmp' => Hello World


// Файл: theory/Example.php

return 1;

// Файл: tmp/Anather.php

return 'Hello World';




>>>>>  Пространство имен <<<<<<<

/*
 * Проблематика
 * Отстутсвие пространств имен подобно отсутствию директорий в файловой системе
 * - Все глобальные идентификаторы должны быть уникальны: константы, функции, классы...
 * - В свою очередь это ведет к подобным именам: PHPUnit_Framework_TestCase

 * Решение
 * Пространства имен предоставляют возможность для группировки определений php 
*/

namespace App\Template;

/*
 * Особенности
 * Могут быть вложенными
 * Не связаны с файловой структурой
 * В одном файле может быть несколько определений пространств
 * Определения находящихся в одном и том же пространстве имеют прямо доступ друг к другу
*/ 


/* 
Директории:
 * theory/
 * 	 Another.php
 * 	 Example.php
 * 	 main.php 
*/

// Файл main.php

namespace Theory; 

require_once 'Example.php';
require_once 'Another.php';

echo \Theory\Example\iam(); // с полным путем (абсолютный путь - а значит не смотрим относительно текущего namespace) 
echo Example\iam(); // относительно текущего namespace Theory
echo \Another\iam(); // с полным путем


// Ниже задаются абсолютные пути, но без ведущего '/'
use function Theory\Example\iam; // импортирование функции. бэкслеш вначале можно ставить, а можно нет (*)
use function Theory\Example\iam as eiam; // задаем альтернативное имя функции
use function Another\iam as aiam; // без задания альтернативного имени -> конфликт имен с (*)
// => после этого можно обращаться к функции как-будто она была уже определена здесь:
echo iam();
echo eiam();
echo aiam();

// Файл Another.php

namespace Another;

function iam()
{
	return "another\n";
}

// Файл Example.php

namespace Theory\Example; // вложенный namespace

function iam()
{
	return "example\n";
}

/*
 * Настоятельно не рекомендуется при программировании комбинировать несколько пространств имен в один файл. Основным применением этому может быть объединение нескольких PHP-файлов в один файл.
*/

namespace MyProject {
	const CONNECT_OK = 1;
	class Connection { /* ... */ }
	function connect() { /* ... */  }
}

namespace { // глобальный код
	session_start();
	$a = MyProject\connect();
	echo MyProject\Connection::start();
}

// PHP-код не может находиться вне скобок конструкции пространства имен, кроме начального выражения declare.

// Значение константы __NAMESPACE__ - это строка, которая содержит имя текущего пространства имен. В глобальном пространстве, вне пространства имен, она содержит пустую строку.




>>>>>  Константы <<<<<<<

namespace Theory;

define('VERSION', 'version-1.5'); // global definition (глобальное определение) - игнорирует namespace, поэтому желательно использовать const
const FOO = 7 ** 10;

echo VERSION;
echo FOO;
echo \Theory\FOO;

defined('\Theory\FOO'); // проверяет определена ли данная константа true
// но!
defined('\Theory\VERSION'); // false

defined('\Theory\HI'); // false

// Предопределенные константы, примеры:
PHP_VERSION; // версия
PHP_OS; // ОС
PHP_BINDIR; // местонахождение исполняемого файла у PHP

// Magic constants:
__LINE__; // текущая строчка
__FILE__; // текущий файл
__DIR__; // текущая директория

// __FUNCTION__, __CLASS__, __TRAIT__, __METHOD__, __NAMESPACE__

constant('FOO'); //  возвратит значение константы, указанной параметром name. Используется, если вам необходимо запросить значение константы, но вам не известно её имя, если, например, она хранится в переменной или возвращается функцией.




>>>>>  Boolean <<<<<<<


/*
 * ! - Отрицание
 * && - И (Конънкция)
 * || - Или (Дизъюнкция)
 * == Совпадение
 * != Не совпадение
 * xor - исключающее или

 * Правила логики:
 * true != false
 * true == !false
 * true && true == true
 * true && false == false
 * false && false == false
 * true || true == true
 * true || false == true
 * false || false == false

 * and, or - ! имеют пониженный приоритет лучше не использовать
*/ 


function isOdd($num) // проверка на нечетность
{
	return $num % 2 != 0;
}




>>>>>  Условие if <<<<<<<

function lucky($num)
{
	if ($num == rand(1,3)) {
		return 'You are lucky!';
	} elseif ($num < 1 || $num > 3) {
		return 'Unexpected number';
	} else {
		return 'Sorry, you are not lucky!';
	}
}

function mod($num)
{
	return $mod >= 0 ? $num : -$num; // тернарный оператор
}


/*
Реализуйте функцию result, которая принимает на вход результат хоккейного матча и исход, который предполагался. Если счет был угадан верно, то функция должна вернуть 2, если исход был угадан верно (победа первой команды, ничья, поражение первой команды), то функция должна вернуть 1, во всех остальных случаях функция возвращает 0.
*/

function result($a, $b, $c, $d)
{
    if ($a == $c && $b == $d) {
        return 2;
    } elseif ($a > $b && $c > $d || $a < $b && $c < $d || $a == $b && $c == $d) {
        return 1;
    } else {
        return 0;
    }
}




>>>>>  Переменные <<<<<<<


function factorial($n)
{
	$result = 1;

	for ($i = 2; $i <= $n; $i++) {
		$result *= $i;
	}

	return $result;
}

function isPrime($n) // проверка на простое число
{
	for ($i = 2; $i = $n / 2; $i++) {
		if ($n % $i == 0) {
			return false;
		}
	}

	return true;
}

/*
Напишите функцию sumDouble, которая принимает на вход два числа: начало последовательности и конец последовательности, а возвращает сумму возведенных в квадрат чисел последовательности с шагом 2. То есть из последовательности от 3 до 7 будут взяты числа 3, 5, 7.
*/

function sumDouble($a, $b)
{
    $result = 0;

    for ($i = $start; $i <= $finish; $i += 2) {
        $result += $i ** 2;
    }

    return $result;
}




>>>>>  Именование в программировании  <<<<<<<

/*

Нотация:
* Верблюжья нотация (CamelCase): MyClass
* Змеиная нотация (snake_case): my_const
* Шашлычная нотация (kebab-case): my-data
* Венгерская нотация https://ru.wikipedia.org/wiki/Венгерская_нотация

# Сущность-Действие
Имя функции должно быть глаголом, переменной - существительным.

# Предикаты
Предикат это функция-проверка, она всегда возвращает либо true, либо false.

В большинстве языков предикаты предваряют префиксом is.
isEmpty();
isValid();
isBusy();

Но не все языки следуют этому правилу. В большинстве лиспов, а так же в ruby (который взял это из лиспов) используется знак ? в конце слова:
empty?
valid?
busy?

Если учесть что в указанных языках вызов функции не требует скобок в конце, то такая форма смотрится особенно естественной.

# Вхождение
Но не все предикаты можно выразить через is. Например, как задать вопрос если мы хотим узнать есть ли в списке чисел нечетное? В таких ситуациях принято использовать слово has:

node.hasChildren();

# Количество
Если вам нужна переменная, в которой содержится количество чего-либо, то используйте комбинацию: сущность во множественном числе + count.

symbolsCount
peopleCount

Это правило важнее даже в другом варианте, а именно, как не надо называть переменную обозначающую количество:

errors;
Такое именование гарантированно вводит в заблуждение. Сущность во множественном числе всегда должна обозначать только коллекцию.


Примеры

// Нормализация данных
normalizeDomainName('hexlet.io');

// Извлечение части данных
getName(user);
getDomainFromEmail('support@hexlet.io');

// Получение массива с ошибками
const errors = validate(user);
if (errors.length > 0) {
  // ...
}

// Подсчеты
calculateDiff(first, second)

// Допуск
canSwim(user)
canViewProfile(user)
*/



>>>>>  Variable Scope - Область видимости переменной <<<<<<<

// переменная доступна вне цикла for и if:
for ($i = 0; $i < 3; $i++) {
	echo $i . "\n";
}

if (true) {
	$val = 'cat'
}

echo $i; // => 2
echo $val; // => cat


# Чистая функция - зависит только от своих аргументов и не делает побочных эффектов.
# Детерминированная функция - функция, которая всегда производит тот же результат при одинаковых вводных даннных


// !!! Не использовать глобальные переменные в функции:

$increment = 1;

function increment($num)
{
	global $increment; // <-> $_GLOBALS['increment']
	return $num + $increment;
}




>>>>>  Строки <<<<<<<

$value = 'text';
echo "string \t with \n \\ escape sequence\n" . PHP_EOL; //  \\ - экранирование '\', PHP_EOL - константа конец строки (в Unix системах - \n / в Windows \n\r)

echo "interpolation example: $value" . PHP_EOL; // интерполяция

function hereDoc($hello)
{
	return <<<EOD
		Example "of $hello string"
		spaning 'multiple lines
		using heredoc syntax.\n\n
EOD;

}

function nowDoc()
{
	return <<<'EOD'
		Example of string
		spaning 'multiple lines
		using nowdoc syntax. $hello.
EOD;
	
}	


$str = 'simple string';

echo $str[0]; // => s
echo $str[strlen($str) - 1]; // => g


// Реализуйте функцию reverse, которая переворачивает строку.

function reverse(String $str)
{
    $result = '';
    
    for($i = strlen($str) - 1; $i >= 0; $i--) {
        $result .= $str[$i];
    }
          
    return $result;
}




>>>>>  Массив <<<<<<<

[1, 2, 3, 5] + [8, 1, 2]; // [1, 2, 3, 5]
[] == []; // true
[1] != [2]; // true


sizeof($arr); // размер массива (кол-во элментов)
in_array('apple', $arr); // проверяет наличие элемента в массиве
empty($arr); // проверяет пустой ли массив
end($arr); // возвращает последний элемент
unset($arr[2]); // удаление элмента массива

function myMax(Array $arr)
{
	if (empty($arr)) {
		return;
	}

	$max = $arr[0];

	foreach ($arr as $val) {
		if ($max < $val) {
			$max = $val;
		}
	}

	return $max;
}


// Реализуйте функцию uniq, которая принимает, как аргумент, массив, и возвращает новый массив, в котором ни один элемент исходного массива не повторяется.

function uniq(Array $arr) {
	$res = [];
	foreach ($arr as $value) {
		if (!in_array($res, $value)) {
			$res[] = $val;
		}
	}

	return $res;
}



>>>>>  Ассоциативный массив <<<<<<<


array_key_exists('undefined', $map); // проверяет присутствует ли данный ключ в ассоц. массиве


$arr = [];
$arr[] = 'val1';
$arr['key'] = 'val2';
$arr[] = 'val3';
$arr['9'] = 'val4';
$arr[] = 'val5';

/* => 
[0] => val
[key] => val
[1] => val
[9] => val
[10] => val // !!! '9' - ключ был строкой
*/

// Реализуйте функцию wordsCount, которая считает количество одинаковых слов в предложении. Результатом функции является ассоциативный массив, в ключах которого слова из исходного текста, а значения это количество повторений.

function wordsCount(String $sentence)
{
	$words = explode(' ', $sentence);
	$countWords = [];

	foreach ($words as $word) {
		if (empty($word)) { continue; }
		array_key_exists($word, $countWords) ? $countWords[$word]++ : $countWords[$word] = 1;
	}

	return $countWords;
}



>>>>>  Аргументы <<<<<<<

round(10.61234, 2); // 10.61
round(1.55, 1); // 1.6
round(1.55, 1, PHP_ROUND_HALF_DOWN); // округление вниз 1.5 

// float, string, bool, int, array


function drop(Array $array, Int $count = 1) // возвращает обрезанный с начала массив на count элементов
{
	$result = [];
	for ($i = $count; $i < sizeof($array); $i++) {
		$result[$i] = $array[$i];
	}

	return $result;
}

function sumArgs()
{
	return array_sum(func_get_args()); // func_get_args() - возвращает массив переданных аргументов
}

function sumArgs1(...$numbers)
{
	return array_sum($numbers); // $numbers - массив переданных аргументов
}

function sumArgs2($arg, ...$numbers) // $arg - можно задавать обязательные параметры
{
	return array_sum($numbers); // $numbers - массив переданных аргументов
}

sumArgs2(10, 2, 4); // !!! => 6



// Реализуйте функцию multiArgs, которая возвращает произведение всех переданных аргументов. Вызванная без аргументов, должна вернуть null.

function multiArgs(...$numbers)
{
    return !empty($numbers) ? array_product($numbers) : null; // array_product - произведение элементов массива
}



>>>>>  Null <<<<<<<

$var = null; 
is_null($var); // true

$result = $var ?? 'nobody'; 
// <-> $result = isset($var) ? $var : 'noboby'


example(); // вызов пустой функции возвращает null

function example($var = null) // необязательный аргумент
{
	return; // <-> return null;
}


// Реализуйте функцию compact которая принимает на вход массив и возвращает новый, полученный удалением элементов со значением null. Ключи оставшихся элементов (тех которые не были null) должны сохраняться.

function compact(array $array)
{
    $newArray = [];
    foreach ($array as $key => $value) {
        if (!is_null($value)) {
            $newArray[$key] = $value;
        }
    }
    return $newArray;
}



>>>>>  Типы <<<<<<<

/*
Система типов - совокупность правил в языках программирования, назначающих свойства, именуемые типами, различным конструкциям, составляющих программу - таким как переменные, выражения, функции или модули

Основная роль системы типов заключается в уменьшении числа багов в программах посредством определения интерфейсов между различными частями программы и последующей проверки согласованности взаимодействия этих частей.

Виды типизации:
 * Статическая - указываем какого типа будут сущности языка. Например, если описываем переменную, то указываем, что переменная типа integer,записать туда можем число и работать можем только как с числом. Ошибки на стадии компиляции (преобр. в машинный код)

 * Динамическая - не надо указывать какого типа будут сущности языка. Тип будет высляться в момент операции над переменной. Ошибки на стадии runtime

 * Сильная (Строгая) - не преобразовывает автоматически типы данных (Python, Ruby)
 * Слабая (Не строгая) - автоматически преобразовывает типы данных (JS, PHP)
*/
 
[] + 1; // => Fatal Error
"" + []; // => Fatal Error

// Type Casting (приведение типов):
 
$foo = 100;
$bar = (bool) $foo;
 
/*
false:
 * 0;
 * '0';
 * 0.0;
 * '';
 * null;
 * [];
*/ 

// Comparison (сравнение):

0 !== false; // true
0 === '0'; // false;

// Functions:

gettype(true); // возвращает тип переданного аргумента - boolean
is_string('asfs'); // true
// is_numeric, is_int и т.д.

// Type Hinting

function drop(Array $array, Int $count = 1): array // float, string, bool, int, array
{
}



/* Дано неотрицательное целое число num. Итеративно сложите все входящие в него цифры до тех пор, пока не останется одна цифра.

Для числа 38 процесс будет выглядеть так:

3 + 8 = 11
1 + 1 = 2
Результат: 2

*/

function addDigits(Int $num)
{
    $sum = (string) $num;

    while (strlen($sum) > 1) {
        $sum = array_sum(str_split($sum));
    }

    return $sum;
}
 

/* Реализуйте функцию binarySum, которая принимает на вход два бинарных числа (в виде строк) и возвращает их сумму. Результат (вычисленная сумма) также должна быть бинарным числом в виде строки. Посмотрите примеры работы функции:

'11' == binarySum('10', '1');
'10010' == binarySum('1101', '101');
*/


function binarySum($num1, $num2)
{
	// decbin — переводит число из десятичной системы счисления в двоичную
	// bindec — переводит двоичное число в десятичное
	return decbin( bindec((int) $num1) + bindec((int) $num2) );
}


/*
Реализуйте функцию isPrime определяющую, является ли число простым. Пример:
echo isPrime(1); // → false
 echo isPrime(7); // → true
 echo isPrime(10); // → false
*/

function isPrime($num)
{
    if ($num < 2) {
        return false;
    }
    for ($i = 2; $i <= $num / 2; $i++) {
        if ($num % $i == 0) {
            return false;
        }
    }

    return true;
}


/*
Реализуйте функцию isPowerOfThree которая определяет, является ли переданное число натуральной степенью тройки. Например число 27 это третья степень (33), а 81 это четвертая (34). Пример:

isPowerOfThree(1); // → true (3^0)
isPowerOfThree(3); // → true
isPowerOfThree(4); // → false
isPowerOfThree(9); // → true
*/

function isPowerOfThree(Int $num)
{
    $current = 1;
    while ($current <= $num) {
        if ($current === $num) {
            return true;
        }
        $current *= 3;
    }

    return false;
}


/*
Реализуйте функцию reverseInt, которая переворачивает цифры в переданном числе:
31 == reverseInt(13);
-321 == reverseInt(-123);
*/

function reverseInt($num)
{
    $reverse = (int) strrev((string) abs($num)); // strrev - переворачивает строку задом наперед / abs - модуль числа
    return $num > 0 ? $reverse : -$reverse;
}

function reverseInt(Int $num)
{
	$reverseAbsInt = (int) strrev((string) (abs($num)));
	return $num > 0 ? $reverseAbsInt : -$reverseAbsInt;
}



>>>>>  HTTP <<<<<<<

/*
Что происходит после того, как в браузер ввели адрес сайта? https://habr.com/company/htmlacademy/blog/254825/

Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. http — это набор правил, который известен и вашему компьютеру и физически отдаленному компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передается информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
*/

$ curl --head -v code-basics.ru
* Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
* Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

http нужно не просто знать, но и уметь делать сырые http-запросы, то есть не косвенно через браузер, но и самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.
*/




>>>>>  Микрофреймворки <<<<<<<

/*
 Фреймворк(каркас) - общая логика, которая структурирует приложение:
 * Принять запрос.
 * Определить, какой обработчик должен выполниться.
 * Выполнить обработчик и подготовить ответ.
 * Вернуть ответ клиенту.
 Сам код на микрофреймворках простой и требует создания буквально одного файла. Микрофреймворки практически ничего не могут самостоятельно. Любая новая функциональность достигается сторонними библиотеками.
 
 Возможности, которыми обладают современные фреймворки:

 * Генерация кода. Любой полноценный фреймворк содержит утилиту cli, позволяющую генерировать код, например, тесты или миграции.
 * Встроенные механизмы для тестирования. Другими словами, фреймворк дает возможность начать писать тесты практически без необходимости что либо дополнительное ставить или конфигурировать.
 * ORM. Либо своя, либо популярная для языка в целом.
 * Шаблонизатор и хелперы (вспомогательные функции) для повторяющихся задач вывода информации.
 * Абстракции для работы с письмами.
 * Инструменты для интернационализации и локализации. 
 * Механизмы, обеспечивающие безопасность, например, CQRS.
 * Интеграция с frontend инструментами.
 * Кеширование.
*/




>>>>>  СУБД <<<<<<<

// Библиотека PDO

// PDO Connection to MySQL
$conn = new PDO('mysql:host=localhost;dbname=yourdbname', 'username', 'password');

// PDO Connection to PostgreSQL
$conn = new PDO('pgsql:host=localhost;dbname=yourdbname', 'username', 'password');

// A quick Select Query with For Loop
$result = $conn->query("SELECT * FROM profile");
foreach ($result as $row) {
    echo $row['id'];
    echo $row['title'];
    echo $row['telephone'];
}

// Slim-PDO. Для Slim /https://github.com/FaaPz/Slim-PDO/ существует проект Slim-PDO, который позволяет взаимодействовать с базой из фреймворка Slim.

$app->post('/ads', function(ServerRequestInterface $request) {
    $parsedBody = $request->getParsedBody(); // Данные пришедшие из формы

    // Соединение с базой должно выполняться на этапе старта приложения (как было с шаблонизатором), а не в конкретном обработчике.
    $dsn = 'mysql:host=your_db_host;dbname=your_db_name;charset=utf8';
    $usr = 'your_db_username';
    $pwd = 'your_db_password';

    $pdo = new \Slim\PDO\Database($dsn, $usr, $pwd);

    $insertStatement = $pdo->insert(['telephone', 'title'])
                       ->into('ads')
                       ->values([$parsedBody['telephone'], $parsedBody['title']]);

    $insertId = $insertStatement->execute(false);
});

// Обратите внимание на то, что библиотека Slim-PDO позволяет выполнять SQL не в виде "сырых" запросов, где SQL писался бы как строка текста (как в репле), а предоставляет небольшой DSL (мини-язык) для написания запроса: insert()->into()->values(). Библиотеку, позволяющую таким образом строить запросы, называют Query Builder. В отличие от сырого SQL в виде строчки, подход, описанный выше, удобен в случаях, когда SQL собирается по условиям. Такое часто бывает на страницах с фильтрами.

/*
Нормализация баз данных заключается в приведении структуры хранения данных к нормальным формам (NF). Всего таких форм существует 8, но часто достаточным является соблюдение первых трех.
 
 * В нормализованной структуре базы данных вы можете производить сложные выборки данных относительно простыми SQL-запросами.
 * Целостность данных. Нормализованная база данных позволяет надежно хранить данные.
 * Нормализация предотвращает появление избыточности хранимых данных. Данные всегда хранятся только в одном месте, что делает легким процесс вставки, обновления и удаления данных. Есть исключение из этого правила. Ключи, сами по себе, хранятся в нескольких местах потому, что они копируются как внешние ключи в другие таблицы.
 * Масштабируемость – это возможность системы справляться с будущим ростом. Для базы данных это значит, что она должна быть способна работать быстро, когда число пользователей и объемы данных возрастают. Масштабируемость – это очень важная характеристика любой модели базы данных и для РСУБД.

https://habr.com/post/193756/

# Денормализация - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных. 
Устранение аномалий данных в соответствии с теорией реляционных баз данных требует, чтобы любая база данных была нормализована, то есть соответствовала требованиям нормальных форм. Соответствие требованиям нормализации минимизирует избыточность данных в базе данных и обеспечивает отсутствие многих видов логических ошибок обновления и выборки данных.

Однако при запросах большого количества данных операция соединения нормализованных отношений выполняется неприемлемо долго. Вследствие этого в ситуациях, когда производительность таких запросов невозможно повысить иными средствами, может проводиться денормализация — композиция нескольких отношений (таблиц) в одну, которая, как правило, находится во второй, но не в третьей нормальной форме. Новое отношение фактически является хранимым результатом операции соединения исходных отношений.

За счёт такого перепроектирования операция соединения при выборке становится ненужной и запросы выборки, которые ранее требовали соединения, работают быстрее.

Следует помнить, что денормализация всегда выполняется за счёт повышения риска нарушения целостности данных при операциях модификации. Поэтому денормализацию следует проводить в крайнем случае, если другие меры повышения производительности невозможны. Идеально, если денормализованная БД используется только на чтение.

Кроме того, следует учесть, что ускорение одних запросов на денормализованной БД может сопровождаться замедлением других запросов, которые ранее выполнялись отдельно на нормализованных отношениях.  


# Нормальная форма - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных. Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение. 

Первая нормальная форма (1NF)
Переменная отношения находится в первой нормальной форме (1НФ) тогда и только тогда, когда в любом допустимом значении отношения каждый его кортеж содержит только одно значение для каждого из атрибутов.

В реляционной модели отношение всегда находится в первой нормальной форме по определению понятия отношение. Что же касается различных таблиц, то они могут не быть правильными представлениями отношений и, соответственно, могут не находиться в 1НФ.


Вторая нормальная форма (2NF)
Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо (функционально полно) зависит от её потенциального ключа.

Третья нормальная форма (3NF)
Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.
Нормальная форма Бойса — Кодда (BCNF)

Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
Четвёртая нормальная форма (4NF)

Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
Пятая нормальная форма (5NF)

Переменная отношения находится в пятой нормальной форме (иначе — в проекционно-соединительной нормальной форме) тогда и только тогда, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.
Доменно-ключевая нормальная форма (DKNF)

Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.

Шестая нормальная форма (6NF)
Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6НФ, также находится и в 5НФ. 


# Cериализация - процесс перевода какой-либо структуры данных в последовательность битов. 

# Десериализация - восстановление начального состояния структуры данных из битовой последовательности. 

# Идемпоте́нтность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.

Итератор
Fluent Interface.
кранирование, SQL Injection.
*/



>>>>>  ORM <<<<<<<

/*
На основе модели предметной области формируется модель данных в коде. Создаются сущности, определяются их связи. Затем строится рабочий код, который оперирует сущностями, исходя из требований (бизнес-правил). На этом этапе возникает вопрос: а как эти сущности отображаются («маппятся» от англ. "map") на базу данных, ведь именно там в конечном итоге все хранится.

Самый простой вариант — создавать по таблице на каждую сущность и связывать их через внешние ключи. Именно так и делают в большинстве проектов, но не руками, а используя ORM (object-relation mapper). По сути, ORM — фреймворк для данных. С помощью него описываются сущности и их связи, определяется то, как сущность отображается на базу данных (как правило в полуавтоматическом режиме). ORM берет на себя серьезную часть работы по генерации SQL-запросов, по извлечению данных и кастингу (преобразование типов базы данных в типы целевого языка и обратно), по автоматическому извлечению связей. В итоге получается, что ORM прячет всю работу с базой данных (требуя только правильного конфигурирования) и сама выполняет все необходимые запросы. В сложных случаях их все равно приходится писать самостоятельно, но, как минимум, ORM содержат в себе query builder, который упрощает генерацию sql.

В php таких ORM довольно много, некоторые из них разрабатывались под конкретные фреймворки и поставляются с ними. Посмотрим на пример с фреймворком Doctrine2.

Определение сущности Photo
*/

// src/Entity/Photo.php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
/**
 * @ORM\Entity
 * @ORM\Table(name="photos", uniqueConstraints={@ORM\UniqueConstraint(name="photo_slug", columns={"slug"})}))
 */
class Photo
{
    /**
     * @ORM\Id
     * @ORM\Column(name="id", type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;
    /**
     * @ORM\Column(type="string", length=64)
     */
    protected $title;
    /**
     * @ORM\Column(type="string", length=150)
     */
    protected $image;
    /**
     * @ORM\Column(type="string", length=100)
     */
    protected $slug;

    /**
     * Get photo id
     *
     * @ORM\return integer
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Get photo title
     *
     * @ORM\return string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * Get photo slug
     *
     * @ORM\return string
     */
    public function getSlug()
    {
        return $this->slug;
    }

    /**
     * Get photo image
     *
     * @ORM\return string
     */
    public function getImage()
    {
        return $this->image;
    }
}

// Использование

$app->get('/photos', function() {
    // Получаем из базы список всех фотографий
    $photos = $this->entityManager->getRepository('App\Entity\Photo')->findAll();
    // Передаем их в шаблон
    return $this->renderer->render($response, "/photos.phtml", ['photos' => $photos]);
});

/*
 * Модель предметной области (или просто Модель) описана с помощью ORM (хотя это не обязательно, хранилище — вещь отдельная от модели).
 * Функция-обработчик обращается к модели для выполнения запрошенных операций и выводит необходимые данные в шаблон.
 * Шаблон описывает представление конкретной страницы и строится на основании данных переданных из функции-обработчика.
*/




>>>>>  MVC <<<<<<<

// Описанная выше структура носит гордое имя MVC или Model-View-Controller (обычно добавляют приписку version 2, так как первая версия MVC используется для толстых клиентов, в которых все работает немного по-другому), где M - модель предметной области, C - наша функция обработчик (в других фреймворках могут быть другие сущности), а V - шаблон. MVC разделяет приложение минимум на три слоя и определяет то, как они могут взаимодействовать друг с другом. Это важно для создания модульных приложений, то есть таких, которые легко развивать и модифицировать. При этом никто не запрещает добавлять новые и дробить текущие слои, все это уже зависит от сложности самого приложения.

/*
 * MODEL - хранение данных; целостность; консистентность; запросы; мутации
 * CONTROLLER - получение, интерполяция и валидация информации; создание и обновление views; запросы в MODEL; изменение MODEL
 * VIEW - презентация
 
 MODEL -> CONTROLLER -> VIEW -> User
 VIEW-> CONTROLLER -> MODEL
 User-> CONTROLLER -> MODEL
 
 * M — ядро приложения. В идеале — чистая бизнес-логика. M не знает ничего о других частях приложения и не может на них влиять.
 * C - использует M для выполнения запрашиваемых операций и отвечает за генерацию V.
 * V - получает данные от C и иногда от M, но такое не приветствуется. И уж точно V не должен знать ничего о базе данных. Кстати, этим грешат начинающие разработчики, которые выполняют SQL запросы прямо из шаблонов.
 
MVC является архитектурным шаблоном (или паттерном проектирования). Шаблон проектирования в разработке — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. В нашем случае контекст — обработка http-запросов.

Паттернов проектирования очень много на все случаи жизни. Некоторые из них очень простые и ближе к идиомам, то есть каким-то локальным участкам кода, которые принято писать тем или иным способом в конкретном языке. Некоторые паттерны — всеобъемлющие, подобные MVC. Они определяют глобальные ограничения, но ничего не говорят о способе реализации. В любом случае паттерны — не догма и не формальная спецификация, а значит всегда есть место для самостоятельного выбора.

В MVC заложена довольно простая, но важная идея разделения приложения на слои с четкими границами. Такой подход позволяет развивать каждый слой независимо от других, при условии, что у вас правильно выстроены зависимости между ними. Обратите внимание, что в MVC все связи однонаправленные. Другими словами, в MVC нет двух слоев, которые знают друг о друге одновременно. Если один слой знает о другом, то второй ничего не знает о первом и наоборот. Модульность (в общем случае — абстракция) — это один из ключевых факторов, делающих приложения по настоящему качественными с точки зрения разработки. 
*/




>>>>>  Коллекции <<<<<<<

/*
Например, в JavaScript канонический способ работы с коллекциями — функции высшего порядка. Посмотрите внимательно:

// Задача: извлечь имена пользователей, оканчивающиеся на `ya` без учета регистра, и привести имена к нижнему регистру
const users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];

const filteredUsers = users.map(n => n.toLowerCase()).filter(n => n.endsWith('ya'));

Возможность так писать доступна в js из коробки, но php — другое дело. Для эффективной работы вам придется «обмазаться» дополнительными библиотеками. Тогда код на php для той же задачи станет таким:
*/

use Stringy\Stringy as S;
use Illuminate\Support\Collection;

$users = ['PetYA', 'Vasya', 'KolyA', 'Mark', 'TonYa', 'John'];
$collection = collect($users);
$filteredUsers = $collection->map(function($n) {
    return strtolower($n);
})->filter(function($n) {
    return s($n)->endsWith('ya');
}





>>>>>  Другое <<<<<<<

/*
# Аутентификация и авторизация	
Аутентификация почти целиком построена на сессиях http, то авторизация требует понимания принципов построения списков контроля доступа (ACL). В наиболее продвинутых фреймворках подобная функциональность либо встроена в сам фреймворк, либо существует в виде дополнений, которые если и не покрывают все потребности, то, по крайней мере, дают основу для построения своей системы.

# OAuth
Аутентификация с помощью социальных сетей стала почти также распространена, как и аутентификация по паролю. Чисто технически её реализация значительно сложнее, она основана на протоколе oauth2, который включает в себя общение по API. Опять же, с нуля ничего писать не придется: для работы с OAuth написана не одна библиотека, но это не отменяет необходимости понимать, что творится под капотом.

# Валидация
Валидация — проверка данных на соответствие установленным требованиям (ограничениям). 

# Инфраструктура
Пилить фичи — только полдела. Чтобы начать разрабатывать нужно для начала настроить окружение разработчика, используя Docker Compose. Затем, чтобы было куда выкладываться, нужно настроить продакшен-окружение (то, где будет работать сайт) и в конце концов задеплоить (развернуть) туда сайт.

Современная инфраструктура — тоже код, и её нужно программировать. Вот список самых важных программ, созданных для этого: Ansible, Terraform, Docker.
*/



>>>>>  МАССИВЫ <<<<<<<

// Реализуйте функцию addPrefix, которая добавляет каждому элементу в массиве переданный префикс. Функция предназначена для работы со строковыми элементами. После префикса автоматически добавляется пробел.

#1:
function addPrefix($names, $prefix)
{
    $result = [];
	
    for ($i = 0; $i < sizeof($names); $i++) {
        $result[$i] = "{$prefix} {$names[$i]}";
    }

    return $result;
}

#2:
function addPrefix($names, $prefix)
{
    return array_map(function($name) use ($prefix)  {
    	return "{$prefix} {$name}";
    }, $names);
}



// Реализуйте функцию reverse, которая располагает значения в обратном порядке без создания нового массива

function reverseArray($coll) 
{
    $size = sizeof($coll); 
    $maxIndex = floor($size / 2);  // округляет дробь в меньшую сторону
	
    for ($i = 0; $i < $maxIndex; $i++) {
        $mirrorIndex = $size - $i - 1;
        $temp = $coll[$i];
        $coll[$i] = $coll[$mirrorIndex];
        $coll[$mirrorIndex] = $temp;
    }
    
    return $coll;
}



// Реализуйте функцию swap, которая меняет местами два элемента относительно переданного индекса. Например, если передан индекс 5, то функция меняет местами элементы, находящиеся по индексам 4 и 6. 

function swap($coll, $center) // hexlet
{
    $prevIndex = $center - 1;
    $nextIndex = $center + 1;
    $isSwappable = array_key_exists($prevIndex, $coll) && array_key_exists($nextIndex, $coll);

    if ($isSwappable) {
        $temp = $coll[$prevIndex];
        $coll[$prevIndex] = $coll[$nextIndex];
        $coll[$nextIndex] = $temp;
    }

    return $coll;
}


/*
Работая на таких высокоуровневых языках как php, позволительно не знать устройство массивов для решения повседневных задач. С другой стороны, подобное понимание делает код менее магическим и дает возможность заглядывать чуть дальше.

Реальные массивы лучше всего рассматривать на языке C, который, с одной стороны, достаточно простой и понятный, с другой - очень близок к железу и не скрывает от нас практически ничего. Когда мы говорим про примитивные типы данных, такие как "строка" или "число", то, на интуитивном уровне, все довольно понятно. Под каждое значение выделяется некоторый размер памяти (в соответствии с типом), в которой и хранится само значение. А как должна выделиться память под хранение массива? И что такое массив в памяти? На уровне хранения, понятия массив - не существует. Массив представляется цельным куском памяти, размер которого вычисляется по формуле "количество элементов * количество памяти под каждый элемент". Из этого утверждения есть два интересных вывода:

Размер массива - фиксированная величина. Те динамические массивы, с которыми мы имеем дело во многих языках, реализованы уже внутри языка, а не на уровне железа.
Все элементы массива имеют один тип и занимают одно и тоже количество памяти. Благодаря этому появляется возможность простым умножением (по формуле, описанной выше) получить адрес той ячейки, в которой лежит нужный нам элемент. Именно это происходит под капотом, при обращении к элементу массива под определенным индексом.

Фактически индекс в массиве - смещение относительно начала куска памяти содержащего данные массива. Высчитывается он так: "индекс * количество памяти занимаемое одним элементом (для данного типа данных)". Пример на C:

// Инициализация массива из пяти элементов типа int
int mark[] = {19, 10, 8, 17, 9};
mark[3]; // 17

Если предположить, что тип int занимает в памяти 2 байта (зависит от архитектуры), то адрес элемента, соответствующего индексу 3, высчитается так: "начальный адрес + индекс * объем памяти для одного элемента типа int".

Теперь должно быть понятно почему индексы в массиве начинаются с нуля. 0 - означает отсутствие смещения.

# Безопасность
В отличие от высокоуровневых языков, в которых код защищен от выхода за границу массива, в таком языке как C, выход за границу не приводит к ошибкам. Обращение к элементу, индекс которого находится за пределами массива, вернет данные, которые лежат в той самой области памяти, куда его попросили обратиться (в соответствии с формулой выше). Чем они окажутся - никому не известно (но они будут проинтерпретированы в соответствии с типом массива. Если массив имеет тип int, то вернется число). Благодаря отсутствию какой-либо защиты выход за границу массива активно эксплуатируется хакерами для взлома программ.

Еще один распространенный вариант использования циклов на массивах — агрегация. Агрегацией являются любые вычисления, которые строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее.
*/

function calculateMax($coll)
{
    if (empty($coll)) {
        return null;
    }

    $max = $coll[0];
    for ($i = 1; $i < sizeof($coll); $i++) {
        if ($coll[$i] > $max) {
            $max = $coll[$i];
        }
    }

    return $max;
}

print_r(calculateMax([]));
print_r(calculateMax([3, 2, -10, 38, 0]));

/*
Если массив пустой, то возвращаем null. Это классический пример использования идиомы guard expression.

Нейтральный элемент бинарной операции — элемент, который ничего не меняет в результате его использования в бинарной операции. По простому, сложение любого числа с нулем всегда дает это же число. Тогда любую сумму, например 3 + 2 + 8, можно вычислить как 0 + 3 + 2 + 8
*/


// Реализуйте функцию calculateAverage, которая высчитывает среднее арифметическое элементов массива. В случае пустого массива функция должна вернуть значение null (используйте в коде для этого guard expression)

function calculateAverage($arr) // my
{
	return empty($arr) ? null : array_sum($arr) / sizeof($arr);
}

function calculateAverage($coll) // hexlet
{
    if (empty($coll)) {
        return null;
    }

    $sum = 0;
    foreach ($coll as $item) {
        $sum += $item;
    }

    return $sum / sizeof($coll);
}


// Реализуйте функцию isContinuousSequence, которая проверяет, является ли переданная последовательность целых чисел - возрастающей непрерывно (не имеющей пропусков чисел). Например, последовательность [4, 5, 6, 7] - непрерывная, а [0, 1, 3] - нет. Последовательность может начинаться с любого числа, главное условие - отсутствие пропусков чисел.

function isContinuousSequence($coll)
{
    if (empty($coll)) { return false; }

    $start = $coll[0];

    foreach ($coll as $i => $item) {
        if ($start + $i !== $item) {
            return false;
        }
    }

    return true;
}




>>>>>  Удаление элементов массива <<<<<<<

/* 
Несмотря на то, что из массива можно удалить элемент, лучше так никогда не делать. Особенно плохо изменять массив во время обхода. Правильный выход из ситуации — создание нового массива. Такой код проще и для понимания и для отладки.

В стандартную библиотеку большинства языков программирования входит функция compact, которая удаляет все null из массива. Вот ее реализация:
*/

function mycompact($coll)
{
    $result = [];
    foreach ($coll as $item) {       
        if (!is_null($item)) {
            $result[] = $item;
        }
    }
    
    return $result;
}

print_r(mycompact([0, 1, false, null, true, 'wow', null])); 

/*
Главное, на что нужно обратить внимание, не происходит никаких удалений и модификаций исходного массива. Вместо этого инициализируется новый массив, который наполняется только подходящими под условие значениями. Именно так нужно воспринимать фразу "удалить из массива что-то". Код с созданием нового массива меньше подвержен ошибкам, проще в отладке и оставляет больше возможностей для анализа. Вы всегда можете посмотреть исходный массив, если что-то пошло не так. Вы всегда можете наблюдать за процессом наполнения результирующего массива, что позволит четко отследить правильность поставленных условий.

По сути, код выше — пример агрегации. Только в отличие от предыдущих примеров, в которых  результатом был примитивный тип, здесь результат — массив. Это совершенно нормально. Сама операция прореживания массива обычно называется фильтрацией.
*/



>>>>>  Генерация строки в цикле <<<<<<<

// Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример в вебе, функция-хелпер, помогающая генерировать html списки в шаблонах. Она принимает на вход коллекцию элементов и возвращает список из них:

$coll = ['milk', 'butter', 'eggs', 'bread'];
buildList($coll); // => <ul><li>milk</li><li>butter</li><li>eggs</li><li>bread</li></ul>

// Самый примитивный алгоритм, который приходит в голову. Пройтись циклом по элементам коллекции и дописать в результирующую строку очередной li элемент. В начале и конце добавить ul и вернуть строчку наружу.

$result = '';

foreach ($coll as $item) {
    $result .= "<li>{$item}</li>";
    // либо так
    // $result = "{$result}<li>{$item}</li>";
}

$result = "<ul>{$result}</ul>";

// Такой способ вполне рабочий, но для большинства языков программирования максимально не эффективный. Дело в том, что конкатенация и интерполяция порождают новую строчку вместо старой и подобная ситуация повторяется на каждой итерации. Причем строка становится все больше и больше. Копирование строк приводит к серьезному расходу памяти и может влиять на производительность. Конечно, для большинства приложений данная проблема не актуальна из-за малого объема прогоняемых данных, но более эффективный подход не сложнее в реализации и обладает дополнительными плюсами. Поэтому стоит сразу приучить себя работать правильно и никогда больше не возвращаться к этому вопросу. В статических языках для подобной цели используется так называемый String Buffer. В динамических — обычный массив. Перепишем программу выше, используя новое знание:

$coll = ['milk', 'butter', 'eggs', 'bread'];
$parts = []; // переименовал для того, чтобы не менять значения переменной

foreach ($coll as $item) {
    $parts[] = "<li>{$item}</li>";
}

$innerValue = implode("\n", $parts);
$result = "<ul>{$innerValue}</ul>";

/*
Как видите, код не сильно поменялся. Разница в том, что теперь собирается массив вместо строки, и в конце он собирается в строку с помощью implode. Помимо эффективности у такого подхода есть дополнительные плюсы:

 * Такой код проще отлаживать и анализировать внутренности
 * Массив можно дообработать, если надо, а строчку — уже нет

*/ 



/*
Реализуйте функцию buildDefinitionList, которая генерирует html список определений (теги dl, dt и dd) и возвращает получившуюся строку.

Параметры функции:
Список определений следующего формата:

$definitions = [
  ['definition1', 'description1'],
  ['definition2', 'description2']
];

Пример:
*/

$definitions = [
    ['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
    ['Бобр', 'Животное из отряда грызунов'],
];

buildDefinitionList($definitions); // => '<dl><dt>Блямба</dt><dd>Выпуклость, утолщение на поверхности чего-либо</dd><dt>Бобр</dt><dd>Живтоное из отряда грызунов</dd></dl>'; 


function buildDefinitionList(Array $definitions)
{
    $parts = [];
    foreach ($definitions as $definition) {
        $name = $definition[0];
        $description = $definition[1];
        $parts[] = "<dt>{$name}</dt><dd>{$description}</dd>";
    }
    $innerValue = implode('', $parts);
    $result = "<dl>{$innerValue}</dl>";

    return $result;
}




>>>>>  Обработка строк через преобразование в массив <<<<<<<

/*
Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. На любые хитрые вопросы «а есть ли в строке знаки препинания» ответ — выбирайте самый простой случай для обработки.

Решить её можно достаточно большим количеством способов. Чем больше называет человек, тем лучше. К ним относятся:

* Посимвольный перебор строки. Эта задачка может быть решена двумя способами. Один из которых связан с использованием конечных автоматов.
* Регулярные выражения. 
* Через преобразование в массив. Этот способ тоже распадается на два. Одно решение через функции высших порядков или решение через цикл.
 
*/ 

function capitalizeWords($sentence)
{
    $words = explode(' ', $sentence);
    
    for ($i = 0; $i < sizeof($words); $i++) {
      $words[$i] = ucfirst($words[$i]);
    }
	
	return implode(' ', $words);
}


// В случае, если строчку нужно разбить по символам, а не по словам, можно воспользоваться функцией str_split. 

$chars = str_split($text);
foreach ($chars as $char) {
    print_r($char);
}

// str_split принимает второй параметр, в котором можно указать количество символов в каждой группе (элементе получившегося массива). По умолчанию используется число 1, поэтому мы получаем массив, в котором каждый элемент — один символ. Но, если указать, например, 3, то в каждом элементе массива будет по три символа.

$text = 'Hello Friend';
$arr2 = str_split($str, 3); // -> 
/*
[0] => Hel
[1] => lo
[2] => Fri
[3] => end
*/


/*
Реализуйте функцию makeCensored, которая заменяет каждое вхождение указанного слова в предложении на последовательность $#%! и возвращает полученную строку. Аргументы:
Текст / Слово
Словом считается любая непрерывная последовательность символов, включая любые спецсимволы.
*/

function makeCensored(string $text, $stopWord) // hexlet
{
    $words = explode(' ', $text);
    $result = [];
    foreach ($words as $word) {
        $result[] = $word === $stopWord ? '$#%!' : $word;
    }

    return implode(' ', $result);
}




>>>>>  Вложенные циклы <<<<<<<

// Во многих языках программирования есть очень полезная функция flatten. В определенных задачах она сильно упрощает жизнь и сокращает количество кода. flatten принимает на вход массив и выправляет его: если элементами массива являются массивы, то flatten сводит все к одному массиву, раскрывая каждый вложенный. Посмотрим на пример:

flatten([[3, 2], 5, 3, [3, [4, 2]], 10]); // => [3, 2, 5, 3, 3, 4, 2, 10]


// Давайте напишем функцию flatten. В общем случае эта функция раскрывает массивы на всех уровнях вложенности. Но мы для простоты сделаем вариант функции, в котором происходит раскрытие только до первого уровня. То есть, если элемент основного массива — массив, то он раскрывается без просмотра его внутренностей (там тоже могут быть массивы).

function flatten($coll)
{
    $result = [];

    foreach ($coll as $item) {      
        if (is_array($item)) {
            foreach ($item as $subitem) {
                $result[] = $subitem;
            }
        } else {
            $result[] = $item;
        }
    }
    
    return $result;
}

/*
Вложенные циклы коварны. Их наличие может резко увеличить сложность кода и в особо тяжелых случаях значительно замедлить его. В тех местах, где можно от них избавиться, лучше от них избавляться.

Для реализации функции flatten лучше использовать слияние массивов, которое мы рассмотрим в одном из следующих уроков. Если же от вложенных массивов уйти не получается, то с высокой вероятностью вложенный цикл можно вынести в отдельную функцию.
*/

function concat($result, $items)
{
    foreach ($items as $item) {
        $result[] = $item;
    }
    return $result;
}

function flatten($coll)
{
    $result = [];
    foreach ($coll as $item) {
        if (is_array($item)) {
            $result = concat($result, $item)
        } else {
            $result[] = $item;
        }
    }

    return $result;
}


// Реализуйте функцию getSameCount, которая считает количество общих уникальных элементов для двух массивов. Аргументы: Первый массив / Второй массив

function getSameCount($coll1, $coll2) 
{
    $count = 0;
    $uniqColl1 = array_unique($coll1);
    $uniqColl2 = array_unique($coll2);

    foreach ($uniqColl1 as $item1) {
        foreach ($uniqColl2 as $item2) {
            if ($item1 === $item2) {
                $count++;
            }
        }
    }

    return $count;
}




>>>>>  Теория Множеств <<<<<<<

/*
Множеством обозначают совокупность объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество арабских цифр включает в себя 10 элементов и является конечным. Понятие конечности носит интуитивный характер и обозначает, что в множестве конечное число элементов.

Пример бесконечного множества — натуральные числа. В свою очередь множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее.

«Подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством (по отношению к подмножеству).

Главное для нас в теории множеств — операции над ними. К ним относятся: дополнение, объединение, пересечение, разность, декартово произведение и некоторые другие.

Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

Переходя к программированию, можно заметить, что массив очень похож на множество, и его действительно можно так рассматривать. Почему это так важно? Понимая принципы, на которых основаны некоторые операции, вы сможете реализовывать их наиболее быстрым и эффективным способом. Например, зная, что вам нужна операция пересечения множеств в php, вы можете попытаться найти функцию, которая делает поставленную задачу. Для этого достаточно ввести в гугл запрос: php set intersect (set — множество, intersect — пересечение). Первая (по крайней мере, у меня) ссылка в поисковой выдаче ведет на нужную функцию array_intersect. Тоже самое вас ждет и с другими операциями.

Отдельно стоит сказать, что реляционные базы данных построены на идеях реляционной алгебры, в которой теория множеств играет центральную роль.
Рассказы о множествах книга: http://ilib.mccme.ru/pdf/rasomn.pdf
*/


// Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

array_intersect($friends1, $friends2); // => ['vasya', 'petya'] // Эта функция принимает любое количество массивов. То есть вы можете находить пересечение любого количества массивов за один вызов.

// Объединением множеств называется множество, в которое входят элементы всех данных множеств. Объединение множеств в php нельзя сделать одним вызовом, но его можно имитировать, соединив две функции:

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

// merge выполняет слияние двух массивов, в отличие от объединения, в нем повторяются элементы которые встречаются там и там (а не должны)
$friends = array_merge($friends1, $friends2);
// => ['vasya', 'kolya', 'petya', 'igor', 'petya', 'sergey', 'vasya', 'sasha'];

// unique удаляет дубли
$sharedFriends = array_unique($friends);
// => ['vasya', 'kolya', 'petya', 'igor', 'sergey', 'sasha']

// Дополнение (разность). Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется diff.

$friends1 = ['vasya', 'kolya', 'petya'];
$friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];
array_diff($friends1, $friends2); // => ['kolya']

// Принадлежность множеству. Проверку принадлежности элемента множеству можно выполнить с помощью функции in_array:
$terribleNumbers = [4, 13];

if (in_array(10, $terribleNumbers)) {
    print_r('woah!');
}


// Реализуйте функцию countUniqChars, которая считает количество уникальных символов в переданной строке. Если передана пустая строка, то функция должна вернуть 0, т.к. пустая строка вообще не содержит символов. Задание необходимо выполнить без использования функции array_unique.

function countUniqChars($text)
{
    if ($text === '') {
        return 0;
    }

    $uniqChars = [];
    $chars = str_split($text);
    
    foreach ($chars as $char) {
        if (!in_array($char, $uniqChars)) {
            $uniqChars[] = $char;
        }
    }

    return count($uniqChars);
}




>>>>>  Сортировка массивов <<<<<<<

// пузырьковая сортировка
function bubbleSort(array $arr)
{
    $size_arr = sizeof($arr);

    do {
        $flag = false;

        for ($i = 0; $i < $size_arr - 1; $i++) {
            if ($arr[$i] > $arr[$i + 1]) {
                 $curr_val = $arr[$i];
                 $arr[$i] = $arr[$i + 1];
                 $arr[$i + 1] = $curr_val;
                 $flag = true;
            } 
        }
        $size_arr--;
    } while($flag);
    return $arr;
}


/*
Весь код делится на два уровня:

* Внутренний цикл for, который проходит по массиву от начала до конца, меняя элементы попарно, если нужно сортировать.
* Внешний цикл while..do, определяющий, когда нужно остановиться. Обратите внимание, что в худшем случае этот цикл выполнится sizeof($arr) раз, что совпадает с теоретическим худшим случаем этого алгоритма, при котором самый большой или маленький элемент находятся в противоположных конце массива от сортированного варианта.
*/




>>>>>  Ссылки <<<<<<<

// Большинство функций, работающих с массивами, после обработки возвращают новый массив. Но некоторые работают по-другому. В этих функциях, как правило, не используется возврат. Они меняют исходный массив напрямую за счет использования ссылок. К таким функциям, например, относится функция сортировки:

$arr = [3, 8, 1];

sort($arr);
print_r($arr);

// Несмотря на то, что подход, меняющий массивы напрямую, сложнее в отладке, его используют в некоторых языках для увеличения эффективности работы. Если массив достаточно большой, то полное копирование окажется дорогой операцией. В реальной жизни (веб разработчика) это почти никогда не проблема, но знать об этом полезно.



>>>>>  Стек <<<<<<<

/*
Структура данных — это конкретный способ хранения и организации данных. В зависимости от решаемых задач, удобным оказывается либо один способ организации данных, либо другой. Как минимум, одну структуру данных вы уже знаете достаточно хорошо — это массив. С точки зрения организации, массив представляет собой совокупность элементов, к которым имеется индексированный доступ (доступ по индексу), а вот с точки зрения хранения — все сложнее. Массивы бывают разные и внутри языка реализуются тоже по-разному.

Каноническая организация хранения массива — непрерывный блок памяти. А индекс в таком случае играет роль смещения по ней. Именно поэтому индексация в массивах начинается с нуля, так как указывает на начало этого блока, а индекс под номером 1 уже является смещением. Но на практике все сложнее. В PHP нет настоящих массивов. 

Кроме массивов существует множество других структур данных, таких как списки, хеш-таблицы, деревья, графы, стек, очередь и другие. Использование структуры данных, подходящей под решаемую задачу, позволяет кардинально упростить код, устраняя запутанную логику.

Некоторые из перечисленных структур данных мы рассмотрим в процессе прохождения курсов и проектов, другие вам нужно будет подтянуть самостоятельно из книг (книги лучше, чем статьи). В любом случае алгоритмы и структуры данных (без фанатизма) составляют базу, на которую нанизывается все остальное в разработке.

Стоит разделять три понятия:

 * Структура данных
 * Конкретный тип данных (или просто «тип данных»)
 * Абстрактный тип данных
 
Со структурой данных все понятно, выше было определение. С типом данных тоже все просто. Например, массив в PHP — это тип данных. Понятие «тип данных» всегда привязано к конкретному языку и может быть абсолютно чем угодно в зависимости от предпочтений разработчиков языка. Другими словами если бы разработчики PHP решили, что числа надо назвать типом данных Array, то никто бы им этого не запретил, несмотря на абсурдность такого имени для чисел. Кроме встроенных типов данных, бывают и пользовательские. Так, PHP позволяет создавать интерфейсы и классы, но об этом мы поговорим чуть позже.

А вот АТД — теоретическое понятие. АТД целиком и полностью определяется набором операций, которые можно выполнять над ним. АТД абстрактный потому, что он ничего не говорит о способе хранения и существует лишь на бумаге и в головах. А вот уже в конкретных языках существуют конкретные типы, реализующие АТД.

АТД нередко путают с понятием «структура данных», более того, часто, структуры данных и АТД имеют одно и тоже название.


# Стек
Стек — упорядоченная коллекция элементов, в которой добавление новых и удаление старых элементов всегда происходит с одного конца коллекции. Обычно его называют вершиной стека.

У стека есть аналоги из реальной жизни. Слово stack, с английского, переводится как «стопка». По сути, любая стопка может рассматриваться как стек. Если не применять грубую физическую силу, то со стопками мы работаем двумя способами. Либо кладем новый элемент (например, книгу) на верхушку стопки, либо снимаем элемент с верхушки. Еще более показательный пример — магазин в огнестрельном оружии. Первый заложенный патрон выйдет из магазина последним. Поэтому стек еще называют "Last In First Out" (LIFO), то есть "последний зашел, первый вышел".

Перед тем, как разбирать конкретную задачу, я покажу вам, что стек играет огромную роль в программировании. Вспомните, как исполняется любая программа. Одни функции вызывают другие, которые, в свою очередь, вызывают третьи, и так далее. После того, как выполнение заходит в самую глубокую функцию, та возвращает значение, и начинается обратный процесс. Сначала идет выход из наиболее глубоких функций, затем из тех, что уровнем выше, и так далее до тех пор, пока не дойдет до самой внешней функции. Вызов функций — ничто иное, как добавление элемента в стек, а возврат — снятие со стека. Именно так всё устроено на аппаратном уровне. К тому же, если в процессе выполнения программы происходит ошибка, то её вывод часто называют Stack Trace (трассировка стека).

Другой пример, связанный с программированием — кнопка «назад» в браузере. История посещений представляет собой стек, каждый новый переход по ссылке добавляет её в историю, а кнопка «назад» извлекает из стека последний элемент.


Стек — абстрактный тип данных со следующим набором операций:

 * Добавить в стек (push)
 * Взять из стека (pop)
 * Вернуть элемент с вершины стека без удаления (peek)
 * Проверить на пустоту (isEmpty)
 * Вернуть размер (size)
 
 В PHP стек можно построить на основе массивов. Для этого используется следующий набор функций: array_push, array_pop, empty, sizeof.
 
 Обратите внимание, что array_pop и array_push изменяют исходный массив. array_pop не только изменяет его, но и возвращает элемент, снятый со стека.
 
 Рассмотрим задачку, решение которой тривиально при использовании стека. Кстати, её нередко задают на собеседованиях, как раз чтобы убедиться, хорошо ли вы знаете базовые структуры данных.

Задача:

 Необходимо реализовать функцию, которая проверяет, что парные символы сбалансированы. То есть каждый открывающий символ имеет закрывающий, и они не перекрываются, например так [{]}. К таким символам в нашем случае относятся <>, {}, () []. Входом в функцию может быть ()<>{}. Такой пример проходит проверку, а вот этот уже нет: [({)}]. Здесь происходит перекрытие фигурных и круглых скобок.

 Решение со стеком выглядит так:

 Если перед нами открывающий элемент, то заносим его в стек
 Если закрывающий, то достаем из стека элемент (очевидно, последний добавленный) и смотрим, что он открывающий для данного закрывающего. Если проверка провалилась, значит выражение не соответствует требуемому формату.
 Если мы дошли до конца строки и стек пустой, то все хорошо. Если в стеке остались элементы, то проверка не прошла. Такое может быть, если в начале строки были открывающие элементы, но в конце не было закрывающих.
 Разберем его построчно:
*/

function checkIfBalanced(string $expression): boolean
{
    
    $stack = [];
    
    $startSymbols = ['{', '(', '<', '['];
    
    $pairs = ['{}', '()', '<>', '[]'];

    
    for ($i = 0; $i < strlen($expression); $i++) {
        $curr = $expression[$i];
        
        if (in_array($curr, $startSymbols)) {
            array_push($stack, $curr);
        } else { 
            $prev = array_pop($stack);
            
            $pair = "{$prev}{$curr}";
            
            
            if (!in_array($pair, $pairs)) {
                return false;
            }
        }
    }
   
    return sizeof($stack) == 0;
}

/*
 Предположим, что на вход функции попала следующая строка: [{]. Ниже описание ключевых шагов при выполнении функции проверки:

 * Первый символ [ заносится в стек, так как он входит в список открывающих
 * Символ { также заносится в стек по той же самой причине
 * Символ ] относится к закрывающим, поэтому со стека забирается последний символ {. Из них составляется пара {], которая не проходит проверку.
 
 # Семантика
 Может возникнуть соблазн использовать эти функции в повседневной практике. Например, чтобы извлечь из массива последний элемент. Несмотря на то, что array_pop действительно позволяет это сделать, такой вариант использования крайне нежелателен по нескольким причинам:

 Побочный эффект данной операции — изменение исходного массива. Даже если далее массив не используется, такой код вносит потенциальные проблемы и заставляет его переписывать в будущем.
 Нарушается семантика. Инструменты нужно использовать по назначению, иначе рождается код, который декларирует одно, но в реальности делает другое. Любой опытный программист, который видит array_pop или array_push сразу считает, что массив в данной части программы используется как стек, но на самом деле он этого не делает. Подобный код заставляет напрягаться и анализировать его лишний раз для понимания сути.
 */
 
 // Реализуйте функцию checkIfBalanced, которая проверяет балансировку круглых скобок в арифметических выражениях.
 
function checkIfBalanced(string $expression): bool
{
    // инициализируем стек
    $stack = [];
    for ($i = 0; $i < strlen($expression); $i++) {
        $curr = $expression[$i];
        if ($curr == '(') {
            array_push($stack, $curr);
        } elseif ($curr == ')') {
            if (empty($stack)) {
                return false;
            }
            array_pop($stack);
        };
    }

    // Если стек оказался пустой после обхода строки, то значит все хорошо
    return sizeof($stack) == 0;
}





>>>>>  Big O <<<<<<<

/*
Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» и нотация О-большое (Big O notation). Она не только полезна при прохождении собеседований, но и даёт понимание того, как вообще оценивать эффективность кода (очень относительно).

Как вы помните, алгоритмов сортировок существует много, я бы сказал очень много. Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом (или классифицируются) по их вычислительной (или алгоритмической) сложности. Сложность оценивается по количеству выполняемых операций. Понятно, что конкретное количество операций зависит от входных данных, например, если массив отсортирован, то количество операций будет минимальным (но они все равно будут, потому что алгоритм должен убедиться в том, что массив отсортирован). Если не отсортирован, то для каждого алгоритма можно подобрать такие входные данные, при которых он будет работать максимально долго и не эффективно. Эти случаи называют соответственно верхней и нижней границей.

Нотация Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Вот некоторые примеры того, как записывается сложность: O(1), O(n), O(nlog(n)).

O(1) описывает так называемую константную сложность. Например обращение к элементу массива по индексу оценивается константой, другими словами оно не зависит от размера массива, поэтому внутри O записывается единица, символизирующая константу. А вот функция, которая печатает на экран все элементы переданного массива используя обычный перебор имеет сложность O(n) (линейная сложность). То есть количество выполняемых операций будет равно количеству элементов массива. Именно это количество символизирует символ n в скобках.

Еще один простой пример — вложенные массивы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью функции in_array, чья сложность O(n), ведь в худшем случае она просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны n, то получается, что поиск пересечений имеет квадратичную сложность или O(n^2) (n в квадрате). Существуют как очень эффективные, так и абсолютно не эффективные алгоритмы. Первые, как правило имеют логарифмическую сложность, последние — степенную, такую, при которой n находится в степени. Скорость работы подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов.

Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность паралеллиться (и если это происходит, то работают крайне эффективно). Как и все в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

Big O, во многом, теоретическая оценка, на практике всё может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых, архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет, потому что работает с небольшим объемом памяти, а где-то в это время есть другой кусок, который вызывается тысячи раз, и приводит к реальному замедлению.

Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд Кнут
*/
 
// Поиск пересечения двух неотсортированных массивов, операция в рамках которой выполняется вложенный цикл с полной поверкой каждого элемента первого массива, на вхождение во второй. Сложность данного алгоритма O(nm) (проивезедение n и m), где n и m размерности массивов. Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), что значительно лучше. Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. Начальное значение каждого указателя 0. Затем идет проверка элементов находящихся под этими индексами в обоих массивах. Если они совпадают то значение заносится в результирующий массив, а оба индекса инкрементируются, если значение в первом массиве больше чем во втором, то инкрементируется указатель второго массива, иначе первого.


function getIntersectionOfSortedArray($arr1, $arr2)
{
	$size1 = sizeof($arr1);
    $size2 = sizeof($arr2);

    if ($size1 == 0 || $size2 == 0) {
        return [];
    }

    $i1 = 0;
    $i2 = 0;
	
    $result = [];
    do {
        if ($arr1[$i1] == $arr2[$i2]) {
            $result[] = $arr1[$i1];
            $i1++;
            $i2++;
        } elseif ($arr1[$i1] > $arr2[$i2]) {
            $i2++;
        } else {
            $i1++;
        }
    } while ($i1 < $size1 && $i2 < $size2);

    return $result;
}





>>>>>  Destructuring <<<<<<<

/*
В программировании часто встречается понятие «синтаксический сахар». Им обозначают конкретные конструкции в языках программирования, которые упрощают часто используемые операции, делая их синтаксически проще.

PHP не богат на подобные конструкции, но кое-что все же имеется. 

Самый простой пример сахара — обмен переменных местами. Обычно для этого используют третью переменную (хотя те, кто сильны в теории, скажут и о XOR варианте обмена):
*/

$a = 5;
$b = 8;

$temp = $a;
$a = $b;
$b = $temp;

// Довольно утомительное занятие. А вот как можно сделать короче:

$a = 5;
$b = 8;

list($b,$a) = [$a, $b]; 
[$b, $a] = [$a, $b]; // c версии 7.1

// Не так круто, как в других языках, где можно писать a, b = b, a, но уже что-то.

// Другой интересный пример синтаксического сахара — destructuring (дестракчеринг или деструктуризация). Представьте, что у нас есть массив из двух элементов, которыми мы хотим оперировать в нашей программе. Самый простой вариант использования — постоянное обращение по индексу $arr[0] и $arr[1]. Такой код не очень хорошо читается, потому что надо понять, что это такое. Поэтому гораздо лучше сначала присвоить эти значения переменным с хорошими именами. Тогда код будет выглядеть так:

$firstName = $arr[0];
$lastName = $arr[1];

// Как видно, код стал значительно понятнее без лишних слов. Дестракчеринг позволяет извлекать элементы из составной структуры, используя особый синтаксис:

[$firstName, $lastName] = $arr;

/*
Получилось и короче и понятнее (особенно если привыкнуть к этому способу записи). Пример с обменом переменных тоже построен на дестракчеринге. Обратите внимание, что справа от = фактически был создан массив [$a, $b]. Дестаркчеринг работает для любого количества элементов и не только с массивами.

Разложение массива можно использовать не только как отдельную инструкцию в коде, но и, например, в циклах:
*/

$points = [ [4, 3], [0, -3] ];

foreach ($points as [$x, $y]) {
    print_r([$x, $y]);
}

// =>
Array
(
    [0] => 4
    [1] => 3
)
Array
(
    [0] => 0
    [1] => -3
)


// Напишем функцию, считающую количество вхождений каждого слова в предложение. Результатом работы этой функции является ассоциативный массив, в котором ключ — "слово", а значение — "количество вхождений". Пример:

function getWordsCount($content)
{
    // Разбиваем на слова
    $words = explode(' ', $content);
    $result = [];
    foreach ($words as $word) {
        if (!array_key_exists($word, $result)) {
            // Инициализация при первом упоминании
            $result[$word] = 1;
        } else {
            $result[$word]++;
        }
    }

    return $result;
}


// Реализуйте функцию getIn, которая извлекает из массива (который может быть любой глубины вложенности) значение по указанным ключам. Аргументы: Исходный массив / Массив ключей, по которым ведется поиск значения. В случае, когда добраться до значения невозможно, возвращается null.

function getIn(array $data, array $keys)
{
    $current = $data;

    foreach ($keys as $key) {
        if (!is_array($current) || !array_key_exists($key, $current)) {
            return null;
        }

        $current = $current[$key];
    }

    return $current;
}


// Реализуем функцию findKeys, которая возвращает список ключей массива, значение которых равно переданному значению:

$lessonMembers = [
  'syntax' => 3,
  'using' => 2,
  'foreach' => 10,
  'operations' => 10,
  'destructuring' => 2,
  'array' => 2,
];

$result = findKeys($lessonMembers, 10);
// => ['foreach', 'operations']

$result = findKeys($lessonMembers, 3);
// => ['syntax']

function findKeys(array $data, $expectedValue)
{
    $result = [];
    foreach ($data as $key => $value) {
        if ($value === $expectedValue) {
            $result[] = $key;
        }
    }

    return $result;
}


// Реализуйте функцию pick, которая извлекает из переданного массива все элементы по указанным ключам и возвращает новый массив. Аргументы: Исходный массив / Массив ключей, по которым должны быть выбраны элементы (ключ и значение) из исходного массива, и на основе выбранных данных сформирован новый массив

function pick(array $arr, array $keys)
{
	$res = [];
	
	foreach ($keys as $key) {
		if (array_key_exists($key, $arr)) {
			$res[$key] = $arr[$key];
		}
	}
	
	return $res;
}



>>>>>  Популярные функции для работы с ассоциативными массивами <<<<<<<

// Функция array_keys извлекает из ассоциативного массива ключи и создает из них массив.


$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data); // => ['first_name', 'last_name']

// Типичное применение данной функции в языках отличных от PHP — обход ассоциативного массива:

$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_keys($data);
foreach($keys as $key) {
    print_r($data[$key]);
}

// В PHP то же самое самое делается прямым обходом ассоциативного массива, но знать про функцию все равно полезно. Например, в JSON (как и в языках, отличных от PHP) массив и ассоциативный массив — разные типы данных.

{
  "autoload": {
    "files": [
      "src/Arrays.php"
    ]
  },
  "config": {
    "vendor-dir": "/composer/vendor"
  }
}

// Выше files — обычный массив, а config — ассоциативный.


// Функция array_values извлекает из ассоциативного массива значения и создает из них массив.


$data = ['first_name' => 'Mark', 'last_name' => 'Smith'];

$keys = array_values($data); // => ['Mark', 'Smith']

/*
array_merge
Наиболее интересная функция — array_merge или так называемое слияние. Слияние двух массивов порождает новый массив, в котором поверх первого массива накладывается второй по следующим правилам:

* Если в первом массиве есть ключ, которого нет во втором, то он остается
* Если в первом и во втором массиве есть один и тот же ключ, то его значением становится значение из второго массива
* Если в первом массива нет ключа, который есть во втором, то он добавляется.

Операция слияния не коммутативна, так же, как и вычитание. Изменение порядка аргументов (перемена массивов) приведет к другому результату.
*/

$data1 = [
    'first_name' => 'Mark',
    'last_name' => 'Polo',
];

$data2 = [
    'last_name' => 'Brin',
    'age' => 15,
];

$result = array_merge($data1, $data2);
// => [
//     'first_name' => 'Mark',
//     'last_name' => 'Brin',
//     'age' => 15,
// ]

// Иногда в программировании возникает задача поиска разницы между двумя наборами данных, такими как ассоциативные массивы. Например, при поиске различий в json файлах. Для этого даже существуют специальные сервисы, например, http://www.jsondiff.com/ (попробуйте нажать на ссылку sample data и затем кнопку Compare).

/*
Реализуйте функцию genDiff, которая возвращает ассоциативный массив, в котором каждому ключу из исходных массивов соответствует одно из четырех значений: added, deleted, changed или unchanged. Аргументы:

* Ассоциативный массив
* Ассоциативный массив
* Расшифровка:

* Added - ключ отсутствовал в первом массиве, но был добавлен во второй
* Deleted - ключ был в первом массиве, но отсутствует во втором
* Changed - ключ присутствовал и в первом и во втором массиве, но значения отличаются
* Unchanged - ключ присутствовал и в первом и во втором массиве с одинаковыми значениями

$result = genDiff(
    ['one' => 'eon', 'two' => 'two', 'four' => true],
    ['two' => 'own', 'zero' => 4, 'four' => true]
);

// => [
//     'one' => 'deleted',
//     'two' => 'changed'
//     'zero' => 'added',
//     'four' => 'unchanged',
// ];

*/

function union(array $data1, array $data2)
{
    return array_unique(array_merge($data1, $data2));
}

function genDiff(array $data1, array $data2)
{
    $keys = union(array_keys($data1), array_keys($data2));
    $result = [];

    foreach ($keys as $key) {
        if (array_key_exists($key, $data1) && array_key_exists($key, $data2)) {
            if ($data1[$key] === $data2[$key]) {
                $result[$key] = 'unchanged';
            } else {
                $result[$key] = 'changed';
            }
        } elseif (array_key_exists($key, $data2)) {
            $result[$key] = 'added';
        } elseif (array_key_exists($key, $data1)) {
            $result[$key] = 'deleted';
        }
    }

    return $result;
}



>>>>>  Destructuring <<<<<<<

// Напомню, что деструктуризация (дестракчеринг) — специальный синтаксис, позволяющий извлекать части из составных данных. Самый простой пример, который мы рассмотрели, заключается в извлечении значений массива состоящего из двух элементов.

[$firstName, $lastName] = $arr;

// На части можно раскладывать не только индексированные, но и ассоциативные массивы, извлекая из них значения по определенным ключам.

$person = ['first' => 'Rasmus', 'last' => 'Lerdorf', 'manager' => true];

// Порядок извлечения не важен

['last' => $lastname, 'first' => $firstname] = $person;

// Теперь переменные $lastname и $firstname содержат соответствующие значения. Имена самих переменных выбираются произвольно, главное — совпадение по ключам.
// PHP допускает вложенный дестракчеринг. С помощью него можно получать значения не только внешнего массива, но и вложенных.

$options = ['enabled' => true, 'compression' => ['algo' => 'gzip']];

[
    'enabled' => $enabled,
    'compression' => [
        'algo' => $compressionAlgo
    ]
] = $options;

// Дестракчеринг ассоциативного массива можно комбинировать с дестракчерингом индексированного.

$x = ['o' => [1, 2, 3]];
['o' => [$a, $b, $c]] = $x;

$y = ['o' => [[1, 2, 3], ['what' => 'WHAT']]];
['o' => [[$one, $two, $three], ['what' => $what]]] = $y;

// Дестракчеринг допустим и в циклах:

$persons = [
    ['first' => 'Rasmus', 'last' => 'Lerdorf'],
    ['first' => 'Fabien', 'last' => 'Potencier'],
    ['first' => 'Taylor', 'last' => 'Otwell']
];

foreach ($persons as ['first' => $firstname, 'last' => $lastname]) {
    var_dump($firstname, $lastname);
} // =>
/*
string(6) "Rasmus"
string(7) "Lerdorf"
string(6) "Fabien"
string(9) "Potencier"
string(6) "Taylor"
string(6) "Otwell"
*/

// Extract
// Кроме описанного выше, в PHP существует еще один способ дестракчеринга, который на первый взгляд кажется проще. Вызов функции extract с переданным ассоциативным массивом приводит к тому, что создаются переменные с именами ключей, в которые записываются значения из массива.


$vars = [
  'color' => 'blue',
  'size'  => 'medium',
  'shape' => 'sphere'
];
extract($vars);

var_dump($color, $size, $shape); // => string(4) "blue" string(6) "medium" string(6) "sphere"

/*
 Ни в одном другом популярном языке нет возможности создать переменные без явного определения переменных. Данный способ обладает массой недостатков и не рекомендуется к использованию. Перечислим их:

 * Переменные всегда создаются для всех ключей массива. Они засоряют локальное окружение и могут приводить к ошибкам если пересекутся с названиями уже существующих переменных.
 * Безопасность. Если содержимое массива приходит извне (из формы или базы данных), то есть потенциальная вероятность попадания в массив ключа, который приведет к перезаписыванию значения существующей переменной.
 * Неявное создание переменных вообще само по себе странная вещь (и нигде не встречается!). Такой код значительно сложнее в анализе.
*/ 





>>>>>  Хеш-таблицы <<<<<<<

/*
Ассоциативный массив — абстрактный тип данных. У него есть и другие названия: «словарь», «мап». В разных языках ему соответствуют разные типы данных, названия которых имеют мало общего с названием ADT. Например:

Ruby - Hash
Lua - Table
Python - Dictionary
JS - Object
Elixir/Java - Map

Ассоциативный массив, в отличие от индексированного массива, нельзя положить в память «как есть». Непонятно, как хранить ключи и связывать их со значениями. Для реализации ассоциативных массивов используют, так называемые, хеш-таблицы.

Хэш-таблица — это структура данных, реализующая интерфейс ассоциативного массива. Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. Независимо от выбранного варианта, основа любой хеш-таблицы — индексированный массив, в котором и хранится вся информация и хеширование, о котором мы поговорим ниже. Остальная логика сводится к разрешению коллизий.

Хеширование
Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс массива. Именно так производятся все операции. Сначала вычисляется индекс на основе ключа, дальше туда либо записываются данные, либо читаются.

Преобразование ключа в индекс массива выполняется с помощью хеширования. Хеширование — операция, которая преобразует любые входные данные в строку фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой».

С хешированием мы встречаемся в разработке крайне часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 ни что иное, как хеш, полученный в результате хеширования.

Самый простой способ хешировать данные на PHP — использовать функцию crc32:
*/

$checksum = crc32('The quick brown fox jumped over the lazy dog.'); // => 2191738434
	
/*
И хотя хеширование позволяет отображать ассоциативный массив на обычный массив, оно не лишено недостатков, с которыми нужно уметь работать.

Коллизии
Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и состава). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат любой хешируемой функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

Из этого факта следует, что не для всех входных данных найдется уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.

Коллизии не так редки, как может показаться. Убедиться в этом можно изучив парадокс дней рождений (https://ru.wikipedia.org/wiki/Парадокс_дней_рождения).
*/




#####  Массив и Ассоциативный Массив ######

/*
В PHP есть только один тип данных для массивов — Array. Его уникальность заключается в том, что с одной стороны он работает как обычный массив, а с другой — как ассоциативный. Зависит от того, как его используют.

Поначалу такой подход может подкупить своей кажущейся простотой, особенно тех, кто не имел дела с другими языками. Но чем дальше в код, тем больше проблем он приносит.

Самый простой пример — JSON. В JSON массив и ассоциативный массив — разные сущности. Если конвертировать JSON в массив, то эта информация теряется. Если мы не знаем структуру JSON, то у нас нет простого способа понять, что перед нами — массив или ассоциативный массив. В интернете с подобным сталкиваются постоянно и предлагают такой способ, как анализ ключей. Если они все числовые, то считаем, что массив, иначе — ассоциативный массив. Конвертация из массива в JSON сопряжена с такими же проблемами. Как понять, во что конвертировать переданный массив?

Другая проблема заключается в том, что достаточно легко ошибиться с типом массива и начать его использовать не по назначению:
*/

$data = [];
$data[] = 10;
$data['key'] = 'value';
$data[] = 'hi!';

// Первое удивление — код работает! Теперь попробуйте догадаться, что находится внутри $data.
 
print_r($data);

// => Array
// (
//     [0] => 10
//     [key] => value
//     [1] => hi!
// )

// Из этого вывода должно быть понятно, что индексированных массивов в PHP нет. Есть упорядоченные ассоциативные массивы, с операцией [] =: добавить элемент с автоматическим присвоением ключа.

$data = ['key' => 'value'];
$data[] = 'console';

// => Array
// (
//     [key] => value
//     [0] => console
// )

// Но самое неудобное — функции которые могут сохранять, а могут не сохранять ключи. Обычно в таких функциях есть дополнительный параметр флаг preserve_keys, который меняет описанное поведение. По сути в описании каждой функции, которая принимает на вход массив (или массивы) и возвращает массив, есть секция с пояснением, сохраняет ли ключи функция или нет, и как это поведение можно изменить.


// Реализуйте функцию, которая принимает на вход массив, состоящий из массивов-пар, и возвращает ассоциативный массив, полученный из этих пар.

fromPairs([['fred', 30], ['barney', 40]]); // → ['fred' => 30, 'barney' => 40]

function fromPairs(array $data)
{
    $result = [];
    foreach ($data as [$key, $value]) {
        $result[$key] = $value;
    }

    return $result;
}


// Реализуйте функцию, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

buildQueryString(['per' => 10, 'page' => 1 ]);
// → page=1&per=10

// Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).

function buildQueryString(array $array)
{
    ksort($array);
    $result = [];
    foreach($array as $key => $value) {
        $result[] = "{$key}={$value}";
    }

    return implode('&', $result);
}


// Реализуйте функцию findWhere, которая принимает на вход массив (элементы которого - ассоциативные массивы) и пары ключ-значение (тоже в виде массива), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам.

findWhere(
    [
        ['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
        ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
        ['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
        ['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
        ['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
        ['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
    ],
    ['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]


function findWhere(array $data, array $values) // my 
{ 
	foreach ($data as $key => $value) { 
		foreach ($values as $k => $v) { 
			if (array_key_exists($k, $data[$key]) && $data[$key][$k] === $v) {				
                if ($v == end($values)) {
					return $value;
				}
			} else {
				break;
			}
		}
	}

	return null;
}

function findWhere($data, $where) // hexlet
{
    foreach ($data as $item) {
        $find = true;
        foreach ($where as $key => $value) {
            if ($item[$key] !== $value) {
                $find = false;
            }
        }
        if ($find) {
            return $item;
        }
    }
}


/*
Чанкованием (от англ. Chunk — ячейка, кусок, осколок) в программировании называют разбиение коллекции (массива) на несколько более мелких коллекций. Например, разобьём массив на чанки, так чтобы в каждом чанке было не более двух элементов: ['a', 'b', 'c', 'd'] -> [['a', 'b'], ['c', 'd']].

src\Arrays.php
Реализуйте функцию getChunked, которая принимает на вход массив и число, задающее размер чанка (куска). Функция должна вернуть массив, состоящий из чанков указанной размерности.
*/

getChunked(['a', 'b', 'c', 'd'], 2); // → [['a', 'b'], ['c', 'd']]
getChunked(['a', 'b', 'c', 'd'], 3); // → [['a', 'b', 'c'], ['d']]
getChunked( ['a', 'b', 'c', 'd', 'e', 'f'], 2)); // → [['a', 'b'] ['c', 'd'], ['e', 'f']]

// PS: Попробуйте реализовать это упражнение без использования встроенной в PHP функции array_chunk. То есть вам нужно написать свою реализацию данной функции.


function getChunked(Array $array, Int $size) 
{
    $result = [];
    for ($i = 0; $i < ceil(sizeof($array) / $size); $i++) { // ceil - округляет дробь в большую сторону
        $result[] = array_slice($array, $i * $size, $size);
    }

    return $result;
}


/*
Реализуйте функцию compareVersion, которая сравнивает переданные версии version1 и version2. Если version1 > version2, то функция должна вернуть 1, если version1 < version2, то - -1, если же version1 = version2, то - 0.

Версия - это строка, в которой два числа (мажорная и минорные версии) разделены точкой, например: 12.11. Важно понимать, что версия - это не число с плавающей точкой, а несколько чисел не связанных между собой. Проверка на больше/меньше производится сравнением каждого числа независимо. Поэтому версия 0.12 больше версии 0.2.
Пример порядка версий:
0.1 < 1.1 < 1.2 < 1.11 < 13.37
*/
compareVersion("0.1", "0.2"); // → -1
compareVersion("0.2", "0.1"); // → 1
compareVersion("4.2", "4.2"); // → 0

function compareVersion(String $first, String $second)
{
    $version1 = explode('.', $first);
    $version2 = explode('.', $second);

    if ($version1 > $version2) {
        return 1;
    } elseif ($version1 === $version2) {
        return 0;
    } else {
        return -1;
    }
}


/*
Вес Хэмминга это количество единиц в двоичном представлении числа.
Реализуйте функцию hammingWeight, которая считает вес Хамминга.
*/

hammingWeight(0); // → 0
hammingWeight(4); // → 1
hammingWeight(101); // → 4



function hammingWeight(int $num) // my
{
	// decbin — переводит число из десятичной системы счисления в двоичную
	// bindec — переводит двоичное число в десятичное
	$bin_str = (string)	decbin($num);
	return substr_count($bin_str, '1'); // substr_count - возвращает число вхождений подстроки

}

function hammingWeight(Int $num) // hexlet
{
    $weight = 0;
    $digits = str_split(decbin($num));
    foreach ($digits as $value) {
        if ($value === '1') {
            $weight += 1;
        }
    }

    return $weight;
}


// Реализуйте функцию lengthOfLastWord, которая возвращает длину последнего слова переданной на вход строки. Словом считается любая последовательность, не содержащая пробелов.

lengthOfLastWord(''); // → 0

lengthOfLastWord('man in BlacK'); // → 5

lengthOfLastWord('hello, world!  '); // → 6

function lengthOfLastWord(String $str)
{
    $words = explode(' ', trim($str));
    return strlen(end($words));
}


// Реализуйте функцию summaryRanges, которая находит в массиве непрерывные возрастающие последовательности чисел и возвращает массив с их перечислением.

summaryRanges([1, 2, 3])); // → ["1->3"]
summaryRanges([0, 1, 2, 4, 5, 7]); // → ["0->2", "4->5"]
summaryRanges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5]); // → ['110->112', '-5->-4']


function summaryRanges(array $arr) // my
{
	$resOp = [];
	$rec = false;
	
	foreach ($arr as $key => $val) {
		if($key == 0) { continue; }
		if (!$rec && $arr[$key - 1] == $val - 1) {
			$beginningOfSequence = $arr[$key - 1];
			$rec = true;
		} elseif ($rec && $arr[$key - 1] != $val - 1) {
			$resOp[] = "$beginningOfSequence->".$arr[$key - 1];
			$rec = false;	
		} elseif($rec && $key == sizeof($arr) - 1) {
			$resOp[] = "$beginningOfSequence->{$val}";
		}
	}
	return $resOp;
}


function summaryRanges(Array $array) // hexlet
{
    $result = [];

    if (empty($array)) {
        return $array;
    }

    $firstValue = $array[0];
    $firstIndex = 0;
    foreach ($array as $index => $value) {
        if ($index === 0) {
            continue;
        }
        $expectedValue = $array[$index - 1] + 1;
        if ($expectedValue !== $value) {
            if ($firstIndex !== $index - 1) {
                $result[] = "$firstValue->{$array[$index - 1]}";
            }
            $firstValue = $value;
            $firstIndex = $index;
        } elseif ($index === sizeof($array) - 1 && $expectedValue === $value) {
            $result[] = "$firstValue->{$array[$index]}";
        }
    }

    return $result;
}


// Реализуйте функцию getMirrorMatrix, которая принимает двумерный массив (матрицу) и возвращает массив, изменённый таким образом, что правая половина матрицы становится зеркальной копией левой половины, симметричной относительно вертикальной оси матрицы. Для простоты условимся, что матрица всегда имеет чётное количество столбцов и количество столбцов всегда равно количеству строк.

getMirrorMatrix([
  [11, 12, 13, 14],
  [21, 22, 23, 24],
  [31, 32, 33, 34],
  [41, 42, 43, 44],
]);

// → [
//     [11, 12, 12, 11],
//     [21, 22, 22, 21],
//     [31, 32, 32, 31],
//     [41, 42, 42, 41],
//   ]

function getMirrorMatrix(array $array) // hexlet
{
    $size = sizeof($array);
    $mirrorArray = [];

    for ($i = 0; $i < $size; $i ++) {
        for ($j = 0; $j < $size / 2; $j ++) {
            $mirrorArray[$i][$j] = $array[$i][$j];
            $mirrorArray[$i][$size - $j - 1] = $array[$i][$j];
        }
    }

    return $mirrorArray;
}


/*
ДНК и РНК это последовательности нуклеотидов.
Четыре нуклеотида в ДНК это аденин (A), цитозин (C), гуанин (G) и тимин (T).
Четыре нуклеотида в РНК это аденин (A), цитозин (C), гуанин (G) и урацил (U).
Цепь РНК составляется на основе цепи ДНК последовательной заменой каждого нуклеотида:
G -> C
C -> G
T -> A
A -> U

Напишите функцию toRna, которая принимает на вход цепь ДНК и возвращает соответствующую цепь РНК (совершает транскрипцию РНК).
*/
toRna('ACGTGGTCTTAA'); // → 'UGCACCAGAAUU'

function toRna(String $nucleotide) 
{
    $map = [
        'G' => 'C',
        'C' => 'G',
        'T' => 'A',
        'A' => 'U',
    ];

    $length = strlen($nucleotide);
    $result = [];

    for ($i = 0; $i < $length; $i++) {
        $result[] = $map[$nucleotide[$i]];
    }

    return implode('', $result);
}


/*
Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов, имеющая треугольную форму. В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел. Строки треугольника симметричны относительно вертикальной оси.

0:      1
1:     1 1
2:    1 2 1
3:   1 3 3 1
4:  1 4 6 4 1

Напишите функцию generate, которая возвращает указанную строку треугольника паскаля в виде массива
Пример:
*/
generate(1); // → [1, 1]
generate(4); // → [1, 4, 6, 4, 1]

function generate(Int $rowNumber) // hexlet
{
	$currentRow = [1];
    
    for ($i = 0; $i < $rowNumber; $i++) {      
        $newRow = [];
        
        for ($j = 0; $j <= $rowNumber; $j++) {
            $first = isset($currentRow[$j - 1]) ? $currentRow[$j - 1] : 0;
            $second = isset($currentRow[$j]) ? $currentRow[$j] : 0;
            $newRow[$j] = $first + $second;
        }

        $currentRow = $newRow;
    }

    return $currentRow;
}


/*
В данном упражнении необходимо реализовать стековую машину, то есть алгоритм, проводящий вычисления по обратной польской записи.

Обратная польская нотация или постфиксная нотация — форма записи математических и логических выражений, в которой операнды расположены перед знаками операций. Выражение читается слева направо. Когда в выражении встречается знак операции, выполняется соответствующая операция над двумя ближайшими операндами, находящимися слева от знака операции. Результат операции заменяет в выражении последовательность её операндов и знак, после чего выражение вычисляется дальше по тому же правилу. Таким образом, результатом вычисления всего выражения становится результат последней вычисленной операции.

Например, выражение (1 + 2) * 4 + 3 в постфиксной нотации будет выглядеть так: 1 2 + 4 * 3 +, а результат вычисления: 15. Другой пример - выражение: 7 - 2 * 3, в постфиксной нотации: 7 2 3 * -, результат: 1.

Реализуйте функцию calcInPolishNotation, которая принимает массив, каждый элемент которого содержит число или знак операции (+, -, *, /). Функция должна вернуть результат вычисления по обратной польской записи.
*/

calcInPolishNotation([1, 2, '+', 4, '*', 3, '+']); // → 15
calcInPolishNotation([7, 2, 3, '*', '-']); // → 1



function calcInPolishNotation(Array $expr)
{
    $stack = [];
    foreach ($expr as $val) {
        if (is_int($val)) {
            array_push($stack, $val);
        } else {
           $endElemDel = array_pop($stack);
           $indexLastElem = sizeof($stack) - 1;
           switch ($val) {
                case '*':
                    $stack[$indexLastElem] *= $endElemDel;
                    break; 
                case '/':
                    $stack[$indexLastElem] /= $endElemDel;
                    break;
                case '+':
                    $stack[$indexLastElem] += $endElemDel;
                    break;
                case '-':
                    $stack[$indexLastElem] -= $endElemDel;
                    break;        
            }
        }
    }   
    return $stack[0];
}




>>>>>  Функции <<<<<<<

// Ранее, я показывал пример того, как в PHP работают с современными фреймворками:

use \Psr\Http\Message\ServerRequestInterface as Request;
use \Psr\Http\Message\ResponseInterface as Response;

require 'vendor/autoload.php';

$app = new \Slim\App;
$app->get('/hello/{name}', function (Request $request, Response $response, array $args) {
    $name = $args['name'];
    $response->getBody()->write("Hello, $name");

    return $response;
});
$app->run();

// В этом коде еще много новых синтаксических конструкций, но я хочу заострить внимание только на одной. Обратите внимание на странное определение функции. Во-первых, у нее нет имени, а во-вторых, функция определяется в том месте, куда должен передаваться второй параметр функции get. Это так называемая анонимная или лямбда функция. Лямбда функции в PHP являются объектами первого рода. В свою очередь, функция get представляет из себя функцию высшего порядка.

/*
Основные понятия данного курса:
 * Детерминированность
 * Побочные эффекты
 * Splat operator
 * Объекты первого рода
 * Функции высшего порядка (map/filter/reduce)
 * Функциональное программирование

Не все из перечисленных тем и возможностей используются в повседневной жизни PHP разработчика (в других языках может быть совсем по-другому), но знать про них нужно. Во-первых, подходы, разбираемые в этом курсе, не являются специфичными для PHP. Зная их, вы гораздо легче сможете переключаться на другие языки. Особенно это касается JS, в котором используется сильно отличающийся от PHP стиль программирования. Во-вторых, работа с функциями, сильно прокачивает общий уровень разработчика.
*/



>>>>>  Чистые функции <<<<<<<

# Детерминированность

// Стандартная функция rand, вызванная без аргументов, возвращает некоторое случайное число.
rand(); // => 151273074
rand(); // => 1129177627

// Функция нужная и полезная, но неудобная в отладке и тестировании. Связано это с тем, что для одних и тех же входных аргументов (отсутствие аргументов так же попадает под это понятие), она может возвращать разные значения. Функции с таким поведением называются недетерминированными. К ним, в том числе, относятся функции, оперирующие системным временем.

// возвращает текущий год
date('Y'); // => 2018

/*
Хотя прямо сейчас повторный запуск вернет точно такое же значение, через год оно уже будет другим (2019). То есть недетерминированной функция считается в том случае, когда она ведет себя так хотя бы единожды.

Детерминированные функции, напротив, ведут себя предсказуемо. Для одних и тех же входных данных, они всегда выдают один и тот же результат. Именно такими являются функции в математике. Для одного и того же x результат работы функции y = f(x) будет один и тот же. Интересно то, что, например, функция print_r детерминированная. Дело в том, что она всегда возвращает одно и тоже значение для любых входных данных. Это значение true, а не то, что печатается на экран, как можно было бы подумать. Печать на экран - побочный эффект, о нем мы поговорим чуть позже.
*/

var_dump(print_r('lala')); // => bool(true)

/*
Понятие детерминированности играет огромную роль в администрировании, в задачах связанных с программной настройкой серверов (configuration managmenet), выкладкой ПО и обновлениями. Ключевые слова: docker, immutable infrastructure, ansible.

Функция становится недетерминированной и в том случае, если она обращается не только к своим аргументам, но и некоторым внешним данным, например глобальным переменным, переменным окружения и так далее. Так происходит потому, что внешние данные могут измениться, и функция начнет выдавать другой результат даже если в нее передаются одни и те же аргументы
*/

function getCurrentShell()
{
    // Функция getenv обращается к указанной переменной окружения
    return getenv('SHELL'); // => /bin/bash
}

# Побочные эффекты (side effects)

// Вторая ключевая характеристика функций - наличие побочных эффектов. Побочным эффектом называют любые действия изменяющие среду выполнения. К ним относятся любые файловые операции, такие как запись в файл, отправка или прием данных по сети, даже вывод в консоль или чтение файла. Кроме того, побочными эффектами считаются обращения к глобальным переменным (как на чтение, так и запись) и изменение входных аргументов в случае, когда они передаются по ссылке. Вызов функции с побочными эффектами также считается побочным эффектом.

function sayHiTo($name)
{
    print_r("Hi, {$name}");
}

// С другой стороны, любые вычислительные операции не являются побочными эффектами. Например, функция, суммирующая два переданных аргументами числа.

function sum($num1, $num2)
{
    return $num1 + $num2;
}


// Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам.

print_r(2 ** 5);

/*
Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет тестирование и отладку. Приводит к возникновению огромного числа ошибок (только при работе с файлами количество возможных ошибок измеряется сотней, начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла). Для их предотвращения код обрастает большим числом проверок и защитных механизмов.

Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе, побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце.

Например, программа, которая конвертирует файл из текстового формата в pdf, в идеале выполняет ровно два побочных эффекта:

 * Читает файл в самом начале работе программы.
 * Записывает результат работы программы в новый файл.

Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Следовательно, побочные эффекты будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.

Инкремент и декремент — единственные базовые арифметические операции в PHP, которые обладают побочными эффектами (изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотловимым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет), а в JS стандарты кодирования предписывают их не использовать.
*/

# Чистые функции

/*
Идеальная функция с точки зрения удобства работы с ней называется чистой (pure). Чистая функция — это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведет себя предсказуемо. Такие функции на 100% соответствуют своим математическим аналогам и могут рассматриваться как математические функции.

Чистые функции обладают рядом ключевых достоинств:

 * Их крайне просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
 * Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
 * Их легко комбинировать получая новое поведение без необходимости переписывать программу.

В хорошо спроектированных программах, побочные эффекты стараются изолировать в небольшой части приложения так, чтобы большая часть кода была чистой.
*/


// Реализуйте функцию sayPrimeOrNot, которая проверяет переданное число на простоту и печатает на экран yes или no.

sayPrimeOrNot(5); // => yes
sayPrimeOrNot(4); // => no


function isPrime(int $num)
{
    for ($i = 2; $i < $num; $i++) {
        if ($num % $i == 0) {
            return false;
        }
    }

    return true;
}

function sayPrimeOrNot($num)
{
    $text = isPrime($num) ? 'yes' : 'no';
    print_r($text);
}




>>>>>  Разделение команд и запросов <<<<<<<

/*
Command-query Separation (CQS) - принцип программирования, изобретенный Бертандом Майером, создателем языка Eiffel.

Он утвеждает, что каждая функция является либо командой которая выполняет действие (action), либо запрос (query) который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.
*/

# Команда

// Возвращает true или false как результат своего выполнения
save($user);


/*
Согласно принципу CQS, функция save является командой. Единственное что она может возвращать (опять же согласно принципу) - успешность своего выполнения, то есть true или false, либо null, как, например, в случае с print_r. Возврат этой функцией любых осмысленных данных, рассматривается как нарушение CQS. Однако, стоит сказать, что существуют ситуации в которых невозможно соблюсти этот принцип. Например открытие файла на запись возвращает файловый дескриптор (идентификатор через который происходят манипуляции с файлом).

Отделение команд от запросов тесно связано с идеями, описанными в уроке про чистые функции. Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторому выполнению действия (хотя их и можно сделать детерминированными, но как правило, такой код скрывает логические ошибки). Следовательно выделение запроса (возврата данных) из команды в отдельную функцию, помогает разделить более чистый код от не чистого. Запросы, как мы увидим позже, можно выполнять множество раз не боясь чего-либо сломать.
*/

$file = fopen('/etc/hosts', 'r');


# Запрос

// Возвращает true или false
isAdmin($user);

/*
Функция isAdmin - предикат, типичный запрос (query) или, можно даже сказать, вопрос, который звучит так "Пользователь администратор?" Такая функция, с точки зрения CQS, не может изменять состояние системы, например, поменять дату проверки на администоратора внутри пользователя или даже сделать пользователя администратором. Это противоречит не только CQS, но и здравому смыслу. В отличие от предыдущего примера, true и false в случае предкатов, это не успешность выполнения функции, а ответ на заданный вопрос. CQS имеет альтернативную формулировку, которая отлично характеризует код выше: "Задавая вопрос, не изменяй ответ". К запросам относятся и любые вычисления.
*/

$max = max([1, 30, 4]);


/*
Этот код не создает никаких побочных эффектов и детерминирован. Его можно вызывать сколько угодно раз без риска получить ошибку или неверный результат.

Отсутствие изменения в вопросах, очень важный принцип, который нужно соблюдать всегда. Даже на интуитивном уровне, ни один человек не ожидает, что проверка isAdmin или вычисление максимального числа в массиве, может выполнить какое-то деструктивное действие. С другой стороны, на практике, такой код иногда попадается и теперь вы знаете как правильно его исправить.
*/



>>>>> Упаковка аргументов <<<<<<<

// Сигнатура функции array_merge в документации определяется так:

array array_merge ( array $array1 [, array $... ] )

// Она говорит нам о том, что в array_merge можно передать любое количество массивов:

array_merge([1]);
# => Array
# (
#     [0] => 1
# )
array_merge([1], [1]);
# => Array
# (
#     [0] => 1
#     [1] => 1
# )
array_merge([1], [1], [3, 4]);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )
array_merge([1], [1], [3, 4], []);
# => Array
# (
#     [0] => 1
#     [1] => 1
#     [2] => 3
#     [3] => 4
# )

// С точки зрения вызова - ничего необычного, просто разное число аргументов. А вот определение функции с переменным числом аргументов выглядит необычно и использует незнакомый для нас синтаксис:

function sum(...$numbers)
{
    return array_sum($numbers);
}

echo sum(9, 4); // => 13
echo sum(-3, 0, 3, 1); // => 1

/*
Три точки представляют собой Splat Operator. В PHP на текущий момент он может использоваться только в определениях и вызовах функций (в других языках его можно использовать значительно шире, в том числе при дестракчиринге). Основная сложность для понимания состоит в том, что Splat Operator выполняет различные действия в зависимости от того, где он применяется. В определении функции он выполняет "упаковку" параметров, а при вызове - наоборот, "распаковку". Про упаковку параметров будем говорить в этом уроке. В следующем же уроке рассмотрим Splat Operator в роли распаковщика.

Итак, назначение Splat Operator в определении функции состоит в том, чтобы собрать в массив все переданные аргументы. Если в функцию не передается ни одного аргумента, то массив будет пустым.
*/

echo sum(); // => 0

// Обратите внимание на то, что этому оператору не важен тип аргументов, они все станут элементами массива, даже если мы передаем на вход функции массивы.

function show(...$arguments)
{
    print_r($arguments);
}

show([]);
# Array
# (
#     [0] => Array
#         (
#         )
#
# )

show([1, 3], [], 3);
# => Array
# (
#     [0] => Array
#         (
#             [0] => 1
#             [1] => 3
#         )
#
#     [1] => Array
#         (
#         )
#
#     [2] => 3
# )

// Теперь взглянем на сигнатуру array_merge еще раз:

array array_merge ( array $array1 [, array $... ] )

// Видно, что функция array_merge ждет на вход как минимум один массив, опциональны только следующие. Такого поведения можно добиться следующим кодом:

function sum($a, ...$numbers)
{
    return $a + array_sum($numbers);
}

echo sum();
// => PHP Fatal error:  Uncaught ArgumentCountError: Too few arguments to function sum(), 0 passed

echo sum(10); // => 10
echo sum(10, 4); // => 14
echo sum(8, 10, 4); // => 22

// Тоже можно сделать и для двух аргументов:

function sum($a, $b, ...$numbers)
{
    # ...
}

// Эту идею можно продолжать и дальше, делая обязательными то количество аргументов, которое требуется. Единственное ограничение: Splat Operator может быть использован только для последнего аргумента. То есть такой код синтаксически не верен:

function sum(...$numbers, $a)
{
    # ...
}

// и такой тоже:

function sum($a, ...$numbers, $a)
{
    # ...
}


// Реализуйте функцию average, которая возвращает среднее арифметическое всех переданных аргументов. Функция принимает на вход от одного числа и больше.

average(0); // => 0
average(0, 10); // => 5
average(-3, 4, 2, 10); // => 3.25

function average($num1,...$numbers)
{
	return (array_sum($numbers) + $num1) / (sizeof($numbers) + 1);
}




>>>>> Распаковка аргументов <<<<<<<

// Splat Operator в вызовах функций синтаксически идентичен Splat Operator в определениях, но выполняет обратное действие:

$arrayOfArrays = [
    [1, 2],
    [2, 3]
];

array_merge(...$arrayOfArrays);
# => Array
# (
#     [0] => 1
#     [1] => 2
#     [2] => 2
#     [3] => 3
# )

// Другими словами, Splat Operator раскладывает массив на аргументы. Количество аргументов, полученных Splat Operator, равно количеству элементов массива. По сути код выше преобразуется в вызов:

array_merge($arrayOfArrays[0], $arrayOfArrays[1]); // array_merge([1, 2], [2, 3]);

// Как и в случае с определением функций, Splat Operator может использоваться совместно с позиционными аргументами:

array_merge([3], ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 1
#     [2] => 2
#     [3] => 2
#     [4] => 3
# )


// Тоже самое справедливо и для большего количества аргументов:

$array = [3, 2];
array_merge([3], $array, ...$arrayOfArrays);
# => Array
# (
#     [0] => 3
#     [1] => 3
#     [2] => 2
#     [3] => 1
#     [4] => 2
#     [5] => 2
#     [6] => 3
# )

// И точно так же должен всегда оказываться последним аргументом.

array_merge(...$arrayOfArrays, [3, 2]); // => Fatal error: Cannot use positional argument after argument unpacking

// В PHP Splat Operator применяется не каждый день, но иногда бывает нужен, если аргументы оказываются записаны в массив.


// Реализуйте функцию union, которая находит объединение всех переданных массивов. Функция принимает на вход от одного массива и больше. Ключи исходных массивов не сохраняются (т.е. все значения итогового массива заново индексируются: 0, 1, 2, ...).

union([3]); // => [3]
union([3, 2], [2, 2, 1]); // => [3, 2, 1]
union(['a', 3, false], [true, false, 3], [false, 5, 8]); // => ['a', 3, false, true, 5, 8]

function union($first,...$rest)
{
	return array_values(array_unique(array_merge($first, ...$rest)));
} 



>>>>> Полезные функции для работы с коллекциями <<<<<<<

/*
Стандартная библиотека в PHP небогата функциями для работы с коллекциями, строками или датами. Этот недостаток можно восполнить, подключив стороннюю библиотеку. Например, в мире JS, есть стандарт де-факто, без которого не обходится практически ни один проект - lodash (https://lodash.com/). В PHP нет единого устоявшегося решения, но есть пачка небольших, которые используются в разных проектах. 

Объектные:

    Collect https://github.com/tightenco/collect
    Stringy https://github.com/danielstjules/Stringy
    Carbon https://github.com/briannesbitt/Carbon

Использующие только функции:

    Funct https://github.com/phpfunct/funct
    Bottomline https://github.com/maciejczyzewski/bottomline

Скажу сразу, что необходимость использования такой библиотеки в реальной работе возникает практически сразу. Те, кто не знает про них, постоянно пишут велосипеды. Еще не так давно программисты в PHP создавали файлики с полезными функциями и таскали их из одного проекта в другой. Хорошо, что эти времена уже прошли и можно не тратить время на то, что уже делалось тысячу раз до нас. Однако, мы не сможем разобрать все возможные функции в рамках наших курсов. Кое-что рассмотрим, но в дальнейшем не забывайте периодически просматривать их на наличие чего-либо полезного.

Обратите внимание на документацию указанных библиотек. Зачастую они повторяют те функции, которые уже встроены в сам язык. Делается это по разным причинам. Вот некоторые из них:

 * Консистентность (согласованность). Функции делают для того, чтобы библиотека была полной.
 * Исправление ошибок PHP. Некоторые функции в PHP по историческим причинам иногда ведут себя неверно.
 * Улучшение. Другой порядок аргументов, расширенные возможности, убранные ограничения или просто понятное имя.
*/


// Итак, поехали. Библиотека Funct.

# Collections

/*
last

Такая простая и нужная функция почему-то отсутствует в самом PHP.
*/

Collection\last([1, 2, 3]); // => 3

/*
rest

Принимает на вход массив и возвращает новый массив, в котором отсутствует первый элемент исходного.
*/

Collection\rest([5, 4, 3, 2, 1]); // => [4, 3, 2, 1]


/*
without

Возвращает копию массива, из которого удалены все значения, переданные в функцию вторым и последующими параметрами.
*/

Collection\without([1, 2, 1, 0, 3, 1, 4], 0, 1); // => [2, 3, 4]


/*
flattenAll

"Выпрямляет" вложенный массив, делая его плоским.
*/

Collection\flattenAll(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', 'c', 'd']

/*
union

Находит объединение множеств.
*/

Collection\union([1, 2, 3], [101, 2, 1, 10], [2, 1]); // => [1, 2, 3, 101, 10]


/*
 findWhere($collection, $value)

Просматривает массив и возвращает первое значение, совпадающее по всем парам «ключ-значение», переданным вторым параметром.
*/

Collection\findWhere(
    [
        ['title' => 'Book of Fooos', 'author' => 'FooBar', 'year' => 1111],
        ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611],
        ['title' => 'The Tempest', 'author' => 'Shakespeare', 'year' => 1611],
        ['title' => 'Book of Foos Barrrs', 'author' => 'FooBar', 'year' => 2222],
        ['title' => 'Still foooing', 'author' => 'FooBar', 'year' => 3333],
        ['title' => 'Happy Foo', 'author' => 'FooBar', 'year' => 4444],
    ],
    ['author' => 'Shakespeare', 'year' => 1611]
); // => ['title' => 'Cymbeline', 'author' => 'Shakespeare', 'year' => 1611]



# Strings

/*
camelize

Принимает на вход строку и возвращает ее версию, записанную в camelCase нотации.
*/

Strings\camelize('data_rate'); //'dataRate'
Strings\camelize('background-color'); //'backgroundColor'
Strings\camelize('-moz-something'); //'MozSomething'
Strings\camelize('_car_speed_'); //'CarSpeed'
Strings\camelize('yes_we_can'); //'yesWeCan

/*
contains

Проверяет, включает ли строчка подстроку.
*/

Strings\contains('PHP is one of the best languages!', 'one'); // true

/*
endsWith

Проверяет, оканчивается ли строчка на подстроку.

*/

Strings\endsWith("hello jon", 'jon'); // => true


// функции для работы с массивами: http://php.net/manual/ru/ref.array.php


/*
Реализуйте функцию getSentenceType, которая принимает на вход текст, определяет его тип и возвращает наружу его название. Тип предложения определяется по последнему символу в тексте.

    ? - question
    ! - shouting
    Все остальное - common

Если передана пустая строчка, то функция должна вернуть null.
*/

getSentenceType(''); // => null;
getSentenceType('what?'); // => question
getSentenceType('wow!'); // => shouting
getSentenceType('haha'); // => common

$ composer require funct/funct // in Terminal - installation library 'funct'

function getSentenceType($sentence)
{
    if ($sentence === '') {
        return null;
    }

    $types = [
        '?' => 'question',
        '!' => 'shouting'
    ];
    $symbol = \Funct\Strings\right($sentence, 1);
    return array_key_exists($symbol, $types) ? $types[$symbol] : 'common';
}




>>>>> Объекты первого класса  <<<<<<<

/*
В языках программирования существует понятие «объекты первого рода (или класса)». Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным. К таким элементам относятся любые данные, например числа, строки, массивы или логические значения. Переменная под это понятие не попадает, объектом первого рода считаются те данные, которые лежат в переменной.
*/

$num = 5; // 5 - объект первого рода

$result = pow($num, 2) // 2 - объект первого рода, $result, $num - содержимое переменных объекты первого рода

// Описанное выше вы проделывали множество раз, и эту тему можно было бы не поднимать, если бы не одно «но». Функции тоже могут быть объектами первого рода:

$func = function () {
  echo "For hands of gold are always cold. But a woman's hands are warm";
};

$func();

// Мы привыкли к такому определению функций:

function greeting()
{
    // ...
}

// У функции есть имя, которое указывается после ключевого слова function, а сама конструкция является инструкцией (кстати, поэтому в конце нет точки запятой). Мы не можем написать так:

// переменная содержащая определение функции?
$fn = function greeting()
{
    // ...
}

// Так как определение функции - инструкция, то оно не может подставляться в те места, где ожидаются выражения. Присваивание как раз подразумевает то, что в правой части находится именно выражение. Соответственно, такой код падает с ошибкой. А следующий код уже работает.

$func = function () {
    echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Даже не вникая в синтаксис можно делать вывод о том, что конструкция справа от «равно» - выражение. И это выражение порождает функцию. В PHP подобные функции называют анонимными, потому что у них нет имени. Глядя на код выше нужно понимать, что определение функции и ее присваивание переменной - две разных операции. Чистое определение выглядит так:

function () {
    echo "For hands of gold are always cold. But a woman's hands are warm";
};

// Очень похоже на обычную функцию за исключением отсутствия имени. Правда, есть еще и стилевые отличия, закрепленные стандартом PSR-2. В других языках анонимные функции нередко называют лямбда-функциями. В принципе, и в PHP их иногда зовут также.

$func();

/*
Имя переменной можно выбирать произвольно, в этом смысле анонимные функции никак не влияют на ситуацию. Более того, в отличие от именованных функций, которые будучи единожды созданными - никуда не изчезают в процессе жизни программы, анонимные функции постоянно создаются и пропадают вместе с переменными, в которые они записаны. Другими словами, анонимные функции всегда локальны относительно контекста и доступны там, где они были созданы если не предпринимать специальных мер по их возврату.

Анонимные функции подобно именованным могут принимать аргументы. В этом отношении поведение абсолютно идентично. Всё, что мы изучали до этого момента для именованных функций один в один работает и для анонимных.
*/

$sum = function ($a, $b) {
    return $a + $b;
}; // Определение анонимной функции должно заканчиваться символом ;, так как это выражение.

$sum(1, 4); // => 5

// А раз анонимная функция — выражение, мы можем определять ее в любом месте программы, допускающем использование выражений, например в теле другой функции!

function sum($a, $b)
{
    // определяем анонимную функцию
    $sum = function ($a, $b) {
        return $a + $b;
    };
    // вызываем анонимную функцию и возвращаем результат ее выполнения
    return $sum($a, $b);
}

sum(1, 4); // => 5

/*
Главное в коде выше не забыть поставить return и помнить, что $a и $b снаружи анонимной функции не связаны с переменными, имеющими те же имена внутри анонимной функции.

Думаю что сейчас в вашей голове возник вопрос «зачем все это? жили же как-то раньше и сейчас проживем». Анонимные функции появились в PHP не сразу, но все же появились. Их использование значительно повышает выразительные возможности языка, и в этом вы скоро убедитесь. Если же взять JS, то там анонимные функции составляют костяк любой программы. Функции, создающие функции, возвращающие функции и принимающие функции как аргументы - основной способ разрабатывать в JS.
*/

$square = function($num) {
	return $num ** 2;
};

$sumOfSquares = function($num1, $num2) use ($square) {
	return $squares($num1) + $squares($num2);
};


# Передача обычных функций

// Несмотря на то, что обычные функции в PHP не являются объектами первого рода, PHP может имитировать соответствующее поведение с помощью строк. Достаточно записать имя функции в переменную и вызвать ее.

$fn = 'strlen';
print_r($fn('clojure for brave')); // => 17

// Точно так же можно осуществить "передачу" функции в функцию.

function call(string $fn, $argument)
{
    return $fn($argument);
}

$result = call('strlen', 'haskell is power!');
print_r($result); // => 16


// Реализуйте анонимную функцию, которая принимает на вход строку и возвращает ее последний символ (или null если строка пустая). Запишите созданную функцию в переменную $last.

function run(string $text)
{
    $last = function (string $text) {
        if ($text === '') {
            return null;
        }
        return $text[strlen($text) - 1];
    };

    return $last($text);
}

// Анонимные функции: http://php.net/manual/ru/functions.anonymous.php




>>>>>  Функции высшего порядка  <<<<<<<

/*
Пока мы рассмотрели только одну возможность объектов первого рода применительно к функциям — присвоение переменной. Самое интересное начинается, когда мы передаем одни функции в другие функции.

За примерами далеко ходить не придется. Вспомним сортировку. В PHP есть функция sort, которая принимает на вход массив и сортирует его. Казалось бы, все отлично, и не о чем больше мечтать, но давайте вообразим себе ситуацию: на вход в программу приходит список пользователей, который нужно отсортировать по возрасту и вывести на экран.
*/

$users = [
    ['name' => 'Igor', 'age' => 19],
    ['name' => 'Danil', 'age' => 1],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];

/*
При таких условиях функция sort становится абсолютно бесполезной, потому что она может сортировать только списки примитивных типов данных. Но выше я описал только лишь одну из тысяч возможных ситуаций. Мы можем захотеть сортировать по любому параметру (или даже по набору параметров) и в любом порядке. Сортировки нужны часто, и многие из них довольно сложны. Худшее, что можно начать делать — реализовывать функцию sort под каждую ситуацию. Так что же делать? Если покопаться в документации PHP, то можно обнаружить функцию usort. Ее определение звучит так:

Сортирует массив по значениям, используя пользовательскую функцию для сравнения элементов
*/ 

bool usort ( array &$array , callable $value_compare_func )

/*
Эта функция сортирует элементы массива, используя для сравнения значений callback-функцию, предоставленную пользователем. Используйте эту функцию, если вам нужно отсортировать массив по какому-нибудь необычному признаку. Слово callback означает то, что наша задача — передать функцию (но не вызывать!), а вызывать ее будет функция usort.

Общая идея состоит в том, что нам не нужно реализовывать алгоритм сортировки каждый раз для каждой ситуации, ведь он не меняется. Все, что меняется — элементы, которые сравниваются между собой в процессе сортировки. И функция usort делегирует взаимодействие с этими элементами нам посредством анонимной функции.
*/

$users = [
  ['name' => 'Igor', 'age' => 19],
  ['name' => 'Danil', 'age' => 1],
  ['name' => 'Vovan', 'age' => 4],
  ['name' => 'Matvey', 'age' => 16],
];

usort($users, function ($a, $b) {
    if ($a['age'] == $b['age']) {
        return 0;
    }
    return $a['age'] > $b['age'] ? 1 : -1;
});

print_r($users);
// => [
//      ['name' => 'Danil', 'age' => 1],
//      ['name' => 'Vovan', 'age' => 4],
//      ['name' => 'Matvey', 'age' => 16],
//      ['name' => 'Igor', 'age' => 19],
//    ];

/*
Если элементы равны, то вы должны вернуть 0, если первый элемент больше второго, то считается, что они отсортированы правильно, и вы должны вернуть 1, иначе возвращается -1, а usort производит их сортировку.

Из кода выше видно, что внутри функции сравнение идет по свойству age переданных пользователей. Нетрудно догадаться, что эта функция вызывается внутри usort множество раз (а именно на каждое сравнение). Как только она начнет возвращать 1 для каждой пары элементов — сортировка завершена.

Функция usort относится к так называемым функциям высшего порядка (high order functions). Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают все сразу. Такие функции, как правило, реализуют некий обобщенный алгоритм (например, сортировку), а ключевую часть логики делегируют вам через анонимную функцию. Главный плюс от применения таких функций — серьезное повышение коэффициента повторного использования кода.
*/

function say(callable $fn) {
    echo $fn();
}

say(function () {
    return 'hi!';
}); // => hi!

/*
Функция say делает вызов функции, находящейся внутри переменной $fn. В нашем примере функция возвращает строку, которая тут же выводится на экран.

Функции высшего порядка настолько удобны в большинстве языков, что практически целиком могут заменить использование тех же циклов. Например, канонический код на JS выглядит так:
*/

const getJsFiles = dir => fs.readdirSync(dir)
  .filter(file => file.endsWith('js'))
  .map(file => path.resolve(dir, file));

/*
В этом коде присутствует 2 функции высшего порядка (filter и map), 3 анонимные функции и два прохода (это делают функции высшего порядка) по содержимому директории dir. Подобный код на PHP, с циклами и без, займет примерно в 4 раза больше строк даже при использовании специальных библиотек, упрощающих использование функций высшего порядка (это те же библиотеки, которые мы рассматривали в курсе). Связано это с многословностью синтаксиса PHP.

В следующих уроках мы рассмотрим три самые главные функции высшего порядка, которыми можно решать практически любые задачи. Две из них используются в примере выше, это map и filter, а третья — reduce (ее еще называют fold). Они все доступны в стандартной библиотеке PHP.
*/ 


// Реализуйте функцию takeOldest, которая принимает на вход список пользователей и возвращает самых взрослых. Количество возвращаемых пользователей задается вторым параметром, который по-умолчанию равен единице.

$users = [
    ['name' => 'Tirion', 'birthday' => '1988-11-19'],
    ['name' => 'Sam', 'birthday' => '1999-11-22'],
    ['name' => 'Rob', 'birthday' => '1975-01-11'],
    ['name' => 'Sansa', 'birthday' => '2001-03-20'],
    ['name' => 'Tisha', 'birthday' => '1992-02-27']
];

takeOldest($users);
# => Array (
#   ['name' => 'Rob', 'birthday' => '1975-01-11']
# )

// Для преобразования даты в unixtimetamp используйте функцию strtotime

// Описание:
firstN($collection, $n = 1)
Collection\firstN([1, 2, 3]); // => [1]
Collection\firstN([1, 2, 3], 2); // => [1, 2]


function takeOldest(array $users, int $count = 1)
{
    usort($users, function ($user1, $user2) {
        return strtotime($user1['birthday']) >= strtotime($user2['birthday']) ? 1 : -1; // strtotime - преобразует текстовое представление даты на английском языке в метку времени
    });

    return firstN($users, $count);
}



>>>>>  Отображение (map)  <<<<<<<
 
/*
Первая функция из золотой тройки называется map. Ее название переводится на русский как "отображение", что точно отражает суть выполняемой операции. Если в программировании говорят об отображении, то всегда подразумевают функцию map. Ее можно найти практически в любом языке, и везде это будет одна и та же операция. В PHP она имеет немного отличающееся название - array_map.

Попробуем прийти к этой функции через примеры. Возьмем список пользователей из предыдущего урока и извлечем из него имена всех пользователей.
*/

$users = [
    ['name' => 'Igor', 'age' => 19], // $v = ['name' => 'Igor', 'age' => 19]
    ['name' => 'Danil', 'age' => 1],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];

$result = [];
foreach ($users as ['name' => $name]) {
    $result[] = $name;
}
print_r($result); // => ['Igor', 'Danil', 'Vovan', 'Matvey']


/*
$points = [ [4, 3], [0, -3] ];

foreach ($points as [$x, $y]) {
    print_r([$x, $y]);
}
*/

// Здесь мы видим обычную агрегацию с использованием foreach. А что, если нам понадобится извлечь возраст? Повторяем:

$result = [];
foreach ($users as ['age' => $age]) { // destructuring
    $result[] = $age;
}
print_r($result); // => [19, 1, 4, 16]

/*
В примерах выше легко увидеть закономерность. Выполняется один и тот же проход по циклу, и результат собирается в переменную $result. Единственное, что меняется — значение, которое мы извлекаем из элементов исходного массива. Именно этот паттерн называется отображением.

Теперь посмотрим как выполнить ту же самую операцию, используя array_map:
*/

$names = array_map(function ($user) {
    return $user['name'];
}, $users);

print_r($names); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

/*
array_map принимает первым параметром анонимную функцию и вторым — коллекцию, которая будет отображаться. Дальше внутри себя array_map делает перебор элементов переданной коллекции и для каждого элемента вызывает ту самую анонимную функцию. На вход этой функции передается элемент исходного массива, а ее результат записывается в новый массив, который и возвращается наружу. Некоторые замечания относительно функции array_map (они относятся в принципе к операции отображения):

 * Возвращаемый массив всегда такого же, размера как и исходный. array_map "отображает" каждый элемент исходного массива в элемент возвращаемого.
 * Внутри анонимной функции можно выполнять любые вычисления, а не только возвращать часть исходного элемента.
 * array_map полностью скрывает от нас наличие обхода и процесс сборки нового массива.
Типичный пример, который любят приводить в документации функции к map разных языков программирования, применение некоторой арифметической операции к каждому элементу коллекции.
*/

$numbers = [5, 2, 3];

$newNumbers = array_map(function ($number) {
    // возводим в квадрат каждое число
    return $number ** 2;
}, $numbers);

print_r($newNumbers); // => [25, 4, 9]


# Реализация

function myMap(callable $callback, $coll)
{
    $result = [];
    foreach ($coll as $item) {
        $result[] = $callback($item);
    }
    return $result;
}

/*
Главное отличие кода функции myMap от ручного обхода массива заключается в том, что функция myMap не знает, что нужно сделать с каждым элементом массива, поэтому она принимает первым аргументом функцию, которую вызывает для каждого элемента исходного массива, а результат вызова записывается в выходной массив. Чем будет этот результат, функция myMap не знает, и ей этого знать не нужно. Ответственность за обработку лежит на пользователях.


Реализуйте функцию getChildren, которая принимает на вход список пользователей и возвращает плоский список их детей. Дети каждого пользователя хранятся в виде массива в ключе children
*/

$users = [
    ['name' => 'Tirion', 'children' => [
        ['name' => 'Mira', 'birdhday' => '1983-03-23']
    ]],
    ['name' => 'Bronn', 'children' => []],
    ['name' => 'Sam', 'children' => [
        ['name' => 'Aria', 'birdhday' => '2012-11-03'],
        ['name' => 'Keit', 'birdhday' => '1933-05-14']
    ]],
    ['name' => 'Rob', 'children' => [
        ['name' => 'Tisha', 'birdhday' => '2012-11-03']
    ]],
];

getChildren($users);
// [
//     ['name' => 'Mira', 'birdhday' => '1983-03-23'],
//     ['name' => 'Aria', 'birdhday' => '2012-11-03'],
//     ['name' => 'Keit', 'birdhday' => '1933-05-14'],
//     ['name' => 'Tisha', 'birdhday' => '2012-11-03']
// ]


// Описание:
Collection\flatten(['a', ['b', ['c', ['d']]]]); // => ['a', 'b', ['c', ['d']]]
Collection\flatten(['a', ['b', ['c', ['d']]]], 2); // => ['a', 'b', 'c', ['d']]
Collection\flatten(['a', ['b', ['c', ['d']]]], 3); // => ['a', 'b', 'c', 'd']



function getChildren(array $users)
{
    $children = array_map(function ($user) {
        return $user['children'];
    }, $users);

    return flatten($children);
}

// без flatten:
[ [['name' => 'Mira','birdhday' => 1983-03-23]], [[]], [[['name' => 'Aria', 'birdhday' => '2012-11-03']]], [['name' => 'Tisha', 'birdhday' => '2012-11-03']] ]




>>>>>  Фильтрация (filter) <<<<<<<


// Следующая операция называется "фильтрация" и выполняется она в PHP с помощью функции array_filter (в других языках ее называют просто filter или select). Операция "фильтрация", по отношению к коллекции, означает что мы удаляем из нее нежелательные элементы.


$users = [
    ['name' => 'Igor', 'age' => 19],
    ['name' => 'Danil', 'age' => 1],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];

$result = [];
foreach ($users as $user) {
    if ($user['age'] > 10) {
        $result[] = $user;
    }
}
print_r($result);
// => Array
// (
//     [0] => Array
//         (
//             [name] => Igor
//             [age] => 19
//         )
//
//     [1] => Array
//         (
//             [name] => Matvey
//             [age] => 16
//         )
//
// )


/*
Фильтрация встречается так же часто как отображение, а возможно и чаще. Общая схема кода при фильтрации практически один в один как и в отображении, кроме пары ключевых моментов:

 * Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано) либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошел.
 * Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил список пользователей, то список пользователей будет и на выходе.

Теперь посмотрим как выглядит фильтрация при использовании функции высшего порядка array_filter.
*/

// Порядок аргументов обратный. Сначала коллекция, затем функция.
$users = array_filter($users, function ($user) {
    return $user['age'] > 10;
});

// В отличие от array_map, функция, которая передается в array_filter должна быть предикатом. То есть ее задача вернуть либо true либо false для каждого элемента коллекции. Ее возврат никак не используется, он всего лишь говорит о том, включать ли текущий элемент в итоговый массив либо нет. Новички часто делают ошибку на этом этапе и начинают возвращать из фильтра то, что они бы хотели увидеть в результирующем массиве (для этого надо применять array_map).

#Реализация

function myFilter($coll, callable $callback)
{
    $result = [];
    foreach ($coll as $key => $item) {
        if ($callback($item)) { // Предикат используется только для проверки
            $result[$key] = $item; // В результат всегда добавляется элемент исходной коллекции
        }
    }
    return $result;
}

// Обратите внимание на то, что array_filter сохраняет ключи. При работе с индексированными массивами такое поведение нежелательно, поэтому придется использовать функцию !!! array_values для сброса порядка.




// Реализуйте функцию getGirlFriends, которая принимает на вход список пользователей и возвращает плоский список подруг всех пользователей (без сохранения ключей). Друзья каждого пользователя хранятся в виде массива в ключе friends. Пол доступен по ключу gender и может принимать значения male или female.

$users = [
    ['name' => 'Tirion', 'friends' => [
        ['name' => 'Mira', 'gender' => 'female'],
        ['name' => 'Ramsey', 'gender' => 'male']
    ]],
    ['name' => 'Bronn', 'friends' => []],
    ['name' => 'Sam', 'friends' => [
        ['name' => 'Aria', 'gender' => 'female'],
        ['name' => 'Keit', 'gender' => 'female']
    ]],
    ['name' => 'Rob', 'friends' => [
        ['name' => 'Taywin', 'gender' => 'male']
    ]],
];

getGirlFriends($users);
# => Array (
#      ['name' => 'Mira', 'gender' => 'female'],
#      ['name' => 'Aria', 'gender' => 'female'],
#      ['name' => 'Keit', 'gender' => 'female']
# )


function getGirlfriends(array $users)
{
    $friends = array_map(function ($user) {
        return $user['friends'];
    }, $users);

    $friends = flatten($friends);

    $girlfriends = array_filter($friends, function ($user) {
        return $user['gender'] === 'female';
    });
    return array_values($girlfriends);
}




>>>>>   Агрегация (reduce)  <<<<<<<

/*
Последняя функция из нашей тройки - array_reduce используется для агрегации (название в других языках accumulate, fold или, по-русски, "свертка"). Она устроена немного сложнее, чем map и filter, но, в целом, сохраняет общий подход с передачей функции.

Как обычно, начнем с примера на циклах. Реализуем код, находящий самого взрослого пользователя.
*/

$users = [
    ['name' => 'Igor', 'age' => 19],
    ['name' => 'Danil', 'age' => 4],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];

$oldest = $users[0];
foreach ($users as $user) {
    if ($user['age'] > $oldest['age']) {
        $oldest = $user;
    }
}

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может быть любой тип данных, как примитивный так и составной, например, массив. Кроме того, агрегация нередко подразумевает инициализацию начальным значением. В примере выше она выполняется на строчке $oldest = $users[0];.

Посмотрим еще один пример агрегации: группировка имен пользователей по возрасту.
*/

$users = [
    ['name' => 'Igor', 'age' => 19],
    ['name' => 'Danil', 'age' => 4],
    ['name' => 'Vovan', 'age' => 4],
    ['name' => 'Matvey', 'age' => 16],
];

$usersByAge = [];
foreach ($users as $user) {
    if (!array_key_exists($user['age'], $usersByAge)) {
        $usersByAge[$user['age']] = [];
    }
    $usersByAge[$user['age']][] = $user['name'];
}

print_r($usersByAge);
# => Array
# (
#     [19] => Array
#         (
#             [0] => Igor
#         )
#
#     [4] => Array
#         (
#             [0] => Danil
#             [1] => Vovan
#         )
#
#     [16] => Array
#         (
#             [0] => Matvey
#         )
#
# )

/*
В этом примере результатом агрегации становится массив массивов, который в самом начале инициируется пустым массивом. Значение, которое накапливает результат агрегации, принятно называть словом "аккумулятор". В примерах выше это $oldest и $usersByAge.

Реализуем первый пример используя array_reduce.
*/

$oldest = array_reduce($users, function ($acc, $user) {
    return $user['age'] > $acc['age'] ? $user : $acc;
}, $users[0]); 	

print_r($oldest); // => ['name' => 'Igor', 'age' => 19]


/*
Функция array_reduce принимает на вход три параметра. Два из них уже традиционны - это коллекция и функция-обработчик, а вот третьим выступает начальное значение аккумулятора. Поиск самого взрослого пользователя аналогичен поиску максимального (или минимального) числа в массиве. Соответственно, аккумулятор должен быть инициализирован первым пользователем. Этот же аккумулятор возвращается наружу.

Анонимная функция, передаваемая в array_reduce - самая важная часть и ключ к пониманию работы всего механизма агрегации. Она принимает на вход два значения. Первый - текущее значение аккумулятора, второй - текущий обрабатываемый элемент. Задача функции - вернуть новое значение аккумулятора. array_reduce никак не анализирует содержимое аккумулятора. Всё, что она делает, передает его в каждый новый вызов до тех пор, пока не будет обработана вся коллекция, и в конце концов вернет его наружу. Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.

Второй пример с использованием array_reduce выглядит так:
*/

$usersByAge = array_reduce($users, function ($acc, $user) {
    if (!array_key_exists($user['age'], $acc)) {
        $acc[$user['age']] = [];
    }
    $acc[$user['age']][] = $user['name'];

    return $acc;
}, []);
print_r($usersByAge);

function getMensCountByYear($users) 
{
	$dates = array_reduce($users, function ($acc, $user) {
		$year = date('Y', strtotime($user['date']));

		if (!array_key_exists($year, $acc)) {
			$acc['year'] = 1;
		} else {
			$acc['year']++;
		}

		return $acc;
	}, []);
	
}

// Код практически не изменился, за исключением того, что ушел цикл и появился возврат аккумулятора из анонимной функции.


# Реализация

function getMensCountByYear(array $users)
{
    $menfolk = array_filter($users, function ($user) {
        return $user['gender'] === 'male';
    });

    $years = array_map(function ($user) {
        return date('Y', strtotime($user['birthday']));
    }, $menfolk);

    return array_reduce($years, function ($acc, $year) {
        if (!array_key_exists($year, $acc)) {
            $acc[$year] = 1;
        } else {
            $acc[$year] += 1;
        }

        return $acc;
    }, []);
}

function myReduce($coll, callable $callback, $init = null)
{
    $acc = $init;
    foreach ($coll as $item) {
        $acc = $callback($acc, $item); // Заменяем старый аккумулятор новым
    }
    return $acc;
}


// array_reduce - очень мощная функция. Формально, можно работать, используя одну лишь ее, так как она может заменить и отображение и фильтрацию. Но делать так не стоит. Агрегация управляет состоянием (аккумулятором) явно. Такой код всегда сложнее и требует больше действий. Поэтому, если задачу возможно решить отображением или фильтрацией, то так и нужно делать.



// Реализуйте функцию getMensCountByYear, которая принимает на вход список пользователей и возвращает массив, в котором ключ это год рождения, а значение это количество мужчин, родившихся в этот год.

$users = [
    ['name' => 'Bronn', 'gender' => 'male', 'birthday' => '1973-03-23'],
    ['name' => 'Reigar', 'gender' => 'male', 'birthday' => '1973-11-03'],
    ['name' => 'Eiegon',  'gender' => 'male', 'birthday' => '1963-11-03'],
    ['name' => 'Sansa', 'gender' => 'female', 'birthday' => '2012-11-03'],
    ['name' => 'Jon', 'gender' => 'male', 'birthday' => '1980-11-03'],
    ['name' => 'Robb','gender' => 'male', 'birthday' => '1980-05-14'],
    ['name' => 'Tisha', 'gender' => 'female', 'birthday' => '2012-11-03'],
    ['name' => 'Rick', 'gender' => 'male', 'birthday' => '2012-11-03'],
    ['name' => 'Joffrey', 'gender' => 'male', 'birthday' => '1999-11-03'],
    ['name' => 'Edd', 'gender' => 'male', 'birthday' => '1973-11-03']
];

getMensCountByYear($users);
# => Array (
#     1973 => 3,
#     1963 => 1,
#     1980 => 2,
#     2012 => 1,
#     1999 => 1
# );

function getMensCountByYear($users) // my
{

	return array_reduce($users, function ($acc, $user) {
		$year = date('Y', strtotime($user['birthday']));

		if ($user['gender'] == 'male') {
			array_key_exists($year, $acc) ? $acc["$year"]++ : $acc["$year"] = 1;
		}

		return $acc;
	}, []);
}

function getMensCountByYear(array $users) // hexlet
{
    $menfolk = array_filter($users, function ($user) {
        return $user['gender'] === 'male';
    });

    $years = array_map(function ($user) {
        return date('Y', strtotime($user['birthday']));
    }, $menfolk);

    return array_reduce($years, function ($acc, $year) {
        if (!array_key_exists($year, $acc)) {
            $acc[$year] = 1;
        } else {
            $acc[$year]++;
        }

        return $acc;
    }, []);
}



>>>>>  Сигналы  <<<<<<<

/*
Пример с usort хорошо демонстрирует важность и удобство функций высшего порядка для решения повседневных задач. Описав алгоритм один раз, мы можем получать различные варианты поведения специфицируя их функциями. Тоже самое относится к рассмотренным функциям map, filter и reduce. Но есть еще один важный аспект, который требует рассмотрения.

Типичный код на PHP выглядит так. Делается один цикл внутри которого выполняются сразу все операции и в конце получается некоторый интересующий нас результат. Ничего криминального, но такой код может быть сложен для анализа, потому что требует держать в голове сразу все операции. С другой стороны, при использовании функций высшего порядка принято разделять задачу на подзадачи и выполнять их последовательно друг за другом выстраивая в цепочку операций.

Предположим что мы пишем функцию, которая принимает на вход список путей файловой системы, находит среди них файлы с расширением php без учета регистра и возвращает имена этих файлов. Для решения этой задачи нам понадобятся следующие функции:


 * is_file - проверяет что переданный путь это реально существующий файл
 * pathinfo - позволяет извлекать расширение из имени файла
 * basename - извлекает имя файла из полного пути
*/

function getPHPFileNames(array $paths)
{
    $result = [];
    foreach ($paths as $path) {
        $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
        if (is_file($path) && $extension === 'php') {
            $result[] = basename($path);
        }
    }

    return $result;
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
print_r($names);
# => Array
# (
#     [0] => index.php
#     [1] => wop.PHP
# )

/*
В примере выше типовое решение с использованием цикла. Его алгоритм можно описать так:

 * Просматриваем каждый путь
 * Если текущий путь файл и его расширение php без учета регистра то добавляем в результирующий массив

Если попытаться тоже самое реализовать используя функцию array_reduce, то на выходе получится код идентичный решению на циклах. Но если хорошо подумать, то можно увидеть что эта задача распадается на две: фильтрацию и отображение.
*/

function getPHPFileNames(array $paths)
{
    // фильтруем оставляя только подходящие пути
    $phpFiles = array_filter($paths, function ($path) {
        $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
        return is_file($path) && $extension === 'php';
    });

    // извлекаем из оставшихся путей имена файлов и возвращаем их наружу
    return array_map(function ($path) {
        return basename($path);
    }, $phpFiles);
}

$names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
print_r($names);


/*
Код получился чуть короче (без учета комментариев), но и многословнее (это исключительно особенность php), но главное не его размер. С увеличением количества операций и их сложности, код разбитый таким образом читается и анализируется значительно проще, так как каждая операция выполняется независимо для всего набора сразу. В голове приходится держать меньше деталей и можно сразу увидеть то, как операция влияет на все данные. Однако, научиться правильно разбивать задачу на подзадачи не так просто, как может показаться в начале. 

Сама возможность такого разбиения основывается на простой идее, которую иногда называют "стандартные интерфейсы". Заключается он в том, что на входе и выходе из функций ожидается один и тот же тип данных, в нашем случае, массив. Это позволяет соединять функции и строить цепочки выполняющие большое количество разных задач, без необходимости реализовывать новые функции. Рассмотренные ранее операции: отображение, фильтрация и агрегация, комбинируясь друг с другом позволяют решать подавляющее число задач по обработке коллекций. С чем-то подобным мы все встречались в своей жизни, когда собирали конструкторы Lego. Небольшое число примитивных деталей за счет одинаковых соединений позволяют строить конструкции практически неограниченной сложности.

Кстати, подобные цепочки нередко заканчиваются на агрегации, так как агрегация почти всегда выполняется в конце и сводит коллекцию к некоторому значению.

Для сравнения я покажу задачу выше, реализованную на JS.
*/

const getPHPFileNames = paths => paths
  .filter(filepath => fs.lstatSync(fullPath).isFile())
  .filter(filepath => path.extname(filepath).toLowerCase() === '.php')
  .map(filepath => path.basename(filepath));

const names = getPHPFileNames(['index.php', 'wop.PHP', 'nonexists', 'node_modules']);
console.log(names); 


// Понятно, что он слишком непривычный, но ухватить фильтры и мапы внутри него не так сложно, да и в целом понять смысл того что происходит. Заметьте, что здесь я разбил фильтр на два. Учитывая лаконичность определения функции в js, гораздо лучше разбивать проверки на большее число фильтров чем делать один сложный фильтр.

# Производительность

/*
За кадром остался вопрос производительности. Возможно, кто-то из вас догадался, что на каждый вызов функции, обрабатывающей коллекцию, мы получаем проход по всему списку. Чем больше таких функций, тем больше проходов. Казалось бы код замедляется, зачем так делать? На практике дополнительные проходы практически никогда не проблема. Задачи, в которых требуется одномоментная обработка десятков и сотен тысяч элементов, встречаются крайне редко. Большая часть операций происходит со списками до тысяч элементов. А для такого списка одним проходом больше одним меньше - разницы, можно сказать, никакой.

Но это не вся правда. На самом деле, существуют специальные коллекции, которые в момент вызова функций фильтрации, отображения и т.п. не выполняют операции сразу. Они накапливают необходимые действия, а во время первого использования выполняют сразу все одним проходом. Это так называемые «ленивые коллекции».
*/


// Реализуйте функцию getFreeDomainsCount, которая принимает на вход список емейлов, а возвращает количество емейлов, расположенных на каждом бесплатном домене. Список бесплатных доменов хранится в константе FREE_EMAIL_DOMAINS.

$emails = [
    'info@gmail.com',
    'info@yandex.ru',
    'info@hotmail.com',
    'mk@host.com',
    'support@hexlet.io',
    'key@yandex.ru',
    'sergey@gmail.com',
    'vovan@gmail.com',
    'vovan@hotmail.com'
];

const FREE_EMAIL_DOMAINS = [
    'gmail.com', 'yandex.ru', 'hotmail.com'
];

getFreeDomainsCount($emails);
# => Array (
#     'gmail.com' => 3
#     'yandex.ru' => 2
#     'hotmail.com' => 2
#  )


function getFreeDomainsCount(Array $mails) // my
{
	return array_reduce($emails, function ($acc, $mail) {
		$domen = explode('@', $mail)[1];
		if (in_array($domen, FREE_EMAIL_DOMAINS) ) {
			array_key_exists($domen, $acc) ? $acc[$domen]++ : $acc[$domen] = 1;
		}

		return $acc;
	}, []);
}

function getFreeDomainsCount(array $emails) // hexlet
{
    $domains = array_map(function ($email) {
        return explode('@', $email)[1];
    }, $emails);

    $freeDomains = array_filter($domains, function ($domain) {
        return in_array($domain, FREE_EMAIL_DOMAINS);
    });


    return array_reduce($freeDomains, function ($acc, $domain) {
        if (!array_key_exists($domain, $acc)) {
            $acc[$domain] = 1;
        } else {
            $acc[$domain] += 1;
        }

        return $acc;
    }, []);
}




>>>>>  Полезные функции высшего порядка  <<<<<<<

// Библиотека Funct, которую мы рассматривали ранее, кроме обычных функций содержит функции высшего порядка. В этом уроке мы рассмотрим некторые из них, которые могут быть полезными в будущем. 


# partition($collection, callable $callback)

// Разбивает массив на два на основании предиката. Те элементы, которые удовлетворяют предикату, попадают в первый массив, другие - во второй.

[$first, $second] = Collection\partition([1, 2, 3, 4, 5, 6, 7, 8, 9], function ($num) {
  return $num % 2 === 0;
}); // => [[2, 4, 6, 8], [1, 3, 5, 7, 9]]

print_r($first); // => [2, 4, 6, 8]
print_r($second); // => [1, 3, 5, 7, 9]


# every($collection, callable $callback = null)

// Возвращает true если каждый элемент коллекции удовлетворяет предикату. По умолчанию проверяет на истинность (== true).

Collection\every([true, 1, null, 'yes']); // => false
Collection\every([true, 1, 'yes']); // => true
Collection\every(
    [2, 4, 6],
    function ($value) {
        return ($value % 2) === 0;
    }
); // => true


# groupBy($collection, callable $callback)

// Группирует элементы коллекции в множества на основании ключа, полученного в результате вызова колбека.

Collection\groupBy([1.3, 2.1, 2.4], function($num) {
    return floor($num);
}); // => [1 => [1.3], 2 => [2.1, 2.4]]


# minValue($collection, callable $callback)

// Возвращает минимальный элемент коллекции на основании результата переданной функции.

Collection\minValue(
    [
        10 => [
            'title' => 'a',
            'size'  => 1
        ],
        20 => [
            'title' => 'b',
            'size'  => 2
        ],
        30 => [
            'title' => 'c',
            'size'  => 3
        ]
    ],
    function ($item) {
        return $item['size'];
    }
);

# => Array (
#    'title' => 'a',
#    'size'  => 1
# )



 
>>>>>  Замыкание <<<<<<<

// Начнем урок с небольшого повторения пройденного материала. Каждая функция создает так называемую область видимости. Внутри этой области доступны только те переменные, которые были определены там же. Все что снаружи - по-умолчанию невидимо.

$age = 5;

function generate()
{
    print_r($age);
}

generate();

// Этот код выдаст предупреждение PHP Notice: Undefined variable: age. Переменная $age определена вне контекста функции и невидима внутри. Точно такое же поведение и у анонимных функций.

$age = 5;

$generate = function () {
    print_r($age);
};

$generate(); // PHP Notice:  Undefined variable: age

// Но передача аргументов все же возможна, и делается она благодаря "замыканию". С помощью этого механизма можно "захватить" переменные из внешнего окружения и использовать их внутри. Правда, только для анонимных функций. Термином "замыкание", нередко называют и саму функцию, которая осуществила захват внешних переменных.

$age = 5;

$generate = function () use ($age) {
    print_r($age);
};

$generate(); // 5

// Захват переменных осуществляется с помощью ключевого слова use и списка переменных, который идет после этого слова. Крайне важно осознать, что use используется при определении функции, а не ее вызове. Может возникнуть закономерный вопрос, зачем это делать, если переменные можно передать в сам вызов.

$age = 5;

$generate = function ($age) {
    print_r($age);
};

$generate($age); // 5

// Замыкания полезны в тех случаях, когда функция определяется в одном месте, а используется в совершенно другом. Замыкание позволяет не таскать за собой гору переменных. А в некоторых ситуациях без них просто не обойтись. Вспомните функцию without из пакета Funct. Эта функция принимает на вход массив и значение, а возвращает новый массив полученный фильтрацией старого по переданному значению. Его реализация, построенная на функциях высшего порядка, подразумевает фильтрацию. Сложность возникает при описании предиката, ведь внутри анонимной функции нужно сравнивать текущее значение и переданный элемент. Замыкание позволяет решить эту задачу просто.

function without(array $items, $value)
{
    $filtered = array_filter($items, function ($item) use ($value) {
        return $item !== $value;
    });
    // !!! Сбрасываем ключи
    return array_values($filtered);
}

without([3, 4, 10, 4, 'true'], 4); // => [3, 10, 'true']

/*
Без добавления use ($value) ничего не получится. $value не виден внутри анонимной функции.
В замыкание можно передать данные по ссылке, что позволит их менять внутри. Но делать так никогда не стоит. Подобное использование создает невероятно сложный в отладке и сопровождении код. Единственная причина, по которой можно использовать передачу по ссылке - рекурсия внутри анонимной функции. 
*/




>>>>> Парадигмы программирования <<<<<<<

/*
В программировании часто используется термин "парадигма".

    Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Парадигма — это больше, чем просто другой алгоритм решения задачи. Как правило, структура кода при использовании разных парадигм отличается очень значительно и требует знаний, выходящих за рамки только синтаксиса языка (например, автоматное программирование требует хотя бы базового понимания теории автоматов). Причем подавляющее большинство современных (и не очень) языков программирования являются мультипарадигменными и позволяют писать код используя множество стилей. Иногда эти стили взаимоисключающие, иногда они дополняют друг друга. К текущему моменту мы писали код используя две парадигмы: императивную и декларативную.


# Императивная парадигма

Императивная парадигма - стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных. Возможно, данное определение звучит страшно, но на практике императивный стиль является доминирующим. Не считая этого курса, весь остальной код мы писали именно в императивном стиле.

Императивная (КАК) Программа - набор инструкций изменяющих состояние (данные). Примеры: Процедурное, ООП

> Циклы
> Присваивание

Декларативная (ЧТО) Программа - спецификация описывающая решение задачи. Примеры: Логическое, Функциональное

> Функции как объекты первого класса
> Рекурсия
> Неизменяемые данные

Функции первого класса можно передавать в качестве аргументов другим функциям, возвращать их как результат других функций, присваивать их переменным или сохранять в структурах данных. Функция высшего порядка — функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

Мультипарадигменные Scala, F#, Ocaml
Императивные Ruby, PHP, Python, C, C++, C#, Perl, Java, Kotlin, Swift, Javascript
Функциональные Haksell, Erlang
Логические Prolog

Лямбда-исчисление - формальная система, разработнная американским математиком Алонзло Чёрчем, для формализации и анализа понятия вычисляемости. Первоначально было реализовано на языке Lisp (1958г.)

Литерал - значение, указанное в коде программы
*/

// Поиск максимального числа
$numbers = [10, 20, 52, 105, 56, 89, 96];
$max = $numbers[0];
foreach ($numbers as $number) {
    if ($number > $max) {
        $max = $number;
    }
}
print_r($max); // => 105

/*
В императивном стиле широко используется присваивание (а, значит, и переменные) и циклы. Эта парадигма популярна потому, что она в точности соответствует тому, как работает компьютер: последовательно выполняет инструкции и использует память для хранения промежуточных результатов. Обычно говорят, что императивная программа отвечает на вопрос КАК («как достичь нужного результата»).

PHP как, впрочем, и java/ruby/python/c#/perl/javascript/go относится к императивным языкам. То есть языкам, в которых доминирующей является императивная парадигма (язык толкает к ее использованию). Что, однако, не мешает использовать и другие парадигмы в рамках этих языков.

# Декларативная парадигма

Императивному стилю противопоставляют декларативный, который нередко называют функциональным. Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос ЧТО («что мы хотим получить»). Эту грань довольно трудно уловить сразу, но, например, вся математика, по своей сути, декларативна.
*/

$numbers = [10, 20, 52, 105, 56, 89, 96];
$max = array_reduce($numbers, function ($acc, $number) {
    return $number > $acc ? $number : $acc;
}, $numbers[0]);
print_r($max); // => 105

/*
Главное отличие декларативной парадигмы от императивной на практике - отсутствие присваивания. Вы можете мне возразить, что в коде выше переменные есть и чисто технически это правда. Присмотритесь к коду внимательнее, вы заметите что переменная создана ровно один раз и больше не меняется. По сути, она рассматривается как константа или, если копнуть глубже, как логическое высказывание. В математике это звучало бы так: допустим "A это множество чисел". Что бы мы дальше не делали, "A" остается всегда тем же чем было во время определения.

Дело в том, что в математике доказательства строятся с помощью логических цепочек. Из одних утверждений следуют другие, и таким образом мы можем прийти к решению задачи. Все это возможно только в том случае, когда утверждения не изменяются. Иначе, следствия могут оказаться неверными уже после того, как они были получены, а значит мы не сможем рассуждать логически.

Тоже самое касается и $acc с $number. Эти параметры всегда определяются ровно один раз, так как каждый вызов функции при таком определении (без использования ссылок) не зависит от другого вызова (спасибо чистым функциям). В мире функциональных языков такую операцию называют связывание. Визуально оно выглядит как присваивание, но это не оно. Попытка связать уже связанный идентификатор (в функциональных языка нет переменных) завершится ошибкой. Ниже пример на языке erlang:
*/

1> A = 4.
4
2> A = 'hey'.
** exception error: no match of right hand side value hey

/*
Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия. Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода. В основном в функциях высшего порядка. Причем они способны заменить рекурсию в подавляющем большинстве задач, в чем мы уже убедились в предыдущих уроках (убедились так, что даже не рассматривали рекурсию). Любая задача из представленных решалась основной тройкой функций высшего порядка.

Функциональных языков довольно много. Они, в своей массе, менее популярны чем императивные, но прочно занимают определенные ниши и активно используются в промышленном программировании. К таким языкам относятся: haskell/erlang/elixir/ocaml/f#. В этих языках нет присваивания и циклов. Императивный код на них написать просто невозможно. Немного особняком стоят такие языки как scala и clojure (и другие из семейства lisp). В этих языках основная парадигма — функциональная, и язык толкает к тому, чтобы писать в таком стиле, но при необходимости на них можно написать самый настоящий императивный код с присваиванием и циклами. А вот, почти все, императивные языки позволяют писать функционально. Причем, если одни языки имеют довольно слабую поддержку функциональной парадигмы, то другие настолько мощную, что в них можно писать только функционально (если хочется). К последним относится и современный JavaScript.

В php поддержка функционального программирования слабее, чем в большинстве других языков, но все же она достаточно серьезная. С каждой новой версией PHP вбирает в себя все больше и больше возможностей, взятых из функциональных языков, многие из которых достаточно быстро становятся популярными и начинают использоваться повсеместно, например, лямбда-функции. С другой стороны, в PHP невозможно обновить массив не используя присваивания (говорят, «в иммутабельном стиле»). Поэтому любой код на PHP использующий функциональные возможности, так или иначе имеет императивные куски.

# Другие парадигмы

Большинство других парадигм являются разновидностями функциональной или императивной парадигм. Из наиболее значимых я бы выделил следующие:

    Логическое программирование
    Автоматное программирование
    Объекто-ориентированное программирование
    Метапрограммирование
*/




>>>>>  Абстракция с помощью функций <<<<<<<

/*
Главная причина создания функций - повышение уровня абстракции, а не сокращения дублирования кода, как вы могли бы подумать. Второе является следствием первого. И действительно, вместо того чтобы реализовывать сортировку самостоятельно в каждом месте где это требуется, можно воспользоваться функцией sort, которая прячет реализацию внутри себя и позволяет программисту не отвлекаться на ненужные детали (вид сортировки, код для ее выполнения).

# Abstraction

В этом заключается суть абстракции, мы игнорируем несущественные стороны, свойства и связи рассматриваемого объекта или процесса, что позволяет представить сложную концепцию в более простой форме. Умение абстрагировать - одно из важнейших свойств нашего мозга. Маленькие дети очень быстро учатся классифицировать предметы нашего мира. Без особого труда понимая, что дерево это дерево, даже если конкретную породу дерева они видят впервые. А два разведенных пальца обозначают зайчика (потому что уши).

Несмотря на это, понимание того, как грамотно строить абстракции (в нашем случае выделять функции) не появляется само по себе. Оно приходит с опытом, при условии, что есть другой человек сильнее вас, который может вам указать на допущенные ошибки, и вы сами отслеживаете проблемы вашей абстракции в процессе эксплуатации (рефлексируете). С другой стороны, излишнее абстрагирование скорее вредно, чем полезно. За награмождением новых сущностей можно потерять суть и тратить больше время на понимание происходящего. Построение абстракции — всегда компромисс. Слишком низкий уровень абстракции приводит к дублированию кода, слишком высокий - может быть очень трудным для понимания (Попробуйте понять Теорию Категорий) и усложняющим решение простых задач.

# Huge Java Call Stack

Функции высшего порядка выводят абстрагирование с помощью функций на новый уровень. Благодаря делегированию поведения внешнему коду (используя анонимные функции), резко расширяется возможность повторного использования кода (алгоритма) в разных ситуациях. И вместо десяти функций для десяти разных участков кода появляется одна функция, которая специфицируется 10 раз разным поведением.

Но не забывайте, что абстракции почти всегда текут.

Пример дырявой абстракции

В первом проекте Хекслета наши ученики совершают одну (совершают много, но сейчас нас интересует одна) ошибку, связанную с неверным выделением абстракций. Если отбросить детали (абстрагироваться!), то задача сводится к написанию функции, которая принимает на вход число, и должна напечатать на экран yes если оно четное и no в обратном случае.

Первое решение выглядит примерно так:
*/

function check($number)
{
  $result = $number % 2 === 0 ? 'yes' : 'no';
  echo $result;
}

// Оно рабочее, но сама концепция четности не выделена в свою абстракцию, что, например, затрудняет тестирование и понимание кода. Здесь он простой, но в более сложных случаях догадаться до того, что за операция выполняется - проблематично. Правильно было бы выделить четность в отдельную функцию (абстракцию).

function isEven($number)
{
    return $number % 2 === 0 ? 'yes' : 'no';
}

function check($number)
{
  $result = isEven($number);
  echo $result;
}

/*
Посмотрите на код выше внимательно. Все ли с ним нормально?

На самом деле, этот код даже хуже чем первая версия, потому что создана неверная абстракция. Понятие четности числа никак не связано ни с выводом на экран, ни со строчками yes или no. Оно существует в вакууме как математическая концепция и не может знать о том, как её собираются использовать. Я уже не говорю про то, что имя isEven начинается с is, а это значит, что функция - предикат. Такие функции могут возращать только логическое значение и никак иначе (исключений не существует!). Правильный вариант выглядит так:
*/

function isEven($number)
{
    return $number % 2 === 0;
}

function check($number)
{
  $result = isEven($number) ? 'yes' : 'no';
  echo $result;
}

/*
И это самый примитивный вариант создания абстракций. В реальном коде обычно все значительно сложнее.

Реализуйте функцию findIndexOfNearest, которая принимает на вход массив чисел и искомое число. Задача функции — найти в массиве ближайшее число к искомому и вернуть его индекс в массиве.
*/

findIndexOfNearest([], 2); // => null
findIndexOfNearest([15, 10, 3, 4], 0); // => 2


function findIndexOfNearest(array $items, $value)
{
    if (sizeof($items) === 0) {
        return null;
    }

    return array_reduce(array_keys($items), function ($acc, $i) use ($items, $value) {
        return abs($items[$i] - $value) < abs($items[$acc] - $value) ? $i : $acc;
    }, 0);
}


// Реализуйте функцию getFirstMenWithLessFriends, которая принимает список пользователей и возвращает пользователя у которого меньше всего друзей. Если список пользователей пустой, то возвращается null.

$users = [
    ['name' => 'Tirion', 'friends' => [
        ['name' => 'Mira', 'gender' => 'female'],
        ['name' => 'Ramsey', 'gender' => 'male']
    ]],
    ['name' => 'Bronn', 'friends' => []],
    ['name' => 'Sam', 'friends' => [
        ['name' => 'Aria', 'gender' => 'female'],
        ['name' => 'Keit', 'gender' => 'female']
    ]],
    ['name' => 'Keit', 'friends' => []],
    ['name' => 'Rob', 'friends' => [
        ['name' => 'Taywin', 'gender' => 'male']
    ]],
];

getFirstMenWithLessFriends($users); // => ['name' => 'Bronn', 'friends' => []];

use Funct\Collection;

function getFirstMenWithLessFriends(Array $users) 
{
	return minValue($users, function ($user) {
		return sizeof($user['friends']);
	});
}


// Реализуйте функцию enlargeArrayImage, которая принимает изображение в виде двумерного массива и увеличивает его в два раза.

$arr = [
    ['*','*','*','*'],
    ['*',' ',' ','*'],
    ['*',' ',' ','*'],
    ['*','*','*','*']
];
// ****
// *  *
// *  *
// ****

enlargeArrayImage($arr);
// ********
// ********
// **    **
// **    **
// **    **
// **    **
// ********
// ********

function enlargeArrayImage($arr)
{
    $result = [];

    foreach($arr as $child) {
        $childArray = [];
        foreach($child as $symbol) {
            $childArray[] = $symbol;
            $childArray[] = $symbol;
        }
        $result[] = $childArray;
        $result[] = $childArray;

    }

    return $result;
}


/*
NRZI код (Non Return to Zero Invertive) — один из способов линейного кодирования. Код формируется путем инверсного состояния при поступлении на вход кодирующего устройства логической единицы, при поступлении логического нуля состояние потенциала не меняется.
https://ru.wikipedia.org/wiki/NRZI
*/

// Реализуйте функцию decode принимающую в качестве параметра строку в виде линейного сигнала и возвращающую строку с бинарным кодом. Пример использования:

$signal = '_|¯|____|¯|__|¯¯¯';
decode($signal); // => '011000110100'

$signal_2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_2); // => '110010000100111'

$signal_3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
decode($signal_3); // => '010010000100111'

/*
Подсказки
* Символ | в строке разделяет разные такты и означает, что уровень сигнала в следующем такте, был изменён на противоположный по сравнению с предыдущим тактом.

* К сожалению, str_split умеет работать только с ASCII символами, поэтому для разделения строки на символы используйте конструкцию preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);, где $str - строка.

*/

function decode($str)
{
    $symbols = preg_split("//u", $str, -1, PREG_SPLIT_NO_EMPTY);

    $mapped = array_map(function ($key) use ($symbols) {
        if ($symbols[$key] === '|') {
            return '|';
        }
        if ($key === 0) {
            return 0;
        }
        return $symbols[$key - 1] === '|' ? 1 : 0;
    }, array_keys($symbols));

    $filtered = array_filter($mapped, function ($item) {
        return $item !== '|';
    });

    return implode('', $filtered);
}



// Реализуйте функцию getSameParity, которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же четность, как и у первого элемента входного массива.

 function getSameParity($coll)
{
    $result = [];
    
    if (empty($coll)) { return $result; }
    
    $reminder = $coll[0] % 2;
    foreach ($coll as $item) {
        if ($item % 2 == $reminder) {
            $result[] = $item;
        }
    }

    return $reminder;
}


/*
Реализуйте функцию getIndexOfWarmestDay, которая находит самый тёплый день (тот, в котором была зарегистрирована максимальная температура) и возвращает индекс этого дня в исходном массиве. Если на вход поступил пустой массив, то функция должна вернуть null

$data = [
    [-5, 7, 1],
    [3, 2, 3],
    [-1, -1, 10],
]

*/

function getIndexOfWarmestDay(array $data)
{
    if (empty($data)) {
        return null;
    }

    $index = 0;
    $max = $data[0][0];
    foreach ($data as $key => $temperatures) {
        $current = max($temperatures);
        if ($current > $max) {
            $max = $current;
            $index = $key;
        }
    }
    return $index;
}




################ PHP: Построение абстракций ################


>>>>>  Линейно-рекурсивный процесс <<<<<<<

function Mypow($base, $exp) // Возведение в степень
{
	if ($exp == 1) { return 1; }
	return $base * Mypow($base, $exp-1);
}

/*
Пусть функция fun вычисляет факториал переданного числа используя рекурсию, тогда ее вызов будет работать так:

fun(4)
4 * func(3)
4 * 3 * func(2)
4 * 3 * 2 * func(1)
4 * 3 * 2 * 1
4 * 3 * 2
4 * 6
=> 24

Там где * 1 рекурсия прерывается, потому что стоит условие в начале функции. И после этого начинается сворачивание.
*/

function rFunc($x) {
   if ($x == 0) { return 1; }
   return $x + rFunc($x - 1);
}

echo rFunc(5); // 5+4+3+2+1+1 => 16


/*
Реализуйте рекурсивную функцию factorial, используя линейно-рекурсивный процесс.

Факториал числа можно выразить следующим образом:
factorial(0) -> 1
factorial(1) -> 1
factorial(n) -> n * factorial(n - 1)
*/

function factorial($num)
{
	return $num <= 1 ? 1 : $num * factorial($num - 1);
}


/* Реализуйте рекурсивную функцию fib, находящую числа Фибоначчи, используя древовидно-рекурсивный процесс.

Формула:
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
*/

function fib($num) 
{
	if ($num <= 1 ) { return $num; }
	return fib($num - 1) + fib($num - 2);
}





######################### ДЕКЛАРАТИВНОЕ ПРОГРАММИРОВАНИЕ #########################

	
>>>>>  Линейно-итеративный процесс <<<<<<<

function myPow($base, $exp) { 
	$powIter = function ($exp, $acc) use ($base, &$powIter) { // блочная структура - использование внутри функции локальной функции. & - т.к. функцию используем в самой себе и во время определения.
		if ($exp == 1) { return $acc; }
		return $powIter($exp - 1, $acc * $base);
	};

	return $powIter($exp, 1); // задаем $acc = 1
}

/*
powIter 4,4,1
powIter 4,3,4
powIter 4,2,16
powIter 4,1,64
=> 64
*/


// Реализуйте рекурсивную функцию factorial 2 способами: 


function factorial($num) 
{
	# линейно-рекурсивный процесс #
	return $num <= 1 ? 1 : $num * factorial($num - 1); 
	
	# линейно-итеративный процесс #
	$iter = function ($num, $acc) use (&$iter) {
		return $num <= 1 ? $acc : $iter($num - 1, $num * $acc);
	};
	return $iter($num, 1);
}


// Реализуйте рекурсивную функцию smallestDivisor, используя линейно-итеративный процесс. Функция должна находить минимальный делитель переданного числа. Минимальный делитель числа - это наименьшее число, на которое делится исходное без остатка.


function smallestDivisor($num)
{

    $iter = function ($acc) use ($num, &$iter) {
        if ($num <= $acc) { return $num; }            
		return $num % $acc == 0 ? $acc : $iter($acc++); 
    };

    return $iter(2);   
}




>>>>>  Функции первого класса. Передача как аргументов <<<<<<<


$sumIntegers = function ($a, $b) use (&$sumIntegers) {
	if ($a > $b) { return 0; }
	return $a + $sumIntegers($a + 1, $b);
};

$sumCubes = function ($a, $b) use (&$sumCubes) {
	if ($a > $b) { return 0; }
	return ($a * $a * $a) + $sumCubes($a + 1, $b);
};


function sum($a, $b, $func) // Функция высшего порядка. Суммирует от a до b, применяя доп. функцию
{
	if ($a > $b) { return 0; }
	return $func($a) + sum($a + 1, $b, $func));
}

echo sum(1, 5, function ($x) { return $x; }); // => 15


// можно описать функцию заранее:

$identity = function ($x) { return $x ** 2; };
echo sum(1, 5, $identity); // => 55


// Реализуйте функцию sum из видео, используя итеративный процесс.

function sum($start, $finish, $func) 
{
    $iter = function ($current, $acc) use ($finish, $func, &$iter) {
        if ($current > $finish) {
            return $acc;
        }

        return $iter($current + 1, $acc + $func($current));
    };

    return $iter($start, 0);
}


/*
Реализуйте функцию product, которая сворачивает последовательность с помощью переданной функции. Последовательность задается первыми двумя аргументами. Первый это начало последовательности, второй это окончание. Например, последовательность [1, 4] это 1, 2, 3, 4. Свертка это сведение последовательности к какому-то значению. Само значение зависит от того, какая операция применяется при свертке. Обратите внимание, что последовательность, типа [$x, $x], состоит из одного числа $x и свертке не подлежит, функция в этом случае должна вернуть само число $x.

'С помощью переданной функции' означает то, что мы применяем эту функцию к элементам последовательности и используем ее результат, как аккумулятор (накопитель результата).

Примеры:
*/
// f(1, 2) => 1 + 2
3 == product(1, 2, function ($first, $second) { return $first + $second; }) // sum

// f(f(3, 4), 5) => f(-1, 5) => -1 - 5
-6 == product(3, 5, function ($first, $second) { return $first - $second; }) // minus

/*
По последнему примеру видно, что операция является левоассоциативной. Рассмотрим данное свойство подробнее на последовательности [1, 4]:

Последовательность: 1, 2, 3, 4. Операция: f - внутренности не важны, главное, что это некая функция.

Разложим операцию с учетом ее левоассоциативности:
*/

f($left1, $right1); // $right1 = 4
f(f($left2, $right2), $right1); // $right2 = 3
f(f(f($left3, $right3), $right2), $right1); // $right3 = 2

// f = function ($first, $second) { return $first - $second; };
f(f(f(1, 2), 3), 4);
f(f(-1, 3), 4);
f(-4, 4); // -8

function product($num1, $num2, $func) 
{
    if ($num1 == $num2) { return $num2; }
    
    return $func(product($num1, $num2 - 1, $func), $num2);
}

echo product(3, 5, function ($first, $second) { return $first - $second; }); // => -6


product(1,3, $func) // ->
$func(product(1, 2, $func), 3); // ->
$func($func(product(1, 1, $func), 2), 3); // ->
$func($func(1,2),3); 




>>>>>  Функции первого класса. Возврат как значения <<<<<<<

/*
Что дает нам возможность возвращать функции как значения?
 * Возможность повышать уровень абстракции
 * Возможность задавать алгоритмы в более обобщенном виде, без спецификации деталей.
*/

function sumGenerator($func)
{
	return function($a, $b) use ($func) { // определение лямбда функции и возврат ее как значения
		return sum($a, $b, $func);
	};
}

function sum($a, $b, $func)
{
	if ($a > $b) { return 0; }
	return $func($a) + sum($a + 1, $b, $func);
}

$sumIntegers = sumGenerator(function($x) { return $x ** 2 }); // лямбда-функция
$sumCubs = sumGenerator(function($x) { return $x * $x * $x; }) // -//-
echo $sumIntegers(1, 5); // => 55
echo $sumCubs(1, 5); // => 255

/*
Ниже приведен пример определения функции, которая возводит свой аргумент в переданную степень (как замыкание). Один пример через прямое определение лямбды, второй через функцию, которая внутри себя определяет точно такую же лямбду и возвращает ее. Результат эквивалентен.
Определение напрямую:
*/

$exponent = 3;
$func = function ($number) use ($exponent) {
    return $number ** $exponent; // операция возведения в степень
};

8 == $func(2); // 2^3

// Определение через вызов функции:

function power($exponent)
{
    return function ($number) use ($exponent) {
        return $number ** $exponent; // операция возведения в степень
    };
}

$func = power(3);
8 == $func(2); // 2^3


// Реализуйте функцию factor, которая принимает на вход число (множитель) и возвращает функцию. Получившаяся функция принимает на вход один аргумент и возвращает результат умножения этого аргумента на множитель.

Пример:

$multiTwo = factor(2); // 2 - множитель

4 == $multiTwo(2); // 2 * 2
20 == $multiTwo(10); // 10 * 2



function factor($multiplier)
{
    return function ($arg) use ($multiplier) {
        return $multiplier * $arg;
    };
}


/*
Реализуйте функцию double, которая принимает как аргумент функцию с одним аргументом и возвращает функцию, которая применяет исходную функцию дважды.
Пример:
Исходная функция с одним аргументом:
*/

2 == $increment(1); // функция увеличивает свой аргумент на единицу

// double вернул новую функцию, которая применяет inc дважды:

$increment2 = double($increment);
3 == $increment2(1) // эквивалентно $increment($increment(1));

// Тут мы применяем double дважды и в итоге increment выполняется 4 раза:

$increment4 = double(double($increment));
5 == $increment4(1);

function double($func)
{
    return function ($arg) use ($func) {
        return $func($func($arg));
    };
}




>>>>> Что такое данные? <<<<<<<


$pair = cons(1, 2); // pair - структура данных 'пара', пришла из лиспа. В PHP не реализована. cons - функция-конструтор

print_r($pair); // =>
/*
Closure Object
(
    [static] => Array
        (
            [x] => 1
            [y] => 2
        )

    [parameter] => Array
        (
            [$method] => <required>
        )

)
*/

echo car($pair); // метод селектор - выбор первого значения из пары => 1
echo cdr($pair); // метод селектор - выбор второго значения из пары => 2

function cons($x, $y)
{
    return function ($method) use ($x, $y) {
        switch ($method) {
            case "car":
                return $x;
            case "cdr":
                return $y;
            default:
                throw new \InvalidArgumentException("Invalid method $method.");
        }
    };
}

function car(callable $pair)
{
	return $pair('car');
}

function cdr(callable $pair)
{
	return $pair('cdr');
}

echo $pair("car"); // так нарушаем абстракцию, просто для понимания. 'car' - называется сообщением, а способ программирования - 'передачей сообщений' => 1

function isPair($pair)
{
    return is_callable($pair);
}

function toString($list)
{
    if (!isPair($list)) {
        return $list;
    }
 
    $iter = function ($items, array $acc = []) use (&$iter) {
        if ($items == null) {
            return $acc;
        }
        return $iter(cdr($items), array_merge($acc, [toString(car($items))]));
    };
    $arr = $iter($list);
 
    return "(" . implode(", ", $arr) . ")";
}




/*
В текущем задании представлен другой способ реализации пар.
   Допишите функцию car основываясь на том как работает функция cons.
   Допишите функцию cdr основываясь на том как работает функция cons.

*/

function cons($x, $y)
{
    return function ($func) use ($x, $y) {
        return $func($x, $y);
    };
}

function car(callable $pair)
{
    return function ($x, $y) use ($pair) {
    	return $x;
    };
}

function cdr(callable $pair)
{
    return function ($x, $y) use ($pair) {
    	return $y;
    };
}


function makeList(...$elements)
{
    return array_reduce(array_reverse($elements), function ($acc, $item) {
        return cons($item, $acc);
    });
}



 
>>>>>  Абстракция данных  <<<<<<<

/*
Абстра́кция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

Это важный инструмент ООП наряду с полиморфизмом, наследованием и инкапсуляцией.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации. Это утверждение неверно, сокрытие особенностей реализации это инкапсуляция.

Абстракция данных — популярная и в общем неверно определяемая техника программирования. Фундаментальная идея состоит в разделении несущественных деталей реализации подпрограммы и характеристик, существенных для корректного её использования. Такое разделение может быть выражено через специальный «интерфейс», сосредотачивающий описание всех возможных применений программы. 
*/

$rat = makeRat(1, 2); //  1 - числитель, 2 з- знаменатель
printRat($rat); // => 1/2
numer($rat); // достает числитель -> 1
denom($rat); // достает знаменатель -> 1
printRat(addRat($rat, makeRat(2,3))); // addRat - сложение рациональных чисел => 7/6


function makeRat($numer, $denom)
{
	return cons($numer, $denom);
}

function numer($rat)
{
	return car($rat);
}


function denom($rat)
{
	return cdr($rat);
}

function cons($x, $y)
{
    return function ($method) use ($x, $y) {
        switch ($method) {
            case "car":
                return $x;
            case "cdr":
                return $y;
            default:
                throw new \InvalidArgumentException("Invalid method $method.");
        }
    };
}


function addRat($rat1, $rat2)
{
	// n1/d1 + n2/d2 == (n1 * d2 + n2 * d1) / (d1 * d2)
	$numer = numer($rat1) * denom($rat2) + numer($rat2) * denom($rat1)
	$denom = denom($rat1) * denom($rat);

	return makeRat($numer, $denom);
}

function printRat($rat)
{
	printf("%d/%d", numer($rat), denom($rat));
}

// ПРИНЦИП ОДНОГО УРОВНЯ АБСТРАКЦИИ:

// Рациональные числа в предметной области:
# addRat subRat equaksRat

// Рациональные числа как числители со знаменателями:
# makeRat numer denom

// Рациональные числа как пары:
# cons car cdr

// То, как реализуются пары
# ...


/*
Программа работает с географическими координатами для вычисления расстояний между точками. Координаты передаются в виде специальных структур данных, так, что широту и долготу можно получить с помощью специальных функций. Широта и долгота представлены в виде чисел, и программе необходимо знать, на каком компьютере были сохранены данные: на 32-битном или 64-битном. Для этого в структуре данных записан специальный флаг, а в программе реализованы две функции для обработки двух форматов чисел.

Нарушается ли в этом случае концепция абстракции данных?

- Да
Ключевое здесь описание уровня абстракции (и зоны ответственности) программы: Программа работает с географическими координатами для вычисления расстояний между точками.

Т.е. на уровне программы происходит работа с такими абстракциями, как географические координаты. Программа не должна знать (и зависеть) о подробностях внутренней реализации этих координат (как, к примеру, код работающий с такими абстракциями как геометрическая точка, не должен знать внутреннее устройство этой точки (пара это или же массив)).

Попытка внутри программы преобразовать значение координат в зависимости от разрядности системы - это уже не зона ответственности программы. Такая абстракция, как географическая координата, не должна зависеть от разрядности системы ("снаружи", с точки зрения кода, который пользуется этой абстракцией) и должна скрывать эти подробности внутри себя, а не перекладывать на использующую программу.
*/

/*
Реализуйте функцию subRat, которая производит вычитание рациональных чисел. При этом (с точки зрения внутренней реализации) функция возвращает в качестве результата новую пару (т.е. исходные пары, являющиеся параметрами функции, не изменяются).
Реализуйте функцию equalRat, которая делает проверку двух рациональных чисел на равенство.
*/

function subRat($rat1, $rat2)
{
    $numer = numer($rat1) * denom($rat2) - numer($rat2) * denom($rat1);
    $denom = denom($rat1) * denom($rat2);

    return makeRat($numer, $denom);
}

function equalRat($rat1, $rat2)
{
    return numer($rat1) * denom($rat2) == numer($rat2) * denom($rat1);
}




>>>>>  Замкнутые множества  <<<<<<<

/*
Список - это абстрактный тип данных, представляющий собой упорядоченный набор значений, в котором некоторое значение может встречаться более одного раза. Экземпляр списка является компьютерной реализацией математического понятия конечной последовательности.

В списке нет индексированного доступа и невозможно получить напрямую доступ к произвольному элементу. В программе у нас есть доступ к голове списка через которую мы можем продвигаться дальше вглубь к хвосту списка.
*/

cons(10, cons(1, 30)); // алгебраическое замыкание 
$list = cons(1, cons(2,cons(3, null))); // структура данных "список"(или "последовательность"). null - показывает конец списка
makeList(1, 2, 3); // аналогично коду выше
// В списке (1, 2, 3) 1 является головой head списка, а (2, 3) хвостом tail списка.

function listRef($list, $n) // показывает элемент определенной позиции (n)
{
	if ($n == 0) {
		return car($list);
	} else {
		return listRef(cdr($list), $n - 1);
	}
}

$l = makeList(1, 2, 5, 7);
echo listRef($l, 0); // => 1
echo listRef($l, 1); // => 2


$l = cons(1, cons(3, cons(5, null)));
echo car(cdr($l)); // cdr возвращает список без головы. (5, 2, 3) -> (2, 3) 	=> 3

$l = cons(1, cons(3, cons(5, null)));
echo car(cdr(cdr($l)));// => 5

$l = cons(1, cons(3, cons(5, null)));
echo cdr(cdr(cdr($l))); // => null


/*
В видео говорится, что в PHP нет готовой реализации списков, но разве массивы из предыдущего курса не делают ровным счётом то же самое? Получается что мы реализуем массив, только с помощью пар? И есть ли какая-то объективная причина причина использовать пары, в таком ключе, ведь с массивами всё проще? Или это всё просто обучающий пример чтобы поработать головой?

=>
Массивы и списки это разные вещи. Массив, как АТД предоставляет возможность произвольного доступа к элементом и их изменение, а список включает в себя буквально две операции: добавить элемент в голову списка и снять голову.

С помощью пар мы реализуем именно список. А цель всего этого курса научить вас абстракциям, показать как из более простых элементов можно строить более сложные за счет композиции. О том что первично, а что является следствием. 

* Абстра́ктный тип да́нных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций. 
*/


// Реализуйте функцию length, которая считает длину списка;

$list = cons(1, cons(2, cons(3, null)));


namespace App\Length;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function length($items)
{
	if ($items === null || !is_callable($items)) {
        return 0;
    } else {
        return 1 + length(cdr($items));
    }
}


// Реализуйте функцию append, которая соединяет два списка; Подсказка: Попробуйте сначала представить как работала бы функция copy, которая принимает на вход список и возвращает его копию.

namespace App\Append;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function append($list1, $list2)
{
    if ($list1 === null) {
        return $list2;
    } else {
        return cons(car($list1), append(cdr($list1), $list2));
    }
}


// Реализуйте функцию reverse, которая переворачивает список;

namespace App\Reverse;

use function Pairs\cons;
use function Pairs\car;
use function Pairs\cdr;

function reverse($list)
{
    $iter = function ($list, $acc) use (&$iter) {
        return is_null($list) ? $acc : $iter(cdr($list), cons(car($list), $acc));
    };
 
    return $iter($list, null);
}




>>>>>  Map   <<<<<<<

/*
map — функция высшего порядка, используемая во многих языках программирования, которая применяет данную функцию к каждому элементу списка, возвращая список результатов. При рассмотрении в функциональной форме она часто называется «применить-ко-всем». https://ru.wikipedia.org/wiki/Map 
// https://codeclimate.com/github/hexlet-components/php-pairs/
*/
    
$scaleList = function ($list, $factor) use (&$scaleList) {
	if ($list == null) {
		return null;
	} else {
		$rest = $scaleList(cdr($list), $factor);
		return cons(car($list) * $factor, $rest);
	}
};

#
$scaleList(cons(1, cons(2, cons(3, null))), 2); // =>
 $rest = $scaleList(cons(2, cons(3, null)), 2);
 return cons(2, $scaleList(cons(2, cons(3, null)), 2));

 $rest = $scaleList(cons(3, null), 2);
 return cons(2, cons(4, $scaleList(cons(3, null), 2)));

 $rest = $scaleList((null), 2);
 return cons(2, cons(4, cons(6, $scaleList((null), 2))));	

 return cons(2, cons(4, cons(6, null)));	
#

$list = makeList(1, 2, 3);
echo listToString($scaleList($list, 2)); // => 2,4,6

$map = function ($func, $list) use (&$map) { // повышаем уровень абстракции
	if ($list == null) {
		return null;
	} else {
		$rest = $map($func, cdr($list));
		return cons($func(car($list), $rest));
	}
};

$func = function($item) { return $item * 3; }
echo listToString($map($func, $list)); // => 3,6,9


// Реализуйте map используя итеративный процесс.

require_once 'Pair.php';

use function App\Pair\cons;
use function App\Pair\car;
use function App\Pair\cdr;
use function App\Pair\reverse;
use function App\Pair\listToString;

function map($func, $list)
{
    $iter = function ($list, $acc) use (&$iter, $func) {
    	return is_null($list) ? reverse($acc) : $iter(cdr($list), cons($func(car($list)), $acc));
    };
	return $iter($list, null);
}




>>>>>  Фильтрация   <<<<<<<

$removeOdds = function ($list) use (&$removeOdds) { // по четным числам
	if ($list == null) {
		return null;
	} else {
		$curr = car($list);

		$rest = $removeOdds(cdr($list));
		if ($curr% 2 == 0) {
			return cons($curr, $rest);	
		} else {
			return $rest;
		}
	}
};

$list = makeList(1,2,3,5,101,100);
echo listToString($removeOdds($list)); // => (2, 10, 100)


// Реализуйте функцию filter, используя итеративный процесс.

function filter($func, $list)
{
	$iter = function ($list, $acc) use (&$iter, $func) {
    	if ($list === null) {
        	return reverse($acc);
    	}

    	$newAcc = $func(car($list)) ? cons(car($list), $acc) : $acc;
        return $iter(cdr($list), $newAcc);
    };

    return $iter($list, null);
}




>>>>>  Свертка   <<<<<<<
 
function sum($list)
{
	$iter = function ($list, $acc) use (&$iter) {
		if ($list == null) {
			return $acc;
		}

		return $iter(cdr($list, $acc + car($list)));
	}; 

	return $iter($list, 0);
}

function accumulate($list, $func, $acc)
{
	$iter = function ($list, $acc) use (&$iter, $func) {
		if ($list == null) {
			return $acc;
		}

		return $iter(cdr($list), $func(car($list), $acc));
	}

	return $iter($list, $acc);
}

$list = makeList(1, 5, 9);
$func = function ($item, $acc) { return $acc + $item; }
echo accumulate($list, $func, 0); // => 15
$func = function ($item, $acc) { return cons($item * 2, $acc); } 
echo listToString(accumulate($list, $func, null)); // => (18, 10, 2)


/*
Реализуйте функцию solution которая принимает на вход список чисел и выполняет следующие действия:
 округляет все числа в списке до верхней границы.
 удаляет нечетные числа.
 возвращает произведение оставшихся элементов.

Подсказки
 Округление до верхней границы: ceil.
 Используйте функции map, filter, reduce из пакета hexlet/pairs, определение которых можно подсмотреть тут https://github.com/hexlet-components/php-pairs.
*/

solution(l(1.3, 3.01, 5.5, 100.9, 2.5)); // → 48.0
solution(l(1.49, 1.99, 9.9, 9.0, -1.2, -2.5)); // → -80.0


namespace App\Solution;

use function Lists\map;
use function Lists\filter;
use function Lists\reduce;

function solution($list) 
{ 
   $ceilNums = map( function ($num) {
   	return ceil($num); 
   }, $list);

   $evenNums = filter(function ($num) { 
   	return $num % 2 == 0; 
   }, $ceilNums); 

   return reduce( function ($num, $acc) {
   	return $num * $acc; 
   }, $evenNums, $acc = 1);
}




>>>>>  Деревья  <<<<<<<

/* 
Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы. Большинство источников также добавляют условие на то, что рёбра графа не должны быть ориентированными. В дополнение к этим трём ограничениям, в некоторых источниках указывается, что рёбра графа не должны быть взвешенными. https://ru.wikipedia.org/wiki/Дерево_(структура_данных)

Дерево можно назвать рекурсивной структурой данных, потому что каждая его часть по сути является деревом само по себе.
https://ru.hexlet.io/blog/posts/recursive
*/

l(2, 3, 4); // => cons(2, cons(3, cons(4, null)));
l(2, 3, l(4, 5)) // => cons(2, cons(3, cons(cons(4, cons(5, null)), null)));
    

function treeMap($list, $func, $acc)
{
	$iter = function ($list, $acc) use (&$iter, $func) {
		if ($list == null) {
			return $acc;
		}
	
		$element = car($list);
		if (isPair($element)) { // isPair - метод проверяет является ли элемент парой
			$newAcc = treeMap($element, $func, $acc);
		} else {
			$newAcc = $func($element, $acc);
		}
		return $iter(cdr($list), $newAcc);
	};
	return $iter($list, $acc);	
}

$list = l(1,3,l(1,l(2,3),2),9); // l == makeList()

$result = treeMap($list, function($item, $acc) { // считает кол-во элементов
	return $acc + 1;
}, 0); // => 7


// Реализуйте функцию reverse, которая переворачивает переданный на вход список рекурсивно.
	
l(1, l(3, 2), 5, l(6, l(5, 4))) => (((4, 5), 6), 5, (2, 3), 1)
l(l(3, l(4, 100), 5, 6, l(7))) => (((7), 6, 5, (100, 4), 3))

require 'Pair.php';

use function App\Pair\car;
use function App\Pair\isPair;
use function App\Pair\cdr;
use function App\Pair\cons;
use function App\Pair\listToString;


function reverse($list)
{
    $iter = function ($list, $acc) use (&$iter) {
    	if (is_null($list)) {
    		return $acc;
    	}

    	$elem = car($list);

	  	if(isPair($elem)) {
			 $newAcc = cons(cons(car($elem), $iter(cdr($elem), null)), $acc);
	  	} else {
			$newAcc = cons($elem, $acc);
	  	}

	  	return $iter(cdr($list), $newAcc);
    };
    
    return $iter($list, null);
}



	
>>>>>  Стандартные интерфейсы  <<<<<<<
 	
	
$list = l(1, 4, 5, 8, 9, 100);

function sumOfDoubleOdds($list) // сумма нечетных чисел * 2
{
    return accumalate($list, function ($item, $acc) {
        if ($item % 2 === 1) {
            return $item * 2 + $acc;
        } else {
            return $acc;
        }
    }, 0);
}

// Принцип "Разделай и властвуй":
    
$result = filter($list, function ($item) {
    return $item % 2 === 1;
});

$result2= map($result, function ($item) {
    return $item * 2;
});
    
$result3 = accumulate($result2, function ($item, $acc) {
    return $acc + $item;
}, 0);
    
echo ($result3); // => 30    

// В других языках реализованы "ленивые коллекции", которые не производят вычислений до их использования.	
	

/*
Реализуйте функцию solution, которая принимает на вход список чисел и выполняет следующие действия:

 удаляет все числа, не кратные трем. 
 возводит оставшиеся числа в квадрат.
 возвращает среднее арифметическое списка полученного после предыдущей операции.

Пример:

22.5 == solution(l(1, 3, 8, 6)) // (3 * 3 + 6 * 6) / 2

Подсказки:

Для подсчета числа элементов в списке используйте функцию length
*/

function solution ($list)
{
	$multiplicityNums = filter($list, function ($item) {
		return $item % 3 === 0;
	});

	$squareNums = map($multiplicityNums, function ($item) {
		return $item ** 2;
	});

	$sumNums = accumulate($squareNums, function ($item, $acc) {
		return $item + $acc;
	}, 0);

	return $sumNums/length($squareNums);
}
    

>>>>>  Оператор присваивания  <<<<<<<

# Процедурный стиль :
	
// Демонстрация - так не делать!
function deposit(&$balance, $amount)
{
	$balance += $amount;
}
	
$balance = 100;
deposit($balance, 10);
echo $balance; // => 100

	
function newDeposit($balance) // инкапсуляция	
{
	return function ($amount) use (&$balance) {
		$balance += $amount;
		return $balance;
	};
}

$d = newDeposit(100);	
echo $d(10); // => 110	
$d2 = newDeposit(100);	
echo $d2(10); // => 110		
	


/*	
Напишите функцию newWithdraw, которая снимает деньги со счета. При попытке снять больше денег, чем есть на счете, она должна возвращать too much.
Пример:

$withdraw = newWithdraw(100);
$withdraw(1000); // 'too much'
$withdraw(50); // 50
$withdraw(45); // 5
*/
	
function newWithdraw($balance) // my
{
    return function ($amount) use (&$balance) {
        $newBalance = $balance - $amount; 
        return ($newBalance >= 0) ? $balance = $newBalance : 'too much';
    };
}	
	
function newWithdraw($balance) // hexlet
{
    return function ($amount) use (&$balance) {
        if ($balance < $amount) {
			  	return "too much";
        } else {
            $balance -= $amount;
            return $balance;
        }
    };
}


	
	
>>>>>  Объекты  <<<<<<<#
 		
function newAccount($balance)
{
	$withdraw = function ($amount) use (&$balance) {
		$balance -= $amount;
		return $balance;
	};
	
	$deposit = function ($amount) use (&$balance) {
		$balance += $amount;
		return $balance;
	}
	
	return function ($funcName, $amount) use ($withdraw, $deposit) { // стиль "передача сообщений"
		switch ($funcName) {
			case "withdraw":
					return $withdraw($amount);
					break;
			case "deposit": 	
					return $deposit($amount);
					break;
		}
	};
}
	
	
$a = newAccount(100);
echo $a("deposit", 50);	// 110
echo $a("deposit", 100); // 10	
	
	
/*	
Измените функцию newAccount из видео так, чтобы она создавала счета, защищенные паролем.

Пример:

$acc = newAccount(100, "secret password");
110 == $acc("deposit", 10, "secret password");
60 == $acc("withdraw", 50, "secret password");
"wrong password!" == $acc("deposit", 10, "wrong password");	
*/	

namespace App;

function newAccount($balance, $password)
{
    $withdraw = function ($amount) use (&$balance) {
        $balance -= $amount;
        return $balance;
    };

    $deposit = function ($amount) use (&$balance) {
        $balance += $amount;
        return $balance;
    };
	

    return function ($funcName, $amount, $p) use ($password, $withdraw, $deposit) {
        if ($password !== $p) {
            return "wrong password!";
        }

        switch ($funcName) {
            case "withdraw":
                return $withdraw($amount);
                break;
            case "deposit":
                return $deposit($amount);
                break;
        }
    };
}



>>>>>  Преимущества присваивания   <<<<<<<#
 

function random($seed) // псевдослучайные  числа
{
	return function () use (&$seed) { // число, являющееся базовым значением для вычисления следующего случайного числа
		$a = 45;
		$c = 21;
		$m = 67;
		$seed = ($a * $seed + $c) % $m;

		return $seed;
	};
}

$a = random(10);
echo $a(); // => 44	
echo $a(); // => 58
echo $a(); // => 27
echo $a(); // => 30

	
/*
Измените функцию random из видео так, чтобы можно было обнулять сгенерированную последовательность.
Пример:
*/

$seq = random(3);
$result = $seq(); // 22
$seq(); // 6
$seq(); // 23

$seq("reset");

$result == $seq(); // 22
	
function random($seed) // псевдослучайные  числа
{
	$start = function () use ($seed) {
		return $seed;
	}

	return function ($function = null) use (&$seed) { // число, являющееся базовым значением для вычисления следующего случайного числа
		if ($function == 'reset') {
			return $seed;
		} else {
			$a = 45;
			$c = 21;
			$m = 67;
			$seed = ($a * $seed + $c) % $m;

			return $seed;
		}
	};
}



>>>>>  Недостатки присваивания   <<<<<<<#

function makeDecrementer($balance) // чистая функция
{
	return function ($amount) use ($balance) {
		return $balance - $amount;
	};
}

$d = makeDecrementer(100);
echo $d(10); // 90
echo $d(10); // 90
echo $d(10); // 90

$d2 = makeDecrementer(100); // $d и $d2 - являются одним и тем же объектом


function makeWithdraw($balance) // нечистая функция
{
	return function ($amount) use (&$balance) { 
		$balance -= $amount;
		return $balance;
	};
}

$w = makeWithdraw(100); // $w и $w2 разные объекты
$w2 = makeWithdraw(100);
$w(10); // => 90
$w(10); // => 80
$w2 = makeWithdraw(100); // => 90

# референциальная (ссылочная) прозрачность

function factorial($n) // функция в полуимперативном стиле
{
	$product = 1;
	$counter = 1;
	$iter = function () use ($n, &$iter, &$product, &$counter) {
		if ($counter > $n) {
			return $product;	
		} else {
			$product *= $counter;
			$couner += 1;
			return $iter();
		}	
	};

	return $iter;
}


/*
Реализуйте функцию fib находящую числа Фибоначчи используя рекурсивно-итеративный процесс, но вместо аккумулятора параметров для вложенной функции $iter используйте переменные.

Формула:

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)

Пример:

2 == fib(3);
5 == fib(5);
55 == fib(10);
*/


/*
[0, 0]
[1, 1]
[1, 2]
[2, 3]
[3, 4]
[5, 5]
[55, 10]
*/


/*
Реализуйте функцию fringe, которая берет в качестве аргумента дерево (представленное в виде списка) и возвращает список, элементы которого - все листья дерева, упорядоченные слева направо.

Пример:
*/
l(4, 3, 2, 1) == fringe(l(l(4, 3), l(2, 1)));


/*
l() => l()
l(1, 2) => l(1, 2)
l(4, 3, 2, 1) => l(l(4, 3), l(2, 1))
l(4, null, 5, 7, 9, 1, 1) => l(l(4, l(null, 5)), l(l(7, 9), 1), 1)
*/




/*
Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и g есть функция x → f ( g (x) ).
Solution.php

Определите функцию compose которая реализует композицию.

Пример:
*/
$square = function ($num) {
    return $num ** 2;
};

$half = function ($num) {
    return $num / 2;
};

$func1 = compose([$square, $half]);
$func1(10); // 25

$func2 = compose([]);
$func2(3); // 3




/*
[3, 3, []],
[1, 0, [$inc]],
[25, 10, [$square, $half]],
[25, -11, [$square, $half, $inc]]
*/



/*
Определите функцию sameParity, которая принимает список построенный на парах и возвращает отфильтрованный список у которого четность каждого элемента совпадает с четностью первого элемента этого списка.
Пример:
*/

l(1, 3) == l(1, 10, 3, 2)


// Подсказки: Функция l это сокращенная запись для вложенных cons. Подробнее https://github.com/hexlet-components/php-pairs

/*
l(), l()
l(1), l(1)
l(1, 5), l(1, 2, 5, 0)
l(10, 2, 0), l(10, 2, 5, 0)]
*/



/*
Реализуйте функцию deepReverse, которая принимает список в качестве аргумента и возвращает в качестве значения список, где порядок элементов обратный и подсписки также обращены.

Пример:
*/
l(l(1, 2), l(3, 4)) == deepReverse(l(l(4, 3), l(2, 1)));



/*
[l(), l()],
[l(2, 1), l(1, 2)],
[l(l(1, 2), l(3, 4)), l(l(4, 3), l(2, 1))],
[l(1, l(1, l(9, 7)), l(l(5, null), 4)), l(l(4, l(null, 5)), l(l(7, 9), 1), 1)]
*/

/*
Реализуйте функцию fib находящую положительные числа Фибоначчи. Аргументом функции является порядковый номер числа.

Формула:

f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)

Пример:

2 == fib(3)
5 == fib(5)
55 == fib(10)
*/



/*
[0, 0]
[1, 1]
[1, 2]
[2, 3]
[3, 4]
[5, 5]
[55, 10]
*/




/*
Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f — функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение которой в точке x есть среднее между f(x − dx), f(x) и f(x + dx).
Solution.php

Напишите функцию smooth, которая в качестве ввода принимает два аргумента: функцию, вычисляющую f, и малое число dx, а возвращает функцию, вычисляющую сглаженную версию f.

Пример:
*/

$smoothFunc = smooth(function ($sum) {
  return sin(rad2deg($sum));
}, 15);

$smoothFunc(10) // ~ 0.438





/*
 public function testSmooth($expected, $x, $dx, $func)
    {
        $smoothFunc = Solution\smooth($func, $dx);
        $this->assertEquals($expected, $smoothFunc($x), '', 0.01);
    }

    public function additionProvider()
    {
    	return [
            [0.438, 10, 15, function ($num) {
                return sin(rad2deg($num));
            }],
            [5, 0, 5, function ($num) {
                return $num + 5;
            }],
            [4, 2, 0.00001, function ($num) {
                return $num ** 2;
            }],
            [9, 3, 0.00001, function ($num) {
                return $num ** 2;
            }]
        ];
    }
}            
*/
