<?

############################# Базы данных: SQL (DDL/DML) #####################

>>>>> Введение <<<<<<<
/*
SQL (англ. structured query language — «язык структурированных запросов») — декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.
Wiki: https://ru.wikipedia.org/wiki/SQL

База данных:

* Содержит данные приложения
* Управляется с помощью СУБД

История:
* К 1980 существовало множество СУБд
* У каждого свой собственный язык запросов
* В 1986 году вышел первый стандарт SQL86

Системы Управления БД
* PostgreSQL
* MySQL (MariaDB, Percona)
* MS-SQL
* Oracle
* Sqlite - встраиваемая кроссплатформенная БД. Поддерживает набор команд SQL и доступна в исходных кодах (язык C).

SQL Parts
* Data Definition Language (DDL)
* Data Manipulation Language (DML)

Data Definition Language (DDL) (язык описания данных) — это семейство компьютерных языков, используемых в компьютерных программах для описания структуры баз данных.
На текущий момент наиболее популярным языком DDL является SQL, используемый для получения и манипулирования данными в РСУБД, и сочетающий в себе элементы DDL, DML и DCL.
Wiki: https://ru.wikipedia.org/wiki/Data_Definition_Language

Data Manipulation Language (DML) (язык управления (манипулирования) данными) — это семейство компьютерных языков, используемых в компьютерных программах или пользователями баз данных для получения, вставки, удаления или изменения данных в базах данных.
На текущий момент наиболее популярным языком DML является SQL, используемый для получения и манипулирования данными в РСУБД. Другие формы DML использованы в IMS/DL1, базах данных CODASYL (таких как IDMS), и других.
Wiki: https://ru.wikipedia.org/wiki/Data_Manipulation_Language
*/

>>>>> Установка <<<<<<<

/*
Основных способа установки два:

1 Через скачивание установщика с сайта. 
https://www.postgresql.org/download/

В разделе "Binary packages" выберите ссылку, на которой написано имя вашей операционной системы. Перейдите по ней и скачайте установщик. Далее запустите его и выполните указанные инструкции.

Если вы счастливый обладатель Windows, то убедитесь что запуск инсталлятора происходит от администратора. К тому же, вам нужно настроить Windows определенным образом, а именно включить подсистему Ubuntu или поставить vagrant. Подробнее здесь https://guides.hexlet.io/


2 Через пакетный менеджер вашей операционной системы (предпочтительно).
macos: brew install postgresql
ubuntu: apt install postgresql
windows: choco install postgresql

После установки PostgreSQL автоматически запускается от имени вновь созданного пользователя postgres. Этот пользователь понадобится нам дальше.
Теперь время убедиться в том, что установка прошла правильно. Посмотрите из командной строки запущен ли PostgreSQL:
*/
$ ps aux | grep postgres
// => postgres  3437  0.0  2.3 295008 24160 ?        S    12:01   0:00 /usr/lib/postgresql/9.5/bin/postgres -D /var/lib/postgresql/9.5/main -c config_file=/etc/postgresql/9.5/main/postgresql.conf
/*
В вашем случае вывод может отличаться, но главное увидеть эту строчку, в которой отображается запуск самой базы данных. Если база данных запущена, то дальше нужно попробовать к ней подключиться. PostgreSQL поставляется со специальной программой psql, которая представляет из себя REPL. Через него можно управлять PostgreSQL и взаимодействовать с базами данных внутри неё.

# Подключение
Подключение к PostgreSQL всегда выполняется от имени конкретного пользователя и к конкретной базе данных. Если не указано другого, то psql попробует подключиться от имени пользователя, запускающего psql, к базе данных с тем же именем.

В самой базе данных используется понятие Роль, а не Пользователь.
*/

# Такой запуск сработает в MacOS, но не сработает в Linux
$ psql
// => psql: FATAL:  role "vagrant" does not exist

/*
Если вы работаете на маке, то подключение уже настроено для вашего текущего пользователя

Если PostgreSQL ещё не настраивался, то такой запуск выдаст ошибку, явно указывающую на отсутствие соответствующей роли. Единственная роль, которая есть в PostgreSQL сразу после установки — postgres.

Небольшое отступление на тему аутентификации. В PostgreSQL существует множество разных способов подключения. Один из самых простых методов называется Peer Authentication: он основан на совпадении имени пользователя, который подключается к PostgreSQL, с именем роли внутри него. А так как у нас есть пользователь postgres снаружи и роль postgres внутри, то им и воспользуемся.
*/

# Запуск программы от имени другого пользователя (postgres)
$ sudo -u postgres psql
postgres=#

/*
Если ваш вывод совпадает с примером, то поздравляю, подключение к PostgreSQL прошло успешно!

Но войти во внутрь это ещё не всё, нужно суметь выйти. Внутри repl доступны разные управляющие команды. Все они построены по одному принципу — перед командой набирается обратный слеш '\': например, для выхода надо набрать \q. Полный список команд доступен по команде \?. Её запуск загружает пейджер, по которому можно перемещаться, используя стандартные комбинации текстового редактора Vim:

postgres=# \?
Informational
  (options: S = show system objects, + = additional detail)
  \d[S+]                 list tables, views, and sequences
  \d[S+]  NAME           describe table, view, sequence, or index
  \da[S]  [PATTERN]      list aggregates
  \dA[+]  [PATTERN]      list access methods
  \db[+]  [PATTERN]      list tablespaces
  \dc[S+] [PATTERN]      list conversions
  \dC[+]  [PATTERN]      list casts
  \dd[S]  [PATTERN]      show object descriptions not displayed elsewhere
  \dD[S+] [PATTERN]      list domains
  \ddp    [PATTERN]      list default privileges
  \dE[S+] [PATTERN]      list foreign tables
  \det[+] [PATTERN]      list foreign tables
  \des[+] [PATTERN]      list foreign servers
  \deu[+] [PATTERN]      list user mappings
  \dew[+] [PATTERN]      list foreign-data wrappers
  ...
Возможные проблемы
*/
$ psql
/* => 
psql: could not connect to database template1: could not connect to server: No such file or directory
    Is the server running locally and accepting
    connections on Unix domain socket "/tmp/.s.PGSQL.5432"?


Этот вывод говорит о том, что подключение не удалось, и нужно выяснять почему.

Ошибка psql: command not found, говорит о том, что PostgreSQL установлен неверно либо не установлен вообще.

Обратите внимание на то, что этот вывод порождается командной строкой на ввод любой несуществующей команды. Возможно даже, что это всего лишь ошибка в имени.

К сожалению, количество возможных проблем, помноженных на разные операционные системы и их версии, настолько велико, что не представляется возможным дать исчерпывающее руководство по их разрешению. Более того, даже опытный разработчик не всегда способен сразу разобраться, глядя на вывод ошибки, и ему требуется время на изучение проблемы (эксперименты и гугление). По этой причине, вопросы по установке лучше задавать сразу в нашем сообществе http://slack-ru.hexlet.io в канале #databases или #os.    

Самостоятельная работа
Установите PostgreSQL и убедитесь в том, что он запускается и работает

# Дополнительные материалы
Настройка локали https://postgrespro.ru/docs/postgrespro/10/locale
Управление пользователями https://postgrespro.ru/docs/postgrespro/10/database-roles
*/

>>>>> Архитектура СУБД <<<<<<<

/*
Программа, которую мы установили в прошлом уроке, называется СУБД или Система Управления Базами Данных. СУБД не то же самое, что и база данных (БД). БД — это хранилище данных, имеющее определённую внутреннюю структуру. Но кто-то должен её обслуживать: создать, обновлять, записывать в неё данные, выбирать их. Именно этим и занимается СУБД — специальная программа, которую необходимо установить на ту машину, где планируется размещать базу данных.

СУБД — невероятно сложные программы, к которым предъявляются практически максимальные требования по надежности, скорости работы и эффективности. Неспроста считается, что если базе данных меньше 10 лет (реляционной базе данных, об этом понятии поговорим позже), то это слишком молодой продукт для использования в серьёзных приложениях.

СУБД реализуется как клиент-серверное приложение. Сервер — сама СУБД, она управляет файлами баз данных, принимает запросы от клиентов и выполняет их команды. Клиент — любое приложение, желающее взаимодействовать с базой данных. Клиентские приложения могут быть разнообразны по форме:

 - текстовая утилита
 - графическое приложение
 - веб-сервер, использующий базу данных для отображения веб-страниц
 - специализированный инструмент для обслуживания БД

Как и в других клиент-серверных приложениях, клиент и сервер, обычно, располагаются на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP. Такая архитектура позволяет обрабатывать СУБД множество клиентов одномоментно. Эта возможность имеет огромное значение для веб-приложений, в которых одновременное число пользователей может составлять сотни тысяч пользователей.

Иногда сервер и клиент располагаются на одной машине. Это удобно во время разработки. 

Самый простой клиент для доступа к базам данных — интерактивная консоль (REPL), которую мы установили на прошлом шаге. Это важный момент, который нужно осознать. Консоль базы данных — это клиентская утилита, которая соединяется с СУБД. Если СУБД не запущена, то консоль не сможет запуститься. По умолчанию соединение происходит на ту машину, на которой запускается сам репл. Это поведение можно изменить, задав соответствующие параметры.
*/

>>>>> Подготовка к работе <<<<<<<

/*
Вспомним, как работает psql. Если эту программу запустить без аргументов, то она пытается подключиться к локальной базе данных (находящейся на той же машине) с именем, совпадающим с именем текущего пользователя, и делает это, используя роль с этим же именем. Если PostgreSQL установлен верно, то запуск этой программы в Linux (например, Ubuntu) ругается на отсутствие соответствующей роли:
*/
$ psql
// => psql: FATAL:  role "vagrant" does not exist

/*
Мы уже научились решать эту проблему, используя sudo -u postgres psql. Но это не лучшее решение, как минимум, по двум причинам:

1 Пользователь postgres имеет максимальные права в СУБД. Тот, кто завладеет им, может уничтожить всё. Поэтому конкретные клиенты (приложения или пользователи) никогда не создают базы данных от имени postgres и никогда не работают из под этого пользователя.
2 Придётся постоянно использовать эту конструкцию sudo -u postgres для любых команд, связанных с СУБД.
Маководам не нужно использовать часть sudo -u postgres, так как после установки PostgreSQL автоматически конфигурируется для работы с вашим пользователем

Для упрощения работы по ходу курса создадим роль, которая имеет такое же имя, как и пользователь, из под которого вы работаете. Выполните следующие действия:

1 Посмотрите имя вашего текущего пользователя: 
*/
$ whoami
// => vagrant

/*
2 Создайте роль с таким же именем внутри PostgreSQL, используя команду createuser. Обратите внимание на то, что команду нужно запускать от пользователя postgres, иначе она попробует соединиться с СУБД от имени текущего пользователя, которого там нет:
*/
# Флаг --createdb добавляет нашей роли возможность создавать базы данных. По умолчанию этой возможности нет.
$ sudo -u postgres createuser --createdb vagrant

// Теперь у нас есть роль в СУБД. Попробуем соединиться с PostgreSQL, используя её:
$ psql
// => psql: FATAL:  database "vagrant" does not exist


/*
Снова ошибка, но уже другая. Теперь psql ругается на то, что не выбрана база данных. Надо сказать что невозможно соединиться с СУБД просто так: соединение всегда происходит с конкретной базой данных. Эту базу данных можно указать самостоятельно, просто передав один аргумент в psql. Мы уже знаем, что внутри PostgreSQL создана база postgres. Попробуем подключиться к ней:
*/
$ psql postgres
// => postgres=>

/*
Соединение удалось. Теперь посмотрим список ролей. Для этого подходит команда \du (Describe Users), которую надо выполнить внутри REPL.

postgres=> \du
                                   List of roles
 Role name |                         Attributes                         | Member of
-----------+------------------------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 vagrant   |                                                            | {}

Как видно, в СУБД создано две роли. Одна postgres, другая — та, которую мы самостоятельно добавили ранее.

Для экспериментов нам понадобится база данных и, возможно, даже не одна. Создадим базу данных с именем hexlet. Сделать это можно из командной строки (не репла psql!) командой createdb.
*/
$ createdb hexlet

/*
Имя для базы данных выбирается произвольно и обычно совпадает с названием проекта, для которого она создается. Имена баз уникальны в рамках одной СУБД. Это значит, что повторный вызов createdb с тем же именем приведёт к ошибке. Кроме того, после установки СУБД сразу создаёт несколько служебных баз данных (например, postgres), которые нужны для работы.

Если запустить эту команду без аргументов, то она попытается создать базу данных, совпадающую с именем вашего пользователя в системе. Узнать это имя можно командой whoami.

Теперь у нас есть роль и база данных для экспериментов. Подключение к этой БД выполняется так:
*/
$ psql hexlet
// => hexlet=>

// Созданную базу данных можно удалить командой dropdb:
$ dropdb hexlet

/*
Не забудьте её снова создать, так как она понадобится нам в дальнейшем.

Запускать такую команду нужно с большой осторожностью. Удаление базы данных — необратимый процесс. Нет ничего страшнее, чем потерять данные, которые, в отличие от кода, невозможно восстановить без резервных копий. Во избежании недоразумений, команда dropdb не работает без аргументов — ей всегда нужно передавать имя базы.

Удаление базы данных возможно только в том случае, если к ней никто не подключен (за исключением того, кто удаляет). Если есть другие клиенты, то СУБД предупредит о невозможности выполнить команду.

# Самостоятельная работа
Создайте роль с именем hexletbot
Создайте базу данных с именем hexletbot
Удалите созданную базу данных
Для дальнейших уроков нам понадобится база данных из репозитория pg-dump-example https://github.com/hexlet-components/pg-dump-example. Всё, что от вас требуется сейчас — загрузить её в базу данных под именем hexlet. Инструкция по загрузке есть в описании репозитория .
*/

>>>>> Структура реляционной базы данных <<<<<<<

/*
PostgreSQL — СУБД, созданная для работы с реляционными базами данных. Понятие "реляционная" мы рассмотрим в уроке, посвященном реляционной модели, а сейчас сосредоточимся на её прикладных аспектах. В этом уроке обзорно рассказывается о том, как устроены базы данных, а уже начиная со следующего, мы начнём создавать базу собственными руками.

Данные в реляционных базах данных представлены в табличном виде и хранятся в таблицах. Такая структура очень напоминает Microsoft Excel. Каждая строка в такой таблице — это связанный набор данных, относящийся к одному предмету.

Разные таблицы предназначены для хранения информации о различных предметах: например, пользователи, статьи или заказы в интернет-магазине. В типичных веб-приложениях таблиц десятки и сотни. В больших — тысячи. На Хекслете их несколько сотен.

У таблиц в базе данных есть определённая структура, которая включает в себя фиксированный набор столбцов (говорят: "полей"). Поля расположены в строго определённом порядке, и каждое поле имеет своё уникальное имя в рамках одной таблицы. Кроме того, у таблицы есть имя, которое, как правило, уникально в рамках одной базы данных. Имя таблицы и её структура задаются при создании, но могут быть изменены впоследствии.

Каждому столбцу сопоставлен тип данных. Тип данных ограничивает набор допустимых значений, которые можно присвоить столбцу, и определяет смысловое значение данных для вычислений. Например, в столбец числового типа нельзя записать обычные текстовые строки, но зато его данные можно использовать в математических вычислениях. И наоборот, если столбец имеет тип текстовой строки, для него допустимы практически любые данные, но он непригоден для математических действий (хотя другие операции, например, конкатенация строк, возможны).

Число строк в таблице переменно — оно отражает текущее количество находящихся в ней данных. В отличие от таблиц в Exсel, в таблицах реляционных баз данных нет никаких гарантий относительно порядка строк в таблице. Он может быть любым. При необходимости этот порядок можно задать с помощью языка SQL, который рассматривается далее по курсу.

Количество данных в разных таблицах варьируется очень сильно. Многие справочные таблицы, которые содержат некоторые фиксированные списки (например, список стран) очень небольшие, количество записей в них варьируется от нескольких штук до нескольких сотен. Другие таблицы, напротив, могут иметь значительные размеры. От сотен тысяч до десятков миллионов записей. Ну и совсем большие содержат сотни миллионов и даже миллиарды записей.

Пример описания таблицы с именем users (на псевдоязыке):

# Структура

users

first_name string
last_name  string
email      string
created_at datetime

# Содержание

| first_name | last_name |       email       | created_at |
|------------|-----------|-------------------|------------|
| Сергей     | Петров    | serj@gmail.com    | 11.10.2005 |
| Иван       | Сидоров   | sidorov@yahoo.com | 03.08.2000 |
| Виктор     | Курганов  | vkurg@indbox.com  | 23.12.2011 |


В дальнейшем эту структуру можно модифицировать, удалять и добавлять поля, менять типы данных и, наконец, удалить всю таблицу целиком. Типичные таблицы содержат десятки полей, но бывают и большие, в которых полей за сотню.

Именование таблиц и полей в базе (и других сущностей) не фиксировано и зависит от программиста. В проектах, активно использующих ORM, имена определяются соглашениями конкретной экосистемы. В этом курсе я использую именование, принятое во фреймворке Rails и его ORM (ActiveRecord). Оно состоит из нескольких правил:


1 Все имена в нижнем регистре
2 Для имён, состоящих из нескольких слов, используется snake_case
3 Имя таблицы во множественном числе

В отличие от Excel, где ввод данных и отображение происходит визуально, в обычных СУБД данные не имеют никакого представления. Вводятся они с помощью команд и выбираются тоже, а вот дальше, всё зависит от программистов, которые выводят эти данные в своих программах. Но существуют специальные клиенты, предназначенные для удобного визуального управления базами данных. Можно сказать, что это "psql на стероидах".

Эти решения бывают как платные, так и бесплатные. Из бесплатных, в мире PostgreSQL, наиболее популярен PgAdmin. Рекомендую поставить его и поэкспериментировать внутри.


# SQL

Управление структурой базы данных и данными внутри таблиц — две разных задачи, выполняющихся одним инструментом — языком SQL. SQL (Structured Query Language) — специализированный язык, разработанный для управления данными в реляционных СУБД.

SELECT * FROM users;


Он разрабатывается независимо от баз данных и имеет собственный стандарт, который с тем или иным успехом реализуют конкретные базы данных. Эта новость должна вас обрадовать, так как на базовом уровне все реляционные базы работают примерно одинаково. Научившись работать с одной базой, не сложно переключиться на другую. Как и в случае браузеров, которые пытаются поддерживать стандарты и имеют собственные расширения, базы данных также поддерживают основной SQL и местами дополняют его своими возможностями. На протяжении курса я буду стараться использовать только стандартные возможности SQL.

С его помощью выполняются практически все задачи внутри СУБД: начиная с управлением ролями и правами для них, заканчивая обновлением данных в таблицах конкретных баз данных. Даже создание базы данных выполняется с помощью SQL. SQL может быть как простым, так и очень сложным. Вряд ли существуют люди, которые знают его на 100%, но некоторый базис должны понимать все прикладные программисты.


Самостоятельная работа
Установите PgAdmin и подключитесь к СУБД, которую вы установили ранее. Для этого вам придется потратить некоторое время на изучение интерфейса программы http://www.postgresqltutorial.com/connect-to-postgresql-database/. Подробный гайд с картинками
Изучите интерфейс программы и существующие базы данных
*/

>>>>> Создание таблиц <<<<<<<

/*
Если вы ещё не создали базу данных hexlet, то самое время это сделать. Сейчас попробуем выполнить эту задачу, используя SQL. Подключитесь к СУБД через psql (не указывая базу данных) и выполните следующие запросы:
*/

DROP DATABASE hexlet;
CREATE DATABASE hexlet;

/*
Если подключиться к той же базе данных, которую вы хотите удалить или пересоздать, то во время попытки удаления СУБД будет ругаться на то, что к базе есть активное соединение (ваше). Именно поэтому важно подключиться к любой другой базе данных.

В примере выше два SQL запроса: один из них удаляет базу данных с именем hexlet, а другой создаёт базу данных с таким же именем. Рассмотрим базовые правила построения запросов:

Каждый запрос должен заканчиваться точкой с запятой. Иначе psql будет думать, что вы продолжаете вводить команды.
Регистр не важен. Можно было написать drop database hexlet;. По сложившейся традиции принято использовать верхний регистр для ключевых слов самого SQL. Это позволяет визуально разделять структуру запроса от данных внутри него: в примере выше это имя базы данных, которое может быть произвольным.
Те самые команды createdb и adduser — не что иное как обёртки, выполняющие SQL запросы внутри СУБД. Их сделали только ради удобства первоначальной настройки и для использования в скриптах автоматизации.

Кстати, SQL поддерживает комментарии. Любая строчка, начинающаяся с двух дефисов — комментарий. Комментарии игнорируются СУБД при построении запросов.
*/
hexlet=> -- i am comment
hexlet=>

// Следующая задача — создать таблицу:

-- Это один запрос, хоть и многострочный. Описание запроса заканчивается символом ;
CREATE TABLE courses (
    name          varchar(255),
    slug          varchar(255),
    lessons_count integer,
    body          text
);


/*
Запросы на создание таблиц принято форматировать так, как показано выше. Это облегчает чтение и анализ, но неудобно для работы в репле.

Этот запрос уже значительно сложнее предыдущего. Для создания таблицы обязательно указывается её имя и перечисляется набор полей с указанием их типов данных. В примере выше создаётся таблица courses с четырьмя полями: name, slug, lessons_count и body.

В отличии от языков программирования, где строка может иметь произвольный размер, в базах данных чаще всего используется специальный тип varchar (в pg его настоящее имя character varying, а varchar это псевдоним), который имеет фиксированный размер. Размер конкретого поля, имеющего такой тип, указывается в скобках после названия типа varchar(10). А вот тип text не требует указания размера и может содержать текст произвольной длины. Возникает резонный вопрос, зачем нужен varchar, когда можно использовать text и не думать о размерах. К сожалению, так не получится. Динамический размер типа text не даётся бесплатно. Если все строки делать текстом, то у приложения очень быстро начнутся проблемы с производительностью. Подробнее вопросы производительности рассмотрим в конце курса.

# Типы данных
Каждое поле в PostgreSQL имеет определённый тип, который задаётся на этапе создания таблицы. Это значит, что значением этого поля могут быть только определённые данные. Если поле имеет числовой тип, то в него невозможно вставить строку, и наоборот. База данных выдаст ошибку при попытке выполнить подобный запрос. PostgreSQL поддерживает большое количество встроенных типов и позволяет создавать свои (пользовательские). Вот основные:


# Числа

Имя     Размер      Описание                            Диапазон
integer 4 байта     типичный выбор для целых чисел      -2147483648 .. +2147483647
bigint  8 байт      целое в большом диапазоне           -9223372036854775808 .. 9223372036854775807

# Даты

Имя         Размер      Описание                            Наименьшее значение     Наибольшее значение     Точность
timestamp   8 байт      дата и время (без часового пояса)   4713 до н. э.           294276 н. э.            1 микросекунда
date        4 байта     дата (без времени суток)            4713 до н. э.           5874897 н. э.           1 день
time        8 байт      время суток (без даты)              00:00:00                24:00:00                1 микросекунда

Значения даты и времени принимаются практически в любом разумном формате, включая ISO 8601, SQL-совместимый и другие. Вот лишь несколько примеров того, как можно задавать дату:

Пример              Описание
1999-01-08          ISO 8601, 8 января в любом режиме (рекомендуемый формат)
January 8, 1999     воспринимается однозначно в любом режиме datestyle


# Логический тип

Имя     Размер  Описание
boolean 1 байт  состояние: истина или ложь

Состояние «true» может задаваться следующими значениями:
TRUE
't'
'true'
'y'
'yes'
'on'
'1'

Для состояния «false» можно использовать следующие варианты:
FALSE
'f'
'false'
'n'
'no'
'off'
'0'


# NULL
Как и в языках программирования, в базах данных присутствует специальное значение NULL, которое используется для пустых значений.


# Строки
Имя                                 Описание
character varying(n), varchar(n)    строка ограниченной переменной длины
text                                строка неограниченной переменной длины


# Просмотр списка таблиц

hexlet=> \d

         List of relations
 Schema |  Name   | Type  |  Owner
--------+---------+-------+---------
 public | courses | table | vagrant


# Просмотр структуры таблицы

hexlet=> \d courses
               Table "public.courses"
    Column     |          Type          | Modifiers
---------------+------------------------+-----------
 name          | character varying(255) |
 slug          | character varying(255) |
 lessons_count | integer                |
 body          | text                   |


# Полезные команды

\l - список всех баз данных
\dt - список всех таблиц

# Дополнительные материалы
Онлайн песочница для выполнения SQL запросов https://www.db-fiddle.com/
Типы данных https://postgrespro.ru/docs/postgresql/11/datatype
CREATE TABLE https://www.postgresql.org/docs/current/static/sql-createtable.html
*/


>>>>> Вставка и модификация данных <<<<<<<

/*
Со структурой закончили, теперь добавим данные. За манипуляцию данными в SQL отвечает подмножество DML (Data Modification Language), включающее в себя INSERT, UPDATE и DELETE запросы.

# Вставка (добавление) данных в таблицу
*/

INSERT INTO courses (name, slug, lessons_count, body)
  VALUES ('basics of programming', 'basics', 10, 'this is theory');

/*
В левой части этого запроса указывается таблица и, через пробел, в круглых скобках, список полей, которые нужно вставить. А справа от ключевого слова VALUES, значения этих полей, указанные в том же порядке. INSERT не является идемпотентным запросом: его повторное выполнение всегда приводит к попытке вставить ещё одну запись, даже если значения остались те же.

Если мы хотим оставить какие-то поля пустыми, то достаточно пропустить их при вставке в обеих частях запроса.
*/
INSERT INTO courses (name, slug) VALUES ('Bash', 'bash');

// INSERT позволяет вставить сразу несколько записей в рамках одного запроса:

INSERT INTO courses (name, slug) VALUES
  ('Bash', 'bash'), ('PHP', 'php'), ('Ruby', 'ruby');

/*
Для этого достаточно перечислить все необходимые значения в круглых скобках через запятую после ключевого слова VALUES.
Ну и последний вариант выполнения этой команды без перечисления полей. Если они не указаны, то это равносильно их полному перечислению:
*/  
INSERT INTO courses VALUES ('linux', 'linux', 3, 'something about linux');

/*
Обратите внимание на то, как записаны значения: числовое значение указано как есть, строковые взяты в одинарные кавычки (двойные использовать для этой цели нельзя).

На текущий момент в нашей таблице три записи. Для их извлечения предназначен SELECT запрос, который не является частью DML. Подробнее поговорим о нём в следующем уроке, а сейчас воспользуемся его базовой формой, которая позволяет извлечь всю таблицу и посмотреть её содержимое:

hexlet=> SELECT * FROM courses;
         name          |  slug  | lessons_count |         body
-----------------------+--------+---------------+-----------------------
 basics of programming | basics |            10 | this is theory
 bash                  | bash   |               |
 linux                 | linux  |             3 | something about linux
(3 rows)


# Обновление (изменение) данных

Обновление записей в таблице выполняется UPDATE запросом:
*/
UPDATE courses SET body = 'updated!' WHERE slug = 'bash';

/*
Обратите внимание на то, что = в WHERE части это не присваивание, а проверка на совпадение, хотя в SET равно уже используется как обычное присваивание.

Поскольку в нашей таблице только одна запись удовлетворяет условию slug = 'bash', то и обновится одна запись. Если бы их было больше, то обновились бы все соответствующие записи. UPDATE может быть как идемпотентным запросом, так и нет: всё зависит от того, как он написан. Конкретно в нашем случае он идемпотентен, то есть его повторные выполнения всегда приведут к одному и тому же результату.

За одну операцию можно обновить несколько полей. Для этого достаточно перечислить каждое присваивание через запятую в части SET. Порядок в котором изменяются поля — не важен:
*/
UPDATE courses SET body = 'updated!', name = 'Bash' WHERE slug = 'bash';

// Самое интересное происходит в части WHERE. Для начала стоит знать, что её можно не указывать:

UPDATE courses SET body = 'oops';

/*
Этот запрос обновит ВСЕ записи. Эта довольно распространённая и страшная ошибка. Если записей в таблице много и они важны, то такой запрос может повлечь за собой серьёзные последствия. Случаи, когда действительно нужно обновить сразу все записи таблицы, очень редки.

С другой стороны, не всегда достаточно простого сравнения по одному полю. Запросы с WHERE нередко требуют других операций, например, сравнения. SQL без проблем позволяет всё это делать, более того, он позволяет использовать логические выражения. Рассмотрим несколько примеров:
*/

// Операции сравнения
UPDATE courses SET name = 'new name' WHERE lessons_count > 3;
UPDATE courses SET name = 'another new name' WHERE lessons_count < 2;

// Логические операции
UPDATE courses SET name = 'new name'
  WHERE slug = 'bash' AND lessons_count > 3;

UPDATE courses SET name = 'another new name'
  WHERE lessons_count < 2 OR lessons_count > 8;

// Для логических операций используются ключевые слова AND и OR. Их можно добавлять и комбинировать в любых количествах. Как и в случае с обычными языками программирования, в составных выражениях полезно использовать явное задание приоритета за счёт круглых скобок.

UPDATE courses SET name = 'another new name'
  WHERE (lessons_count < 2 AND lessons_count > 8) OR slug = 'linux';

# Удаление данных

DELETE FROM courses WHERE slug = 'bash';

/*
В базах данных есть ещё один способ удалять данные в таблице — TRUNCATE. Он не является частью стандарта, но реализован большинством баз данных. У него две особенности:

Он предназначен для полной очистки таблиц.
В отличие от DELETE, он выполняется очень эффективно.
TRUNCATE courses;

Дополнительные материалы
INSERT https://www.postgresql.org/docs/current/static/sql-insert.html
UPDATE https://www.postgresql.org/docs/current/static/sql-update.html
DELETE https://www.postgresql.org/docs/current/static/sql-delete.html
TRUNCATE https://www.postgresql.org/docs/current/sql-truncate.html
*/



>>>>> Выборка данных <<<<<

/*
Операция SQL, с которой чаще всего соприкасаются программисты, — SELECT. В типичных веб-приложениях данные выбираются в 10 раз чаще, чем модифицируются. SELECT невероятно мощная команда, и именно большая часть вопросов на собеседованиях посвящена умению им пользоваться.

В самостоятельной работе одного из прошлых уроков был указан репозиторий pg-dump-example, в котором содержится структура и данные для БД hexlet. Если вы ещё не загрузили данные в базу, то самое время это сделать. Не забудьте выполнять все запросы этого урока в базе hexlet через REPL psql.

Самая простая форма запроса SELECT выглядит так:
*/
SELECT * FROM users;

// Этот запрос достаёт всё содержимое таблицы users. Звёздочка в данном примере означает "все поля". Если поля нужны не все, то достаточно перечислить их через запятую (вместо звёздочки):

SELECT username, email FROM users;

/*
Поля не обязательно перечислять в том же порядке, в котором они идут в таблице. Более того, в результате такого запроса порядок полей в выводе будет соответствовать не тому, что в таблице, а тому, что указано в части SELECT.

На практике выборка, которая извлекает все записи, встречается редко из-за объёмов таблиц и необходимости ограничивать вывод для конкретного пользователя. В этом случае используется WHERE, который мы рассматривали в прошлом уроке. Он работает одинаково вне зависимости от типа выполняемого запроса, будь-то UPDATE, DELETE или SELECT.

После WHERE указывается имя поля, которое сравнивается с некоторым значением (это один из вариантов)
Выбираем всех пользователей, родившихся ранее 21 октября 2018 года
*/
SELECT * FROM users WHERE birthday < '2018-10-21';

/*
И даже в таком варианте количество возможных записей может быть слишком большим. Думаю, вы не раз видели пейджинг на страницах поисковых систем, когда результаты поиска разбиваются на страницы по 10 элементов, а пейджинг позволяет перемещаться по ним. Конечно, этот механизм можно реализовать целиком в коде. Но так не делают, потому что количество данных, перегоняемых из базы данных в код, может быть огромным. На такую задачу не хватит никаких ресурсов сервера. Поэтому пейджинг реализуют на уровне базы данных. Для его реализации используют LIMIT.
*/
SELECT * FROM users LIMIT 3;

/*
Этот запрос выберет не больше 3-х записей. Если в таблице их меньше, то выберутся все, что есть: 0, 1 или 2. Меняя количество записей в лимите, мы увеличиваем или уменьшаем выборку.

Однако, SQL НЕ гарантирует никакого порядка в выборках выше. Если явно не указать сортировку, то мы не можем достоверно знать, в каком порядке вернутся данные. Поэтому в подобных выборках всегда присутствует секция ORDER BY:
*/
SELECT * FROM users ORDER BY birthday;

// Такой запрос отсортирует данные по ключу birthday в прямом порядке: кто родился раньше — будет выше. Если нужно отсортировать в обратном порядке, то надо добавить ключевое слово DESC (англ. descending — "убывающий").

SELECT * FROM users ORDER BY birthday DESC;

// На этом базовые возможности SELECT заканчиваются. Все части запроса, которые мы рассмотрели, комбинируются друг с другом и даже могут использоваться одновременно:

SELECT username, created_at FROM users WHERE birthday < '2018-10-21' ORDER BY birthday DESC LIMIT 2;

/*
Порядок следования частей WHERE, ORDER BY и LIMIT в SQL запросе не фиксирован, но, как правило, их записывают в том же порядке, что и в запросе выше.

Для удобства, длинные запросы разбивают на строчки:
*/
SELECT username, created_at FROM users
  WHERE birthday < '2018-10-21'
  ORDER BY birthday DESC
  LIMIT 2;



>>>>> Реляционная модель данных <<<<<<<  

/*
Основой логики работы в реляционных СУБД является реляционная алгебра, именно поэтому в подобных системах добавляют приставку "реляционная". Если посмотреть книги, посвященные базам данных (особенно университетские), то они в обязательном порядке дают её, и иногда в больших количествах.

# Иерархическая модель

Существует множество разных способов представить одни и те же данные. Один из первых широко используемых способов — иерархическая модель. В такой модели данные представлены в виде дерева, где дочерние элементы находятся в зависимости от родительских. Самый яркий пример древовидной структуры — файловая система (ФС). Вероятно, будет сюрпризом для вас, что файловая система — это база данных, а операционная система ведёт себя, как СУБД по отношению к ФС. Однако то, как мы видим данные и как они хранятся в реальности (на диске) — две большие разницы. Физическое размещение данных на носителях — прерогатива конкретных СУБД, и здесь они соревнуются, кто быстрее и эффективнее. А вот их внешнее представление — это то, что видит пользователь, и оно очень сильно влияет на способ взаимодействия с данными. Именно поэтому разные способы представления данных называются моделями. Эти модели не отражают то, что происходит на самом деле (на физическом уровне), они лишь описывают то, как данные структурированы и как с ними можно взаимодействовать. Модели данных очень похожи на абстрактные типы данных, которые определяют интерфейс взаимодействия с типом и не определяют его внутреннюю реализацию.

# Сетевая модель

Эта проблема решается в сетевой модели данных, которая расширяет иерархическую возможностью иметь множество предков. По сути, сетевая модель представляет из себя граф. В сетевой структуре каждый элемент может быть связан с любым другим элементом.

Недостатком сетевой модели данных являются высокая сложность и жесткость схемы БД, построенной на её основе. Поскольку логика процедуры выборки данных зависит от физической организации этих данных, то эта модель не является полностью независимой от приложения. Другими словами, если необходимо изменить структуру данных, то нужно изменить и приложение.

# Реляционная модель

В конечном итоге, наибольшее распространение получила реляционная модель данных. Именно на её основе построены РСУБД (реляционные СУБД). В реляционной модели данные представляют собой набор отношений. Формальное определение понятия отношение звучит так:

Пусть дана совокупность типов данных T1, T2, ..., Tn, называемых также доменами, не обязательно различных. Тогда n-арным отношением R, или отношением R степени n называют подмножество декартовa произведения множеств T1, T2, ..., Tn.

Отношение — это, как вы уже догадались, математическое понятие, у него нет физического представления. Часто, для упрощения, говорят, что отношение это как таблица. Такое сравнение, хоть и кажется соблазнительным, но создаёт неверное представление о реальной природе и особенностях отношений. В этом смысле реляционная база данных это лишь попытка отразить реляционную модель, а не её точная копия.

Реляционная модель очень сильно опирается на теорию множеств, которую нужно знать хотя бы немного. Теория множеств, в своей базе, довольно простой и интуитивно понятный раздел математики. Центральное понятие теории множеств — множество, совокупность произвольных элементов, объединённых по какому-либо признаку, например, множество натуральных чисел (бесконечное множество) или множество учеников одного класса (конечное множество). В свою очередь, из любого множества можно выделить подмножество. То есть множество элементов, которое меньше исходного, но содержащее только лишь элементы исходного множества.


Например, множество натуральных чисел является подмножеством по отношению к множеству целых чисел, которое в свою очередь является подмножеством рациональных чисел. Из чего, кстати, следует что натуральные числа являются подмножеством и рациональных чисел.

Еще одно важное понятие — кортеж. Кортеж — это упорядоченный набор данных фиксированной длины. Элементами кортежа может быть всё, что угодно. В принципе, больше ничего интересного в кортежах нет, это всего лишь математический способ представить некоторый набор связанных данных.

Теперь мы знаем достаточно для изучения отношений. Отношение — это множество кортежей, называемых телом отношения, в котором каждый кортеж соответствует схеме. Схема — это заголовок отношения, она описывает общую структуру кортежей, количество элементов внутри них и их типы. Каждый такой элемент называется атрибутом.

Несмотря на визуальную схожесть с таблицей, у отношений есть существенные отличия:В отношении нет двух одинаковых элементов (кортежей).
 - В отношении нет двух одинаковых элементов (кортежей).
 - Порядок кортежей в отношении не определён.
 - Порядок атрибутов в заголовке отношения не определён.

Именно эти аспекты делают таблицу непригодной для точного описания понятия "отношение". В любой таблице порядок столбцов (соответствуют аттрибутам схемы) и строк (соответствуют кортежам) строго определён. Но не следует путать теорию с практикой. На практике мы оперируем таблицами и не можем игнорировать их природы. Во всех реляционных базах данных столбцы расположены в определённом порядке, и данные тоже добавляются строго определённым образом. Другое дело, что этот порядок зависит от реализации самой базы данных и не может быть задан явно (он задаётся при выборке).

Как это ни странно, но реляционная модель оказывается удачным выбором в подавляющем большинстве ситуаций, и она не обладает недостатками, присущими другим моделям. Именно поэтому она приобрела столь широкое распространение. Но она требует время на освоение и привыкание, потому что придётся начать мыслить иначе. Для взаимодействия с данными, описанными реляционной моделью используется реляционная алгебра (элементы которой рассмотрим позже).

С точки зрения теории, данные, представленные в реляционной модели, должны быть нормализованы, то есть приведены к нормальной форме. Нормальная форма — это некоторые требования, которым должно удовлетворять отношение для минимизации избыточности данных, потенциально приводящих к логическим ошибкам. Всего существует 6 нормальных форм, от первой до шестой. С каждым следующим уровнем требования всё жёстче и включают в себя все предыдущие уровни. Вот определения первых трех (не пытайтесь их понять и запомнить):

1. Переменная отношения находится в первой нормальной форме (1НФ) тогда и только тогда, когда в любом допустимом значении отношения каждый его кортеж содержит только одно значение для каждого из атрибутов.

2. Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо (функционально полно) зависит от её первичного ключа.

3. Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

В таком виде, эта информация понятна только студентам профильных вузов. Поэтому дальше разговор пойдет о практических аспектах нормальных форм. В следующих уроках, мы познакомимся с тремя первыми формами, так как они наиболее часто используются в реальной разработке. Причём программисты, которые часто работают с базами данных, даже не помнят, теорию связанную с формами. Единожды поняв, как структурируются данные в реляционной модели, мозг самостоятельно предлагает правильные решения по тому, как разложить данные.


Дополнительные материалы
Основы реляционной алгебры https://habr.com/post/145381/
Реляционная модель данных https://ru.wikipedia.org/wiki/Реляционная_модель_данных
*/



>>>>>> Первая нормальная форма <<<<<<

/*
Возьмем для примера обычный интернет-магазин, в котором продается электроника. Каждый раз когда пользователь делает заказ, в базу данных заносится запись об этом (в таблицу order_items). В нее входит вся необходимая информация: какой товар купил пользователь, сколько он стоил, адрес доставки и другое. Затем эти данные используются всеми подразделениями интернет-магазина, начиная от бухгалтеров, заканчивая службой доставки.

order_items

first_name  last_name   address                     item                price
Сергей      Иванов      Москва, ул. Промышленная    утюг                15.00
Иван        Петров      Самара, ул. Энгельса        кофеварка           5000.00
Виктор      Сидоров     Омск, ул. Дворцовая         утюг, телевизор     1000.00, 6500.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук             20000.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук             20000.00

В последнем столбце, у первой строки цена указана в долларах, в остальных записях это рубли. Последняя запись повторяет предыдущую, потому что этот заказ выполнил тот же человек, но сделал это в другое время

Невооруженным взглядом видно, что в этой табличке много повторяющейся информации. Попробуем привести ее к правильной структуре, с точки зрения реляционной модели. Для этого пройдемся по нормальным формам.

Первая нормальная форма сводится к трем правилам:
1. Каждая ячейка таблицы может хранить только одно значение
2. Все данные в одной колонке могут быть только одного типа
3. Каждая запись в таблице должна должна однозначно отличаться от других записей

# Каждая ячейка – одно значение

В примере выше, у одной записи, поля item и price содержат два значения, разделенных запятой. Такой способ организации данных имеет множество недостатков. Например пропадает возможность делать обычную выборку по условиям:
-- Как найти записи о всех проданных утюгах?
*/
SELECT * from order_items WHERE item = "?"

/*
Другая проблема связана с типами данных. Поле прайс в таблице order_items имеет числовой тип (numeric). Если мы захотим хранить там более одного значения, то тип превратиться в строковой, а все данные станут обычными строками. При такой организации, невозможно проверить корректность данных, формат числа. Становится, крайне, проблематично выполнить агрегирующие запросы, например, посчитать выручку за определенный месяц одним запросом.

Избавиться от перечислений в ячейках можно через создание новых записей:

first_name  last_name   address                     item        price
Сергей      Иванов      Москва, ул. Промышленная    утюг        15.00
Иван        Петров      Самара, ул. Энгельса        кофеварка   5000.00
Виктор      Сидоров     Омск, ул. Дворцовая         утюг        1000.00
Виктор      Сидоров     Омск, ул. Дворцовая         телевизор   6500.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00

# Данные одного типа

Верхняя запись в выводе выше, содержит цену указанную в долларах, хотя все остальные цены указаны в рублях. Чисто технически, база никак не укажет на это. Что доллары, что рубли выше представлены числами, но, с точки зрения программы, эти числа имеют совершенно разную природу.

Как и в предыдущем случае, разные данные в рамках одного поля делают невозможным выполнение агрегирующих запросов (поиск сумм, максимального, минимального). Кроме того, усложняется обработка данных на уровне кода. В коде придется каким-то образом понимать, что из себя представляют данные.

Вот еще несколько примеров, с похожей ситуацией:

 - Хранение даты свадьбы в поле "день рождения"
 - Хранение телефона вместо адреса в поле "адрес"
Исправленная версия таблицы:


first_name  last_name   address                     item        price
Сергей      Иванов      Москва, ул. Промышленная    утюг        1000.00
Иван        Петров      Самара, ул. Энгельса        кофеварка   5000.00
Виктор      Сидоров     Омск, ул. Дворцовая         утюг        1000.00
Виктор      Сидоров     Омск, ул. Дворцовая         телевизор   6500.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00
Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00

# Уникальные записи

Обратите внимание на последние две записи. Они выглядят идентично, хотя это два разных заказа сделанных одним человеком в разное время. Вероятно он купил ноутбук сначала для себя, а потом для супруги.

Реляционная модель требует от нас уникальности каждой записи. Для чего это нужно? Иначе невозможно понять что к чему относится и с какой записью нужно работать при изменениях. Очень легко начать править не то и потерять важную информацию. Причем мы даже не можем полагаться на порядок данных внутри таблицы, ведь он не гарантирован.

Реализовать уникальность можно несколькими способами, например, добавить новых полей, которые сделают запись уникальной, например дату заказа. Этот способ не очень надежный, а главное не очень удобный в работе. Придется постоянно анализировать весь набор полей. Гораздо лучше добавить первичный ключ.

Первичный ключ это поле или набор полей, которое содержит уникальное значение для каждой записи. Первичный ключ не может меняться, его значение однозначно определяет любую запись в таблице.

На практике составные ключи используются редко из-за неудобства работы с ними

В качестве первичного ключа можно использовать какое-то значение из окружающего мира, например email или ФИО, но нужно однозначно убедиться что ключ не будет повторяться. Такой первичный ключ называется естественным. Естественные ключи используют редко, из-за их не надежности. Почти наверняка они не уникальны и могут изменяться или повторяться. Например номер паспорта меняется при смене паспорта.

Другой подход основан на использовании автоматически генерируемых уникальных значениях. Такой первичный ключ называется суррогатным и поддерживается любой базой данных "из коробки". Иногда это просто числа, а иногда и сложные число-буквенные строки (хеши). Добавим в нашу таблицу первичный ключ:

id  first_name  last_name   address                     item        price
8   Сергей      Иванов      Москва, ул. Промышленная    утюг        1000.00
2   Иван        Петров      Самара, ул. Энгельса        кофеварка   5000.00
7   Виктор      Сидоров     Омск, ул. Дворцовая         утюг        1000.00
4   Виктор      Сидоров     Омск, ул. Дворцовая         телевизор   6500.00
9   Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00
6   Сергей      Иванов      Москва, ул. Матросова       ноутбук     20000.00

Первичный ключ принято создавать первым полем с названием id. Для первичного ключа обязательно указывать PRIMARY KEY в описании таблицы:
*/
CREATE TABLE products (
    id bigint PRIMARY KEY,
    first_name varchar(255),
    address varchar(255)
    address varchar(255),
    price numeric // специальный тип данных, подходящий под работу с деньгами. Обеспечивает высокую точность при расчетах.
);

/*
Такой ключ все еще нужно формировать самостоятельно (с автогенерацией мы познакомимся позже), но теперь, база данных сама следит за уникальностью. При попытке создать запись с повторяющимися первичными ключами возникнет ошибка.

# Дополнительные материалы
Первичный ключ https://ru.wikipedia.org/wiki/Первичный_ключ
Внешний ключ https://ru.wikipedia.org/wiki/Внешний_ключ
Суррогатный ключ https://ru.wikipedia.org/wiki/Суррогатный_ключ
*/



>>>>>> Вторая нормальная форма <<<<<<


/*
Вторая нормальная форма включает в себя два пункта:
- Таблица должна быть в первой нормальной форме
- Все аттрибуты (не ключевые) таблицы должны зависеть от первичного ключа

Зависимость от первичного ключа означает что этот аттрибут имеет такое значение именно в данном контексте. Предположим что в примере выше, Сергей это всегда один и тот же человек, делающий заказ на разные адреса. В таком случае видно, что адрес привязан к конкретному заказу. Это и есть зависимость от первичного ключа. А вот имя пользователя и его фамилия с заказом никак не связано. Оно имеет отношение к самому пользователю.

Согласно второй форме, атрибуты first_name и last_name необходимо вынести в свою таблицу, которая будет отвечать за пользователей:

users

id  first_name  last_name
2   Сергей      Иванов
3   Иван        Петров
5   Виктор      Сидоров


В этой таблице всего три записи, потому что у нас три уникальных пользователя. Каждому из этих пользователей присваивается свой уникальный номер (первичный ключ).

Теперь нужно связать таблицу order_items с таблицой users. Делается это через указание первичных ключей в зависимых таблицах. Ниже пример:


id  user_id     address                     item        price
8   2           Москва, ул. Промышленная    утюг        1000.00
2   3           Самара, ул. Энгельса        кофеварка   5000.00
7   5           Омск, ул. Дворцовая         утюг        1000.00
4   5           Омск, ул. Дворцовая         телевизор   6500.00
9   2           Москва, ул. Матросова       ноутбук     20000.00
6   2           Москва, ул. Матросова       ноутбук     20000.00

Мы удалили first_name, last_name и добавили user_id. В этом поле хранятся идентификаторы пользователей, а само поле называется внешним ключом (или вторичным).

Такую же операцию нужно произвести и с товаром. Вынесем item в свою таблицу:

goods

id  name
50  утюг
30  кофеварка
20  телевиозор
33  ноутбук


id  user_id     address                     good_id price
8   2           Москва, ул. Промышленная    50  1000.00
2   3           Самара, ул. Энгельса        30  5000.00
7   5           Омск, ул. Дворцовая         50  1000.00
4   5           Омск, ул. Дворцовая         20  6500.00
9   2           Москва, ул. Матросова       33  20000.00
6   2           Москва, ул. Матросова       33  20000.00


Важно понимать, что внешний ключ это не ссылка. Таблицы существуют сами по себе и во внешнем ключе указывается конкретное значение, которое должно совпадать с первичным ключом другой таблицы.

Синтаксис определения вторичного (внешнего) ключа:

REFERENCES <название таблицы на которую смотрим> (<список полей в той таблице, которым соответствуем>)

-- Внешних ключей может быть любое количество: сколько ссылок — столько и ключей
*/

CREATE TABLE orders (
    id bigint PRIMARY KEY,
    // Тип внешнего ключа должен быть такой же, как у первичного в той таблице, куда ссылается внешний
    user_id bigint REFERENCES users (id),
    // остальные поля
);

/*
Для чего это нужно? Таким образом автоматически поддерживаются гарантии корректности. Например, невозможно удалить запись из основной таблицы, если на эту запись есть ссылки из внешних ключей в другой таблице. Это очень важно для соблюдения целостности, чтобы случайно не завести базу данных в неконсистентное состояние (то есть такое состояние, при котором данные ссылаются на несуществующие данные).

Дополнительные материалы
Потенциальный ключ https://ru.wikipedia.org/wiki/Потенциальный_ключ
*/



>>>>> Третья нормальная форма <<<<<<<

// Текущая структура:

/*
id  first_name  last_name
2   Сергей      Иванов
3   Иван        Петров
5   Виктор      Сидоров


id  name
50  утюг
30  кофеварка
20  телевиозор
33  ноутбук

id  user_id address                     good_id     price
8   2       Москва, ул. Промышленная    50          1000.00
2   3       Самара, ул. Энгельса        30          5000.00
7   5       Омск, ул. Дворцовая         50          1000.00
4   5       Омск, ул. Дворцовая         20          6500.00
9   2       Москва, ул. Матросова       33          20000.00
6   2       Москва, ул. Матросова       33          20000.00


Третья нормальная форма, так же как и вторая, включает в себя два пункта:
 - Таблица должна быть в второй нормальной форме
 - Все колонки в таблице зависят от первичного ключа и не зависят друг от друга
Стоимость заказа зависит от цены товара, но в то же время, цена товара, как это ни странно, зависит от самого товара, то есть от good_id. Для приведения таблицы к третьей формы, нам нужно вынести цену в товар:

id  name        price
50  утюг        1500.00
30  кофеварка   5000.00
20  телевиозор  6500.00
33  ноутбук     20000.00

И наша таблица преобретает такой вид:


id  user_id     address                     good_id
8   2           Москва, ул. Промышленная    50
2   3           Самара, ул. Энгельса        30
7   5           Омск, ул. Дворцовая         50
4   5           Омск, ул. Дворцовая         20
9   2           Москва, ул. Матросова       33
6   2           Москва, ул. Матросова       33


С одной стороны, мы выполнили большую часть необходимой нормализации, с другой, новая структура имеет фатальный недостаток. Цена товара, вещь изменяемая, а вот стоимость покупки которую мы совершили в прошлом – нет. Но если нормализация выполнена целиком, то при изменении цены заказа, измениться стоимость абсолютно всех совершенных покупок, в которые входил данный товар. С точки зрения бухгалтерии и истории покупок это недопустимо.

Это значит, что цена товара должна копироваться в таблицу good_items. Но и в таблице goods она тоже нужна. В первую очередь для вывода на сайте на витрине.

А что насчет адреса? Адрес тоже зависит от пользователя, но более сложным образом. Один пользователь может иметь несколько адресов (от нуля до бесконечности). Учитывая все что мы говорили про нормальные формы, перенести адреса в таблицу пользователей нельзя. Мы не можем хранить несколько значений в одной колонке и не можем дублировать записи, так как нарушится уникальность первичного ключа.

Правильное решение – завести под адреса свою собственную таблицу. В этой таблице адрес будет связан с пользователем, а вместо поля address в таблице заказов появится поле user_address_id.

Так, по крайней мере, мы бы поступили в теории. На практике же, неизвестно нужно ли выносить адрес или нет, все зависит от конкретной бизнес-логики конкретного приложения.
*/

>>>>> Автоинкремент <<<<<<<

/*
На протяжении последних уроков мы создавали значения первичных ключей самостоятельно. Так можно делать в учебных целях, но в промышленной разработке эту задачу берут на себя базы данных. Общий принцип механизма автогенерации такой: внутри базы к каждой таблице создаётся и привязывается отдельный счётчик, который увеличивается на единицу при вставке новой строки, а получившееся значение записывается в то поле, которое помечено как автогенерируемое.

До определённого момента механизм автоинкремента в каждой СУБД был реализован по-своему, иногда значительно отличающимися способами. Это создавало проблемы при переходе от одной базы данных к другой и усложняло реализацию программного слоя доступа к базе данных. Причём эта функциональность добавлена в стандарт SQL:2003, то есть очень давно. И только в 2018 году PostgreSQL (начиная с версии 10) стал его поддерживать. Такой автоинкремент известен под именем GENERATED AS IDENTITY:
*/
CREATE TABLE colors (
  // Одновременное использование и первичного ключа и автогенерации
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name varchar(255)
);

INSERT INTO colors (name) VALUES ('Red'), ('Blue');

SELECT * FROM colors;

/* => 
Этот запрос вернёт:

id  name
1   Red
2   Blue


Интересно поведение автогенератора при удалении записей. Если удалить запись с id равным двум и вставить ещё одну запись, то значением поля id будет 3. Автогенерация никак не связана с данными в таблице. Это отдельный счётчик, который всегда увеличивается. Таким образом избегаются вероятные коллизии и ошибки, когда один и тот же идентификатор принадлежит сначала одной записи, а потом другой.

Вот его структура из документации:

column_name type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]

Тип данных может быть SMALLINT, INT или BIGINT
GENERATED ALWAYS — не позволит добавлять значение самостоятельно, используя UPDATE или INSERT
GENERATED BY DEFAULT — в отличие от предыдущего варианта, этот вариант позволяет добавлять значения самостоятельно

PostgreSQL позволяет иметь более одного автогенерируемого поля на таблицу.
*/



>>>>> Онтология <<<<<<<

/*
Рассмотрим как пример Хекслет, так как вы с ним достаточно хорошо знакомы. Вы неплохо знаете его предметную область, хотя вряд ли думали о ней так, как мы сделаем сейчас. В первую очередь, для её понимания нужно выделить ключевые понятия, а именно сущности, вокруг которых строится вся логика. У обучающих ресурсов это, как правило, "курс" и "урок". Но на самом деле сущностей гораздо больше. В случае Хекслета ещё можно выделить профессию, испытание (практика после курса), code review, квиз (набор вопросов и ответов), участника курса (вы становитесь участником, когда вступаете в курс), проект. Этот список можно продолжать ещё долго. Но сущности не существуют сами по себе, они находятся в некоторых взаимоотношениях друг с другом. Например, квиз содержит (агрегирует) в себе вопросы, которые, в свою очередь, содержат в себе ответы. Профессия состоит из курсов, а курсы из уроков, уроки — из теории, квиза и практики. Эти связи имеют конкретные названия. Например, один урок может находиться только в одном курсе, но курс содержит множество уроков. Такая связь называется один ко многим (one-to-many или o2m). В свою очередь, один курс могут проходить множество пользователей, и один пользователь может проходить много курсов. Такая связь уже называется многие ко многим (many-to-many или m2m). Реже встречается связь один к одному (one-to-one или o2o). На Хекслете такая связь установлена между пользователем и экспертом.

Описание объектов рассматриваемой области и связей между ними называется онтологией предметной области. Эту онтологию хорошо знают эксперты соответствующей области: в бухгалтерии — бухгалтер, в обучении — преподаватель. Но, в отличие от программистов, они часто представляют её на интуитивном уровне, неформально. На практике программисты (или бизнес-аналитики и менеджеры) общаются с заказчиками, которые могут сами выступать в роли экспертов и строят вместе с ними формальную онтологию (этот процесс происходит постоянно в процессе развития проекта и не выделяется в отдельный этап проектирования). То есть выделяют конкретные термины, договариваются о том, что они означают и как связаны друг с другом. Затем, используя ER-модель, программист формирует необходимую модель данных. Не обязательно на бумаге или в специализированных программах, чаще такая модель существует только в голове и коде.

Именно эта модель и становится основной для проектирования базы данных. Каждая сущность в реляционной базе данных представлена таблицей, а связи между сущностями реализуются через внешние ключи.

# Entity-Relationship Diagram

В ERD, каждая сущность представлена блоком, в котором перечисляются поля. Между блоками рисуются линии, имеющие некоторые заранее определенные концы, они определяют тип связи между сущностями.

Виды связей
# Один ко Многим (one2many)
Наиболее распространенный вид связи. Например, у одного человека может быть много машин, телефонов, ноутбуков и так далее (все вещи, находящиеся в индивидуальной собственности). Технически, такая связь организуется через внешний ключ, добавленный в зависимую сущность (ту, которая "many").

users

id  first_name  last_name   created_at
1   Сергей      Петров      11.10.2005
38  Иван        Носов       03.08.2000
22  Виктор      Пирогов     23.12.2011

emails

id  user_id email
1   1       serj@gmail.com
2   1       petrov@mail.ru
10  38      ivan@yahoo.com
22  22      vkurg@indbox.com

Если мы хотим узнать все емейлы, которые есть у пользователя с идентификатором 1, то нужно выполнить такой запрос:
*/
SELECT * FROM emails WHERE user_id = 1

/*
# Один к Одному
Например у каждой страны есть ровно одна столица:

countries

id  name    created_at
2   Russia  11.10.2005
38  Spain   03.08.2000
22  Germany 23.12.2011

cities

id  name        country_id  capital created_at
34  Moscow      2           true    11.10.2005
33  Valencia    38                  03.08.2000
99  Voronez     2                   23.12.2011
4   Ulyanovsk   2                   23.12.2011
5   Berlin      22  true            23.12.2011

Связь o2o, обычно существует не сама по себе, а внутри связи o2m. То есть у каждой страны есть города, но только один из них столица.


# Многие ко многим (many2many)

many2many встречается очень часто:
- У каждого человека множество друзей, каждый человек друг для множества других.
- Один человек проходит множество курсов, один курс проходится множеством людей.

Эта связь реализуется уже не так просто. Технически невозможно связать две таблицы связью многие ко многим без введения третьей таблицы.

users

id  first_name  created_at
2   Сергей      11.10.2005
38  Иван        03.08.2000
22  Виктор      23.12.2011

courses

id  name            created_at
8   PHP basics      11.10.2005
55  Python basics   03.08.2000
22  Ruby basics     23.12.2011

course_members

id  user_id     course_id   created_at
34  2           8           11.10.2005
33  38          55          03.08.2000
99  22          22          23.12.2011
4   22          8           23.12.2011
5   38          2           23.12.2011

Здесь исходные таблицы — это users и courses, а связующая — course_members. Она имеет свой первичный ключ, и каждая запись содержит ссылки как на конкретный курс, так и на конкретного пользователя. На Хекслете эта таблица начинает заполняться в тот момент, когда пользователь нажимает кнопку "Вступить в курс". Для данного пользователя создаётся запись с его идентификатором и идентификатором курса, который он собрался проходить.

Если мы захотим узнать все курсы, которые проходит пользователь, то выполним такой запрос:
*/
SELECT course_id FROM course_members WHERE user_id = 3;

// Если захотим узнать, кто проходит данный курс, то такой запрос:
SELECT user_id FROM course_members WHERE course_id = 3;

/*
Такая структура соблюдается для любых двух сущностей, которые надо связать. В общем виде схема выглядит так: Есть исходные таблицы A и B. Для них создаётся новая таблица AB, внутри которой есть два внешних ключа — a_id и b_id, которые связаны с исходными таблицами.

Как показывает жизнь, такая промежуточная таблица почти наверняка становится самостоятельной сущностью. Если брать курсы, то важно понимать закончил ли пользователь курс или нет, хочется знать когда конкретно он сделал, сколько заданий решил и так далее. Вся эта информация может храниться только в одном месте, именно в той связанной таблице.

# Дополнительные материалы
Онтология (информатика) https://ru.wikipedia.org/Онтология_(информатика)
*/

>>>>> Создание базы данных <<<<<<<

/*
Локаль - набор параметров, определяющий региональные настройки пользовательского интерфейса, такие как язык, страна, часовой пояс, набор символов и т. п.

Документация:
CREATE DATABASE / PostgreSQL Manual: https://www.postgresql.org/docs/9.0/static/sql-createdatabase.html

По умолчанию пользователь, из учетной записи которого выполнялась команда создания, является владельцем (owner) только что созданной БД.
*/ 

$ psql -U postgres // подключаемся к СУБД от имени пользователя postgres
CREATE DATEBASE test; // создание БД test
\? // справка по cлужебным командам
\l // список БД
ALTER DATEBASE test RENAME TO test2; // переименование БД
ALTER DATEBASE test OWNER TO vagrant; // изменение владельца БД
DROP DATABASE test2; // удаление БД test2
\q // выход из клиента

$ create -U postgres test // создаем БД из под пользователя postgres не заходя в клиент 
$ dropdb -U postgres test // удаляем БД из под пользователя postgres не заходя в клиент 

// В случаях когда название сущности в базе (например таблицы) состоит из не цифро-буквенных символов или совпадает с ключевыми словами самого sql, то имена заключают в двойные кавычки.


>>>>> Создание таблицы <<<<<<<

$ psql -U postgres 
$ \c hexlet // подключаемся к БД hexlet
$ \d // список таблиц
$ \d products // describe: просмотреть информацию о таблице

// file: ddl.sql

CREATE TABLE products ( // создание таблицы products
	product_no integer,
	product boolean, 
	name character varying, // character varying похож на varchar в MYSQL
	description text,
	count integer,
	price numeric, // хранение дробных чисел
	created_at timestamp // есть вариант с timezone
);

// в PostgreSQL действует строгая типизация

$ psql -U postgres hexlet < ddl.sql // перенаправляем поток - отправляем содержимое файла в БД


>>>>> Ограничения <<<<<<<

/*
Первичные и внешние ключи в базах данных относятся к понятию Constraints ("ограничения"). Оно включает в себя различные модификаторы колонок в базе данных, добавляющие ограничения на их содержимое. В этом уроке мы вспомним, что уже проходили, а заодно рассмотрим новые и крайне полезные ограничения.

# Первичный ключ

Первичный ключ однозначно идентифицирует каждую запись внутри таблицы. Задаётся с помощью фразы PRIMARY KEY, которая добавляется после указания типа при создании таблицы. Первичный ключ в таблице может быть только один и, как правило, для него используется суррогатный ключ — идентификатор, который не имеет никакого физического смысла.
*/
CREATE TABLE products (
    id integer PRIMARY KEY,
    name text,
    price numeric
);

/*
# Внешний ключ

Ограничение, которое связывает указанную колонку с данными из другой таблицы. Это ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведёт к ошибке.
*/

CREATE TABLE orders (
    id integer PRIMARY KEY,
    product_id integer REFERENCES products (id),
    quantity integer
);

/*
В данной таблице атрибут product_id связан с атрибутом id таблицы products. Как это проявляется:

Если попробовать вставить в orders запись со значением product_id, которого нет в таблице products, то возникнет ошибка.
Если попытаться удалить запись из products, на которую есть ссылки из таблицы orders, то возникнет ошибка.
Количество внешних ключей не ограничено, все связи нужно обязательно отмечать (объявлять с помощью ключевых слов), иначе возможно нарушение целостности.

# Not Null

Это ограничение указывает на то, что колонка не может содержать null значения. Его можно комбинировать с другими ограничениями, например, внешними ключами. Первичный ключ является Not Null по умолчанию.
*/
CREATE TABLE products (
    id integer PRIMARY KEY,
    name text NOT NULL,
    price numeric
);

CREATE TABLE orders (
    id integer PRIMARY KEY,
    product_id integer REFERENCES products (id) NOT NULL,
    quantity integer
);

/*
# Уникальность

Для гарантии уникальности значений одного поля используется ключевое слово UNIQUE.
*/
CREATE TABLE products (
    id integer PRIMARY KEY,
    name text UNIQUE,
    price numeric
);

// Иногда бывает нужно реализовать уникальность по двум или более атрибутам. Для этого нужно описать UNIQUE отдельно от конкретного поля:

CREATE TABLE products (
    id integer PRIMARY KEY,
    name text,
    locale varchar,
    price numeric,
    UNIQUE(name, locale)
);

// UNIQUE никогда не используется совместно с первичным ключом, так как он уникален по определению.


CREATE TABLE products ( // создание таблицы products
	product_no integer NOT NULL, // ограничение не-null - колонка не должна содержать значение null.
	product_no integer UNIQUE, // ограничения уникальности - данные, содержащиеся в колонке или группе колонок являются уникальными по отношению к другим строкам в той же таблице
	product_no integer PRIMARY KEY // первый ключ
	product_no integer UNIQUE NOT NULL, // ограничение первичного ключа
	UNIQUE(product_no, count); // ограничение на группу столбцов. Комбинация полей должна быть уникальной, но не внутри.
	price numeric CHECK (price > 0) // задать для определённой колонки, выражение, которое будет осуществлять проверку, помещаемого в эту колонку значения.
);

// Внешний ключ может также ограничивать и ссылаться на группу колонок. Такое ограничение необходимо записывать как ограничение на таблицу. Вот пример:

CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);

/*
Документация:
Ограничения целостности: http://postgresql.ru.net/manual/ddl-constraints.html
Constraints: http://www.postgresql.org/docs/9.4/static/ddl-constraints.html
Ограничения и первичные ключи: http://postgresql.ru.net/node/4

/**@@
Выполните в psql запрос, который создает таблицу cars с полями id (primary key), name (unique, not null), price (без констрейнов) и created_at (not null). Типы столбцов нужно выбрать самостоятельно.
**/

CREATE TABLE cars (
    id integer PRIMARY KEY,
    name character varying UNIQUE NOT NULL,
    price numeric,
    created_at timestamp NOT NULL
);


/**@@
users           orders      order_items     goods


id          ->  user_id  ->  order_id ->    id
email           id           id             name
first_name      create_at    item_id        price
                             price  
*/

CREATE TABLE goods (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name varchar(255),
  price integer
);

CREATE TABLE orders (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  user_id bigint REFERENCES users(id),
  created_at timestamp
);

CREATE TABLE order_items (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  order_id bigint REFERENCES orders(id),
  price integer,
  item_id bigint REFERENCES goods(id)
);


>>>>>> Изменение структуры таблицы (ALTER) <<<<<<

/*
# Добавление колонки
-- в таблице "courses"
-- добавить колонку с именем "example1" и типом "timestamp"
*/
ALTER TABLE courses ADD COLUMN example1 timestamp;

/*
Здесь после фразы ADD COLUMN идёт строка описания новой колонки, точно такая же, как и при создании таблицы. В простейшем случае она выглядит так: <имя колонки> <тип>. Здесь можно указывать любые ограничения, добавлять ключи, автогенерацию, значение по умолчанию и многое другое. Самое приятное, что синтаксис на 100% совпадает с синтаксисом создания новой колонки.

# Переименование колонки
-- в таблице "courses"
-- изменить колонку "example1":
-- поменять имя с "example1" на "example2"
*/
ALTER TABLE courses RENAME COLUMN example1 TO example2;

/*
# Удаление колонки
-- в таблице "courses"
-- удалить колонку с именем "example2"
*/
ALTER TABLE courses DROP COLUMN example2;

/*
# Обновление колонки

Команда по изменению параметров колонки наиболее сложная. Практически каждый элемент, который поддаётся обновлению, имеет собственный синтаксис для этого обновления. Вот пара базовых примеров:
*/
ALTER TABLE addresses
    ADD PRIMARY KEY (id);


ALTER TABLE addresses
    ALTER COLUMN created_at SET DATA TYPE timestamp,
    ALTER COLUMN street DROP NOT NULL;

ALTER TABLE products ADD CONSTRAINT product_id_uniq UNIQUE (product_id);

/*
Наиболее распространённые команды:
    ADD — добавление констрейна: например, ключа или уникальности
    SET — установка значения: например, типа данных
    DROP — удаление констрейна

Запрос ALTER устроен таким образом, что в рамках одного обновления можно группировать только одинаковые операции. В примере выше как раз это показано: один запрос добавляет первичный ключ, а другой обновляет сразу два поля. Если попробовать объединить их в один ALTER, то СУБД завершит запрос с ошибкой.
*/

>>>>>> Сортировка (ORDER) <<<<<<

/*
# Неопределённость порядка сортировки

Выборка данных из базы не имеет определённого порядка, точнее порядок есть, но он никак логически не обоснован. База данных, по умолчанию, возвращает данные в том порядке, в котором ей удобнее. По счастливому стечению обстоятельств этот порядок может совпасть с желаемым, но рассчитывать на это нельзя. Теоретически он может поменяться при следующем запросе или когда количество данных в таблице изменится. Обновление версии базы данных тоже может повлиять на это.

# Общая схема запроса на сортировку

Сортировка задаётся с помощью части ORDER BY, за которой следует имя поля, по которому происходит сортировка:
*/
SELECT * FROM users ORDER BY username;

// База данных — умная штука, она знает, как сравнивать не только числа, но и строки, и даты. Сортировка по датам — крайне частая операция, выглядит она идентично любой другой сортировке:

SELECT * FROM users ORDER BY created_at;

/*
# Управление порядком сортировки

Если ничего дополнительно не указывать, то ORDER BY сортирует в прямом порядке — от меньшего к большему. Запрос выше — это сокращённая версия полного запроса с сортировкой: полный запрос включает в себя ASC, который подставляется автоматически, если ничего не указано:

тоже самое что и SELECT * FROM users ORDER BY created_at;
*/

SELECT * FROM users ORDER BY created_at ASC;

// Для сортировки в обратном порядке указывается DESC:
SELECT * FROM users ORDER BY created_at DESC;

// Иногда возникает необходимость сортировать данные сразу по нескольким полям. Этого легко добиться, просто перечисляя поля через запятую:
SELECT * FROM users ORDER BY first_name, created_at;

// Порядок сортировки в таком случае задаётся для каждого поля индивидуально:
SELECT * FROM users ORDER BY first_name DESC, created_at DESC;
SELECT first_name, created_at FROM users ORDER BY first_name ASC, created_at DESC;

/* => 
first_name  created_at
Maryse      2019-03-04 13:03:01
Maryse      2018-12-06 10:24:04
Maryse      2018-12-06 10:09:48
Sunny       2019-03-04 13:04:28
Sunny       2018-12-06 06:19:30
Tanya       2018-12-06 07:12:01
Tanya       2018-12-05 23:55:15

В этой выборке сначала выполняется сортировка по имени в прямом порядке. Затем, внутри групп с одинаковым именем, происходит сортировка по created_at в обратном порядке.

# Сортировка NULL-значений

У сортировки есть один тонкий момент, связанный с сортировкой полей, содержащих NULL. Если ничего не указано дополнительно, то считается, что NULL больше любого значения. Другими словами, при прямой сортировке они окажутся в конце выборки, а при обратной — в начале. Этим поведением можно управлять с помощью фразы NULLS FIRST:

-- сортируем по возрастанию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, содержащие NULL, идут последними
*/
SELECT * FROM users ORDER BY created_at ASC;

/*
-- сортируем по возрастанию даты (поле "created_at")
-- поля, содержащие NULL, идут первыми
*/
SELECT * FROM users ORDER BY created_at ASC NULLS FIRST;

// и NULLS LAST:

/*
-- сортируем по убыванию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, содержащие NULL, идут первыми
*/
SELECT * FROM users ORDER BY created_at DESC;

/*
-- сортируем по убыванию даты (поле "created_at")
-- поля, содержащие NULL, идут последними
*/
SELECT * FROM users ORDER BY created_at DESC NULLS LAST;

# Равенство строк




>>>>>> Условия (WHERE) <<<<<<

/*
-- В случае базы данных знак `=` должен восприниматься
-- как математическое равенство, а не присваивание.
*/

SELECT * FROM users WHERE id = 3;
UPDATE users SET first_name = 'Valya' WHERE id = 3;
DELETE FROM users WHERE id = 3;

// Если нужно получить все записи, кроме тех, что имеют определённое значение (даже если запись одна), то нужно = ("равно"), заменить на != ("НЕ равно"): 
SELECT * FROM users WHERE id != 3;


# Проверка на равенство с NULL
// Сравнение с конкретным значением работает для всех типов данных, кроме NULL. У последнего свой собственный синтаксис.

// Равно NULL:
SELECT * FROM users WHERE first_name IS NULL;

// Не равно NULL:
SELECT * FROM users WHERE created_at IS NOT NULL;


# Равенство строк

// Работа со строками тоже имеет свои особенности. В соответствии со стандартом ANSI SQL, строки в PostgreSQL регистрозависимые. Это значит, что следующие два запроса выбирают разные данные:

SELECT * FROM users WHERE first_name = 'sunny';
SELECT * FROM users WHERE first_name = 'Sunny';

// По этой причине данные в базе стараются хранить в нормализованном виде. То есть, перед добавление в БД их приводят, например, к нижнему регистру, и то же самое делают при выборках. Классический пример — email. Его нужно хранить только в нижнем регистре.


# Другие операции сравнения

// Кроме точного соответствия, SQL поддерживает и все остальные операции сравнения: > (больше), < (меньше), != (не равно), >= (больше либо равно, "не меньше"), <= (меньше либо равно, "не больше").

SELECT *
  FROM users
  WHERE created_at < '2018-10-05';


# Логические операторы

// В свою очередь все операции можно объединять в цепочки, используя логические операторы OR и AND:  

SELECT *
  FROM users
  WHERE created_at < '2018-10-05' AND created_at > '1998-10-05';



# BETWEEN 

// Обратите внимание, что BETWEEN при сравнении включает границы диапазона.  

SELECT *
  FROM users
  WHERE created_at BETWEEN '2018-01-01' AND '2018-10-05';
// Идентично SELECT * FROM users WHERE created_at >= '2018-01-01' AND created_at <= '2018-10-05';


# IN
// В некоторых ситуациях требуется найти не диапазон, а строки, в которых поле соответствует одному значению из набора. Предположим, что мы хотим найти пользователей с идентификаторами 1, 2 или 5, выполнив один запрос. Наиболее очевидный способ — использовать OR:  
SELECT * FROM users WHERE id = 1 OR id = 2 OR id = 5;

// Страшно представить, во что превратится запрос, если понадобится найти десяток совпадений. К счастью, SQL предлагает другое решение - IN:
SELECT * FROM users WHERE id IN (1, 2, 5);

// В ситуации, когда нужно исключить определённые записи, достаточно добавить NOT:
SELECT * FROM users WHERE id NOT IN (1, 2, 5);


# LIKE

// Иногда нужно искать по частичному совпадению: например, проверяя, что строка начинается или заканчивается с определённой последовательности символов. Допустим, мы хотим посмотреть пользователей, имя которых начинается с буквы A:

SELECT * FROM users WHERE first_name LIKE 'A%';

// % — специальный заполнитель, который означает "всё, что угодно". Если его поставить в конце, то поиск выполняется по совпадению в начале фразы, если в начале — то по совпадению с концом, а если в середине - то проверяется совпадение внутри текста. Совпадение в конце может понадобиться для анализа пользователей, зарегистрированных с определённого почтового домена:

SELECT * FROM users WHERE email LIKE '%hotmail.com';

// Обратите внимание на то, что этот поиск регистрозависимый. Если вы хотите искать БЕЗ учёта регистра, то используйте ILIKE.


>>>>>> Лимит (LIMIT) <<<<<<

// Типичные таблицы в веб-проектах содержат огромное число данных, поэтому их никогда не показывают на страницах сразу все. Обычно выводится лишь небольшая часть — скажем, 50 строк. Для ограничения выборки используется LIMIT.

SELECT * FROM users LIMIT 10;

// Такой запрос извлечёт 10 записей. Как вы уже знаете, из-за неопределённости порядка сортировки по умолчанию неизвестно, какие это будут записи. Для гарантии обязательно явно определять сортировку. Более того, LIMIT без сортировки практически никогда не используется.

SELECT * FROM users ORDER BY id LIMIT 10;

// А что, если пользователь, просмотрев первые 10 записей, захочет посмотреть следующие 10? Это обычная ситуация, которая реализуется через пейджинг — специальный механизм, который позволяет перемещаться по страницам. Для его реализации одного LIMIT не достаточно, также понадобится смещение OFFSET:
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10;

// Этот запрос отсортирует пользователей, пропустит первые 10 (за счет части OFFSET 10) и возьмёт 10 записей. Таким образом, меняя OFFSET, можно обойти все данные в таблице:

// выбрать записи с 21 по 30
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;

// выбрать записи с 31 по 40
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 30;



>>>>>> DISTINCT <<<<<<

// Предположим, что нам нужно узнать все имена, которые есть у наших пользователей. Самый простой способ сделать это — выполнить запрос не всех полей, а только имени:

// -- получить список имён всех пользователей
SELECT first_name FROM users;

// Но проблема в том, что эти имена наверняка дублируются: ведь разные люди вполне могут иметь одинаковые имена. Избавиться от дублей можно с помощью DISTINCT.
SELECT DISTINCT first_name FROM users;

/*
 first_name
------------
 Delphine
 Hanna
 Maxwell
 Russell
 Mia

Такой запрос выведет только уникальные имена.
DISTINCT позволяет указывать не одно, а сразу несколько полей: 
-- DISTINCT добавляется в запрос только один раз, независимо от того, сколько колонок перечисляется
*/
SELECT DISTINCT first_name, last_name FROM users;

/*
 first_name |   last_name
------------+---------------
 Rhiannon   | Tremblay
 Vesta      | Kassulke
 Ena        | Gorczany
 Florencio  | Collier
 Garrett    | Koss

В эту выборку попадут все значения с уникальным сочетанием имён и фамилий. Это значит, что имена и фамилии повторяться могут, но пара всегда уникальна. Если в DISTINCT добавить первичный ключ (SELECT DISTINCT id, first_name FROM users), то запрос извлечёт все записи. Такой результат является следствием уникальности первичного ключа.

DISTINCT можно совмещать с агрегатными функциями (им посвящён отдельный урок): например, посчитать количество пользователей с уникальными именами:
*/
SELECT COUNT(DISTINCT first_name) FROM users;


# DISTINCT ON

/*
Эта форма DISTINCT настолько сильно отличается от своей исходной формы, что о ней стоит сказать подробнее. В отличие от базовой формы, DISTINCT ON позволяет отдельно указывать поля по которым проверяется уникальность и поля которые должны оказаться в результирующей выборке.

-- Все записи, уникальные по user_id
*/
SELECT DISTINCT ON (user_id) * FROM topics;

/*
 id | user_id |              title              | body                  |       created_at
----|---------|---------------------------------|-----------------------|------------------------
  2 |       2 | molestiae voluptas velit        | Quod quasi molestiae. | 2019-06-02 23:42:30.688

-- Все title для уникальных user_id
*/
SELECT DISTINCT ON (user_id) title FROM topics;  

/*
             title
-------------------------
 molestiae voluptas velit

-- SELECT DISTINCT user_id, title FROM topics;
-- Такой запрос вернет совершенно другие данные, он вернет все уникальные пары user_id-title
-- То есть здесь возможно повторение user_id в результирующей выборке
*/
SELECT DISTINCT ON (user_id, title) user_id, title FROM topics;
// А этот запрос, равносилен тому что был выше


// При работе с DISTINCT ON важно правильно использовать сортировку.
SELECT DISTINCT ON (user_id) id, user_id, title, created_at
  FROM topics
  ORDER BY user_id, created_at;

/* =>
 id | user_id |            title             |       created_at
----+---------+------------------------------+-------------------------
 48 |       1 | qui non velit                | 2018-12-05 21:49:52.631
  7 |       4 | delectus in nihil            | 2018-12-06 00:46:32.712
 26 |       6 | rerum rerum recusandae       | 2018-12-05 18:39:47.937
 34 |       7 | soluta non voluptas          | 2018-12-06 07:55:00.095


Такой запрос вернёт первый созданный топик для каждого пользователя. Запросы с DISTINCT ON требуют того, чтобы первыми полями в ORDER BY следовали те поля, которые идут после ON. Только тогда сортировка отработает так, как ожидается. В запросе выше это user_id, он указан в сортировке первым. В противном случае (ORDER BY created_at, user_id), результат будет неверен. 
*/

>>>>>> Функции <<<<<<
/*
При реализации пейджинга обычно показывают общее число страниц. Для этого надо посчитать число строк в конкретной таблице. Как это сделать? Обычная выборка уже никак не поможет, но помогут функции. SQL это больше чем просто язык запросов, это практически язык программирования, хотя и очень специфичный.

Функции, которые что-то считают по таблице, называются агрегатными. К ним относятся нахождение числа записей, суммы значений, среднего арифметического и многое другое. В этом уроке мы рассмотрим только самые популярные, полный список функций смотрите в документации.
*/

# Count

SELECT COUNT(*) FROM users;
/* =>
 count
-------
    99
(1 row)
*/

// COUNT() — функция, которая считает количество записей в выборке. Подчеркну — не в таблице, а в выборке:
SELECT COUNT(*) FROM users WHERE birthday < '2018-10-21';

/* =>
 count
-------
    91
(1 row)

Такой запрос вернёт ровно одну запись с одним значением — количеством строк по указанному условию.
Функция COUNT() относится к так называемым агрегирующим (агрегатным) функциям. То есть функциям, которые что-то считают по набору данных: например, сумму, количество, среднее арифметическое и так далее. У функции COUNT есть несколько форм:
- Когда аргументом функции является *, она считает количество строк.
- Если в неё передать имя конкретного поля, то она посчитает количество строк, в которых это поле НЕ равно NULL.
*/


# Max, Min
// Функции MAX и MIN позволяют находить максимальное и минимальное значение соответственно.
SELECT MAX(birthday) FROM users WHERE gender = 'male';

/* =>
    max
------------
 2018-12-06
 (1 row)
*/

SELECT MIN(birthday) FROM users WHERE gender = 'female';
/* =>
    min
------------
 2017-12-08
 (1 row)
*/


# Sum
/*
Функция SUM находит сумму всех значений.
-- Получить сумму всех заказов из таблицы Orders,
-- которые были совершены в 2016 году.
*/

SELECT SUM(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';

# Avg
/*
Функция AVG находит среднее арифметическое всех значений.
-- Получить среднюю стоимость всех заказов из таблицы Orders,
-- которые были совершены в 2016 году.
*/

SELECT AVG(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';


>>>>>> Группировка (GROUP) <<<<<<

/*
Типичные задачи, связанные с агрегатными функциями, выглядят так: Вывести общее число топиков для каждого пользователя. Используя только функции, невозможно выполнить данную задачу за один запрос, придётся делать выборку для каждой категории индивидуально:
*/
SELECT COUNT(*) FROM topics WHERE user_id = 3;
SELECT COUNT(*) FROM topics WHERE user_id = 4;

/*
Если пользователей тысячи (десятки, сотни, миллионы!), то такое решение вопроса не приемлемо в принципе. Подобные задачи возникают настолько часто, что для них существует специальная форма GROUP BY. Группировка, как это ни странно, группирует строки по определённому признаку для выполнения подсчётов внутри каждой группы независимо от других групп.
*/
SELECT user_id, COUNT(*) FROM topics GROUP BY user_id;

/* =>
 user_id | count
---------+-------
      71 |     1
      80 |     1
      84 |     3
      92 |     1
      60 |     1
      97 |     2
      98 |     1
      44 |     1
      40 |     1
      43 |     1

В запросе выше создаются группы записей по значению поля user_id. Это можно представить себе как набор виртуальных таблиц, каждая из которых содержит все записи, принадлежащие одному пользователю. Подсчёт количества идёт по каждой из этих таблиц (групп) независимо от других. К результатам такой выборки можно применять сортировку и лимитирование:     
*/
SELECT user_id, COUNT(*) FROM topics GROUP BY user_id ORDER BY count DESC LIMIT 3;

/* =>
 user_id | count
---------+-------
      84 |     3
      97 |     2
      57 |     2
*/

// Сортировка позволяет обращаться не только к полям самой таблицы, но и к вычисленному значению. По умолчанию имя этого "виртуального" поля совпадает с именем функции, но его можно изменить с помощью механизма псевдонимов:      

SELECT user_id, COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id
  ORDER BY topics_count
  DESC LIMIT 3;

// Псевдонимы создаются не только для агрегатных значений, но и для любых имён, перечисляемых в запросе, переименовываются даже существующие поля. Общая структура задания имени выглядит так: <expression> AS <name>.

SELECT first_name AS name FROM users;

// Псевдонимы хороши тем, что, определив их в одном месте, они становятся доступны в других частях SQL запроса:
SELECT first_name AS name FROM users ORDER BY name;

// Вопрос на засыпку: а что произойдёт, если мы попытаемся выполнить следующий запрос:
SELECT user_id, created_at, COUNT(*) AS topics_count FROM topics GROUP BY user_id;

// Он завершится с ошибкой:
/* =>
ERROR:  column "topics.created_at" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT user_id, created_at, COUNT(*) AS topics_count FROM topics G...


Понимание того, почему запрос выше не сработает — ключ к пониманию того, как работает GROUP BY. Группировка — операция, которая создает из записей таблицы, независимые группы записей по которым проводится анализ. Группа записей — не то же самое, что одна запись. Это значит, что мы не можем просто взять и указать имя любого поля, надеясь, что база данных сама выберет какое-то значение из этой группы. Такое поведение создаёт неоднозначность и, по сути, бесмысленно. Поэтому СУБД отслеживает такие ошибки и просит выполнить одно из двух действий:

- Указать поле created_at в выражении GROUP BY. Тогда значение этого поля для каждой группы будет одинаковым (в этом и суть группировки), а значит СУБД однозначно определит, что нужно добавить в результат:
*/
SELECT user_id, created_at, COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id, created_at;

/* =>
 user_id |       created_at        | topics_count
---------+-------------------------+--------------
      40 | 2018-12-05 18:40:05.603 |            1
      67 | 2018-12-06 05:23:40.65  |            1

Такой запрос выполнит группировку сначала по user_id, а затем по дате создания. Так как даты создания у всех топиков уникальны (почти наверняка), то вся таблица разобъётся на группы по одному элементу. Смысла в таком запросе не очень много, гораздо полезнее сделать то же самое с разбивкой по дням или месяцам. Тогда можно будет увидеть сколько топиков создаёт конкретный пользователь каждый день:

-- В этом запросе используется функция EXTRACT,
-- которая извлекает значения из даты: например, номер дня или месяца      
*/
SELECT user_id, EXTRACT(day from created_at) AS day, COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id, day
  ORDER BY user_id;

/* => 
 user_id | day | topics_count
---------+-----+--------------
       1 |   5 |            1
       1 |   6 |            1
       4 |   6 |            1
       6 |   5 |            1
       7 |   6 |            2
       8 |   5 |            1
       9 |   6 |            1

- Использовать created_at внутри агрегатной функции: в таком случае будет получен результат на основе анализа всех значений в рамках группы. Например, добавление вызова MAX(created_at) посчитает дату последнего добавленного топика для каждой группы:
*/
SELECT user_id, MAX(created_at), COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id;

/* =>
 user_id |           max           | topics_count
---------+-------------------------+--------------
      40 | 2018-12-05 18:40:05.603 |            1
      67 | 2018-12-06 05:23:40.65  |            1
      49 | 2018-12-06 14:55:08.99  |            1
      43 | 2018-12-06 00:20:11.835 |            1
*/

# HAVING

/*
В более сложных ситуациях бывает нужно проводить анализ только по некоторым группам. Предположим, что мы хотим выбрать всех пользователей, у которых количество топиков больше одного. Эта задача сводится к поиску групп, в которых число записей превышает число 1. Подобный запрос невозможно сделать, используя WHERE, так как эти условия применяются к записям исходной выборки, ещё до создания самих групп. Для реализации данной задачи понадобится дополнение к GROUP BY, которое называется HAVING.
*/      

SELECT user_id, COUNT(*) FROM topics
  GROUP BY user_id
  HAVING COUNT(*) > 1;

/*
 user_id | count
---------+-------
      84 |     3
      97 |     2
      57 |     2
      30 |     2
      83 |     2
       7 |     2
      38 |     2
       1 |     2
(8 rows)


Подчеркну, что HAVING нужен для отбора групп по какому-то агрегатному признаку: например, количеству записей в группе. В ситуациях, когда надо смотреть значение конкретного поля — используйте WHERE.

Группировка — мощный, но в то же время сложный инструмент, позволяющий анализировать данные в таблицах. Не заморачивайтесь над тем, чтобы выучить его от и до прямо сейчас. Опытные разработчики пользуются им не каждый день и сами постоянно подсматривают в документацию. Важно понимать спектр задач, для которых группировка подходит, а остальное — дело техники и умения читать документацию. Это общее правило, характерное для изучения многих других аспектов баз данных.
*/

/**@@
Составьте запрос (к таблице users), который считает количество пользователей, рождённых (поле birthday) в каждом году (из тех, что есть в birthday) по следующим правилам:

Анализируются только те пользователи, у которых указан год рождения.
Выборка отсортирована по году рождения в прямом порядке.
# Подсказки
1 Чтобы извлечь год из дня рождения, воспользуйтесь конструкцией: EXTRACT(year FROM birthday) AS year_of_birthday.
2 Итоговая таблица должна иметь два поля с именами year_of_birthday и count.
*/
SELECT EXTRACT(year FROM birthday) AS year_of_birthday, COUNT(*)
  FROM users
  WHERE birthday IS NOT NULL
  GROUP BY year_of_birthday
  ORDER BY year_of_birthday;

// Можно ли выполнить такой запрос?
SELECT user_id FROM topics GROUP BY user_id;
// > Нельзя, так как непонятно какую запись из каждой группы нужно вернуть. Запрос должен однозначно описывать возвращаемые данные.




>>>>>> Соединения (JOINS) <<<<<<

/*
Как мы уже знаем, реляционная модель подразумевает связь между данными разных отношений посредством внешних ключей. С практической точки зрения это значит, что, зная первичный ключ одной сущности, мы можем извлечь связанные с ней данные из другой сущности.

-- Извлекаем все топики пользователя с id = 3
*/
SELECT * FROM topics WHERE user_id = 3;

// В простых ситуациях данные извлекаются так, как показано выше. Но есть множество ситуаций, где простой выборкой не обойтись. Предположим, что мы хотим найти всех пользователей Хекслета, которые ни разу не создавали топики. На текущий момент мы знаем ровно один способ выполнить эту задачу:

// 1 Извлекаем из базы всех пользователей, которые создали хотя бы один топик:
SELECT DISTINCT user_id FROM topics;

// 2 Затем ищем всех пользователей, у которых идентификаторы не совпадают со списком user_id, полученном на предыдущем этапе:

SELECT * FROM users
  WHERE user_id NOT IN(<список идентификаторов, полученный предыдущим запросом>);

// В итоге задача будет решена, но есть одна маленькая (или большая) проблема. Количество идентификаторов может быть огромным, и гонять их из базы в код и обратно — не самая разумная идея.

# INNER JOIN

/*
Задача: Найти записи в одной таблице (пользователей), для которых нет записей в другой таблице (топиков). Реляционная алгебра позволяет выполнить эту операцию с помощью соединения JOIN, используя ровно один запрос. Начнём знакомство с JOIN на примере:
-- В выборке участвуют не все записи только для того, чтобы уместить
-- её на экран, а вообще здесь можно использовать `*`
*/

SELECT first_name, title
  FROM users JOIN topics ON users.id = topics.user_id LIMIT 5; 

/* =>
 first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Oleta      | eaque fugiat consequatur
 Brandon    | aut exercitationem expedita
 Domenica   | voluptatem soluta similique

Результатом данного запроса станет выборка, в которую попали поля обеих таблиц. Здесь соединяются две таблицы: users и topics по условию users.id = topics.user_id. Это важное условие для правильной работы. В нашем примере отношения связаны внешним ключом: соответственно, при джойне этих таблиц нужно явно указать, как мы их соединяем. Общий синтаксис выглядит так: SELECT * FROM table1 JOIN table2 ON table1.id_field_name = table2.id_field_name (на самом деле общая форма сложнее, так как джойнить можно произвольное число таблиц и условий соединения тоже может быть много). 

JOIN — это сокращенная версия соединения INNER JOIN, то есть внутреннего соединения.

В эту выборку попадают только те записи, для которых есть соответствие в другой таблице. Причём, если у одного пользователя пять топиков, то в выборке окажутся все пять строк. Такой запрос имеет смысл делать на странице вывода топиков, что позволит к каждому топику сразу же вывести нужную информацию и о самом пользователе.

Запросы с соединениями порождают одну небольшую проблему. В примере выше часть SELECT содержит только те поля, которые уникальны среди всех полей обеих таблиц. Соответственно, при выборке не возникает неоднозначностей. Если выполнить этот же запрос со звёздочкой, то в выборку попадут поля, у которых одинаковые названия, что создаст сложности при анализе данных уже в коде приложения. А при выполнении запроса с указанием дублирующихся полей вообще возникнет ошибка:
*/
SELECT id FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;
/*
ERROR:  column reference "id" is ambiguous
LINE 1: SELECT id FROM users JOIN topics ON users.id = topics.user_i...

В таких случаях спасают псевдонимы и возможность указывать таблицу для каждого поля:
*/

SELECT users.id AS user_id, topics.id AS topic_id
    FROM users
    JOIN topics ON users.id = topics.user_id 
    LIMIT 5;

/* =>
 user_id | topic_id
---------+----------
       9 |        1
      33 |        2
      43 |        3
      49 |        4
      10 |        5
(5 rows)
*/

# LEFT JOIN

/*
Но этот запрос не поможет решить нашу исходную задачу. Для её решения понадобится операция левого соединения LEFT JOIN.

LEFT JOIN берёт все данные из одной таблицы и присоединяет к ним данные из другой, если они присутствуют. Если нет, то заполняет их NULL. Чисто технически этот запрос отличается только тем, что добавляется слово LEFT:
*/
SELECT first_name, title FROM users
  LEFT JOIN topics ON users.id = topics.user_id LIMIT 5;

/* =>
first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Mia        |
 Royal      |
 Enos       | et eos dicta

LEFT JOIN полезен в тех ситуациях, когда нам нужно работать со всеми данными (возможно, по условию WHERE) одной таблицы и связанными с ними данными, если они есть. Если их нет, то ничего страшного, мы всё равно хотим получить данные из первой таблицы.

Этот запрос всё ещё не возвращает нам то, что мы хотели изначально. Но теперь, глядя на эту выборку, как на новое отношение, вы и сами можете сказать, что осталось сделать, чтобы получить пользователей, которые не оставили ни одного топика на Хекслете. Правильно, нужно добавить в выборку условие WHERE:
*/
SELECT COUNT(*)
  FROM users
  LEFT JOIN topics ON users.id = topics.user_id
  WHERE title IS NULL;

/* =>
 count
-------
    59
(1 row)

Соединения не единственный способ делать выборки сразу по нескольким таблицам. Альтернативный подход это вложенные запросы. Он проще для восприятия, но не всегда возможно его эффективное выполнение.

Визуализация соединений https://sql-joins.leopard.in.ua/

В каком из видов JOIN'а имеет значение порядок указания таблиц?
>  в left join

Если в множестве А есть записи "1", "2, "3" и "4", а в множестве B есть записи "3", "5", "7" и "9", то какие записи будут в пересечении "A left join B"?
> "1", "2, "3" и "4"

*/

/**@@
solution.sql
Составьте запрос, который извлекает из базы идентификатор топика и имя автора топика (first_name) по следующим правилам:

Анализируются топики только тех пользователей, чей емейл находится на домене lannister.com
Выборка отсортирована по дате создания топика в прямом порядке
*/
SELECT topics.id, first_name
  FROM topics
  JOIN users ON topics.user_id = users.id
  WHERE email LIKE '%@lannister.com'
  ORDER BY topics.created_at;


>>>>> Транзакционность <<<<<<

/*
Далеко не все операции с базой данных можно выразить одним запросом. Классический пример — перевод денег с одного счёта на другой. Допустим, у нас есть таблица счетов accounts, в которой две записи:


id  user_id amount
1   10  100
2   30  100

Процесс перевода можно грубо (потому что в реальности всё гораздо сложнее) представить так:
*/

// 1. Проверяем, что у пользователя достаточно денег.
SELECT amount FROM accounts WHERE user_id = 10;

// 2. Списываем необходимую сумму со счёта этого пользователя.
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;

// 3. Зачисляем деньги другому пользователю:
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;

/*
В результате этих манипуляций таблица примет следующий вид:

id  user_id amount
1   10  50
2   30  150

Главная (но не единственная) проблема в этом процессе — отсутствие гарантии завершения. Представьте, что система успела выполнить списание, и в этот момент произошла ошибка, выключили питание, компьютер перезагрузился. В результате получится странная ситуация: деньги списались, но никуда не зачислились:

id  user_id amount
1   10  50
2   30  100

Подобное поведение недопустимо не только при работе с деньгами, но и в большинстве других ситуаций. Данные приложения, по возможности (в распределённых системах это невозможно, см. CAP-теорему и Eventually Consistency), должны находиться в согласованном состоянии. И добиться этого можно с помощью механизма транзакций. Понятие "транзакция" не является специфичным для баз данных, им пользуются и в обычной жизни. Например, операция снятия денег в банкомате — это бизнес-транзакция. Мы, как пользователи банкомата, ожидаем, что эта операция либо снимет деньги, либо нет, и банкомат это обеспечивает. Но, если копнуть глубже, то станет понятно, что операция снятия денег — это нетривиальный процесс, который приводит не только к множеству запросов в базу данных, но и к затрагиванию нескольких (многих?) систем, у которых свои собственные процессы и базы данных внутри.

Как бы там ни было, главное, что мы ожидаем от любой подобной транзакции — атомарность. С точки зрения пользователя она всегда выглядит, как одна операция, которая либо завершается успешно либо не проходит. Транзакции в базе данных, в этом смысле, значительно проще, чем бизнес-транзакции. За обеспечением необходимых гарантий следит сама база данных, а не программист:
*/

BEGIN;
SELECT amount FROM accounts WHERE user_id = 10;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;

/*
Транзакции в PostgreSQL — это блок запросов, обрамлённый запросами BEGIN и COMMIT. Первый запрос открывает транзакцию, второй — её закрывает. Любая ошибка, возникшая внутри транзакции, откатывает целиком все изменения, которые были сделаны после запроса BEGIN. При необходимости, транзакцию можно откатить самостоятельно, выполнив запрос ROLLBACK до COMMIT. Подобное иногда бывает нужно при выполнении запросов из кода приложения.

Согласованность — одно из 4-x требований, которые предъявляются к любым транзакциям. В информатике акроним ACID описывает требования к транзакционной системе (не обязательно базе данных), обеспечивающие наиболее надёжную и предсказуемую её работу. Требования ACID были в основном сформулированы в конце 70-х годов:

# Atomicity — Атомарность
Любая транзакция не может быть частично завершена — она либо выполнена, либо нет.

# Consistency — Согласованность
Завершившаяся транзакция должна сохранять согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты, при том, что в процессе работы транзакции данные могут оказываться не согласованными. В примере выше снятие денег с одного счёта приводит к тому, что данные рассинхронизированы, но в момент завершения транзакции этого нет. Гарантия согласованности данных не может быть полностью обеспечена только средствами базы данных (например, различные констрейнты). Поддержка этого свойства включает в себя работу со стороны программистов, которые пишут необходимый для этого код.

# Isolation — Изолированность
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Ни одна транзакция не может увидеть изменения, сделанные другими незавершёнными транзакциями. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).


# Durability — Устойчивость
Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

# Дополнительные материалы
Официальная документация https://postgrespro.ru/docs/postgresql/11/tutorial-transactions
ACID https://ru.wikipedia.org/wiki/ACID
Уровни изоляции транзакции https://ru.wikipedia.org/wiki/Уровень_изолированности_транзакций
*/

/**@@
Механизм дружбы в социальных сетях, обычно, реализуется через отдельную таблицу ссылающуюся на обоих пользователей. Когда два человека начинают дружить, то в эту таблицу заносятся сразу две записи:

id  user1_id    user2_id
1   3           10
2   10          3

Такой способ организации данных позволяет работать с понятием "дружба" независимо от того, кто был указан первым, а кто вторым.

solution.sql
Составьте транзакцию, которая создает дружбу между пользователями Tirion и Jon.

Подсказки
Идентификаторы пользователей можно узнать сделав соответствующий запрос в базу данных
Перед тем как записывать решение в файл, откройте psql и попробуйте сделать выборку там
*/
BEGIN;
INSERT INTO friendship (user1_id, user2_id) VALUES (7, 2);
INSERT INTO friendship (user1_id, user2_id) VALUES (2, 7);
COMMIT;



>>>>>> Производительность <<<<<<

/*
Вопрос производительности базы данных и запросов к ней с течением времени становится всё актуальнее. Чем больше проект и сложнее связи, чем больше данных в таблицах, тем выше вероятность столкнуться с медленной работой и нежелательными блокировками. Подобные вопросы редко касаются новичков, и в проектах всегда есть кому ими заняться, но общее понимание иметь стоит даже на начальном этапе, хотя и не стоит уделять этому слишком много внимания. С другой стороны, собеседующие иногда задают вопросы на оптимизацию базы данных даже совсем зелёным новичкам, и если они что-то отвечают, то им добавляется большой плюс в карму.

Производительность базы данных настолько серьёзная тема, что ей посвящена не одна книга. Бесполезно пытаться уместить всё в один урок, поэтому я всего лишь опишу основные направления в этой теме и предоставлю большое число ключевых слов для самостоятельного изучения, если, конечно, вам это интересно.


Начнем с того, как база данных выбирает данные. SQL — декларативный язык, то есть им мы описываем ЧТО хотим получить, а не КАК. Но это не устраивает машину, СУБД должна знать, каким образом добраться до этих данных. Во всех базах данных реализована подсистема, которая называется планировщик (scheduler). Она строит так называемый план запроса. Этот план описывает, как конкретно будут извлечены данные, которые хранятся внутри базы данных. При построении плана планировщик учитывает множество факторов: например, статистику обращений, информацию о количестве данных в таблицах и многое другое. Более того, планировщик в PostgreSQL применяет генетические алгоритмы, для того, чтобы строить план быстро и эффективно. Результат работы планировщика можно посмотреть командой EXPLAIN:
*/
EXPLAIN SELECT * FROM users
  JOIN topics ON users.id = topics.user_id
  WHERE users.created_at > '10.10.2018';

/** =>
                                     QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join  (cost=10.66..23.59 rows=42 width=2377)
   Hash Cond: (topics.user_id = users.id)
   ->  Seq Scan on topics  (cost=0.00..11.30 rows=130 width=572)
   ->  Hash  (cost=10.50..10.50 rows=13 width=1805)
         ->  Seq Scan on users  (cost=0.00..10.50 rows=13 width=1805)
               Filter: (created_at > '2018-10-10 00:00:00'::timestamp without time zone)
(6 rows)


Справа в самом низу показаны операции, которые выполняются в первую очередь. Затем данные, полученные на этих шагах, передаются выше — и так до самого верха. Слева указаны операции, которые производятся с данными, например Seq Scan означает последовательный перебор таблицы (самая дорогая операция при условии, что данных много). Подробнее про план читайте в соответствующей статье https://habr.com/company/oleg-bunin/blog/319018/. 


# Индексы

План запроса можно использовать по-разному: например, переписать (или даже разбить) запрос на более эффективный. С другой стороны, некоторые запросы уже достаточно оптимизированы, и тогда для их ускорения используют индексы. Индекс — это специальная структура внутри базы данных, создаваемая для ускорения поиска. Концептуально индекс в базе данных подобен предметному указателю в любой книге.
*/

// -- Пример создания индекса по полю birthday таблицы users
CREATE INDEX ON users(birthday);

/*
Но создание индекса само по себе не гарантирует эффективности, многое зависит от того, правильный ли индекс создан, сколько уже индексов было в табличке (каждый новый индекс замедляет вставку и обновление данных), сколько данных в таблице, какие запросы выполняются к этой таблице.

В PostgreSQL встроено 6 разных видов индексов, подходящих под разные ситуации. Для работы с ними нужно понимать несколько вещей:

1. Устройство индексов как таковых. Здесь не обойдётся без знания структур данных и алгоритмов. В первую очередь речь идёт про сбалансированные деревья (btree).
2. Классификацию видов запросов. Например, запрос по диапазону или запрос с применением LIKE оператора — совершено разные виды запросов, которые по разному работают и оптимизируются.
3. Влияние различных конструкций SQL на план запроса: например, ORDER BY — дорогая операция, которая часто приводит к полному перебору таблицы.

# Денормализация

/*
Ещё один подход, связанный с оптимизацией, называется денормализацией. Денормализация — это процесс, обратный нормализации. С точки зрения реляционной теории, такого понятия не существует и оно само по себе противоречит её идеям, но на практике этот способ активно применяется, так как за счёт избыточности позволяет упростить запросы (так как данные ближе и их легче извлечь). Цена за денормализацию — дополнительный объём и (не во всех случаях) необходимость производить синхронизацию данных самостоятельно: например, мы можем хранить имя пользователя в разных таблицах, что создаёт сложности при изменении имени. Нужно не забыть поменять его во всех таблицах, где оно используется. В общем случае, денормализация значительно сокращает число запросов с соединениями (joins).

# Дополнительные материалы
Типы индексов в PostgreSQL https://postgrespro.ru/docs/postgresql/11/indexes-types
B-дерево https://ru.wikipedia.org/wiki/B-дерево
Продуманная оптимизация http://optimization.guide/
*/

/*@@
Таблица departments содержит все подразделения компании.

id  name
1   IT
2   Sales

Таблица employees содержит всех работников. Каждый работник имеет id и колонку для id подразделения department_id.

id  name    salary  department_id
1   Joe     70000     1
2   Henry   80000     2
3   Sam     60000     2
4   Max     90000     1

solution.sql
Напишите SQL запрос который найдет самые большие зарплаты для каждого департамента.

name  salary
IT    90000
Sales 80000
*/

SELECT
  departments.name,
  max(employees.salary) as salary
FROM departments
  JOIN employees ON employees.department_id = departments.id
  GROUP BY departments.name;


/**@@
Даны следующие таблицы:

Университеты

id  name
1   name1
2   name2
3   name3

Студенты

id  name  university_id
1   vASYA   1
2   petya   2
3   misha   2
4   anna    3

solution.sql
Напишите SQL запрос который найдет имена всех студентов из университета с именем name2.
*/

SELECT students.name FROM students
  INNER JOIN universities ON students.university_id = universities.id
  WHERE universities.name = 'name2';

/**@@
Таблица employees содержит всех работников включая их менеджеров. Каждый работник имеет id и колонку для id менеджера manager_id.


id    name    salary  manager_id
1     Joe     70000       3
2     Henry   80000       4
3     Sam     60000     NULL
4     Max     90000     NULL

solution.sql
Напишите SQL запрос который найдет имена всех работников, которые получают больше чем их менеджеры.
*/
SELECT employees.name
  FROM employees JOIN employees AS manager ON (employees.manager_id = manager.id)
  WHERE employees.salary > manager.salary;

/**@@
Таблица weathers содержит записи значений температур в разные дни. Каждая запись имеет id, дату date и значение температуры temperature.


id  date        temperature
1   2016-01-01  10
2   2016-01-02  25
3   2016-01-03  20
4   2016-01-04  30

solution.sql
Напишите SQL запрос для выбора id всех записей, температура в которых была выше, чем в предыдущий день (чем вчера).
*/
SELECT current_weathers.id
FROM weathers AS current_weathers
    JOIN weathers AS yesterday_weathers
    ON current_weathers.temperature > yesterday_weathers.temperature
    AND (current_weathers.date - yesterday_weathers.date) = 1;




/* старые конспекты: */
>>>>> Добавление записи <<<<<<<
INSERT INTO products VALUES (1, 'car', 3.55);
select * from products;
INSERT INTO products (product_no, price) VALUES (4, 1); // вставка в определенные столбцы
INSERT INTO products (product_no, price) VALUES (4, 1), (9, 10); // вставка в определенные столбцы нескольких строк
DELETE FROM products; // удаляет все записи в products!
DELETE FROM products WHERE price = 10;

>>>>> Обновление данных <<<<<<<
UPDATE products SET PRICE = 4 WHERE product_no = 2;
UPDATE products SET price =2, name = 'book2' WHERE  product_no > 5; // обновление нескольких значений
UPDATE products SET price = price + 3; // увеличиваем значения колонки на 3

SELECT * FROM PRODUCTS;


/**@@
Увеличьте прайс в два раза для записи с именем nissan.
Установите имя в bmw для записи с id равным 10.
**/

CREATE TABLE cars (
    id integer PRIMARY KEY,
    name character varying UNIQUE NOT NULL,
    price numeric
);

INSERT INTO cars VALUES (1, 'nissan', 1.12);
INSERT INTO cars (id, name) VALUES (10, 'kia');

UPDATE cars SET price = price * 2 WHERE name = 'nissan';
UPDATE cars SET name = 'bmw' WHERE id = 10;



>>>>> Значения по умолчанию  <<<<<<<
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name character varying,
    price numeric DEFAULT 3.3 // по умолчанию
);

CREATE SEQUENCE serial; // генератор чисел, может быть подключен к разным таблицам (является стандартом SQL)
SELECT * FROM serial; // => таблица с 1 полем (start_value = 1, last_value = 3, max-value = 92233... и т.д.)
SELECT nextval('serial'); // продвигает последовательность к следующему значению => 1
SELECT nextval('serial'); // => 2

CREATE TABLE products (
    product_no integer PRIMARY KEY DEFAULT nextval('serial'), // будет 3
    name character varying,
    price numeric DEFAULT 3.3 // по умолчанию
);

// Сокращенный вариант <->
CREATE TABLE products (
    product_no SERIAL PRIMARY KEY;
    // ...
);


/**@@
Создайте таблицу cars. Сделайте поле id типа SERIAL, текстовое поле name и поле price со значением по умолчанию равным 1.22.
**/

CREATE TABLE cars (
    id SERIAL PRIMARY KEY,
    name character varying,
    price numeric DEFAULT 1.22
);



>>>>> Модификация таблиц  <<<<<<<
// Adding a Column
ALTER TABLE products ADD COLUMN description text; // добавление колонки с типом
ALTER TABLE products DROP COLUMN description;

// Adding a Constraint 
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no); // в () поля на которые вешаем CONSTRAINT
ALTER TABLE products DROP CONSTRAINT some_name;

ALTER TABLE products ALTER COLUMN product_no SET NOT NULL; // для NOT NULL отделный синтаксис
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;

// Changing a Columns Default Value
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;

// Changing a Columns Data Type
ALTER TABLE products ALTER COLUMN price TYPE numeric(10, 2);

// Renaming a Column
ALTER TABLE products RENAME COLUMN product_no TO product_number;

// Renaming a Table
ALTER TABLE products RENAME TO items;


/**@@
Напишите запрос который изменит таблицу products так как описано ниже:

Поле name должно стать not null, unique и иметь тип character varying;
Добавьте поле amount типа integer;
Удалите default у поля price;
**/

DROP TABLE IF EXISTS "products";

CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name text,
    price numeric DEFAULT 1
);

ALTER TABLE products
    ADD COLUMN amount integer,
    ALTER COLUMN name TYPE varchar,
    ALTER COLUMN name SET NOT NULL,
    ADD CONSTRAINT name_uniq UNIQUE (name),
    ALTER COLUMN price DROP DEFAULT;


>>>>>  Схема <<<<<<<

/* => 

Schema | Name                    | Type     | owner
----------------------------------------------------
public | products                | table    | postgres
public | products_product_no_seq | sequence | postgres

Schema своего рода namespace в SQL
*/

SELECT * FROM schema.table // название_схемы.название_таблицы
CREATE SCHEMA mysupershema;

\dn // список схем
\dt *.* // список всех таблиц(сюда входят sequence, функции, и т.д.) во всех схемах

SHOW search_path; // показывает в каких схемах осуществляется поиск => имя_пользователя, public и в pg_catalog
drop schema myschema cascade; // cascade - удалить указанную сущность и все зависимости

/*
Документация:
Создание последовательности: https://postgrespro.ru/docs/postgrespro/10/sql-createsequence
Схемы: http://postgresql.ru.net/manual/ddl-schemas.html

/**
Выполните в psql следующие запросы:
Создание схемы custom.
Создание последовательности serial в новой схеме.
**/

CREATE SCHEMA custom;
CREATE SEQUENCE custom.serial;



>>>>>  Представления <<<<<<<
CREATE VIEW products2 AS SELECT * FROM PRODUCTS; // в \d будет иметь тип не table, а view (по сути вложенный запрос)
SELECT * products2;
DROP VIEW products2; // удаление view
/*
Документация:
CREATE VIEW in PostgreSQL: http://www.postgresql.org/docs/9.4/static/sql-createview.html
Представления в PostgreSQL: http://postgresql.ru.net/manual/tutorial-views.html
Представления в БД / Википедия: http://bit.ly/1MjW1qC
Представления в MySQL: http://habrahabr.ru/post/47031/


/**@@
Выполните в psql создание новой view с назавнием cars_without_price. Вью должна быть основана на выборке из таблицы cars и должна содержать все поля этой таблицы за исключением price;
**/

CREATE TABLE cars (
    id integer PRIMARY KEY,
    name character varying UNIQUE NOT NULL,
    price numeric
);

INSERT INTO cars VALUES (1, 'nissan', 1.12);

CREATE VIEW cars_without_price AS select id, name FROM cars;



>>>>> SELECT <<<<<<<
select * from products;
select price, name from products;
select pricem name as name2 from products; // задание псовдонима колонке
select price + 2 as newprice from products; // увеличение значений колонок + псовдонима колонке
select 2 + 3; испольщование SQL как калькулятора
select random() + price from products; // увеличение колонки price на рандомное значение

/*
Полезные ссылки
Использование SQL для извлечения информации из таблиц: http://postgresql.ru.net/gruber/ch3.html
SELECT / PostgreSQL documentation: http://www.postgresql.org/docs/9.4/static/sql-select.html
Википедия / Что такое ORM: https://ru.wikipedia.org/wiki/ORM

/**@@
Выполните в psql запрос, который выбирает из таблицы products поля name и new_price. new_price вычисляется по формуле price + 1;
**/

SELECT name, (price + 1) AS new_price 
    FROM products;



>>>>>  WHERE <<<<<<<
select * from products where product_no = 1;
select * from products where price = 20 and price = 30; // <->
select * from  products where product_no in (1, 3, 4); //  product_no = 1 или 3 или 4
select * from  products where price between 20 and 30; // price от 20 до 30
select * from  products where name is null; // is null - значение поля не задано (null), задано - is not null

/*
Полезные ссылки
PostgreSQL SELECT (with WHERE): http://www.postgresql.org/docs/9.4/static/sql-select.html
Квалифицированный выбор при использовании предложений: http://www.postgresql.org/docs/9.4/static/sql-select.html

/**@@
Выполните в psql запрос который выбирает из таблицы goods все названия товаров, у которых категория products и цена от 3 до 5 включительно;
**/

SELECT name 
    FROM goods
    WHERE category = 'products' 
    AND price BETWEEN 3 AND 5



>>>>>  Where и like <<<<<<<
// like - просматривает всю таблицу
select * from products where name like 'car'; // ищет поле с точным соответствием
select * from products where name like 'c%'; // поля начинающиеся с 'c'
select * from products where name like '%c'; // поля заканчивающиеся на 'c'
select * from products where name like '_v_'; // 3 символа, в середине - 'v'
select * from products where name ilike '_v_'; // нерегистрозависимый поиск

/* 
Полезные ссылки
Pattern matching in PostgreSQL: http://www.postgresql.org/docs/9.4/static/functions-matching.html
Использование LIKE в PostgreSQL: http://postgresql.ru.net/docs/sql_kg/2-3-4.html
Что такое полнотекстовый поиск (и отличия от LIKE): http://habrahabr.ru/post/40218/
*/



>>>>>  Порядок вывода <<<<<<<
select * form products order by product_no ASC; // ASC - по умолч. - по возрастанию (поля с null - в конце), DESС - по убыванию (поля с null - в начале)
select * form products order by product_no DESС null last; // null - теперь будут последними
select * form products order by product_no price, name; // сортировка по нескольким полям

/*
Полезные ссылки
Sorting rows in PostgreSQL: http://www.postgresql.org/docs/9.4/static/queries-order.html
Сортировка строк в PostgreSQL: http://postgresql.ru.net/manual/queries-order.html


/**@@
Выполните в psql запрос, который выбирает из таблицы goods все названия товаров из категории cars, отсортированных по уменьшению цены.
**/

SELECT name
    FROM goods
    WHERE category = 'cars'
    ORDER BY price DESC;



>>>>>  Ограничение выборки <<<<<<<
select * from products order by name limit 1; // использовать с order by!
select * from products order by name limit 10 offset 50; // offset - пропустить элементов. Пропущенные с помощью offset данные в любом случае проходят выборку, поэтому при большом значении offset запрос будет медленным

/*
Полезные ссылки
PostgreSQL Limit and Offset: http://www.postgresql.org/docs/9.4/static/queries-limit.html
Русскоязычная документация PostgreSQL: http://postgrespro.ru/doc/queries-limit.html

/**
Выполните в psql запрос который выбирает из таблицы goods название самого дешевого товара;
**/

SELECT name FROM goods ORDER BY price LIMIT 1;



>>>>>  Выборка уникальных записей <<<<<<<
select distinct name from products; // => 1 поле с уникальными записями
select distinct name, price from products; // => 2 поля, с уникальными записями в колонке name
select distinct on (name) name, price from products order by name desc; // distinct on - дубликаты убирают по одному полю. Обработка DISTINCT ON происходит после сортировки ORDER BY

// Предложение DISTINCT ON не является частью стандарта SQL и иногда считается плохим стилем, потому что потенциально может привести к неожиданным результатам. При разумном использовании GROUP BY и подзапросов в FROM, данное предложение может быть опущено, но часто оно является наиболее удобной альтернативой.

/*
Полезные ссылки
PostgreSQL Distinct clause: http://www.postgresql.org/docs/9.4/static/sql-select.html#SQL-DISTINCT
Distinct / Документация PostgreSQL: http://postgresql.ru.net/manual/queries-select-lists.html#QUERIES-DISTINCT

/**
Выполните в psql запрос который выбирает из таблицы goods все уникальные названия товаров, у которых категория cars;
**/

SELECT DISTINCT name FROM goods WHERE category = 'cars';


>>>>>  Группировка <<<<<<<
DROP TABLE products;

CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    category PRIMARY KEY,
    name character varying,
    price integer
);

insert into products (category, name, price) values
('cars', 'bmw', 900,),
('cars', 'bmw', 1000),
('products', 'butter', 80),
('products', 'eggs', 4);

select category, count(id) from products group by category; // группирока по категории + вывод количества катагорий =>
cars        | 2
products    | 2

select category, count(id), avg(price) from products group by category; // -//- + среднее значение =>
cars        | 2 | 950  
products    | 2 | 42

select category, name,  count(id), avg(price) from products group by category, name; // группировка по 2 значениям =>

cars        bmw     | 2 | 950  
products    butter  | 1 | 80
products    eggs    | 1 | 4

select category, name,  max(id), min(price) from products group by category, name;

select category, name,  max(id), min(price) from products group by category, name having count(id) > 1 AND avg(price) > 5; // having - where для группы

/*
Полезные ссылки
Aggregate Functions in PostgreSQL: http://www.postgresql.org/docs/9.4/static/functions-aggregate.html
Агрегатные функции в PostgreSQL: http://postgresql.ru.net/manual/tutorial-agg.html
*/

// count, max, avg - агрегатные функции
// 'where' применяется к выборке до группировки, а 'having' — после

/**@@
Выполните в psql запрос который выбирает из таблицы goods названия категорий и количество товаров в этой категории. Выбираться должны только те группы у которых больше одного товара.
**/

SELECT category, COUNT(*) FROM goods GROUP BY category HAVING COUNT(*) > 1

/*
Объединения таблиц (Inner join) 

id | category_id | name
1       1           php
2  |    1        |  ruby

id | name
1  | languages
2  | tools

select * from courses join categories on categories.id = category_id;
select cs.id as category_id, c.id as course_id from courses c join categories cs on cs.id = category_id; 


Полезные ссылки
Наглядное представление работы join на примере множеств: http://sql-joins.leopard.in.ua/
Join (SQL) / Википедия: http://bit.ly/1HTHZFE 

/**@@
Выполните в psql запрос который выбирает из таблиц goods и categories две записи состоящие из названия товаров (name) и имени категории (as category_name), у которых price больше 2 и товары отсортированы по имени в обратном порядке. Выберите не более двух записей;
**/

CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name character varying UNIQUE NOT NULL
);

CREATE TABLE goods (
    id SERIAL PRIMARY KEY,
    category_id integer,
    name character varying UNIQUE NOT NULL,
    price numeric
);

INSERT INTO categories (id, name) VALUES (1, 'cars'), (2, 'products'), (3, 'computers');

INSERT INTO goods (category_id, name, price) VALUES
    (1, 'bmw', 2.10), (null, 'kia', 700.02), (1, 'nissan', 0.9),
    (2, 'eggs', 2.13), (2, 'milk', 1.02), (null, 'butter', 2.2),
    (1, 'fiat', 500.3);



select g.name, c.name from goods g join categories c on g.id = category_id where price > 2 order by name desc;




############################ PHP PDO: Работа с базой данных ############################


>>>>>  Соединение с базой данных  <<<<<<< 

namespace Theory

$opt = [
    \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION   // режим ошибок - Exceptions    
       ];

/* $dsn = "mysql:host=$host;dbname=$db;charset=$charset"; // Формат описывающий параметры для подключения */

$pdo = new \PDO('sqlite::memory', null, null, $opt); // 2-й, 3-й параметр логин и пароль.

$pdo->exec("CREATE TABLE users (id integer, name string)"); // выполняет SQL-запрос и возвращает количество затронутых строк    
$pdo->exec("INSERT INTO users VALUES 3, 'adel')");     
$pdo->exec("INSERT INTO users VALUES (7, 'ada')");    
$data = $pdo->query("SELECT * FROM users")->fetchAll(); // выполняет SQL-запрос и возвращает результирующий набор в виде объекта PDOStatement
print_r($data);


/**
Реализуйте интерфейс App\DDLManagerInterface в классе App\DDLManager
Пример использования:
**/

$dsn = 'sqlite::memory:';
$ddl = new DDLManager($dsn);

$ddl->createTable('users', [
    'id' => 'integer',
    'name' => 'string'
]);

/*
Получившийся запрос в базу:

CREATE TABLE users (
    id integer,
    name string
);
*/

namespace App;

interface DDLManagerInterface
{
    public function __construct($dsn, $user = null, $pass = null);

    public function createTable($table, array $params);
}


namespace App;

class DDLManager implements DDLManagerInterface
{
    private $pdo;

    public function __construct($dsn, $user = null, $pass = null)
    {
        $options = [\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION];
        $this->pdo = new \PDO($dsn, $user, $pass, $options);
    }

    public function createTable($table, array $params)
    {
        $fieldParts = array_map(function ($key, $value) {
            return "{$key} {$value}";
        }, array_keys($params), $params);
        $fieldsDescription = implode(", ", $fieldParts);
        $sql = sprintf("CREATE TABLE %s (%s)", $table, $fieldsDescription);
        return $this->pdo->exec($sql);
    }  

    public function getConnection()
    {
        return $this->pdo;
    }
}



>>>>>  Безопасность при работе с внешними данными  <<<<<<<

// WRONG!!!

$id = 7;
$name = 'ada';
$pdo->exec("INSERT INTO users VALUES ($id, '$name')");


// SQL INJECTION:
$id = 8;
$name = "ada'); DELETE FROM users; --";  //  '); - закрываем запрос; -- комментируем оставшуюся часть запроса'); в конце
$sql = "INSERT INTO users VALUES ($id, '$name')";
print_r($sql);
$pdo->exec($sql);

// OK:
$VALUES = [3, 'm\'ark --']; 
$data = implode(', ', array_map(function ($item) use ($pdo) { 
    return $pdo->quote($item);  // заключает строку в кавычки (если требуется) и экранирует специальные символы внутри строки подходящим для драйвера способом.
}, $VALUES));
$sql = "INSERT INTO users VALUES ($id, '$name')";
print_r($sql);

$data = $pdo->query("select * from users")->fetchAll();
print_r($data);


/**
Query класс который предоставляет абстракцию поверх sql. Его главное достоинство это возможность строить динамические запросы без склеивания строк. Реализуйте метод toSql.

Пример использования:
**/

$query = new Query($pdo, 'users');
$query = $query->where('from', 'github');
$query = $query->where('id', '3')->where('age', 21);

// SELECT * FROM users WHERE from = 'github' AND id = 3 AND age = 21;
$query->toSql();
$query->all();


namespace App;

class Query
{
    private $pdo;
    private $table;
    private $where = [];

    public function __construct($pdo, $table, $where = [])
    {
        $this->pdo = $pdo;
        $this->table = $table;
        $this->where = $where;
    }

    public function where($key, $value)
    {
        $where = [$key => $value];
        return $this->getClone($where);
    }

    public function all()
    {
        return $this->pdo->query($this->toSql())->fetchAll();
    }

    public function toSql()
    {
        $sqlParts = [];
        $sqlParts[] = "SELECT * FROM {$this->table}";
        
        if ($this->where) {
            $where = implode(' AND ', array_map(function ($key, $value) {
                $quotedValue = $this->pdo->quote($value);
                return "$key = $quotedValue";
            }, array_keys($this->where), $this->where));
            $sqlParts[] = "WHERE $where";
        }

        return implode(' ', $sqlParts);        
    }

    private function getClone($where)
    {
        $mergedData = array_merge($this->where, $where);
        return new self($this->pdo, $this->table, $mergedData);
    }
}



>>>>>  Результат запроса в базу данных  <<<<<<<

$stmt = $pdo->query("select * from users"); // подготовленный запрос, возращает объект PDO Statement 

print_r($stmt->fetchAll()); // данные извлекаются сразу. При этом, ключи представлены дважды: как числовые индексы и как ключ в ассоциативном массиве.
print_r($stmt->fetchAll(\PSO::FETCH_ASSOC)); // возращает ассоциативный массив

// задаем дефолтный способ извлечения:
$options = [
             \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
             \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC
           ];

while ($row = $stmt->fetch()) { // работаем с курсором, данные как правило находятся в базе (зависит от клиента) 
    print_r($row);
} 

// или        

foreach ($stmt as $value) {
    print_r($value);
}

// PDO::FETCH_COLUMN - вытаскивает только одну колонку из результата.

$data = $pdo->query('SELECT name FROM users')->fetchAll(PDO::FETCH_COLUMN);

/* array (
  0 => 'John',
  1 => 'Mike',
  2 => 'Mary',
  3 => 'Kathy',
) */

// PDO::FETCH_KEY_PAIR - из двух запрошенных полей содержимое первого становится ключом, а второго - значением одномерного массива.

$data = $pdo->query('SELECT name, car FROM users')->fetchAll(PDO::FETCH_KEY_PAIR);

/* array (
  'John' => 'Toyota',
  'Mike' => 'Ford',
  'Mary' => 'Mazda',
  'Kathy' => 'Mazda',
)*/

// PDO::FETCH_UNIQ - возвращает массив с остальными полями. Первое поле должно быть уникальным.

$data = $pdo->query('SELECT * FROM users')->fetchAll(PDO::FETCH_UNIQUE);

/* array (
  'John' => array (
    'sex' => 'male',
    'car' => 'Toyota',
  ),
  'Mike' => array (
    'sex' => 'male',
    'car' => 'Ford',
  ),
  'Mary' => array (
    'sex' => 'female',
    'car' => 'Mazda',
  ),
  'Kathy' => array (
    'sex' => 'female',
    'car' => 'Mazda',
  ),
) */

$stmt = $pdo->query("select MAX(id) from users");
print_r($stmt->fetchColumn() . "\n"); // возвращает данные одного столбца  => 3


/*
Query — класс, который является абстракцией поверх sql. Его главное достоинство это возможность строить динамические запросы без склеивания строк.

Реализуйте метод count в соответствии с примером ниже.
Реализуйте метод map в соответствии с примером ниже.

Пример использования:
*/

$query = new Query($this->pdo, 'users');
$query = $query->where('social', 'github');
$query = $query->select('id', 'name');

$query->count() == sizeof($query->all());

$coll = $query->map(function ($row) {
    return $row['id'] . '-' . $row['name'];
});
print_r($coll); // ['id1-name1', 'id2-name2', ...]


namespace App;

class Query
{
    private $pdo;
    private $table;
    private $data = [
        'select' => '*',
        'where' => []
    ];

    public function __construct($pdo, $table, $data = null)
    {
        $this->pdo = $pdo;
        $this->table = $table;
        if ($data) {
            $this->data = $data;
        }
    }

    public function count()
    {
        $query = $this->select('COUNT(*)');
        $stmt = $this->pdo->query($query->toSql());
        return $stmt->fetchColumn();
    }

    public function map($func)
    {
        $stmt = $this->pdo->query($this->toSql());
        return array_map($func, $stmt->fetchAll());
    }

    public function select(...$arguments)
    {
        $select = implode(', ', $arguments);
        return $this->getClone(['select' => $select]);
    }

    public function where($key, $value)
    {
        $data = ['where' => array_merge($this->data['where'], [$key => $value])];
        return $this->getClone($data);
    }

    public function all()
    {
        return $this->pdo->query($this->toSql())->fetchAll();
    }

    public function toSql()
    {
        $sqlParts = [];
        $sqlParts[] = "SELECT {$this->data['select']} FROM {$this->table}";
        if ($this->data['where']) {
            $where = $this->buildWhere();
            $sqlParts[] = "WHERE $where";
        }

        return implode(' ', $sqlParts);
    }

    private function buildWhere()
    {
        return implode(' AND ', array_map(function ($key, $value) {
            $quotedValue = $this->pdo->quote($value);
            return "$key = $quotedValue";
        }, array_keys($this->data['where']), $this->data['where']));
    }

    private function getClone($data)
    {
        $mergedData = array_merge($this->data, $data);
        return new self($this->pdo, $this->table, $mergedData);
    }
}

// TEST:

namespace App;

class QueryTest extends \PHPUnit_Framework_TestCase
{
    private $pdo;

    public function setUp()
    {
        $opt = array(
            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION
        );
        $pdo = new \PDO('sqlite::memory:', null, null, $opt);
        $pdo->exec("
                CREATE TABLE users (id integer,
                                    name string,
                                    social string,
                                    age integer)
            ");

        $pdo->exec("INSERT INTO users VALUES (1, 'John', 'github', 17)");
        $pdo->exec("INSERT INTO users VALUES (3, 'Adel', 'facebook', 17)");
        $pdo->exec("INSERT INTO users VALUES (8, 'Mike', 'github', 17)");
        $this->pdo = $pdo;
    }

    public function testCount()
    {
        $query = new Query($this->pdo, 'users');

        $this->assertEquals(3, $query->count());
        $this->assertCount(3, $query->all());
    }

    public function testMap()
    {
      $query = new Query($this->pdo, 'users');
      $query = $query->where('social', 'github')
          ->where('age', 17);

      $coll = $query->map(function ($row) {
          return $row['id'] . '-' . $row['name'];
      });
      $this->assertEquals(['1-John', '8-Mike'], $coll);
    }
}




>>>>>  Формирование подготовленных запросов  <<<<<<<

namespace Theory

$opt = [
    \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,   // режим ошибок - Exceptions 
    \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC   
       ];

$pdo = new \PDO('sqlite::memory', null, null, $opt); // 2-й, 3-й параметр логин и пароль.

$pdo->exec("CREATE table users (id integer, name string, role string)");    
$pdo->exec("INSERT INTO users VALUES (1, 'jorn', 'member')");
$pdo->exec("INSERT INTO users VALUES (3, 'adel', 'admin')");
$pdo->exec("INSERT INTO users VALUES (7, 'ada', 'member')");	

$stmt = $pdo->query("SELECT * FROM users");

$stmt = $pdo->prepare('SELECT name FROM users WHERE role :=role'); // подготавливает запрос, :role - символьное имя. При многократном вызове такой способ работает быстрее из-за кеширования плана запроса
$stmt->bindValue(':role', 'member', \PDO::PARAM_STR); // 3-й параметр необязательный - тип данных
$stmt->execute(); // подставляет данные в запрос

$data = [
		  [1, 'jorn', 'member'],
		  [2, 'mike', 'admin'],
		  [3, 'adel', 'member']
];

$stmt = $pdo->prepare("INSERT INTO users VALUES (?, ?, ?)");
foreach ($data as $value) {
	$stmt->execute($value);
}

$stmt = $pdo->prepare("SELECT name FROM users WHERE role = ? AND name != ?"); // ? - плейсхолдер
$stmt->execute(['member', '']);

print_r($stmt->fetchAll());


/**
UserMapper это класс отвечающий за сохранение объектов класса User в базе вместе с зависимостями. В нашем примере User может содержать фотографии (класс Photo).

Структура таблиц описана в файле UserMapperTest.php.

Пример:
**/
$user = new User();
$user->addPhoto('family', '/path/to/photo/family');
$user->addPhoto('party', '/path/to/photo/party');
$user->addPhoto('friends', '/path/to/photo/friends');

$mapper = new UserMapper($pdo);
$mapper->save($user);

// Реализуйте функцию save в классе UserMapper. В этом задании достаточно реализовать логику сохранения (только вставку) фотографий пользователя.

// file Photo.php:

namespace App;

class Photo
{
    private $user;
    private $name;
    private $filepath;

    public function __construct($user, $name, $filepath)
    {
        $this->user = $user;
        $this->name = $name;
        $this->filepath = $filepath;
    }

    public function getName()
    {
        return $this->name;
    }

    public function getFilepath()
    {
        return $this->filepath;
    }
}

// file: User.php

namespace App;

class User
{
    private $photos;
    private $id;

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function getId()
    {
        return $this->id;
    }

    public function getName()
    {
        return $this->name;
    }

    public function setId($id)
    {
        $this->id = $id;
    }

    public function addPhoto($name, $filepath)
    {
        $photo = new Photo($this, $name, $filepath);
        $this->photos[] = $photo;
    }

    public function getPhotos()
    {
        return $this->photos;
    }
}

// file: UserMapper.php

namespace App;

class UserMapper
{
    private $pdo;

    public function __construct(\PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function save(User $user)
    {
        $stmtUser = $this->pdo->prepare("INSERT INTO users (name) VALUES (?)");
        $stmtUser->execute([$user->getName()]);
        $user->setId($this->pdo->lastInsertId());

        $stmt = $this->pdo->prepare("INSERT INTO user_photos (user_id, name, filepath) VALUES (?, ?, ?)");

        foreach ($user->getPhotos() as $photo) {
            $stmt->execute([$user->getId(), $photo->getName(), $photo->getFilepath()]);
        }
    }
}

namespace App\Tests;

use PHPUnit\Framework\TestCase;

use App\User;
use App\UserMapper;

class UserMapperTest extends TestCase
{
    private $pdo;
    private $mapper;

    public function setUp()
    {
        $opt = array(
            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
        );
        $pdo = new \PDO('sqlite::memory:', null, null, $opt);

        $pdo->exec("create table users (
            id integer primary key autoincrement,
            name string not null)");

        $pdo->exec("create table user_photos (
            id integer primary key autoincrement,
            user_id integer not null,
            name string not null,
            filepath string not null)");

        $this->mapper = new UserMapper($pdo);
        $this->pdo = $pdo;
    }

    public function testFetchReducer()
    {
        $user = new User('Mark');
        $user->addPhoto('family', '/path/to/photo/family');
        $user->addPhoto('party', '/path/to/photo/party');
        $user->addPhoto('friends', '/path/to/photo/friends');

        $this->mapper->save($user);

        $stmt = $this->pdo->query("SELECT COUNT(*) FROM user_photos");
        $this->assertEquals(3, $stmt->fetchColumn());
    }
}




>>>>>  Like  <<<<<<<
 
$stm = $pdo->prepare("SELECT * FROM users WHERE name LIKE %?"); // так не работает

$name = 'a';
$value = '$name%';
$stm = $pdo->prepare("SELECT * FROM users WHERE name LIKE ?");
$stm->execute($value);
$data = $stm->fetchAll(\PDO::FETCH_UNIQUE);

print_r($data);


/*
Реализуйте функцию like, которая:
 * принимает на вход pdo и массив
 * строит запрос по данным из массива
 * выполняет запрос
 * возвращает данные в формате PDO::FETCH_COLUMN
Запрос должен возвращать id из таблицы users. У массива структура следующая: 1) ключ - это название поля; 2) значение - это часть запроса, которую нужно использовать в like выражении. Лайки из этого массива нужно соединять с помощью OR. Если массив пустой, то запрос должен выполнять следующий sql: select id from users.

Пример:
**/

$pdo->exec("create table users (id integer, first_name string, email string)");
$pdo->exec("insert into users values (1, 'john', 'john@gmail.com')");
$pdo->exec("insert into users values (3, 'adel', 'adel@yahoo.org')");

$params = ['email' => '%gmail%', 'first_name' => 'ad%'];

[1, 3] == like($pdo, $params); // select id from users where email LIKE ? OR first_name LIKE ?

function like($pdo, array $params)
{
    if (!$params) {
       $stmt = $pdo->query("SELECT id FROM users"); 
    } else {    
        $keys = array_map(function ($key) {
            return "$key LIKE ?";
        }, array_keys($params));

        $values = array_values($params);

        $stmt = $pdo->prepare("SELECT id FROM users WHERE " . implode(' OR ', $keys));
        $stmt->execute($values);
    }
    return $stmt->fetchAll(\PDO::FETCH_COLUMN);
}

#2:

function like($pdo, array $params)
{
    $likeParts = array_reduce(array_keys($params), function ($acc, $item) {
        $acc[] = "$item LIKE ?";
        return $acc;
    }, []);
    $sqlParts = [];
    $sqlParts[] = "select id from users";
    if (!empty($likeParts)) {
        $sqlParts[] = "where";
        $sqlParts[] = implode(" OR ", $likeParts);
    }
    $sql = implode(" ", $sqlParts);
    $stmt = $pdo->prepare($sql);
    $stmt->execute(array_values($params));

    return $stmt->fetchAll(\PDO::FETCH_COLUMN);
}


>>>>>  Реализация in  <<<<<<<

$opt = [
    \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
    \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC
];

$pdo = new \PDO('sqlite::memory:', null, null, $opt);
$pdo->exec("create table users (id integer, name string)");

$data = [
    [1, 'john'],
    [3, 'adel'],
    [8, 'ada']
];

$stmt = $pdo->prepare("insert into users values (?, ?)");
foreach ($data as $value) {
    $stmt->execute($value);
}

$idx = [1, 2, 3];
$in = implode(', ', array_fill(0, sizeof($idx), '?')); // заполняет массив значениями
$sql = "SELECT * FROM users WHERE id IN ($in)";
$stm = $pdo->prepare($sql);
$stm->execute($idx);
print_r($stm->fetchAll());


/**
Реализуйте функцию where, которая принимает на вход соединение с базой данных и массив описывающий условия выборки. Функция должна вернуть список идентификаторов пользователей отсортированных по возрастанию.

Пример:
**/

where($pdo, []);           // select id from users order by id
where($pdo, ['id' => []]); // select id from users order by id

// select id from users where first_name in ('john', 'adel') order by id
where($pdo, ['first_name' => ['john', 'adel']])

// select id from users where first_name = 'ada' or source in ('bing', 'gmail') order by id
where($pdo, ['first_name' => 'ada', 'source' => ['bing', 'gmail']])


function where($pdo, $params)
{
    $whereParts = array_reduce(array_keys($params), function ($acc, $key) use ($pdo, $params) {
            $values = (array) $params[$key];
            if ($values) {
                $in = array_map(function ($item) use ($pdo) {
                    return $pdo->quote($item);
                }, $values);
                $joinedIn = implode(", ", $in);
                $acc[] = "$key IN ($joinedIn)";
            }
            return $acc;
    },[]);

    $where = $whereParts ? 'WHERE ' . implode(' OR ', $whereParts) : '';
    $query = sprintf("SELECT id FROM users %s ORDER BY id", $where);
    $stmt = $pdo->prepare($query);
    $stmt->execute();

    return $stmt->fetchAll(\PDO::FETCH_COLUMN); 
}