post: https://habr.com/ru/post/133781/

@@@@ Работа с индексами @@@@
/*
Таблица, в который нет индексов, представляет собой беспорядочный набор строк, и для поиска нужной записи, допустим по id, необходимо проверить все ее строки на совпадение с искомым значением, для этого нужно просканировать всю таблицу от начала до конца. Это может занять много времени и будет исключительно неэффективно, особенно если таблица содержит только несколько записей, удовлетворяющих условию поиска.

В качестве примера рассмотрим таблицу, содержащую подведомственные рассматриваемому интернет-провайдеру организации. В данном контексте в таблице присутствует два поля – id организации (org_id) и название организации (org_name).

Допустим, мы добавили индекс на поле org_id (см. Рис. 1 ). Индекс содержит запись о каждой строке из таблицы, и записи индекса отсортированы по значению org_id. Теперь вместо сканирования всех записей в таблице мы можем воспользоваться индексом. Предположим, что требуется найти строку, содержащую запись об организации (Институт автоматики и электрометрии СО РАН), у которой уникальный идентификатор (org_id) равен 2. Сканирование по индексу возвращает одну строку. Значения в индексе отсортированы по возрастанию, поэтому достижении следующего значения (с org_id равным 3) можно завершать сканирование: после 3 мы уже не найдем нужных значений. В случае, если искомые значения находятся где-то посередине таблицы, с помощью специальных алгоритмов (например, методом бинарного поиска) можно перейти к нужной строке без длительного линейного сканирования таблицы.

В целом, большинство запросов можно оптимизировать, если правильно создать нужные индексы в таблице и построить запрос так, чтобы они эффективно использовались. Однако существуют такие запросы, скорости выполнения которых отнюдь не помогают индексы — например, в случае, когда по индексу выбирается больше чем около 1/10 всех записей в таблице, оптимизатор предпочтет FTS (Full Table Scan) вместо использования индекса, поскольку последовательное чтение с диска происходит быстрее, чем читать из разных частей диска (передвижение головки по диску — seek — это “дорогая” операция). Оптимизатор можно “заставить” использовать индекс, используя опцию FORCE INDEX, но это обычно не даёт выигрыша в скорости. Также таблицы могут быть такого большого размера, что создание индекса будет непрактичным с точки зрения занимаемого объема или длительности выполнения операции. Кроме того, за удобство использования индексов приходится определенным образом “расплачиваться”, у индексов есть свои недостатки. В большинстве своем они незначительны, но о них стоит знать.
*/



@@@@ Недостатки использования индексов @@@@
/*
Во-первых, индексы ускоряют поиск данных, но замедляют операции добавления, удаления и модификации данных в индексируемых столбцах, поскольку при каждом изменении данных в такой таблице приходится перестраивать индекс. Взаимосвязь тут простая: чем больше индексов имеет таблица, тем больше замедление операций над записями.

Во-вторых, индексный файл занимает определенное место на диске (нередки случаи, когда индексы занимают больше места, чем сами данные). При создании большого количества индексов, размер такого индексного файла может быстро достичь максимального размера. Это может стать причиной достижения предельного размера таблицами быстрее, чем это было бы без использования индексов.

Для таблиц типа MyISAM излишнее индексирование таблиц может привести к достижению индексным файлом его максимального размера быстрее, чем файлом данных ( проблему можно решить с помощью PARTITIONING).

Таблицы типа BDB хранят данные и индексы в одном файле. Это, безусловно, является причиной более быстрого достижения максимального размера табличным файлом.

Таблицы типа InnoDB размещаются в едином табличном пространстве. При добавлении индексов дисковое пространство, отведенное под табличное пространство, будет исчерпано быстрее.
*/



@@@@ Глобальные переменные @@@@
/* Найти изделия с минимальной ценой:*/
SELECT @min_price:=MIN(price) FROM shop;
SELECT * FROM shop WHERE price=@min_price;

/*
 * Записываются как @var_name.
 * Принимают значения целого (int), дробного (real) и строчного (string) типа.
 * Присваивание переменной значения производится через оператор SET (SET @var1='RUS'),
 * или через оператор SELECT (SELECT 'RUS' INTO @var1;),
 * или в ходе выполнения запроса через оператор “:=” (“=” трактуется как равенство) (@var1:=72).
 *
 * Неинициализированная переменная принимает значение NULL.
 */

/** Преимущества использования:
 * Возможность сохранять промежуточные результаты в переменных и оперировать им по ходу дальнейшего выполнения
 * запроса
 * Позволяет значительно ускорить выполнение некоторых запросов (за счет меньшего количества сканирований таблицы),
 * а также позволяет выполнять такие запросы, которые в стандартной реляционной модели реализуются очень сложно или вовсе не реализуются.
 */

/** Недостатки использования:
 * Сложная переносимость на другие СУБД (механизм ПП служит определенной надстройкой над реляционной моделью баз данных в рамках СУБД MySQL). Впрочем, данный недостаток не очень критичен, поскольку на данный момент все крупные СУБД имеют свои отклонения от стандарта ANSI SQL.
 * Поведение глобальных переменных будет зависеть от порядка выполнения сложного запроса, который может меняться
 оптимизатором MySQL (если не используется оператор STRAIGHT_JOIN).
 */

 /** Использование:
  * запрос таков, что не может эффективно использовать индексы (количество выбранных значений по индексу чересчур
  велико и оптимизатор делает FTS);
  * в ходе выполнения запроса используются вычисленные на предыдущих шагах и занесенные в глобальные переменные
  значения.
*/



@@@@ Локальные переменные @@@@
/*
 * Объявляются в начале блока BEGIN/END
 * Доступны только внутри процедуры.
 */
CREATE PROCEDURE `var_proc` (IN paramstr VARCHAR(20))
BEGIN
  DECLARE a, b INT DEFAULT 5;
  DECLARE str VARCHAR(50);
  DECLARE today TIMESTAMP DEFAULT CURRENT_DATE;
  DECLARE v1, v2, v3 TINYINT;

  INSERT INTO table1 VALUES (a);
  SET str = 'I am a string'; /* задаем значение локальной переменной */
  SELECT CONCAT(str,paramstr), today FROM table2 WHERE b >=5;
END;


@@@@ Хранимые процедуры (> 5 версии) @@@@

/*
 * Позволяют автоматизировать сложные процессы на уровне MySQL, нежели использовать для этого внешние скрипты.
 * Это даёт наиболее высокую скорость выполнения, т.к. мы не выполняем большое количество запросов,
 * а всего лишь один раз вызываем ту или иную процедуру (или функцию).
  */

/* Параметры: */
CREATE PROCEDURE proc1 () /* пустой список параметров */
CREATE PROCEDURE proc1 (IN varname DATA-TYPE) /* один входящий параметр. Слово IN необязательно, потому что
параметры по умолчанию - IN (входящие). */
CREATE PROCEDURE proc1 (OUT varname DATA-TYPE) /* один возвращаемый параметр. */
CREATE PROCEDURE proc1 (INOUT varname DATA-TYPE) /* один параметр, одновременно входящий и возвращаемый. */
/* Можно задавать несколько параметров разных типов. */


CREATE PROCEDURE `procedure1`(IN iInput1 INT, IN iInput2 INT)
SELECT * FROM `data` WHERE `id` = iInput1 AND `id2` = iInput2;

/* Пример: Один из хороших случаев применения хранимых процедур - тогда, когда вам нужно объединить несколько
запросов в один, например добавление темы в форум и увеличение общего количества тем: */
CREATE TABLE `threads` ( `id` INT NOT NULL AUTO_INCREMENT , `title` VARCHAR(255) NOT NULL, `tag` VARCHAR(255) NOT NULL, PRIMARY KEY ( `id` ) ) ENGINE = MYISAM;
/* таблица, с различными статистическими переменными сайта, в том числе общее количество тем в форме. */
CREATE TABLE `variables` ( `id` INT NOT NULL AUTO_INCREMENT , `name` VARCHAR(255) NOT NULL, `value` INT NOT NULL DEFAULT 0, PRIMARY KEY ( `id` ) ) ENGINE = MYISAM;

/* Допустим у нас там есть запись с name = threads и value = 0. Создадим новую хранимую процедуру procedure2. */
CREATE PROCEDURE `procedure2`(IN sTitle VARCHAR(255))BEGIN
  INSERT INTO `threads` (`title`) VALUES (sTitle);
  UPDATE `variables` SET `value` = `value` + 1 WHERE `name` = `threads`;
END

/* Два запроса объединили в один. Теперь мы можем вызвать эту процедуру таким образом: */
CALL procedure2(`My new thread`);
/* Таким образом, вместо того, чтобы делать два или больше запросов (например через php), мы можем передать один */


@@@@ Курсоры @@@@
/* Курсоры позволяют пройтись по всем полученным результатам запроса. Добавим еще одну таблицу - hits: */
CREATE TABLE `tags` ( `id` INT NOT NULL AUTO_INCREMENT , `tag` VARCHAR(255) NOT NULL , PRIMARY KEY ( `id` ) ) ENGINE = MYISAM
/* Сюда мы будем записывать все тэги из всех тем. Хранимая процедура будет выглядеть так: */
CREATE PROCEDURE `procedure3`()BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE sTag VARCHAR(255);
  DECLARE iCount INT DEFAULT 0;

  DECLARE rCursor CURSOR FOR SELECT `tag` FROM `threads` WHERE 1;
  DECLARE CONTINUE HANDLER FOR SQLSTATE `02000` SET done=1;

  OPEN rCursor;
    FETCH rCursor INTO sTag;

    WHILE done = 0 DO
      SELECT COUNT(*) INTO iCount FROM `tags` WHERE `tag` = sTag;

      IF iCount = 0 THEN
        INSERT INTO `tags` (`tag`) VALUES (sTag);
      END IF;

      FETCH rCursor INTO sTag;
    END WHILE;

  CLOSE rCursor;
END

/*
Подробно. Процедура пройдет через каждую тему, каждый тег пробьет по таблице tags, и если данный тег отсутствует, то она его добавит.

Курсор для запроса SELECT, который выберет теги из всех тем (WHERE 1). После курсора объявляем что-то вроде исключения - что делать, когда результаты кончатся (SQLSTATE "02000′ означает это окончание). В этом случае мы в переменную done запишем 1, чтобы в последствии выйти из цикла.

Открываем курсор, и получаем первую запись. Дальше в цикле - Выбираем количество совпадений из таблицы тегов для текущего тега и помещаем результат в переменную iCount. Если результатов нет, то запросом INSERT вставляем новый тег.

В конце концов закрываем курсор и выходим из процедуры. Ну вот и всё.
*/


/* Извлечение данных: */
CREATE PROCEDURE `procedure4`() BEGIN
  DECLARE iTags INT DEFAULT 0;
  DECLARE iThreads INT DEFAULT 0;

  SELECT COUNT(*) INTO iTags FROM `tags`;
  SELECT COUNT(*) INTO iThreads FROM `threads`;

  SET @tags = iTags, @threads = iThreads;
END

/*
Объявляем две переменных - iTags - количество тегов, и iThreads - общее количество тем.

Далее два простых запроса на выборку, заполняя наши переменные. В конце присваиваем системным переменным значения
текущих простых переменных. При вызове данная процедура ничего не возвращает, но после ее вызова мы можем считать требуемые значения из системных переменных:
*/
CALL procedure4();SELECT @tags, @threads;

DROP PROCEDURE IF EXISTS procedure4; /* удаление хранимой процедуры */


@@@@ IF @@@@

CREATE PROCEDURE `proc_IF` (IN param1 INT)
BEGIN
  DECLARE variable1 INT;
  SET variable1 = param1 + 1;

  IF variable1 = 0 THEN
    SELECT variable1;
  END IF;

  IF param1 = 0 THEN
    SELECT 'Parameter value = 0';
  ELSE
    SELECT 'Parameter value <> 0';
  END IF;
END;



@@@@ CASE @@@@
/*
 * CASE - это еще один метод проверки условий и выбора подходящего решения.
 * Это отличный способ замены множества конструкций IF.
 * Конструкцию можно описать двумя способами, предоставляя гибкость в управлении множеством условных выражений.
*/

CREATE PROCEDURE `proc_CASE` (IN param1 INT)
BEGIN
  DECLARE variable1 INT;
  SET variable1 = param1 + 1;

  CASE variable1
    WHEN 0 THEN
      INSERT INTO table1 VALUES (param1);
    WHEN 1 THEN
      INSERT INTO table1 VALUES (variable1);
    ELSE
      INSERT INTO table1 VALUES (99);
  END CASE;
END

/* или */

CREATE PROCEDURE `proc_CASE` (IN param1 INT)
BEGIN
  DECLARE variable1 INT;
  SET variable1 = param1 + 1;

  CASE
    WHEN variable1 = 0 THEN
      INSERT INTO table1 VALUES (param1);
    WHEN variable1 = 1 THEN
      INSERT INTO table1 VALUES (variable1);
    ELSE
      INSERT INTO table1 VALUES (99);
  END CASE;
END;


@@@@ WHILE @@@@
/* Технически, существует три вида циклов: цикл WHILE, цикл LOOP и цикл REPEAT. */

CREATE PROCEDURE `proc_WHILE` (IN param1 INT)
BEGIN
  DECLARE variable1, variable2 INT;
  SET variable1 = 0;

  WHILE variable1 < param1 DO
    INSERT INTO table1 VALUES (param1);
    SELECT COUNT(*) INTO variable2 FROM table1;
    SET variable1 = variable1 + 1;
  END WHILE;
END