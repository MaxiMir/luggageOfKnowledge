<?
########## PHP: Настройка окружения ##########
/*
мы поддерживаем репозиторий php-package (https://github.com/hexlet-boilerplates/php-package) — так называемый бойлерплейт. Репозиторий, содержащий базовую структуру проекта на PHP. Вы всегда можете подглядывать в него и делать по аналогии.

Если все прошло удачно, то теперь самое время повыполнять код на PHP. PHP поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для его запуска достаточно набрать php -a (в Windows REPL не работает):
*/

$ php -a
Interactive shell

php >

// Теперь можно выполнять код на PHP и сразу же смотреть результат его выполнения. Наберите любой валидный код на PHP, например такой:

php > echo 5 + 10;
15
php >

/*
REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из репла достаточно нажать Ctrl + C. Если вы ошиблись при вводе команды, например забыли ;, то всегда можно выйти и зайти снова.

Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
*/

php > $a = 5;
php > $b = 10;
php > echo $a + $b;
15

// Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях, когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением php, например, index.php, а затем запустить:

// index.php:

<?php

echo 'hello!';


$ php index.php
hello!

// Обратите внимание, что запускать код нужно из той же директории, в которой лежит файл index.php, либо указывать путь до файла.




########## Composer ##########

/*
Composer — это свободный пакетный менеджер для установки зависимостей и самих модулей PHP. С помощью скрипта можно в несколько нажатий установить нужный модуль, а также все его зависимости, например, ZendFramework или Symphony. Он широко используется разработчиками PHP скриптов. 

Практически с самого зарождения программирования (когда код стал храниться в памяти компьютера), появилась идея переиспользования кода не только в рамках одного проекта, но и сквозь разные проекты. Например, функции для работы с датами, математическими формулами, всевозможными расчетами одни и те же во всех проектах, где они требуются. Подобное переиспользование приводит к резкому возрастанию производительности. Программисты современности могут сосредоточиться на решении уникальных задач бизнеса, вместо создания своих велосипедов для решения инфраструктурных задач. Особенно просто стало жить во времена git и github.

Первоначально общий код выносился в файлы, которые программисты часто держали на своих собственных компьютерах и копировали из проекта в проект. Такой способ обладает рядом существенных недостатков:

    Сложно передать другим
    У каждого своя собственная копия решений одних и тех же решений (немного разных решений)
    Доработкой занимается только автор
    В сумме много разных копий без возможности быстрого обновления
    Из-за того, что код копируется прямо в другой проект, он, как правило, модифицируется и становится специфичным

Если использовать git, то часть проблем решается автоматически. Мы можем сказать, что набор общих файлов называется "библиотека", а конечные проекты начинают использовать библиотеки как написанные нами, так и сторонними разработчиками. Но тут возникает следующая сложность - когда таких библиотек становится много, то у них также появляется общий код более низкого уровня. Например, финансовые библиотеки могут использовать функции для преобразования валют. Чтобы подобный код не дублировался, хочется его вынести в общее место. Этот процесс может продолжаться бесконечно. Одни библиотеки зависят от других, те в свою очередь от третьих и так далее. С точки зрения переиспользования кода все хорошо, большое число маленьких библиотек, решающих всевозможные задачи, позволяют быстро двигаться вперед, но с точки зрения управления появляются проблемы:

    Необходимо ввести понятие "версия", а библиотеки начинают зависеть не только друг от друга, но и от версий друг друга. Почему это нужно? Очень просто. Предположим, что создатель библиотеки обновил её, изменив сигнатуры функций (другое число параметров, другие параметры, другой возврат), или, как говорят, сломал обратную совместимость. В такой ситуации наша первоначальная библиотека перестанет работать (если мы обновим вторую библиотеку), так как она рассчитывала на одно поведение зависимой библиотеки, а получила другое.

    Необходимо стандартизировать способ создания библиотек, только в таком случае станет возможным автоматизировать процесс их соединения без ручного управления. Скажу навскидку, типичный веб проект может зависеть от сотни библиотек, которые в свою очередь зависят от других библиотек. Общее число зависимостей может легко перевалить за тысячу. Руками управлять таким зоопарком не представляется возможным.

    Проблема, описанная выше, также требует наличия автоматизированного средства по управлению зависимостями. Обновлению, установке и удалению.

Всеми этими вопросами занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется прямо с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.

# Терминология

В PHP используются следующие понятия.
Пакет - собственно, та самая библиотека, которую мы либо пишем, либо используем в проекте как зависимость.

Репозиторий (Registry) - хранилище пакетов PHP, которое называется Packagist. Каждый желающий может опубликовать пакет в Packagist, потратив буквально минуту времени, а остальные смогут его использовать. В хранилище, на текущий момент, сотни тысяч пакетов и их количество растет. Исходный код пакетов, как правило, хранится на гитхабе, но это не обязательно. Пакеты в PHP никак не связаны с git и github.



# Глобальная установка пакетов

Многие пакеты в PHP представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту phploc, которая умеет считать количество строк и сущностей в PHP проекте. Инструкция по установке подобных пакетов обычно присутствует на странице репозитория в гитхабе (https://github.com/sebastianbergmann/phploc).
*/
$ composer global require phploc/phploc

/*
Отмечу несколько моментов:
	global - означает, что установка глобальная, то есть пакет ставится в операционную систему как обычная программа

	Чтобы shell увидел программу, установленную глобально, нужно правильно настроить переменную окружения $PATH

# Переменные окружения

PATH

В файловых системах ОС существует понятие "исполняемый файл" или, как часто говорят, бинарник (в реальности он не всегда бинарный). Именно эти файлы запускаются, когда определенная команда в shell представлена реальной программой (и это бывает не всегда). Например, запуск ls в Bash. Кстати, узнать где лежит этот файл можно командой which ls. Возможно, сейчас вам кажется, что в запуске программ ничего необычного, но дьявол кроется в деталях. Правильный вопрос звучит так: откуда shell знает, где искать этот бинарник? Ведь, если взять и самостоятельно создать подобный файл и назвать его hey, а потом положить в произвольное место системы, то попытка запустить hey ни к чему не приведет.
*/

$ hey
-bash: hey: command not found

// Весь секрет состоит в использовании переменных окружения. Мы не будем говорить про них подробно (об этом в курсе по командной строке), но общий принцип следующий — переменные окружения глобальны и доступны всем. Их основное предназначение - конфигурация. Так вот, существует некая системная переменная PATH, внутри которой содержатся пути, по которым shell ищет то, что вы пытаетесь запустить. Вот вывод на моем ноутбуке:

$ echo $PATH
/usr/local/sbin:/usr/local/opt/postgresql@9.5/bin:~/.composer/vendor/bin:~/.yarn/bin:/var/tmp/nim/bin:~/.local/bin:~/.nimble/bin:~/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/Library/Frameworks/Mono.framework/Versions/Current/Commands

/*
: отделяет пути друг от друга. Этот список у всех разный, так как его можно настраивать и многие программы это делают автоматически. Иногда приходится его расширять самостоятельно.

В большинстве языков программирования пакетные менеджеры подкладывают ссылки на установленные пакеты в стандартные пути. Например, в /usr/local/bin. Этот путь добавлен в $PATH по умолчанию, а значит любой исполняемый файл внутри него будет найден при вызове из командной строки.

В случае Composer необходимо добавлять путь в $PATH самостоятельно. Самый простой способ это сделать - добавить в конец файла ~/.bash_profile следующую строку: export PATH=$PATH:$HOME/.composer/vendor/bin (после этого нужно открыть новую терминальную сессию). Теперь оболочка будет искать исполняемые файлы и в папке ~/.composer/vendor/bin.

Возвращаемся к phploc. Процесс установки занимает некоторое время, в течении которого видно как скачивается не только сам пакет, но и его зависимости. Дальше ничего делать не нужно, так как phploc создан утилитой командной строки, он сразу готов к использованию.
*/

$ phploc src

phploc 4.0.0 by Sebastian Bergmann.

Directories                                          3
Files                                               10

Size
  Lines of Code (LOC)                             1882
  Comment Lines of Code (CLOC)                     255 (13.55%)
  Non-Comment Lines of Code (NCLOC)               1627 (86.45%)
  Logical Lines of Code (LLOC)                     377 (20.03%)
    Classes                                        351 (93.10%)
      Average Class Length                          35
        Minimum Class Length                         0
        Maximum Class Length                       172
      Average Method Length                          2
        Minimum Method Length                        1
        Maximum Method Length                      117
    Functions                                        0 (0.00%)
      Average Function Length                        0
    Not in classes or functions                     26 (6.90%)

/*
Если что-то пошло не так, убедитесь что вы все правильно настроили:
	Изучите вывод echo $PATH. Есть ли там путь до исполняемых файлов Composer.
	Проверьте, все ли установилось командой which phploc.


# Проект

Composer работает таким образом, что объединяет понятия "проект" (приложение или application) и "пакет" в одно целое. В общем случае считается, что проект, в отличие от пакета, это конечный продукт, который никуда не публикуется, что довольно очевидно. Если компания делает сайт на PHP, то этот сайт, хотя и использует публичные зависимости, сам по себе хранится в приватном репозитории и никуда не утекает. Но с точки зрения Composer все происходит одинаково. Причем под проектом понимается не обязательно что-то большое. Даже если ваш проект (файл) состоит из 3 строчек кода и использует зависимости, вам понадобится работать с ним как с полноценным проектом. Начинается все просто. Необходимо выполнить команду composer init в той папке, где вы собираетесь писать код.
*/

$ composer init


  Welcome to the Composer config generator

This command will guide you through creating your composer.json config.

Package name (<vendor>/<name>) [sergey/example]:
Description []:
Author [Kirill Mokevnin <mokevnin@gmail.com>, n to skip]:
Minimum Stability []:
Package Type (e.g. library, project, metapackage, composer-plugin) []:
License []:

Define your dependencies.

Would you like to define your dependencies (require) interactively [yes]?
Search for a package:
Would you like to define your dev dependencies (require-dev) interactively [yes]?
Search for a package:

{
    "name": "sergey/example",
    "authors": [
        {
            "name": "Sergey",
            "email": "sergey@sergey.com"
        }
    ],
    "require": {}
}

Do you confirm generation [yes]?


/*
После этого вам предложат ответить на десяток вопросов. Если вы не понимаете значение некоторых вопросов, то смело жмите Enter, потом все можно будет поправить.

Когда вопросы закончатся, Composer покажет конечный результат в виде JSON. JSON - это текстовый формат для представления структурированных данных. Если вы не знакомы с ним, то не стоит переживать, формат это не язык программирования. Достаточно выучить несколько правил по формированию данных в виде JSON для того, чтобы чувствовать себя комфортно.
*/

{
    "name": "mokevnin/myproject",
    "authors": [
      {
      "name": "Kirill Mokevnin",
      "email": "mokevnin@gmail.com"
      }
    ],
    "require": {}
}

/*
Если вас все устраивает, то Composer создаст файл composer.json. Именно этот файл является ключевым. Абсолютно все, что касается зависимостей (и не только), полностью описывается в нем.

Имя пакета, записанное в composer.json, состоит из двух частей. Первая - vendor name, имя, под которым вы зарегистрированы в Packagegist, вторая - project name. Причем vendor name уникален глобально (то есть все пользователи имеют свое собственное неповторимое имя), а вот project name должен быть уникален только в пределах vendor name.

Composer рекомендует именовать пакет словами в нижнем регистре и в качестве разделителя использовать дефис, например: dependency-injection.

# Проблемы

Если в файле composer.json содержатся синтаксические ошибки, иными словами, есть нарушения правила форматирования JSON, то при попытке сделать что-то с проектом будут появляться подобные ошибки:
*/

[Seld\JsonLint\ParsingException]
"./composer.json" does not contain valid JSON
Parse error on line 2:
"name": "mokevnin/myproject",
---------^

/*
Обычно любые сообщения с «неожиданными» (unexpected) символами или строками говорят о наличие синтаксической ошибки.

Воспользуйтесь валидаторами JSON для проверки корректности своего файла. Например, jsonlint.com или другими подобными инструментами, которые можно загуглить по запросу "json validator".


# Самостоятельная работа
    Создайте директорию my-project в любом удобном месте вашего компьютера
    Создайте проект в директории my-project используя composer init

В результате в папке проекта должен оказаться файл composer.json
*/