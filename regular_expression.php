<?
################# REGULAR EXPRESSION #################

/./g - любой символ
/\./g - // экранирование символа '.' 
/g // глобальный поиск (обрабатываются все совпадения с шаблоном поиска)

/*
Полезные ссылки
Википедия: Регулярные выражения: https://ru.wikipedia.org/wiki/Регулярные_выражения
Онлайн редактор регулярных выражений: https://regex101.com
Cheatsheet: таблица синтаксиса регулярных выражений: https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/
*/

>>>>> символьные классы <<<<<<<
/[a-z]/g // интервал, любой символ от «a» до «z»
/\d/g // десятичная цифра <-> [0-9]
/\D/g // любой символ, кроме десятичной цифры
/\s/g // пробельный символ
/\S/g // любой символ, кроме промельного
/\w/g // любая цифра, буква или знак подчеркивания  <-> [0-9a-zA-Z_]
/\W/g // любой символ, кроме цифры, буквы или знака подчеркивания
/[aj]/g // группа символов 'a', 'j': java => JAvA
/[aj-]/g // группа символов 'a', 'j' и '-'
/[^aj]/g // ^ - инвертирование java => jaVa



/**
Напишите регулярное выражение, в котором:
	Первый и второй символ это числа
	Третий символ это /
	Четвертый это любой символ, за исключением a-z
**/

/\d\d/[^a-z]/g



>>>>> Позиция внутри строки <<<<<<<

/^java/g // ^ - начало строки
/$script/g // $ - конец строки
/a\b/g // \b - конец слова: java => javA
/\bj/g // \b - начало слова: java => Java
/a\B/g // \B - все, что не в конце слова: java => javA
/\Bj/g // \B - все что в не вначале слова: clojurescriptj => cloJurescriptJ
/\Bj\B/g // \B - только в середине слова: clojurescriptj => cloJurescriptj

hello and hello again, my friend! // /^hello\b/g => HELLO and hello again, my friend!



>>>>> Альтернатива <<<<<<<

/gray|grow/g //  <-> /gr(ay|ow)/g gray grow grey => GRAY GROW grey
/gr[ae]y/g // gray grow grey => GRAY grow GREY


/**
Напишите регулярное выражение, которое соответствует подстрокам one или two или three.
**/

/one|two|three/g


>>>>> Квантификация <<<<<<<

/col[ou]?r/g // ? количество раз, сколько предыдущая группа может повторятся COLOR, colour, colouur, colouuur
/colou?r/g // ? ни разу или 1 раз: color, colour, colouur, colouuur => COLOR, COLOUR, colouur, colouuur
/colou+r/g // + как минимум 1 раз: color, colour, colouur, colouuur => color, COLOUR, COLOUUR, COLOUUUR
/colou*r/g // * ни разу или сколько угодно раз: => color, colour, colouur, colouuur => COLOR, COLOUR, COLOUUR, COLOUUUR
/colou{2}r/g // {n} точное число повторений: color, colour, colouur, colouuur => color, colour, COLOUUR, colouuur
/colou{2,}r/g // {n,} минимальное количество повторений:  color, colour, colouur, colouuur => color, colour, COLOUUR, COLOUUUR
/colou{2,3}r/g // {n,m} повторение от т до m: color, colour, colouur, colouuur => color, colour, COLOUUR, COLOUUUR


/**
Напишите регулярное выражение, которое находит email адреса, удовлетворяющие следующим условиям:

Часть до @ может содержать не менее одного символа класса \w. Пример: info;
Часть после @ и до ., после которой начинается домен, может содержать только буквы и быть не короче трех символов. Пример: hexlet;
Часть после . может содержать только буквы и быть от 2 до 5 символов в длину. Пример: io.
**/

^\w+@[a-zA-Z]{3,}\.[a-zA-Z]{2,5}$



>>>>> Жадность <<<<<<<

\<.*>\g // все в <> => <a href="http://www.yandex.ru">google</a>
\<[^>]*>\g // все кроме ">" => <a href="http://www.yandex.ru"> и </a>
\<.*?>\g // ? - из "жадного" квантификатора делает "ленивого" => <a href="http://www.yandex.ru"> и </a>

<?
/**
Напишите регулярное выражение, которое находит подстроки, состоящие из:
(
Хотя бы один любой символ
)
**/

\(.+?\)



>>>>> Группировка. Обратная связь <<<<<<<

/(ta|tu)-\1/g // подставить значение 1 группы:ta-tu ta-ta tu-tu => ta-ta tu-tu
/(?:ta|tu)-\1/g // отключить обратную связь
a(?>bc|b|x)cc // атамарная группировка возврат по строке отключается(ищет не с b, c a): abccaxcc => abccAXCC

<?
/**
Напишите регулярное выражение, которое находит подстроки состоящие из:
 три символа из класса символов a-z
 :
 группа символов из первого условия
**/

([a-z]{3}):\1



 
>>>>> Модификаторы <<<<<<<


/(?:t.)-(?:t.)/g // => ta-tu

ta-tu ta-t
Tu-tu tu-T

/(?i:t.)-(?:t.)/g // i - включить режим регистронезависимости => ta-tu Tu-tu
/(?i:t.)-(?si:t.)/g // s - '.' начинает включать перенос строки и возврат каретки => ta-tu ta-t Tu-tu tu-T
/(?-i:t.)-(?si:t.)/g // - - отключение модификатора => ta-tu ta-t tu-T


>>>>> Просмотр вперед/назад <<<<<<<



LudovicXV, LudovicXVI, LudovicXVIII, LudovicLXVII, LudovicXXL

/Ludovic(?=XVI)/g // позитивный просмотр вперед: за которой следует XVI => Ludovic без XVI Ludovic без XVIII
/Ludovic(?!XVI)/g // негативный проосмотр вперед: за которыми не следует XVI => Ludovic без XV Ludovic без LXVII Ludovic без XXL
/(?<=One )Two/g // просмотр назад позитивный: One Two, Free Two => Two без One
/(?<!One )Two/g // просмотр назад негативный: One Two, Free Two => Two без Free

/**
Напишите регулярное выражение, которое находит подстроку 1, за которой следует подстрока 2:
 80
 : и один или более символов не входящих в класс a-z
Используйте позитивный просмотр вперед.
**/

// match
['80:8080, 80:!@#$'];

// not match
['80:', '80', '80:d123f'];


>>>>> Флаги <<<<<<<

/aa/ // aa aa aa => AA aa aa
/aa/g // g - global (поиск всех сопоставлений) aa aa aa => AA AA AA
// i - игнорирование регистра, s - переводы строк не учитываются

>>>>> Поиск по условию <<<<<<<

(?(?<=a)m|p) // mam, pap => maM, Pap
