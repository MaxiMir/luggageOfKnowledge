<?

############### ООП ###############

/*
#1 Онтология
Описание объектов рассматриваемой области и связей между ними называется онтологией предметной области. Эту онтологию хорошо знают эксперты соответствующей области (в бухгалтерии — бухгалтер, в обучении — преподаватель), но в отличие от программистов, они часто представляют ее на интуитивном уровне, неформально. На практике, программисты (или бизнес-аналитики и менеджеры) общаются с заказчиками, которые могут сами выступать в роли экспертов и строят вместе с ними формальную онтологию (этот процесс происходит постоянно в процессе развития проекта и не выделяется в отдельный этап проектирования). То есть выделяют конкретные термины, договариваются о том что они означают и как связаны друг с другом. Затем, используя ER-модель (https://ru.wikipedia.org/wiki/ER-модель), программист формирует необходимую модель данных. ER-модель — используется при высокоуровневом (концептуальном) проектировании баз данных. На этом этапе уже проявляются зачатки архитектуры будущего приложения.

Кстати, далеко не всегда можно однозначно сказать какая связь существует между двумя сущностями. Иногда программисты думают наперед и сразу формируют более сложные связи, например m2m, а не o2m, что сказывается на сложности кода. Чем сложнее связь, тем больше кода и выше стоимость ее создания и поддержки. Сложность связей можно описать так (правее — сложнее): o2o, o2m, m2m. Иногда программисты ошибаются при выборе той или иной связи, что обычно говорит о недостаточно хорошем понимании предметной области. Приведу интересный пример. Предположим, что в системе нужно реализовать пользователя и заграничный паспорт. Интуитивно кажется, что между этими понятиями связь один к одному, ведь один пользователь может иметь один заграничный паспорт. Так? Не совсем, паспорт может поменяться, если он был утерян или закончился срок действия. К тому же, в некоторых странах (в России недавно приняли такой закон) разрешено владение одновременно несколькими заграничными паспортами.

С другой стороны, реальный мир всегда сложнее и полнее чем любая модель и задача программиста состоит не в том, чтобы создать универсальную и всеобъемлющую модель некоторой области, а в том, чтобы понять потребности конкретного бизнеса, выделить для них только значимые части рассматриваемой предметной области и перенести ее в код.

В зависимости от языка меняется способ представления сущностей в коде. В некоторых определяются типы (используя АТД, интерфейсы или классы), в других структуры. Третьи вообще не предоставляют никаких вариантов, кроме словарей (ассоциативных массивов). То самое понятие ООП имеет непосредственное отношение к рассматриваемой теме. 

Проблемно-ориентированное проектирование:
https://ru.wikipedia.org/wiki/

Ментальное программирование:
https://www.youtube.com/watch?v=EEq1wdM2M2w
https://www.youtube.com/watch?v=Hk_uSvADUIo

Simple Made Easy:
https://www.infoq.com/presentations/Simple-Made-Easy



#2 data hiding 
Функция makeDecartPoint называется конструктором, потому что она создает новый примитив, функции getX и getY — селекторами (selector), от слова "select", что в переводе означает "извлекать" или "выбирать". 

data hiding - Скрытие структуры данных за счет взаимодействия с ней только посредством функций:
*/

$point = makeDecartPoint(3, 4);
$symmetricalPoint = makeDecartPoint(-getX($point), getY($point)); 

function makeDecartPoint($x, $y)
{
    return [
        'x' => $x,
        'y' => $y
    ];
}

function getX($point)
{
    return $point['x'];
}

function getY($point)
{
    return $point['y'];
}

// или полярная система координат:

function makeDecartPoint($x, $y)
{
     // конвертация
     return [
         'angle' => atan2($y, $x),
         'radius' => sqrt($x ** 2 + $y ** 2)
     ];
}

/*
#3 Интерфейс
Интерфейсом называют набор функций (имена и их сигнатуры, то есть количество и типы входящих параметров, а также возвращаемое значение), не зависящих от конкретной реализации. Такое определение один в один совпадает с понятием абстрактного типа данных. Например, для точек интерфейсными являются все функции, которые мы реализовывали в практике, и которые описывались в теории. Но функции бывают не только интерфейсные, но и вспомогательные, которые не предназначены для вызывающего кода и используются исключительно внутри абстракции.
*/

function makeUser($name, $birthday)
{
    return [
        'name' => $name,
        'birthday' => $birthday
    ];
}

function getAge($user)
{
    return calculateAge($user['birthday']);
}

function isAdult($user)
{
    return getAge($user) >= 18;
}

// Внутренняя функция не являющаяся частью интерфейса абстракции User
function calculateAge($birthday)
{
    $secondsInYear = 31556926;
    return floor((time() - strtotime($birthday)) / $secondsInYear);
}

/*
PHP существует конструкция имеющая имя Interface. Она используется для явного описания интерфейсов, а также выполняет ряд дополнительных функций.

#4:

Рациональные числа в PHP не поддерживаются, поэтому построить абстракцию для них придется самостоятельно. Как обычно, нам понадобятся конструктор и селекторы:
*/
$num = makeRational(1, 2); // одна вторая
$numer = getNumer($num); // => 1
$denom = getDenom($num); // => 2


function makeRational($numer, $denom)
{
    return "{$numer}/{$denom}";
}

function getNumer($rational)
{
    return explode('/', $rational)[0];
}

function getDenom($rational)
{
    return explode('/', $rational)[1];
}

print_r(makeRational(10, 3)); // => 10/3


function mul($rational1, $rational2) // **
{
    return makeRational(
        getNumer($rational1) * getNumer($rational2),
        getDenom($rational1) * getDenom($rational2)
    );
}

/* **
С точки зрения вызывающего кода все нормально, абстракция сохранена. На вход в mul подаются рациональные числа, на выходе — рациональное число. А вот внутри никакой абстракции нет, обращение с рациональными числами строится на основе знания их устройства. Любое изменение внутренней реализации рациональных чисел потребует переписывания всех операций, работающих с рациональными числами напрямую, без селекторов и конструкторов. Данный код нарушает принцип одного уровня абстракции (single layer abstraction).

При разработке сложных систем используется подход — уровневое проектирование. Он заключается в том, что системе придается структура при помощи последовательных уровней. Каждый из уровней строится путем комбинации частей, которые на данном уровне рассматриваются как элементарные. Части, которые строятся на каждом уровне, работают как элементарные на следующем уровне.

Уровневое проектирование пронизывает всю технику построения сложных систем. Например, при проектировании компьютеров резисторы и транзисторы сочетаются (и описываются при помощи языка аналоговых схем), и из них строятся и-, или- элементы и им подобные, служащие основой языка цифровых схем. Из этих элементов строятся процессоры, шины и системы памяти, которые в свою очередь служат элементами в построении компьютеров при помощи языков, подходящих для описания компьютерной архитектуры. Компьютеры, сочетаясь, дают распределенные системы, которые описываются при помощи языков описания сетевых взаимодействий, и так далее. (c) SICP



# Инварианты

Абстракция, благодаря data hiding, позволяет нам не думать о деталях реализации и сосредоточиться на ее использовании. Более того, при необходимости реализацию абстракции можно всегда переписать, не боясь сломать использующий ее код (почти). Но есть еще одна важная причина, по которой нужно использовать абстракцию — соблюдение инвариантов.

Инвариант в программировании — логическое выражение, определяющее непротиворечивость состояния (набора данных).
*/
$num = makeRational($numer, $denom);
$denom == getDenom($num); // => true
$numer == getNumer($num); // => true

/*
Другими словами, мы ожидаем, что, передав в конструктор числитель и знаменатель, мы получим их (те же числа), если применим селекторы к этому рациональному числу. Именно так определяется корректность работы данной абстракции. Практически этот код является тестами.

Инварианты существуют относительно любой операции, и иногда довольно хитрые. Например, рациональные числа можно сравнивать между собой, но не прямым способом, потому, что одни и те же дроби можно представлять разными способами: 1/2 и 2/4. Код который не учитывает этого факта, работает некорректно.
*/

$num1 = makeRational(2, 4);
$num2 = makeRational(8, 16);

print_r($num1 == $num2); // => false

/*
Задача приведения дроби к нормальной форме называется нормализацией. Реализовать ее можно разными способами. Самый очевидный — выполнять нормализацию во время создания дроби, внутри функции makeRational. Другой — выполнять нормализацию уже при обращении через функции getDenom и getNumer. Последний способ обладает недостатком — вычисление нормальной формы происходит на каждый вызов. Избежать этого можно, используя технику мемоизации (https://ru.wikipedia.org/wiki/Мемоизация).

Учитывая новые вводные, становится понятно, что инвариант, связывающий конструктор и селекторы, нуждается в модификации. Функции getDenom и getNumer должны вернуть не переданные значения, а значения после нормализации (если дробь уже нормализована, то это будут те же самые значения).
*/

$num = makeRational(10, 20);
getDenom($num); // => 1
getNumer($num); // => 2

/*
Как бы там ни было, становится понятно, что абстракция не только прячет от нас реализацию, но и отвечает за соблюдение инвариантов. Любая работа в обход абстракции чревата тем, что не будут учтены внутренние преобразования. Многие языки в своем арсенале имеют средства для data hiding. Эти механизмы защищают данные от прямого доступа. В PHP за это отвечают модификаторы доступа к свойствам объектов public, protected и private.

Data hiding можно организовать и без специальных средств, только за счет функций высшего порядка. Данный способ основан на создании абстракций только с помощью анонимных функций, замыканий и передачи сообщений (подробнее в SICP).

Хочу сразу предостеречь вас от следования культу карго. Несмотря на то, что идея с data hiding выглядит очень здраво, в реальности подобные механизмы крайне легко обходятся с помощью Reflection API и даже без них, просто за счет ссылочных данных. Поэтому подобная защита — она больше "от дурака". Второй момент связан с тем, что в мире немало языков (пример - JavaScript), в которых все нормально с абстракциями, но нет механизмов для data hiding и ничего страшного не произошло. Другими словами, на практике, при использовании абстракций, никто особо и не пытается их нарушать специально. И я склоняюсь к мысли, что значение принудительного data hiding сильно преувеличено.


# Структуры

Самый лучший способ по настоящему понять ООП — изучить и прорешать вторую главу в SICP/

В предыдущих уроках мы познакомились с универсальным способом реализовывать абстракции — ассоциативным массивом. Он не требует написания никакого дополнительного кода, его можно брать и заполнять так, как нам вздумается в зависимости от ситуации. С другой стороны, он не обеспечивает типобезопасности. Так как любая сущность представляется этим массивом, то по ошибке можно вызывать функцию, предназначенную для одной абстракции, например, точки, на другой абстракции, например, сегменте.
*/

$num1 = makeRational(10, 20);
// Этот код выполнится, но в $num2 окажется что-то странное:
$num2 = makeRational($num1, 20);

/*
Что при этом произойдет - непонятно и зависит от того, насколько удачно совпали структуры. И если такое произошло, то функция внезапно может отработать без ошибок и даже что-то вернуть. В итоге программа продолжит работать некорректно, вместо того, чтобы завершиться с ошибкой. Кроме того, не существует универсального способа проверить тип данных, так как все есть массив. Описанные проблемы далеко не всегда являются проблемами. То есть нет движения за отказ от ассоциативных массивов. Но есть ситуации, где действительно лучше использовать специализированные средства.

Отдельного внимание заслуживают языки со статической типизацией. В этих языках нельзя просто так взять и начать использовать ассоциативный массив как в динамических языках. Любые составные данные должны быть типизированы и описаны, причем до начала использования. По этой причине в таких языках для работы с составными данными используются, например, записи, структуры или классы.

Перед тем как переходить непосредственно к объектам, посмотрим на структуры языка СИ, так вы лучше поймете происходящее. К счастью, их синтаксис достаточно прост и нагляден.

Примеры несколько упрощены, так как использование указателей, в данном случае, помешает нам понять суть.
*/

// Описание структуры Точка
typedef struct
{
    int x;
    int y;
} point;

/*
Здесь typedef и struct ключевые слова языка, а point — название, которое я выбрал самостоятельно для именования структуры. x и y — элементы (члены) структуры.

Структура всегда имеет название, которое может являться ее типом как в примере выше (благодаря typedef). В теле структуры (все что между {}) описываются элементы структуры, имена и их типы.
*/

int main()
{
    // Создание переменной p1 типа point.
    point p1 = { .x = 0, .y = 1 };

    // Печать на экран. Доступ к частям структуры происходит через точку p1.x и p1.y
    printf("%d", p1.x); // => 0
    printf("%d", p1.y); // => 1

    // Изменение значения в структуре
    p1.x = 20;
    p1.y = -10;
}

/*
Доступ к элементам структуры происходит через точку. Например, если в программе присутствует переменная p1, являющаяся структурой point, то для чтения x нужно написать p1.x, а для чтения y — p1.y. Практически то же самое и в случае присваивания - для изменения x нужно написать p1.x = 5.

Структура, как и ассоциативный массив, не дает data hiding. Создание функций для конструирования, извлечения и модификации структуры — целиком и полностью ответственность программиста. И, также, как и ассоциативный массив, тип "структура" в СИ — рекурсивная (древовидная) структура данных. Другими словами, элементом структуры может быть другая структура.
*/

typedef struct
{
    point center; // point это структура
    int radius;
} circle;

int main()
{
    // При создании круга одновременно создается точка
    circle c1 = { .center = { .x = 3, .y = 3 }, .radius = 10 };

    // Доступ к вложенным членам происходит через дополнительные точки
    printf("%d", c1.center.x); // => 3
    printf("%d", c1.radius); // => 10

    // изменение значения в структуре
    c1.center.y = 20;
    c1.radius = -10;
}

/*
С помощью структур в СИ описывают практически любые композитные (составные) данные. Посмотрев на определения структур, можно сказать, с чем работает данная программа, какие сущности в ней выделены и как они связаны между собой.


# Классы

Аналогом структур из СИ в PHP являются классы (как вы увидите позже, классы устроены намного сложнее). По крайней мере, в первом приближении.
Обратите внимание на стиль - где ставятся открывающие и закрывающие скобки:
*/

class Point
{
    public $x;
    public $y;
}

/*
Определение класса подозрительно похоже на определение структуры. За ключевым словом class следует имя класса, затем в фигурных скобках перечисляются элементы класса. Если в структурах их элементы назывались членами, то в PHP их принято называть свойствами. Такое именование характерно для большинства классовых языков. В PHP классы должны начинаться с заглавной буквы.

Одно из отличий классов от структур связано с наличием встроенного механизма data hiding. Ключевое слово public делает свойства публичными, то есть доступными снаружи для чтения и модификации. Это поведение аналогично тому, как ведут себя элементы структур. Кроме public есть и другие варианты, но мы их рассмотрим позже, когда поговорим об инкапсуляции и методах.

Определив класс, можно начать создавать объекты или, как их еще называют, экземпляры (instance) класса. На текущий момент достаточно рассматривать объект как конкретную структуру данных с конкретными данными.
*/

// Создаем объект типа Point
$point = new Point();

// По умолчанию значения равны null
print_r($point->x); // => null
print_r($point->y); // => null

// Обратите внимание на синтаксис. Такой вызов неверный: $point->$x.
$point->x = 5;
$point->y = 10;

print_r($point->x); // => 5
print_r($point->y); // => 10


/*
Создание объекта выглядит как вызов функции, к которому добавили ключевое слово new, и, как вы увидите позже, это так и есть. В остальном все работает как и в структурах, только для разделения используется не точка, а стрелка. При обращении к свойствам, знак $ перед именем свойства не ставится.

Если распечатать объект на экран print_r($point), то можно увидеть его структуру и значения всех свойств.

Point Object
(
    [x] => 5
    [y] => 10
)

Классы как рекурсивная структура данных

Как и в случае со структурами, значением свойства объекта может быть другой объект. Ограничений на вложенность никаких нет: объекты, содержащие объекты, которые содержат объекты — это нормально.
*/

class Circle
{
    public $center;
    public $radius;
}

$circle = new Circle();
$circle->radius = 3;
$circle->center = new Point();
$circle->center->x = 5;
$circle->center->y = 10;

print_r($circle->center->x); // => 5
print_r($circle->radius); // => 3

/*
Типы данных

В PHP около 10 встроенных типов данных, с большинством которых мы уже знакомы, например со строками или массивами. Объекты в этом списке представлены типом object.
*/
gettype($circle); // object
gettype($point); // object

/*
С другой стороны, каждый класс может рассматриваться как пользовательский тип данных, а его объекты-значения (инстансы) - как данные этого типа. Далее в процессе обучения я использую понятие "тип" как синоним понятия "класс". На синтаксическом уровне классы, наравне с обычными типами, могут использоваться для описания входных и выходного типов данных функций.
*/

function showUser(User $user) {
    // ...
}

/*
Такое определение вызовет ошибку при передачи в функцию любых посторонних данных.



# Namespace

Неймспейс задается с помощью ключевого слова namespace, за которым следует имя неймспейса. По стандарту, один файл должен соответствовать одному неймспейсу. В случае когда внутри неймспейса определяются только функции (а не классы) имя неймспейса должно соответстовать имени файла с учетом регистра, то есть для нашего примера имя файла math.php, следовательно имя неймспейса math. Теперь посмотрим на то, как использовать функции определенные в неймспейсе:
*/
// file: math.php:

namespace math;

function sum($a, $b)
{
    return $a + $b;
}

// file: index.php:

require_once('math.php');

\math\sum(5, 8); // 13


/*
Файловая структура практически любого проекта на PHP выглядит так:

src/
    Formatters/
      	Pretty.php
    	Generator.php

tests/
composer.json
composer.lock
.git
README.md

Если взять файл Pretty.php, то его неймспейс следовало бы назвать FormattersPretty что отражает вложенность Formatters/Pretty. Но можно сделать еще лучше - использовать вложенные неймспейсы:
*/
namespace Formatters\Pretty;

function render($data)
{
    // some code
}

// Или

namespace Generator;

function generate($data)
{
    return \Formatters\Pretty\render($data);
}

/*
Каждый проект или пакет принято помещать в одно общее пространство и не загрязнять глобальное пространство множеством неймспейсов. Это название выбирается на основе названия самого проекта, той директории внутри которой лежит src. В нашей структуре директорий это my-site. Это значит, что общим пространством для всех файлов внутри src будет MySite:
*/

// file: src/Formatters/Pretty.php

namespace MySite\Formatters\Pretty;

// some code

// C помошью механизма импорта функцию можно импортировать в текущий неймспейс так, как будто она определена прямо здесь:

namespace Generator;

use function Formatters\Pretty\render;

function generate($data)
{
    return render($data);
}


// Изредка случаются ситуации, когда хочется импортировать функцию, но в текущем пространстве либо уже определена функция с таким именем, либо функция с таким именем была импортирована ранее из другого неймспейса. Сделать это можно через алиасы (псевдонимы), механизм позволяющий переименовывать импортируемые функции: 

namespace Generator;

use function Formatters\Pretty\render;
use function Formatters\Simple\render as simpleRender;

function generate($data)
{
    return simpleRender($data);
}


# Автозагрузка классов

/*
Принято определять ровно один класс на файл. Более того, в этом файле больше не может быть никаких инструкций, не считая определения неймспейса. Чисто технически, язык не запрещает нарушать это правило, но лучше следовать стандартам кодирования (https://www.php-fig.org/psr/psr-2/#4-classes-properties-and-methods)

Классы немного по-другому работают с неймспейсами. Если неймспейс содержит только функции, то его определение обычно оканчивается именем файла (без расширения). Во всех наших упражнениях именно такая структура. 

file: src/solution.php
*/
namespace App\solution;

function ...

/*
В случае с классами неймспейс не содержит имени файла. Его роль выполняет само название класса. Причем файл должен называться в точности как класс и с учетом регистра.

file: src/Point.php
*/

namespace App;

class Point
{

}

// Использовать этот класс в другом неймспейсе можно так:

namespace AnotherApp;

use App\Point;

$point = new Point();

// либо так:

namespace AnotherApp;

$point = new \App\Point();

/*
Полное описание требований к тому, как правильно стилистически именовать классы и как соотносить их с файловой структурой, приведено в стандарте PSR4. Этот стандарт важно соблюдать по двум причинам. Первая связана с единым подходом к именованию и формированию структуры, что позволяет легко ориентироваться в проектах. Но есть и другая, не менее важная причина — автозагрузка классов.

Если определенный неймспейс в PHP содержит только функции, то для его загрузки используется специальная секция autoload/files в файле composer.json.
*/

"autoload": {
  "files": [
    "src/Points.php",
    "src/Segments.php"
  ]
}

/*
Эту секцию вы могли видеть практически в каждой практике на Хекслете. Composer требует перечисления всех таких файлов, и только в этом случае он загрузит их автоматически. Причем произойдет это в любом случае, не важно, используются функции этих неймспейсов или нет.
*/

// Эта строчка приводит к загрузке всех файлов, указанных в секции files
require __DIR__ . '/vendor/autoload.php';

/*
С классами ситуация другая. PHP содержит специальный механизм (http://php.net/manual/ru/function.spl-autoload-register.php) автозагрузки классов. Этот механизм работает так: если интерпретатор наталкивается на использование класса, то он проверяет, определили ли вы автозагрузчик классов, и, если определили, то вызывает его (пример https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md). Composer определяет такой загрузчик автоматически. Его можно конфигурировать с помощью файла composer.json. Если структура классов в вашем приложении соответствует PSR4, то конфигурация минимальна. Стандарт PSR4 задает стиль именования, позволяющий однозначно определять полное имя класса (включая неймспейсы) на основании пути до файла (относительно корня проекта) и наоборот.
*/

FULLY QUALIFIED CLASS NAME   | NAMESPACE PREFIX| BASE DIRECTORY         | RESULTING FILE PATH
\Acme\Log\Writer\File_Writer | Acme\Log\Writer | ./acme-log-writer/lib/ | ./acme-log-writer/lib/File_Writer.php
\Zend\Acl 					 | Zend            | /usr/includes/Zend/    | /usr/includes/Zend/Acl.php
\Symfony\Core\Request        | Symfony\Core    | ./vendor/Symfony/Core/ | ./vendor/Symfony/Core/Request.php

{
    "autoload": {
        "psr-4": {"App\\": "src/"}
    }
}

/*
В данном примере указано, что в папке src относительно расположения файла composer.json находится неймспейс App, соответствующий стандарту PSR4. В этом случае Composer только регистрирует автозагрузчик, который подключает файлы с классами по необходимости, только во время их использования.

Все примеры на Хекслете используют автозагрузку классов. Рекомендую подглядывать в файл composer.json каждой практики и анализировать содержимое. Кроме того, понимать автозагрузку лучше всего не через внимательное чтение документации, а через эксперименты. Попробуйте самостоятельно собрать простой php пакет и создайте внутри него классы. Не забывайте, что всегда можно подглядывать в наш шаблон (https://github.com/hexlet-boilerplates/php-package).

ДОкументация: http://php.net/manual/ru/language.oop5.autoload.php

# Свойства

Свойства класса иногда называют аттрибутами или полями класса, но общепринятым все же является термин "свойства". Объявление свойств по умолчанию устанавливает в них значение null.
*/

class Point
{
    public $x;
    public $y;
}

$p = new Point();
var_dump($p);
// class Point#1 (2) {
//   public $x =>
//   NULL
//   public $y =>
//   NULL
// }

class User
{
    public $children = [];
    public $status = 'approved';
}

$user = new User();
print_r($user->children); // => []

/*
По историческим причинам свойства в PHP можно определять с помощью ключевого слова "var", но делать этого не нужно. По своему действию "var" аналогичен "public" и существует в языке только для обратной совместимости (с версиями языка < 5).

Свойства классов хоть и описываются в классе, но не принадлежат ему. То есть каждый объект при создании получает свою собственную копию свойств. В этом смысле поведение абсолютно аналогично структурам.
*/

$user1 = new User();
$user1->status = 'declined';
$user2 = new User();
print_r($user2->status); // approved

/*
Динамическое обращение к свойствам

В некоторых ситуациях имя свойства, к которому нужно обратиться, задается динамически и хранится в переменной. В такой ситауции можно использовать специальный синтаксис обращения к свойству:
*/
$propertyName = 'key'
$obj->$propertyName = 'value';
$obj->$propertyName; // value
$obj->key; // value

/*
Документация: http://php.net/manual/ru/language.oop5.properties.php

# Указатели

Мы привыкли к тому, что данные в PHP всегда передаются по значению. Так происходит и при присваивании, и при передаче данных в функции.
*/

$a = 5;
$b = $a;

$a = 4;
print_r($b); // => 5

// Это правило применимо ко всем данным без исключения. Если мы хотим сделать передачу по ссылке, то нужно использовать &.

$a = 5;
$b =& $a;

$a = 4;
print_r($b); // => 4

/*
Но объекты ведут себя подобно передаче по ссылке даже без &.

По этой причине многие считают, что передача объектов всегда происходит по ссылке. Это не верно. Тот механизм, который используется для передачи объектов, внешне ведет себя точно так же, как и передача по ссылке, но это другой механизм.
*/

$p1 = new Point();
$p1->x = 3;
$p1->y = 5;
$p2 = $p1;

$p2->x = 100;
print_r($p1->x); // => 100

/*
Когда создается объект, в переменную записывается не он сам, а указатель (pointer) на него. Указатель можно воспринимать как идентификатор (номер) объекта, находящегося где-то в памяти. Когда мы присваиваем переменной объект $p2 = $p1, то происходит копирование этого идентификатора, но сам он не меняется. Другими словами, идентификатор всегда указывает на тот же самый объект. Поэтому создается впечатление, что объекты передаются по ссылке как при присваивании, так и при передаче объектов в функции.
*/

function setX($point, $x)
{
    $point->x = $x;
}

$point = new Point();
$point->x = 3;
$point->y = 4;
setX($point, 8);
print_r($point->x); // => 8

/*
По этой причине, работа с объектами резко отличается от того, что мы изучали раньше, например, функции, меняющие объекты, редко что-то возвращают наружу. И эти же функции почти никогда не бывают чистыми, ведь, меняя объекты, они влияют на внешнее окружение. Популярные языки программирования строят работу с объектами на основе императивной парадигмы, что, в общем случае, не обязательно. С другой стороны, есть ряд задач, в которых удобнее работать с объектами в декларативном стиле, например, при обработке коллекций.

Документация: http://php.net/manual/ru/language.oop5.references.php 



Реализуйте функцию dup, которая клонирует переданную точку. Под клонированием подразумевается процесс создания нового объекта, с такими же данными как и у старого.
*/
namespace App\PointFunctions;

function dup($point)
{
    $clonedPoint = new \App\Point();
    $clonedPoint->x = $point->x;
    $clonedPoint->y = $point->y;

    return $clonedPoint;
} // <-> clone($point);

// В другом файле:

use function App\PointFunctions\dup;

$point1 = new \App\Point();
$point2 = dup($point1);

$point1 == $point2; // true
$point1 === $point2; // false

/*
# Сравнение объектов

Сравнение объектов обладает некоторыми особенностями, о которых надо знать. Главное правило сравнения состоит в том, что объекты разных типов никогда не равны. Здесь никаких сюрпризов.
*/
$p = new Point();
$s = new Segment();

$s == $p;  // => false
$s === $p; // => false

/*
Если же тип один и тот же, то возникает две ситуации: одна для оператора нестрогого сравнения и другая — для строгого.

Нестрогое сравнение (==)
Два объекта считаются равными, если они имеют одинаковые свойства и их значения совпадают.
*/
$p1 = new Point(3, 9);
$p2 = new Point(3, 9);

$p1 == $p2; // => true

// Но что будет, если значением свойства объекта является другой объект?

$s1 = new Segment(new Point(1, 3), new Point(8, 5));
$s2 = new Segment(new Point(1, 3), new Point(8, 5));

$s1 == $s2; // => true

/*
Если вложенные объекты совпадают по правилу описанному выше, то исходные объекты также считаются равными. Другими словами, правило — рекурсивно, и проверка идет по всем вложенным объектам.

Строгое сравнение (===)
Строгое сравнение, напротив, проверяет только совпадение значения указателей. Объекты равны строго, только если это один и тот же объект.
*/

$p1 = new Point(3, 9);
$p2 = new Point(3, 9);

$p1 === $p2; // => false

$p3 = $p1;
$p3 === $p1; // => true

/*
Свое сравнение
На практике, все же, объекты устроены сложнее и сравнивать их стандартными средствами не получается. Например, сравнение может происходить на основании идентификаторов, взятых из базы данных. В таких случаях остается только один способ — написать свою собственную функцию (или метод) сравнения.


# Конструктор

Структура в СИ может быть инициализирована значениями прямо при создании.
*/
int main()
{
    // Создание переменной p1 типа point.
    point p1 = { .x = 0, .y = 1 };
}

/*
Объекты в PHP тоже могут быть инициализированы при создании, но для этого придется внести изменения в класс — написать функцию-конструктор. Конструктор класса похож на тот конструктор, который мы реализовывали, знакомясь с абстракциями. Разница только в том, что в случае классов конструктор находится внутри класса, а не описывается как обычная функция снаружи.
*/

class Point
{
    public $x;
    public $y;

    public function __construct($x, $y)
    {
        $this->x = $x;
        $this->y = $y;
    }
}

$point = new Point(1, 10);
$point->x; // => 1
$point->y; // => 10

/*
Конструктор класса — функция с именем __construct. Эту функцию невозможно вызвать напрямую. Она вызывается автоматически во время создания объекта new Point(5, 3), а параметры, переданные в этот вызов, сразу попадают в конструктор. Это значит, что, если в классе определен конструктор с двумя обязательными параметрами, то создание объекта всегда потребует два обязательных параметра. Сам по себе конструктор подчиняется тем же правилам, что и обычные функции, например, при необходимости можно указать значения по умолчанию. PHP, в силу динамической природы, допускает создание ровно одного конструктора на класс.

Конструктор не может и не должен ничего возвращать (технически вы можете написать return, но этот возврат никем не используется).

Самое интересное происходит внутри конструктора. Во-первых, конструктор вызывается тогда, когда объект уже создан. Этот объект доступен внутри конструктора как переменная $this. Такое поведение может показаться странным, ведь, глядя на эту конструкцию $point = new Point(1, 10), видно, что правая часть выполняется раньше присваивания, а значит и конструктор вызывается раньше. Ответ кроется в том, какая логика скрывается за оператором new. Процесс создания объекта внутри PHP выглядит следующим образом:

1. Создается объект без вызова чего-либо. Технически, внутри интерпретатора создается та самая структура из языка СИ (PHP написан на СИ).
2. Вызывается конструктор, в который передается объект. Синтаксически этой передачи не видно, но она есть. Можно сказать, что объект попадает внутрь конструктора как нулевой параметр, то есть внутри PHP для нашего класса, определенного выше, сигнатура конструктора выглядит так: __construct($this, $x, $y).
3. Объект $this наполняется в соответствии с кодом, находящимся в теле функции __construct. Так как объект всегда передается по указателю, то возврат из конструктора не нужен.
4. Объект возвращается наружу. В этот момент отрабатывает присваивание.
Основная задача конструктора — заполнить свойства объекта переданными параметрами. Этот способ сложнее, чем тот, который мы рассматривали в структурах (где ничего не надо определять, а можно заполнять при конструировании), и вот почему:

1. Свойства могут быть защищены от прямого изменения или чтения. Этот вопрос рассматривается позже.
2. Свойства могут требовать дополнительных расчетов, как, например, в ситуации с рациональными числами, которую мы рассматривали ранее, где происходило преобразование входных координат в другой способ представления.
3. В конструкторе можно выполнять различные побочные эффекты, например, читать файлы или выполнять сетевые вызовы (открыть соединение с базой данных). С этой возможностью нужно быть очень осторожным. Побочные эффекты резко усложняют код и затрудняют тестирование.

Документация: http://php.net/manual/ru/language.oop5.decon.php



# Инкапсуляция
В первой части этого курса мы строили абстракции, используя обычные функции с применением подхода data hiding.
*/    
$point = makeDecartPoint(3, 4);
getX($point); // => 3
getY($point); // => 4

/*
В Объектно-ориентированном подходе, функции объединяются с данными и описываются вместе внутри класса (в классово-ориентированных языках). Инкапсуляция - механизм, позволяющий описывать данные и функции, оперирующие ими, в рамках одной языковой конструкции. В случае PHP, такой конструкцией является класс.

Мы уже начали так делать, когда знакомились с конструктором. Такие функции принято именовать методами, так как они связаны с объектом, на котором вызываются. Визуально вызов метода выглядит как обращение к свойству и его вызов.
*/

$point = new Point(3, 4);
$point->getX(); // => 3
$point->getY(); // => 4

/*
Вызов метода не требует передачи объекта в аргументах, потому что метод вызывается на объекте и имеет к нему доступ через переменную $this.
*/

class Point
{
    public $x;
    public $y;

    public function __construct($x, $y)
    {
        $this->x = $x;
        $this->y = $y;
    }

    public function getX()
    {
        return $this->x;
    }

    public function getY()
    {
        return $this->y;
    }
}

/*
Методы, которые извлекают составные части объекта, принято называть геттерами (getters), а методы, изменяющие составные части — сеттерами (setters). Как правило, геттеры и сеттеры один в один отображаются на конкретные свойства внутри объекта. Технически, методы — обычные функции, за исключением доступа к $this и способа вызова.
*/

class Point
{
    public $x;
    public $y;

    public function __construct($x, $y)
    {
        $this->x = $x;
        $this->y = $y;
    }

    public function getX()
    {
        return $this->x;
    }

    public function getY()
    {
        return $this->y;
    }

    public function setX($x)
    {
        $this->x = $x;
    }

    public function setY($y)
    {
        $this->y = $y;
    }
}

$point = new Point(5, 10);
$point->setX(100);
print_r($point->getX()); // => 100


/*
Сеттеры в примере выше показаны только для демонстрации. В реальном коде точка почти наверняка будет неизменяемым объектом.

Но геттеры и сеттеры - не единственные типы функций, которые позволяет описывать класс. В принципе, все, что мы описывали работая без классов, с таким же успехом описывается и с классами.

Реализация без классов:
*/

function distanceTo($point1, $point2)
{

    $squareOfX = (getX($point1) - getX($point2)) ** 2;
    $squareOfY = (getY($point1) - getY($point2)) ** 2;

    return sqrt($squareOfY + $squareOfX);
}

// Реализация в классе:

class Point
{
    ...

    /*
     * Рассчет по теореме пифагора связи между
     * сторонами прямоугольного треугольника с^2 = a^2 + b^2
    */
    public function distanceTo($point)
    {

        $squareOfX = ($this->getX() - $point->getX()) ** 2;
        $squareOfY = ($this->getY() - $point->getY()) ** 2;

        return sqrt($squareOfY + $squareOfX);
    }
}

$point1 = new Point(0, 0);
$point2 = new Point(3, 4);
print_r($point1->distanceTo($point2)); // => 5
print_r($point2->distanceTo($point1)); // => 5

/*
Данная операция обладает свойством коммутативности. Результат вычисления не зависит от того, в каком порядке идут аргументы. Соответственно, при использовании методов, можно вызывать distanceTo как на одном объекте, так и на другом.

Нередко методы выполняют не только вычисления, но и возвращают новые объекты. Например, так произойдет при вычислении симметричной точки.
*/

class Point
{
    ...

    public function getSymmetricalPoint()
    {
        // Можно выполнять промежуточное создание переменной, а можно возвращать сразу
        return new Point(-$this->getX(), -$this->getY());
    }
}

$point = new Point(3, 8);
$point->getSymmetricalPoint(); // => (-3, -8)

/*
Выше мы рассмотрели техническую сторону вопроса, оставив за кадром описание преимуществ и недостатков такого похода, а также связанные темы, например, data hiding или полиморфизм. Их описание довольно обширно и практически бесполезно без хотя бы минимального опыта использования. О том, что дает или забирает инкапсуляция, я расскажу на протяжении ближайших уроков. Отдельного обсуждения заслуживает вопрос о способе хранения методов - где они находятся физически (внутри объекта или нет?). С ним мы разберемся в уроках, посвященных полиморфизму и динамической диспетчеризации.

Документация: http://php.net/manual/ru/language.oop5.visibility.php


/**
Реализуйте класс для работы с рациональными числами, включающую в себя следующие методы:

Конструктор — принимает на вход числитель и знаменатель.
Метод getNumer — возвращает числитель
Метод getDenom — возвращает знаменатель
Сложение add — складывает переданные дроби
Вычитание sub — находит разность между двумя дробями
**/
$rat1 = new Rational(3, 9);
$rat1->getNumer(); // => 3
$rat1->getDenom(); // => 9

$rat2 = new Rational(10, 3);

$rat3 = $rat1->add($rat2); // => Абстракция для рационального числа 99/27
$rat3->getNumer();         // => 99
$rat3->getDenom();         // => 27

$rat4 = $rat1->sub($rat2); // => Абстракция для рационального числа -81/27
$rat4->getNumer();         // => -81
$rat4->getDenom();         // => 27

class Rational
{
    public $numer;
    public $denom;

    public function __construct($numer, $denom)
    {
        $this->numer = $numer;
        $this->denom = $denom;
    }

    public function getNumer()
    {
        return $this->numer;
    }

    public function getDenom()
    {
        return $this->denom;
    }

    public function add($rational)
    {
        $numer = $rational->getNumer() * $this->getDenom() + $this->getNumer() * $rational->getDenom();
        $denom = $rational->getDenom() * $this->getDenom();
        return new Rational($numer, $denom);
    }

    public function sub($rational)
    {
        $numer = $this->getNumer() * $rational->getDenom() - $rational->getNumer() * $this->getDenom();
        $denom = $rational->getDenom() * $this->getDenom();
        return new Rational($numer, $denom);
    }
}








# Data Hiding (Data Protection)

Как я уже упоминал, в терминологии ООП творится довольно серьезная путаница. Она возникает, в первую очередь, из-за того, что многие программируют либо на одном языке, либо если и на разных, то часто схожих по структуре языках. Соответственно, происходит профессиональная деформация, когда программист видит мир сквозь призму одного языка. Одна из таких историй происходит вокруг инкапсуляции и data hiding. Напомню, что data hiding - подход, при котором нельзя изменить данные напрямую, в обход интерфейса, тем самым нарушив инварианты (такое происходит не всегда). Есть языки, в которых присутствует data hiding, например, haskell, но нет инкапсуляции. В ООП data hiding появляется благодаря двум возможностям:

- инкапсуляции
- области видимости свойств

Однако учтите что в литературе часто отождествляют термины инкапсуляция и защита данных. Поэтому не пугайтесь если многие вокруг вас будут утверждать что инкапсуляция это про защиту данных, но даже не вспомнят про объединение функций и данных в рамках одной структуры

Достаточно изменить слово public на private у любого свойства, как пропадет возможность обращаться к нему напрямую снаружи объекта.
*/
class Point
{
    private $x;
    private $y;

    public function __construct($x, $y)
    {
        // Внутри по прежнему доступ есть
        $this->x = $x;
        $this->y = $y;
    }

    public function getX()
    {
        return $this->x;
    }

    public function getY()
    {
        return $this->y;
    }
}

$point = new Point(10, 8);
print_r($point->getX()); // => 10
$point->x; // PHP Fatal error:  Uncaught Error: Cannot access private property Point::$x<Paste>

/*
Подчеркну, что речь идет именно о доступе снаружи. Внутри он должен остаться, иначе как мы сможем оперировать этим свойством?

Data hiding считается важным аттрибутом любой абстракции, независимо от того, работаем мы в ООП стиле, или нет. Именно по этой причине существуют геттеры. В ООП, построенном на классах, вообще не принято обращаться к свойствам напрямую. Геттеры - первое, что реализуется при описании любого нового класса. Кстати, в языке Ruby нельзя (один способ есть, но он выходит за рамки обсуждаемой темы) обратиться к свойству объекта без геттера, но описываются они там значительно проще и компактнее, чем в таких языках, как PHP или Java, и выглядят как обращения к свойствам (в ruby можно не ставить скобки при вызове функций). Тоже самое касается и сеттеров. Свойства напрямую не редактируют, так как потенциально можно нарушить инварианты.

# Изменяемость

Сеттеры (setters) служат для изменения внутреннего состояния объекта. Как и геттеры, они именуются особым образом. К сеттерам обычно добавляется префикс set, если этот сеттер что-то устанавливает и add - если добавляет.
*/
$point1 = new Point(10, 11);
$point2 = new Point(-3, 3);
$segment = new Segment($point1, $point2);

$segment->getStartPoint(); // (10, 11)
$segment->setStartPoint(new Point(3, 8)); // Допустимо, потому что new Point(3, 8) - выражение
$segment->getStartPoint(); // (3, 8)

/*
На практике изменения объектов происходят почти всегда с помощью сеттеров, и крайне редко - через изменение свойства напрямую. Причем объекты (впрочем, как и любая абстракция) иногда хранят внутри себя свойства, которые нельзя изменять снаружи (например, соединение с базой данных), и для них не делают сеттеров.

Вообще говоря, с сеттерами связано много головной боли. Несмотря на data hiding, встроенный в объекты, как я уже говорил ранее, можно легко создать ситуацию, в которой из одного объекта извлекается другой объект и меняется. Естественно, исходный объект об этих изменениях ничего не знает. Проблема обостряется тогда, когда один объект используется по всему приложению. В такой ситуации он ведет себя как глобальная переменная (в худшем ее проявлении). Изменения, сделанные в одном месте, коснутся всего.

Например, ранее вы создали класс для работы с рациональными числами. Если бы методы add и sub изменяли объект, на котором вызываются, то получить неверные рассчеты стало бы крайне просто. Достаточно использовать одно рациональное число в нескольких местах, и любое его изменение повлияет на всех, кто использует это число. Абсолютно такая же ситуация и с графическими примитивами на плоскости.
*/

$point1 = new Point(10, 11);
$point2 = new Point(-3, 3);
$segment1 = new Segment($point1, $point2);
$segment2 = new Segment($point1, $point2);

// Функция moveUp перемещает весь отрезок на три значения вверх. Она не возвращает новый сегмент, а мутирует сам объект.
$segment1->moveUp(3);
print_r($segment1); // => [(10, 14), (-3, 6)]

/*
Если внутри moveUp происходит изменение точек (вместо создания новых), то такое изменение повлияет и на segment2, хотя мы и не собирались его перемещать.
Другой яркий пример - Маркдаун (https://guides.hexlet.io/markdown/#что-это-значит).
Для генерации маркдауна, вообще говоря, достаточно обычной функции:
*/

$html = generateHtml($markdown);

// Иногда поведение генератора надо менять, а у него довольно много разных опций, например, нужно ли вырезать опасные теги и вообще - разрешать ли использовать теги:

$html = generateHtml($markdown, ['sanitaize' => 'true']);

// По-прежнему используется функция, и с кодом все хорошо. Но, если опций много и они одинаковые по всему приложению (во всех местах, где происходит генерация), то появляется много дублирования с передачей этих опций на каждый вызов. Эту задачу можно решить двумя способами. Один основан на генерации функции, которая замыкает внутри себя опции (такое решение популярно в js). Второй - можно использовать объект как способ хранить состояние.

$markdown = new Markdown($options);
$html = $markdown->render($text);

// Теперь достаточно прокинуть в нужную часть приложения объект $markdown, вызвать метод render - и больше не беспокоиться об опциях. Но обязательно найдется место, в котором понадобится особое поведение. И некоторые создатели подобных библиотек пытаются решить возникшую проблему, добавив сеттер на изменение опций, заложенных в объект.

$markdown->setOptions(['sanitize' => false]);
$html = $markdown->render($text);

/*
Такой код создает потенциальную огромную дыру, которую очень сложно отловить. Так как сеттер меняет состояние объекта, а объект - общий для разных частей программы, то все вызовы метода render после вызова setOptions будут основываться на новых опциях, хотя изначально мы хотели поменять поведение только для одного места.

Существует ли способ сделать все красиво? Нет, фундаментальная проблема "изменяемое состояние" может быть убрана только отказом от изменения и созданием нового на основе старого вместо мутаций. Последний прием подходит не всегда, но мы уже использовали его на практике, например, в рациональных числах.

# Магические методы (__toString)

Некоторые методы в классах имеют специальное предназначение и часто называются "магическими". Их легко отличить от других методов наличием двух подчеркиваний в начале имени метода. К таким методам относится и конструктор. Другим полезным и часто используемым методом является __toString. Его "магичность" заключается в том, что он вызывается автоматически, в тех ситуациях, когда объект используется как строка. К таким ситуациям относится интерполяция или конкатенация. Результат вызова этого метода используется как строковое представление объекта.
*/

class Point
{
    public $x;
    public $y;

    public function __construct($x, $y)
    {
        $this->x = $x;
        $this->y = $y;
    }

    public function getX()
    {
        return $this->x;
    }

    public function getY()
    {
        return $this->y;
    }

    public function __toString()
    {
        return "({$this->x}, {$this->y})";
    }
}

$point = new Point(1, 10);

// Автоматически вызывается __toString
echo $point; // => (1, 10)

// и тут
$message = 'hello, ' + $point;

// и тут
$message2 = "hi, {$point}";

/*
Но этот же метод не вызовется если передать объект в print_r. Эта функция всегда пытается отобразить внутреннее представление того, что ей передали.

__toString должен вернуть строку, иначе произойдет ошибка. Ошибка возникнет и в том случае, когда у объекта нет метода toString.
*/

echo $o; // PHP Catchable fatal error:  Object of class stdClass could not be converted to string

// Документация: http://php.net/manual/ru/language.oop5.magic.php#object.tostring

class Connection
{
    protected $link;
    private $dsn, $username, $password;
    
    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }
    
    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
    
    public function __sleep()
    {
        return array('dsn', 'username', 'password');
    }
    
    public function __wakeup()
    {
        $this->connect();
    }
}

/*
#  Константы классов

Напомню, что в PHP есть такая конструкция как константа. Она используется для хранения каких-то постоянных данных, которые, как правило, глобальные. Например, константа PHP_VERSION содержит версию PHP, в которой был запущен код (а его можно запустить на разных версиях интерпретатора). Эта константа относится к предопределенным (предоставляется интерпретатором). PHP позволяет создавать свои собственные константы, используя конструкцию const SEC_PER_DAY = 86400;. Эти константы принадлежат неймспейсу и могут быть импортированы из него, используя конструкцию use const App\Times\SEC_PER_DAY;.

Класс встроен в язык http://php.net/manual/ru/class.datetime.php
*/
class DateTime
{
    const RSS = 'D, d M Y H:i:s O';
    const RFC822 = 'D, d M y H:i:s O';
}

// Внутри классов константы определяются точно таким же способом, как и снаружи. Основное отличие проявляется в способе доступа.

print_r(DateTime::RSS); // => D, d M Y H:i:s O

/*
Синтаксически обращение происходит с использованием двух двоеточий после имени класса, за которыми, в свою очередь, идет имя константы. Обратите внимание на отсутствие знака $. Для констант классов нет особого синтаксиса импорта. Он не нужен по очень простой причине - импортируется в другие неймспейсы всегда класс, а константа извлекается уже из него.

Внутри класса к константе можно обратиться ровно таким же образом, но есть и другой способ:
*/
class DateTime
{
    /* ... */

    public function getRssFormat()
    {
        return self::RSS;
    }
}

/*
В этом способе вместо имени класса слева стоит ключевое слово self. Его удобство заключается в отсутствии дублирования имени класса. Эта проблема особенно актуальна при активном использовании констант внутри самого класса.

Предопределенные константы
Внутри класса определено несколько магических констант:

__CLASS__ - текущее имя класса
__METHOD__ - текущее имя метода
В отличии от обычных констант, магические не требуют префикса self:: и доступны только внутри класса.
*/

class Example
{
    public function printMethodName()
    {
        print_r(__METHOD__);
    }
}


// Кроме магических, в классах есть одна специальная константа class. Она возвращает полное имя класса и может вызываться только через класс.

namespace App;

class User
{

}

User::class // => App\User

/*
Эта константа возвращает полное имя класса относительно неймспейса, в котором происходит ее вызов.

Модификаторы доступа

С версии PHP 7.1 константы обрели возможность иметь модификатор доступа. По умолчанию константы публичные, но если очень хочется, можно их сделать приватными.
*/

class DateTime
{
    private const RSS = 'D, d M Y H:i:s O';
    public const RFC822 = 'D, d M y H:i:s O';
}


namespace App;

class Example
{
      public function printMe()
      {
          print_r(self::class);
      }
}

$obj = new Example();
$obj->printMe(); // =>  App\Example

/*
Документация: http://php.net/manual/ru/language.oop5.constants.php


Реализуйте недостающие части класса Timer, который описывает собой таймер обратного отсчета. Необходимо дописать конструктор принимающий на вход три параметра: секунды, минуты (необязательный) и часы (необязательный). Конструктор должен подсчитать общее количество секунд для переданного времени и записать его в свойство secondsCount.

Воспользуйтесь константой SEC_PER_MIN для перевода минут в секунды (через умножение)
Реализуйте дополнительную константу SEC_PER_HOUR и воспользуйтесь ей для перевода часов в секунды
*/

$timer = new Timer(10);
$this->assertEquals(10, $timer->getLeftSeconds());


namespace App;

class Timer
{
    const SEC_PER_MIN = 60;
	const SEC_PER_HOUR = 60 * self::SEC_PER_MIN;
    private $secondsCount;

    public function __construct($sec, $min = 0, $hour = 0)
    {
        $this->secondsCount = $sec + $min * self::SEC_PER_MIN + $hour * self::SEC_PER_HOUR;
    }

    public function getLeftSeconds()
    {
        return $this->secondsCount;
    }

    public function tick()
    {
        $this->secondsCount--;
    }
}




# Статические свойства
/*
Статическое свойство, в отличие от обычного свойства, принадлежит классу, а не инстансу. С точки зрения синтаксиса отличие только лишь в дополнительном ключевом слове static.
*/

namespace App;

class User
{
    public static $table = 'users';
}

// Если попробовать обратиться к нему через объект, используя ->, то возникнет ошибка.

$user = new User();
$user->table; // PHP Notice: Accessing static property App\User::$table as non static

/*
Статическое свойство не часть объекта, то есть не часть его состояния. Основной способ обращения к статическому свойству похож на то, как мы обращались к константам. Статические свойства, подобно обычным свойствам, имеют область видимости. Их всегда можно сделать приватными.
*/
print_r(User::$table); // => users

/*
В отличии от констант, свойства требуют наличия знака $. Только не перепутайте: $table — это не имя переменной, а имя статического свойства.

К свойствам все же можно обращаться, используя объекты, но это лишь синтаксический сахар. Объект в таком вызове используется только как способ понять, что это за тип.
*/
$user = new User();
$user::$table; // в реальности вместо $user подставляется класс

/*
Такая возможность открывает доступ к полиморфизму, о котором мы еще будем разговаривать.

К статическим свойствам можно обращаться не только снаружи, но и внутри объектов этого же типа. Как и в случае констант, есть два способа. Первый показан выше, когда мы указываем полное имя класса, второй способ использует уже знакомый нам self:
*/

class User
{
    public static $table = 'users';

    public function getTable()
    {
        return self::$table;
    }
}

$user = new User();
$user->getTable(); // users

/*
Зачем?
Основная цель статических свойств — хранить информацию о типе в целом, безотносительно его экземпляров. Таким приемом часто пользуются для связи сущностей предметной области с базой данных. Например, в статическом свойстве удобно (но не всегда правильно) хранить имя соответствующей таблицы в базе данных. В случае с User выше, таблица называется users. Подобная возможность активно используется в ORM (фреймворк для отображения сущностей предметной области из базы в код и обратно).

В идеале статические свойства класса должны инициализироваться при старте программы и никогда не меняться. Ведь статическое свойство по своим характеристикам является глобальной переменной. Если сохранять туда временные данные и менять их, то очень просто создать трудноподдерживаемый код с большим числом ошибок.

По этой причине статические свойства часто делают приватными, а доступ снаружи оставляют через статические методы.

Документация: http://php.net/manual/ru/language.oop5.static.php

# Статические методы
*/

class User
{
    private static $table = 'users';

    public static function getTable()
    {
        return self::$table;
    }
}

User::getTable(); // users

/*
Статические методы, как и свойства, не принадлежат экземплярам, они — часть типа. Следовательно, из статического метода невозможно получить доступ к объекту (ведь нет никакого объекта) через $this. $this внутри него просто не существует. Статические методы могут обращаться к другим статическим методам или статическим свойствам, используя self.

Как я уже упоминал в предыдущем уроке, статические методы часто используют для доступа к приватным статическим свойствам. Причем, как геттеры, так и сеттеры, которые нужны редко, но все же бывают нужны.

Но есть еще один способ использования статических методов, не связанный со статическими свойствами. Их используют как способ создать объект вместо прямого вызова конструктора через оператор new.

Как вы помните, PHP (как, впрочем, и любой динамический язык) позволяет иметь ровно один конструктор для класса. В случае таких данных, как время, это - серьезное ограничение, потому, что нельзя одним конструктором описать все возможные способы создания дат, которые используются в коде.
*/

$date = new DateTime('2000-01-01');

/*
В стандартной библиотеке PHP есть класс DateTime, который принимает на вход строчку определенного формата и возвращает соответствующий объект. А что, если в нашей программе формат времени другой? А если у нас вообще нет строчки, а есть отдельные числа? Естественным желанием было бы иметь разные конструкторы под разные задачи. Их у нас нет, но зато есть статические методы, которых можно создать столько, сколько нужно.
*/

// Специальная библиотека для работы с датами будет рассматриваться в следующем курсе
$vancouverTimeRightNow = Carbon::now('America/Vancouver');  //implicit __toString()
$noonTodayLondonTime = Carbon::createFromTime(12, 0, 0, 'Europe/London');
$internetWillBlowUpOn = Carbon::create(2038, 01, 19, 3, 14, 7, 'GMT');

// Как видно из кода выше, статические методы имеют разные сигнатуры, но внутри они, так или иначе, вызывают конструктор, передвая туда уже подготовленные параметры. Конструктор можно вызывать двумя способами: первый — использовать полное имя класса, второй — черезself. Второй способ предпочтительнее просто потому, что позволяет не дублировать имя класса.

class Carbon
{
    public static function now($timezone = '')
    {
        return new self(date("Y-m-d H:i:s"), $timezone);
    }
}

/*
Подводя итог, можно сказать, что статические методы используют как фабрику объектов в случаях, когда создание объекта достаточно сложное и требует некоторых манипуляций.

Еще есть третий способ использования статических методов — глобальные функции неймспейса. Такой способ особенно популярен в языках типа Java, где физически невозможно создать функцию вне класса. В PHP очень похожая модель, и, хотя создавать функции можно в обычных неймспейсах, по факту делают так редко. Одна из причин связана с наличием автозагрузки классов, такой способ банально удобнее с точки зрения лени. С точки зрения "правильности" такой код скорее "неправильный". Если статическая функция не порождает объектов данного типа, или хотя бы не использует статические свойства, то непонятно, почему она вообще оказалась в этом классе. Но это в теории. На практике есть устоявшиеся нормы и традиции. В своей практике, работая в проектах, построенных на классовой модели (не все проекты в PHP разрабатываются именно так), вы будете встречать код, который почти всегда принадлежит тому или иному классу.

Документация: http://php.net/manual/ru/language.oop5.static.php


Добавьте в класс Time статический метод fromString, который позволяет создавать инстансы Time на основе времени переданного строкой формата часы:минуты.
*/

$time = Time::fromString('10:23');
$this->assertEquals('10:23', $time->toString());


namespace App;

class Time
{
    private $h;
    private $m;

    public static function fromString($time)
    {
        [$h, $m] = explode(':', $time);
        return new self($h, $m);
    }

    public function __construct($h, $m)
    {
        $this->h = $h;
        $this->m = $m;
    }

    public function toString()
    {
        return "{$this->h}:{$this->m}";
    }
}

# Интерфейсы (Конструкция языка `interface`)
/*
Интерфейс в PHP — конструкция языка, описывающая абстрактный типы данных (АТД). Напомню, что АТД (https://ru.wikipedia.org/wiki/Абстрактный_тип_данных) определяет набор операций (функций), независимых от конкретной реализации типа (в нашем случае класса) для манипулирования его значениями. На практике интерфейсы содержат определения функций (то есть описание их сигнатур) без их реализации.


Хотя данная конструкция для нас в новинку, само понятие интерфейса используется на протяжении всего курса. В первую очередь это касается рассуждений о рассматриваемом типе. Для оперирования точками на плоскости нам не нужна "реализация" точек. Достаточно того, что мы представляем их визуально и знаем операции, выполняемые над ними. То же самое касается и более базовых концепций, например, чисел и любых арифметических операций. Задумывались ли вы над тем, как на самом деле выполняются арифметические операции? Ответ на этот вопрос гораздо сложнее, чем может показаться на первый взгляд, и он зависит не только от языка, но и от конкретного аппаратного обеспечения (железа). Однако незнание ответа не мешает нам пользоваться числами, строками и массивами, не зная их устройства.
*/
// file: DecartPointInterface.php

namespace App;

// Интерфейсы, по аналогии с классами, хранятся в своих собственных файлах
// и загружаются автоматически при следовании стандарту PSR4.

// Имя интерфейса может быть любым, главное - соответствие PSR4.

interface DecartPointInterface
{
    public function __construct($x, $y);
    public function getX();
    public function getY();
}

/*
То, что раньше мы описывали словами и держали в голове, теперь явно записано в виде кода. Декартова точка — это АТД с тремя операциями:

- Создание точки из двух значений
- Извлечение координаты X
- Извлечение координаты Y
По сути, прикладному коду больше ничего знать о точках и не нужно. Естественно, если нам понадобятся новые операции, то мы всегда можем их добавить, тем самым расширив интерфейс. Свои собственные АТД можно менять как угодно и когда угодно, только учтите, что изменение интерфейса влечет за собой исправления кода, использующего этот интерфейс.

Сама по себе конструкция Interface никак не влияет на остальной код. Недостаточно просто создать интерфейс, в этом нет смысла. Интерфейс должен быть реализован, и тогда он начнет приносить пользу.
*/

namespace AnotherApp;

// Импорт интерфейса
use App\DecartPointInterface;

class DecartPoint implements DecartPointInterface
{
    private $x;
    private $y;

    // Интерфейсные функции
    public function __construct($x, $y)
    {
        $this->x = $x;
        $this->y = $y;
    }

    public function getX()
    {
        return $this->x;
    }

    public function getY()
    {
        return $this->y;
    }

    // Не интерфейсные функции

    public function __toString()
    {
        return "({$this->getX()}, {$this->getY()})";
    }
}

/*
Реализация интерфейса происходит за счет ключевого слова implements, за которым идет название интерфейса. Интерпретатор проверяет, чтобы в классе были описаны все функции интерфейса и их сигнатуры совпадали, а если это не так, то возникает ошибка. Реализация интерфейса никак не ограничивает возможности по наполнению класса, другими словами, вы можете определять и добавлять в класс все, что хотите, помимо интерфейсных функций.

Сами по себе интерфейсы мало полезны. Например, можно в любой программе открыть все файлы с классами и удалить часть определения класса, которая описывает реализацию интерфейсов (слово implements и то что идет за ним). После этого не изменится ровным счетом ничего - программа продолжит выполняться так же, как и выполнялась. Но ситуация меняется, если использовать интерфейс в сигнатурах функций и методов вместо классов.
*/

function compare(DecartPointInterface $point1, DecartPointInterface $point2)
{
    // ...
}

/*
Во время выполнения программы PHP проверяет, реализует ли класс соответствующий интерфейс, и если нет, то возникает ошибка. Причем проверка идет именно на наличие записи implements в определении класса, а не на факт того, что методы определены (проверка реализации интерфейса гарантирует это).

Такая запись позволяет коду завязываться не на конкретную реализацию точек, а на их интерфейс. Это - ключевая мысль, которую имеет смысл обсуждать подробнее вместе с полиморфизмом.

Countable
В PHP встроен интерфейс Countable, а функция count умеет работать с любым объектом, реализующим этот интерфейс.
*/

class Collection implements Countable
{
    private $items;
    
    public function __construct($items = [])
    {
        $this->items = $items;
    }
    
    public function count()
    {
        return sizeof($this->items);
    }
}

$coll = new Collection([3, 2, 5]);
print_r(count($coll));

/*
Документация: 
Интерфейсы: http://php.net/manual/ru/language.oop5.interfaces.php
Утиная типизация: https://ru.wikipedia.org/Утиная_типизация
Принцип инверсии зависимостей: https://ru.wikipedia.org/wiki/Принцип_инверсии_зависимостей


Реализуйте класс User, который создает пользователей. Конструктор класса принимает на вход два параметра: идентификатор и имя.

Реализуйте интерфейс Comparable для класса User. Сравнение пользователей происходит на основе их идентификатора.
*/
$user1 = new User(4, 'tolya');
$user2 = new User(1, 'petya');

$user1->compareTo($user2); // false

// file: Comparable.php

interface Comparable
{
    public function compareTo($obj);
}



// file: User.php

class User implements Comparable
{
    private $id;
    private $name;

    public function __construct($id, $name)
    {
        $this->id = $id;
        $this->name = $name;
    }

    public function getId()
    {
        return $this->id;
    }

    public function compareTo($user)
    {
        return $this->getId() === $user->getId();
    }
}

/*
#  Плюсы и минусы разных способов организации абстракций


Теперь, после того, как мы немного поработали с объектами, давайте попытаемся ответить на вопрос: "какую такую задачу они решают, которую не решают абстракции на основе обычных функций + ассоциативный массив как структура"?

Изложенные ниже тезисы могут показаться вам совсем чуждыми и непонятными в силу отсутствия опыта. В этом нет ничего страшного, главное - увидеть направления, а отработкой мы займемся в следующих курсах.

Перед тем как начать уходить глубже в тему объектов, хочу вас предостеречь. ООП в современном мире воспринимается большим числом программистов (особенно начинающими), как серебряная пуля, как средство от всех болезней. Учитывая, что в PHP это основной способ строить абстракции, у вас может сложиться такое же впечатление. Но это не так. Во-первых, под ООП понимают две абсолютно разные концепции. Та, которую мы обсуждаем, является мейнстримом, и встроена во многие языки настолько глубоко, что писать в другом стиле либо невозможно, либо очень тяжело. Но есть и другая, созданная Аланом Кеем. Что интересно, именно Алан является создателем термина ООП, но его ООП не имеет почти ничего общего с тем, что сейчас называется ООП.

ООП для меня это сообщения, локальное удержание и защита, скрытие состояния и позднее связывание всего. Это можно сделать в Smalltalk и в LISP. Alan Key

Во-вторых, существуют другие способы получить поведение, похожее на то, которое вы будете наблюдать в ООП-коде. Более того, многие из них значительно мощнее в возможностях (и некоторые появились задолго до ООП-языков). Например, мультиметоды в языке Clojure дают большую свободу (мультидиспетчеризацию) и позволяют строить полиморфизм на специализированных функциях.

В общем и целом, чем больше разных по структуре языков и парадигм вы знаете, тем лучше понимаете, что происходит. Рекомендую: clojure, haskell, elixir, kotlin и js (последний стандарт).

Преимущества
1. Пожалуй, основное преимущество связано с полиморфизмом подтипов. Подробно эта тема освещается позже. Сейчас лишь скажу, что если мы вызываем функцию, то это всегда некоторая конкретная функция, импортированная из конкретного неймспейса. А вот если мы вызываем метод, то появляются варианты. Когда интерпретатор доходит до кода с вызовом метода $obj->methodCall(), он не может сразу сказать, где определен данный метод, потому что ответ на этот вопрос зависит от того, какой тип у $obj. Отсюда следует, что, если разные объекты содержат методы с одинаковым именем (и сигнатурой), то их можно прозрачно (для вызывающего кода) подменять. На практике такая возможность местами упрощает код (становится меньше условных конструкций), но главное — делает его расширение проще.

2. Работа с абстракцией, основанной на ассоциативном массиве, таит в себе один сюрприз. Так как любая сущность представляется этим массивом, то можно по ошибке вызывать функцию, предназначенную для одной абстракции (например, точки), на другой абстракции (например, сегменте). Что при этом произойдет — непонятно, и зависит от того, насколько удачно совпали структуры. И если такое произошло, то функция внезапно может отработать без ошибок и даже что-то вернуть. В итоге программа продолжит работать некорректно, вместо того, чтобы завершиться с ошибкой. Инкапсуляция исключает подобную ситуацию. Вызываемый метод всегда принадлежит тому объекту, на котором он вызывается. Если метода нет, то будет ошибка, если есть — то он отработает так, как и должен отработать. Но это преимущество является преимуществом только при сравнении с абстракциями, построенными на общих структурах данных (и в динамических языках), такими, как ассоциативные массивы. В языках с развитой системой типов (но без ООП), например, в haskell, подобной проблемы также нет.
*/

$segment = makeSegment(makePoint(1, 3), makePoint(10, 11));
// Функция отработает, хотя в нее передали сегмент, а не точку
getX($segment); // getX - функция, предназначенная для работы с точками	

/*
3. Это преимущество немного неожиданно. Возможность вызывать методы у объектов открывает дорогу к автокомплиту в редакторах. Да-да! Именно благодаря такому способу вызова редактор может подсказать список методов, которые есть у данного объекта. Если вы сначала пишите функцию, а затем передаете туда данные, то вы должны знать про существование функции заранее. Но тут нужно оговориться. Вызов функции после данных не является прерогативой ООП. В некоторых современных языках (Nim, D, Rust) поддерживается Unified Function Call, который позволяет проделывать такой же трюк с обычными функциями. Ниже пример на языке Nim (https://nim-lang.org/).
*/

# Создается тип Vector, представляющий из себя кортеж из двух элементов
type Vector = tuple[x, y: int]

# Определяется функция, принимающая на вход два вектора и возвращающая новый вектор,
# полученный сложением исходных векторов
proc add(a, b: Vector): Vector =
  (a.x + b.x, a.y + b.y)

let
  # Создается переменная v1, содержащая вектор
  v1 = (x: -1, y: 4)
  # Создается переменная v2, содержащая вектор
  v2 = (x: 5, y: -2)

  # Обычный вызов функции
  v3 = add(v1, v2)

  # Вызов через точку: v1 передается в функцию add первым параметром
  v4 = v1.add(v2)

  # Цепочка вызовов. Результат предыдущего вычисления всегда передается первым параметром в следующий
  v5 = v1.add(v2).add(v1)

/*
4. Реализация ООП в PHP содержит конструкции для обеспечения data hiding. Справедливости ради скажу, что, несмотря на это, их всегда можно обойти (например, используя Reflection API). Причем не только в PHP, но и в других языках с похожей моделью, например, в Java. С другой стороны, практика показывает, что отсутствие таких механизмов не создает больших проблем при работе. К таким языкам относится JavaScript.

Недостатки
1. Инкапсуляция. Как и всегда в инженерной деятельности, за возможности нужно платить. Инкапсуляция, при всех своих плюсах, создает огромную проблему. Расширяемость поведения объекта падает до нуля. Если мы работаем с обычными функциями, то достаточно написать новую функцию, чтобы можно было продолжать работать. Когда речь заходит про инкапсуляцию, то все не так. Дело в том, что методы описываются в классах. В PHP класс можно описать ровно один раз. И большая часть этих классов приходит в проекты из сторонних библиотек. Как только понадобится расширить поведение любого стороннего класса, мы сразу сталкиваемся с проблемами. Любой код из библиотек поставляется как есть, и мы не можем открыть исходный код любой библиотеки и внести необходимые нам правки. По этой причине расширяемость поведения объектов в ООП языках — головная боль. Как правило, создатели класса пытаются заботиться об этом сами, давая возможность расширять свое поведение снаружи (если это возможно). Существуют языки, в которых эту проблему пытаются решать, позволяя "дописывать" определение класса по ходу работы программы, - например, в Ruby. В js то же самое достигается за счет механизма прототипов. Языки, в которых функции и данные разделены не имеют подобного недостатка, и код на них пишется, как ни странно, легче и проще (хотя местами многословнее). Сюда же можно отнести проблему, называемую антипаттерном (плохой реализацией) god object.

Если вы уже немного знакомы с ООП, то можете подумать, что наследование спасает от этой проблемы. Так вот, наследование не просто не спасает, но и само по себе является проблемой. Об этом я расскажу в соответствующем курсе, когда мы разберем суть наследования как отношения между типами, и ограничениями, без которых наследование невозможно.

2. Представление любой мало-мальской сущности в языке с помощью пользовательского типа сильно раздувает программу. А сущности часто создают только по той причине, что не нашлось подходящего под нее типа (в котором логично было бы описать ее). Существует миф о том, что программы, написанные в ООП-стиле (на самом деле имеется ввиду та самая модель ООП, которая используется в языках типа PHP или Java), при больших размерах оказываются относительно компактными по объему кода. В реальности все с точностью до наоборот. Программы на языке Clojure компактнее аналогов на PHP во много раз. И чем больше кода, тем больше разрыв. Эта тема настолько животрепещущая, что кто-то не поленился и создал проект-шутку FizzBuzzEnterpriseEdition. К тому же, появляются проблемы с ответственностями. Собака должна есть еду ($dog->eat($food)), или же еда съедается собакой ($food->eatBy($dog))? Несмотря на кажущуюся абсурдность, подобная проблема реальна и проявляется очень часто.

3. Думаю, что влияние этого пункта вы уже ощутили на себе, хотя мы только начали. Слишком много языковых сущностей (Бритва Оккама). В PHP постоянно добавляют новые возможности по реализации ООП. Вот лишь некоторые из них: абстрактные классы, анонимные классы, интерфейсы, статические методы, видимость методов, видимость свойств, видимость констант, трейты, магические методы, наследование. И это только ключевые слова. А все эти механизмы могут взаимодействовать друг с другом, порождая неведомые комбинации, у каждой из которых есть свое особенное поведение и ограничения. В итоге одно и то же поведение можно реализовать десятком разных способов. Приходится знать тысячи нюансов и постоянно решать споры о том, какой подход лучше.

Видео: Изоморфизм Рича Хикки https://www.youtube.com/watch?v=b-Eq4YV4uwc



Реализуйте класс Url который описывает переданный в конструктор HTTP адрес и позволяет извлекать из него части:
*/

$url = new Url('http://yandex.ru?key=value&key2=value2');
$url->getScheme(); // http
$url->getHost(); // yandex.ru
$url->getQueryParams();
// [
//     'key' => 'value',
//     'key2' => 'value2'
// ];
$url->getQueryParam('key'); // value
// второй параметр - значение по умолчанию
$url->getQueryParam('key2', 'lala'); // value2
$url->getQueryParam('new', 'ehu'); // ehu


// file: UrlInterface.php:
namespace App;

interface UrlInterface
{
    public function getScheme();
    public function getQueryParams();
    public function getQueryParam($key, $defaultValue = null);
    public function getHost();
    public function getQuery();
}

namespace App;

// file: UrlInterface.php

class Url implements UrlInterface
{
	private $url;
    private $scheme;
    private $host;
    private $queryParams;

    public function __construct($url)
    {
        $data = parse_url($url);

        $this->scheme = $data['scheme'];
        $this->host = $data['host'];
        $this->query = $data['query'];
        $this->queryParams = $this->parseQuery($data['query']);
    }

    public function getScheme()
    {
        return $this->scheme;
    }

    public function getQueryParams()
    {
        return $this->queryParams;
    }

    public function getQueryParam($key, $defaultValue = null)
    {
        return $this->queryParams[$key] ?? $defaultValue;
    }

    public function getHost()
    {
        return $this->host;
    }

    public function getQuery()
    {
        return $this->query;
    }

    private function parseQuery($query)
    {
        $parts = explode('&', $query);
        $params = array_reduce($parts, function ($acc, $item) {
            [$key, $value] = explode('=', $item);
            $acc[$key] = $value;
            return $acc;
        }, []);x
        return $params;
    }
}	



################################### Объектно-ориентированный дизайн  ###################################

/*
Fluent Interface
stdClass - встроенный в PHP класс, который автоматически используется при преобразовании типов
Структуры данных - ОО-версии популярных структур данных.
PHPUnit - фреймворк для тестирования в PHP
Collect - библиотека для работы с коллекциями в ОО-стиле
Carbon - библиотека для работы с датами в ОО-стиле
Stringy - библиотека для работы со строками в ОО-стиле


Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. (Wiki)

Простым языком, определение звучит так: типовое решение для типовой задачи. Термин пришел в программирование из архитектуры. В 1970-е годы архитектор Кристофер Александр составил набор шаблонов проектирования, типовых решений для различных архитектурных задач. Спустя полтора десятка лет эта идея была заимствована и адаптирована применительно к разработке графических оболочек языка SmallTalk. Сейчас паттерны встречаются повсеместно, постоянно изобретаются и переизобретаются. Некоторые из них описывают задачи, связанные с небольшим участком кода, другие определяют, например, способы работы в распределенных системах. Причем последние отвязаны от языка программирования. Интересный факт: некоторые шаблоны в языках появились вследствие ограничений самих языков и пытаются обойти их.

Как минимум один паттерн проектирования мы уже знаем по уроку "статические методы". Его называют Фабрика. Фабрика - функция, порождающая объекты, создание которых сложнее, чем просто передача данных в конструктор.
*/
class Carbon
{
    public static function now($timezone = '')
    {
        return new self(date("Y-m-d H:i:s"), $timezone);
    }
}

/*
Паттерн фабрика никак не завязан ни на статические методы, ни на объектно-ориентированное программирование, ни на конкретный язык. Ключевое в этом шаблоне - "функция порождает данные"; чем являются данные (хоть объекты, хоть функции - те самые объекты первого рода) или функция - не важно. В статических языках подобные паттерны определяются строже из-за необходимости согласования типов.

Возможно, вы удивитесь, что для такой примитивной задачи придуман целый паттерн, и будете правы. Паттерн - не обязательно что-то сложное и доступное только избранным. Паттерном называют любую задачу, которая повторяется безотносительно оценки сложности решения. Поэтому, хотите вы того или нет, в вашем коде уже встречаются шаблоны проектирования, даже если вы об этом не знаете. Правда, до некоторых типовых решений самостоятельно дойти крайне сложно.

Насколько важно изучать шаблоны проектирования? Не отрицая полезность, предупрежу, что большинство описаний шаблонов в интернете завязано на конкретную книгу (https://ru.wikipedia.org/wiki/Design_Patterns). Далеко не все паттерны, описанные в ней полезны и встречаются в обычной жизни. Многие из них специфицированы под конкретные языки и не применимы в том же виде в других языках. Еще больше паттернов (на порядки) в этой книге не описано.

Как только появились паттерны, то не могли не появиться и антипаттерны. Антипаттерн - такое же типовое решение (потому что им часто пользуются), но создающее больше проблем, чем приносящее пользы. Обычно такие решения возникают из-за непонимания причинно-следственных связей в коде.

Дополнительные материалы:
Антипаттерн: https://ru.wikipedia.org/wiki/Антипаттерн
Паттерны без привязки к языку: https://github.com/Hexlet/patterns/tree/master/content

# Конфигурация

Markdown - упрощенный язык разметки, который удобен при работе с текстом (в отличие от HTML). Браузеры не умеют отображать markdown напрямую, поэтому он транслируется в HTML и уже затем показывается. Трансляция markdown в HTML описывается чистой функцией. Она не зависит от внешнего окружения, детерминирована и не порождает побочных эффектов.
*/

$html = markdownToHtml($markdown);

// На входе текст (в формате markdown), на выходе - тоже текст (в формате html). Если нужно изменить поведение трансляции, то достаточно передать вторым параметром массив опций.

$html = markdownToHtml($markdown, ['sanitize' => false]);

/*
Теперь давайте вообразим объектно-ориентированную версию этого кода. Перед тем, как двигаться дальше, попробуйте отвлечься от чтения и подумайте над следующими вопросами:

Что мы вообще хотим получить такого от ООП, чего не дает нам чистая функция?
Как будет выглядеть получившийся интерфейс?
Как вы помните, ключевая идея ООП - абстракция данных. Можно ли сказать, что в процессе преобразования markdown в HTML есть абстракция? Нет. Абстракция подразумевает наличие некоторого понятия (типа), значения которого обладают временем жизни. Это значит, что она создается и затем многократно и по-разному используется. Например, невозможно представить работу с пользователем в виде одной функции. Если говорить о markdown, то конкретный текст этого формата не интересует нас сам по себе, мы не определяем над ним некоторый набор операций и не собираемся им активно пользоваться. Все, что мы хотим, прямо здесь и сейчас (в том коде) - получить HTML и забыть про markdown.

Если бы мы хотели построить вокруг текста абстракцию, то код выглядел бы так:
*/

$md = new Markdown($markdown);
$html = $md->render();

/*
В примере выше тип Markdown представляет собой абстракцию над текстом в формате markdown. Смысла в таком коде мало, а вот проблем он доставит. Эти две строчки начнут неразрывно встречаться в каждом месте, в котором требуется получить HTML. Объект $md становится сразу не нужен, как только получен HTML, у него нет времени жизни. Такой антипаттерн особенно часто встречается у новичков. Загвоздка здесь именно в том, чтобы разобраться, где у нас абстракция данных, а где нет.
*/

$md1 = new Markdown($markdown1);
$html1 = $md->render();

$md2 = new Markdown($markdown2);
$html2 = $md2->render();

/*
Существует формальное правило, позволяющее это определить. Если создание объекта и вызов метода можно заменить на обычную функцию, то ни о какой абстракции речи не идет, и правильный подход, в данной ситуации, сводится к переносу данных из конструктора в сам метод.
*/

$md = new Markdown();
// очень важно, чтобы render оставался чистой функцией и не сохранял $markdown внутри объекта
$html1 = $md->render($markdown1);
$html2 = $md->render($markdown2);

/*
В этом коде Markdown - тип, относящийся к транслятору, а не к тексту. У такого объекта жизненный цикл шире, чем ожидание однократного вызова функции render (как в предыдущем случае). Он может (и должен) переиспользоваться столько раз, сколько потребуется. Для этого важно оставить функцию render чистой и не менять состояние объекта между вызовами.

Тогда становится непонятно, зачем здесь вообще объект. И на это есть 3 причины.

Идиоматика. В PHP, как и в Java, принято практически все оформлять в виде классов. К тому же для них работает автозагрузка.
Полиморфизм подтипов. Разберем в последущих курсах.
Третья и главная причина (для данного случая) - Конфигурация.
Разберем последний пункт подробнее. Представьте что маркдаун на проекте используется повсеместно (на Хекслете очень часто) и код генерации HTML выглядит так:
*/

// В одном месте
$html1 = markdownToHtml($markdown1, ['sanitaize' => true]);

// Где-то в другом месте
$html2 = markdownToHtml($markdown2, ['sanitaize' => true]);

/*
Чем больше возникает таких мест, тем больше дублируется передача опций. Изменение поведения потребует переписывания всех мест вызова этой функции. Логичным шагом было бы задать опции в одном месте и затем их переиспользовать.
*/

// В одном месте
$html1 = markdownToHtml($markdown1, $options);

// Где-то в другом месте
$html2 = markdownToHtml($markdown2, $options);

/*
Использование объекта позволяет убрать явную передачу (про которую легко забыть). Суть этого паттерна заключается в конфигурировании. То есть объект в данном случае выступает в роли контейнера, содержащего опции для markdown, которые применяются при рендеринге, что позволяет их не передавать каждый раз.
*/

$md = new Markdown(['sanitize' => true]);
$html1 = $md->render($markdown1);
$html2 = $md->render($markdown2);

/*
Под конфигурированием, всегда понимается передача опций (различных настроек необходимых данной библиотеке) в конструктор во время создания объекта. Особенно полезным такая конфигурация становится тогда, когда объект создается в одном месте программы (на этапе инициализации приложения), а используется в других местах. Возможность конфигурации не навязывает саму конфигурацию, как правило, подобные объекты можно создавать и без указания чего либо, тогда поведение остается "дефолтным", но смысл от этого не меняется.
*/

$md = new Markdown();
$html = $md->render($markdown);

/*
Популярная библиотека для HTTP запросов построена по такому же принципу. Перед выполнением запроса необходимо создать объект. Конструктор соответствующего класса позволяет задать базовую конфигурацию, но через него нельзя указать запрашиваемый адрес, ведь это не часть конфигурации, а часть самого запроса.

Попробуйте проверить себя. Выполнение HTTP запроса это абстракция данных или нет?
*/

$client = new \GuzzleHttp\Client();
$res = $client->get('https://api.github.com/repos/guzzle/guzzle');
echo $res->getStatusCode();

/*
Данный прием не является прерогативой классов и объектов. В функциональных языках (и в js) он крайне просто реализуется через замыкание

Какой дизайн кода правильный (при условии что решено использовать класс) для библиотеки определяющей местоположение по IP адресу?
*/

$ipgeo = new IpGeo();
$result = $ipgeo->resolve($ip);
print_r($result->city());
print_r($result->country());

/*
Валидация - процесс проверки корректности данных. В вебе происходит всегда при отправке форм, например, регистрация на многих сайтах проверяет корректность введенного емейла, его уникальности (что такого пользователя уже нет).

Каждый тип валидации в таких системах (на PHP) обычно представлен классом-валидатором, который принимает на вход опции и предоставляет интерфейс в виде функции validate. Эта функция принимает на вход то что проверяется (валидируется) и возвращает массив с ошибками. Если массив пустой, значит ошибок нет.

Реализуйте класс PassworValidator ориентируясь на тесты.

Этот валидатор поддерживает следующие опции:
minLength (по-умолчанию 8) - минимальная длина пароля
containNumbers (по-умолчанию false) - требование содержать хотя бы одну цифру

Массив ошибок в ключах содержит название опции, а в значении текст указывающий на ошибку (тексты можно подсмотреть в тестах)
*/

namespace App;

class PasswordValidator
{
    const OPTIONS = [
        'minLength' => 8,
        'containNumbers' => false
    ];

    private $options = [];

    public function __construct(array $options = [])
    {
        $this->options = array_merge(self::OPTIONS, $options);
    }

    public function validate(string $password): array
    {
        $errors = [];
        if (mb_strlen($password) < $this->options['minLength']) {
            $errors['minLength'] = 'too small';
        }

        if ($this->options['containNumbers']) {
            if (!$this->hasNumber($password)) {
                $errors['containNumbers'] = 'should contain at least one number';
            }
        }

        return $errors;
    }

    private function hasNumber($subject)
    {
        return strpbrk($subject, '1234567890') !== false;
    }
}

/*
# Изменяемая конфигурация

Как мы выяснили в предыдущем уроке, многие объекты в ООП не являются абстракцией данных, а используются как способ сохранить конфигурацию для выполнения повторяющихся действий, таких как генерация HTML из Markdown или определение города по IP. Конфигурация осуществляется через передачу опций в конструктор объекта, а сами опции, хранятся внутри и используются для всех последующих вызовов.
*/

// timeout устанавливает ограничение в одну секунду на длительность запроса
$ipgeo = new IpGeo(['timeout' => 1000]);
$ipgeo->resolve('123.4.3.2');

/*
Но что если для конкретного запроса, нужно временно установить опции отличные от тех что были переданы в конструктор? Для выхода из этой ситуации есть три возможных решения

Создание нового объекта

Самое простое решение сводится к созданию нового объекта в том месте где нам нужно. Это решение хоть и простое, но обладает рядом недостатков. Главный недостаток связан с невозможностью подмены реализации (тот самый полиморфизм о котором мы будем говорить в будущем), так как объект создается не на этапе конфигурирования системы, а в том месте где происходит вызов. Это, в свою очередь, ведет к тому что придется дублировать общие опции, а тестирование станет затруднительным (если не невозможным).
*/
$ipgeo = new IpGeo(['timeout' => 10]);
$ipgeo->resolve('123.4.3.2');

/*
Сеттеры
Самый страшный вариант связан с использованием сеттеров.
*/
$ipgeo = new IpGeo(['timeout' => 1000]);

// В одной части программы
$ipgeo->resolve('123.4.3.2');

// В другой части программы
$ipgeo->setOption('timeout', 10);
$ipgeo->resolve('123.4.3.2');

/*
Изменяемое состояние, самое сложное что есть в программировании. Его наличие приводит практически ко всем сложностям с которыми мы встречаемся и создает трудноотловимые и опасные баги. Догадайтесь, что пойдет не так после выполнения последних двух строк? Наш объект $ipgeo используется совместно всеми частями системы из этого следует что его изменение в одном месте повлияет на все последующие вызовы. В случае работы с Markdown все может быть еще страшнее, так как неправильный вывод порождает дыры в безопасности, а конкретно возможность провести XSS:
*/
$md = new Markdown(['sanitaize' => true]);

// В одной части программы
$md->render($markdown);

// В другой части программы отключаем санитайз
$md->setOption('sanitize', false);
$md->render($markdown2);

/*
sanitaize, флаг отвечающий за включение безопасного рендеринга. Если его выключить, то теги script вставленные в markdown отобразятся как есть. Такое иногда нужно и допустимо для своего собственного текста (например на Хекслете это уроки), но недопустимо для текста который вводят пользователи. Мутация объекта md создает дыру в безопасности. Избежать ее можно не забыв вернуть опцию обратно:
*/
$md = new Markdown(['sanitaize' => true]);

// В одной части программы
$md->render($markdown)

// В другой части программы отключаем санитайз
$md->setOption('sanitize', false);
$md->render($markdown2)
$md->setOption('sanitize', true);

/*
Как вы понимаете, в силу человеческого фактора, программист обязательно забудет это сделать. Такой код, в котором сначала что-то меняется в одну сторону, а потом восстанавливается обратно, почти всегда говорит о проблемах архитектуры и его можно написать безопасно.

Новые опции на время запроса
Правильный способ решает все проблемы указанные выше. Его использование основано на передаче дополнительного параметра в метод. Этот параметр содержит временные опции, которые применяются только для данного запроса.
*/

$md = new Markdown(['sanitaize' => true]);

// В одной части программы
$md->render($markdown);

// В другой части программы отключаем санитайз на время выполнения запроса
$md->render($markdown2, ['sanitaize' => false]);
$md->render($markdown3); // sanitaize по прежнему равен true

// Теперь все в порядке. Sanitize включен глобально, но в конкретном запросе он был переопределен $md->render($markdown, ['sanitaize' => false]) и это никак не отражается на последующих вызовах метода render.



/*
Для работы с текстом в вебе бывает полезна функция truncate, которая обрезает слишком длинный текст и ставит в конце, например, троеточие:
truncate('long text', ['length' => 3]); // => lon...
*/

namespace App;

class Truncater
{
    const OPTIONS = [
        'separator' => '...',
        'length' => 200,
    ];

    private $options = [];

    public function __construct(array $options = [])
    {
        $this->options = array_merge(self::OPTIONS, $options);
    }

    public function truncate(string $text, array $options = []): string
    {
        $options = array_merge($this->options, $options);
        if (mb_strlen($text) <= $options['length']) {
            return $text;
        }
        return substr_replace($str, $options['separator'], $options['length']);
    }
}

namespace App\Tests;

use App\Truncater;
use PHPUnit\Framework\TestCase;

class TruncaterTest extends TestCase
{
    public function testTruncate()
    {
        $truncater = new Truncater();
        $actual = $truncater->truncate('one two');
        $this->assertEquals('one two', $actual);
        $actual = $truncater->truncate('one two', ['length' => 6]);
        $this->assertEquals('one tw...', $actual);
        $actual = $truncater->truncate('one two', ['separator' => '.']);
        $actual = $truncater->truncate('one two', ['length' => '3']);
        $this->assertEquals('one...', $actual);

        $truncater = new Truncater(['length' => 3]);
        $actual = $truncater->truncate('one two');
        $this->assertEquals('one...', $actual);
        $actual = $truncater->truncate('one two', ['separator' => '!']);
        $this->assertEquals('one!', $actual);
        $actual = $truncater->truncate('one two');
        $this->assertEquals('one...', $actual);
    }
}

/*
# stdClass

PHP поставляется с небольшим набором предопределенных классов, в который входит stdClass. Этот класс имеет особое значение для языка и используется в некоторых ситуациях автоматически.

Первое, что бросается в глаза: stdClass нарушает стандарт именования и начинается с маленькой буквы. Вторая особеность проявляется при работе с ним - в stdClass нет предопределенных свойств и методов, но объекты этого класса могут наполняться любыми свойствами в процессе работы.
*/

$obj = new stdClass();
$obj->key = 'value';

var_dump($obj);
// class stdClass#1 (1) {
//   public $key =>
//   string(5) "value"
// }

/*
В обычной ситуации, попытка записать значение в неопределенное свойство приводит к ошибке. В случае с stdClass ошибки не возникает. Такого эффекта можно добиться с помощью специальных магических методов __get и __set. Эти методы вызываются автоматически при обращении к неопределенным свойствам и позволяют создавать их на лету.
*/

class MyStdClass
{
    private $properties = [];

    public function __set($name, $value)
    {
        $this->properties[$name] = $value;
    }

    public function __get($name)
    {
        return $this->properties[$name];
    }

    // Для полноты полезно реализовать метод __isset
    // http://php.net/manual/ru/language.oop5.overloading.php#object.isset
}

$obj = new MyStdClass();
$obj->key = 'value'; // __set($name, $value) где $name = 'key', а $value = 'value'
$obj->key; // __get($name) где $name = 'key'

print_r($obj);
// MyStdClass Object
// (
//     [properties:Tmp\MyStdClass:private] => Array
//         (
//             [key] => value
//         )
//
// )

/*
Такие объекты очень похожи на ассоциативные массивы, но с объектным синтаксисом. Более того, в JavaScript встроен тип данных object, который ведет себя одновременно и как ассоциативный массив, и как объект из примера выше. В зависимости от желания, к нему можно обращаться и так, и так.
*/
const obj = {};
obj.key = 'value';
obj.key; // value
obj['key']; // value

obj['key'] = 'value2';
obj.key; // value2

/*
Преобразование типов
Преобразование ассоциативного массива в объект приводит к созданию объекта класса stdClass;
*/

$userAsArray = [
  'name' => 'George',
  'age' => 18
];

$userAsObject = (object) $userAsArray;

var_dump($userAsObject);
// class stdClass#2 (2) {
//   public $name =>
//   string(6) "George"
//   public $age =>
//   int(18)
// }

/*
Парсинг JSON
В PHP не разделяются понятия массив и ассоциативный массив, что резко отличается от всех остальных языков и форматов. Например, в JSON это два разных типа данных.
*/

{
  "files": ["src/Countable.php", "src/Moment.php"],
  "require": {
    "phpunit": "*",
    "http-client": "*"
  }
}

/*
В JSON files содержит массив, а require - ассоциативный массив. Именно в таких ситуациях и подходит stdClass (хотя, откровенно говоря, это - костыль из-за отсутствия нормальных массивов). Функция json_decode парсит переданный ей JSON и формирует либо массив, либо объект stdClass, в зависимости от того, чем были данные внутри JSON.

stdClass Object
(
    [files] => Array
        (
            [0] => src/Countable.php
            [1] => src/Moment.php
        )

    [require] => stdClass Object
        (
            [phpunit] => *
            [http-client] => *
        )

)

Конфигурация
Многие фреймворки используют stdClass для хранения конфигурации, так как она динамическая (то есть состав ключей меняется в зависимости от потребностей разработчика).

Реализуйте функцию toStd, которая п ринимает на вход ассоциативнвый массив и ввозвращает объект типа stdClass такой же структуры. Выполните задачу проставляя ключи и значения вручную без использования преобразования типа.
*/

$data = [
    'key' => 'value',
    'key2' => 'value2',
];
$config = toStd($data);

$config->key; // value
$config->key2; // value2

/*
# PHPUnit
Практика на хекслете проверяется автоматическими тестами, к которым вы уже немного привыкли, если смогли добраться до текущего урока. Для тестирования PHP-кода мы используем фреймворк PHPUnit, который, хоть и не единственный, но до сих пор - самый популярный. Имея некоторое представление об ООП, мы можем поговорить о его устройстве.
*/

namespace App\Tests;

use function App\Math\average;
use PHPUnit\Framework\TestCase;

/*
Единственная незнакомая синтаксическая конструкция в этом тесте - `extends TestCase`.
С ее помощью реализуется наследование. О наследовании пойдет разговор в следующих курсах, а сейчас достаточно знать, что все методы, которые мы вызываем внутри нашего теста, определены в классе `TestCase` и именно наследование позволяет их использовать.
*/

class MathTest extends TestCase
{
    public function testAverage()
    {
        $this->assertEquals(0, average(0));
        $this->assertEquals(5, average(0, 10));
    }
}

/*
Не имеет значения предмет тестирования; любой тест PHPUnit всегда описывается в классе с именем ЧтотоTest внутри директории tests. Если тестируется какой-то конкретный класс с именем Foo, то, по соглашению, его тесты располагаются в классе FooTest. Точно такое же правило с неймспейсами без классов. Как правило, структура папок внутри tests совпадает со структурой исходных файлов - так проще ориентироваться, и некоторые редакторы позволяют автоматически переключаться между тестом и исходным файлом при такой структуре и именовании.

src/                                tests/
`-- Money/Currency.php              `-- Money/CurrencyTest.php
`-- IntlFormatter.php               `-- IntlFormatterTest.php
`-- Money.php                       `-- MoneyTest.php

Каждый тестовый класс состоит из тестовых методов. Тестовые методы всегда начинаются с префикса test, например, testAverage - только тогда PHPUnit понимает, что это тестовый метод и выполняет его автоматически при прогоне тестов. Тестовые методы пишутся программистом. Нет никаких правил в том, сколько их должно быть и какова должна быть их структура. Если нужно написать десять разных тестов на одну функцию, то так и нужно делать.

Главная задача любого тестового метода - выполнить ту проверку, ради которой задумывался соответствующий тест. В примере выше тестируется функция average, находящая среднее арифметическое всех переданных в эту функцию чисел. Average - чистая функция, а значит, ее легко тестировать. Достаточно передать в функцию несколько чисел и проверить возвращаемое значение.

Проверки в PHPUnit выполняются с помощью специальных функций - утверждений. Этих функций довольно много, но среди них есть несколько наиболее используемых. Метод assertEquals принимает на вход два значения:

Expected. Ожидаемый результат - то, что должна вернуть функция.
Actual. Результат, который на самом деле вернула функция.
Порядок важен. На его основе PHPUnit формирует вывод, в котором указывает, что ожидалось, а что пришло на самом деле.

Другое популярное утверждение assertTrue (и assertFalse), оно принимает только один аргумент и отлично подходит для тестирования предикатов.

Анализ дизайн
Дизайн тестов на основе классов, теряет свою популярность, а во многих языках уже давно не используется. Современный подход растет из BDD (https://en.wikipedia.org/wiki/Behavior-driven_development) процесса. Синтаксически такие тесты часто полагаются на функции высшего порядка describe и it.
*/
describe('Example', function () {
    $object = new stdClass();
    $object->name = 'pho';

    context('name', function () use ($object) {
        it('is set to pho', function()  use ($object) {
            expect($object->name)->toBe('pho');
        });
    });
});

/* Замечу, что в PHP такой стиль выглядит немного тяжелым из-за обилия синтаксических конструкций.

Дополнительные материалы:
Официальная документация https://phpunit.de/manual/6.5/en/writing-tests-for-phpunit.html
Behat (BDD Framework) http://behat.org/en/latest/quick_start.html
Codeception (Браузерные тесты) https://codeception.com/
Начинаем писать тесты (Правильно) https://ru.hexlet.io/blog/posts/how-to-test-code




/**
Реализуйте тест CourseTest, проверяющий работоспособность метода getName класса Course.
**/

// file: App/Course.php
namespace App;

class Course
{
    private $name;

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function getName()
    {
        return $this->name;
    }
}

// tests/CourseTest.php:

namespace App\Tests;

use PHPUnit\Framework\TestCase;

class CourseTest extends TestCase
{
    public function testGetName()
    {
        $name = 'my super course';
        $course = new \App\Course($name);
        $this->assertEquals($name, $course->getName());
    }
}



# DS

PHP поставляется с библиотекой, называемой SPL (Standard PHP Library http://php.net/manual/en/book.spl.php). Кроме прочего, она содержит набор классов, реализующих популярные структуры данных, таких, как стек или очередь.
*/

$q = new SplStack();
$q->push(3);
$q->push(10);
$q->pop(); // 10
$q->pop(); // 3

/*
Несмотря на то, что SPL встроен в язык, конкретно к Datastructures есть множество претензий со стороны комьюнити как по производительности, так и по интерфейсам классов. Все это вылилось в создание расширения php-ds (DS). Подробнее о нем читайте в статье https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd. php-ds можно установить как обычный пакет https://github.com/php-ds/polyfill. Вся документация доступна здесь: http://docs.php.net/manual/ru/book.ds.php.

DS включает в себя Vector, Deque, Map, Set, Stack, Queue, PriorityQueue, Pair. Эти структуры, в жизни обычного веб-разработчика нужны не каждый день, но все же такое случается. Если вы с ними не знакомы, то рекомендую пробежаться по вики.

Stack
Стек - это коллекция типа "Последний вошел, первый вышел" (Last In, First Out или LIFO), которая позволяет работать только с самым верхним (последним) значением. Итерация происходит от конца к началу с удалением взятого элемента.
*/
$stack = new Ds\Stack();
$stack->push(3);
$stack->push(10);
$stack->pop(); // 10
$stack->pop(); // 3
print_r($stack->toArray());

/*
Методы pop и push составляют основной интерфейс класса. push добавляет элемент (или элементы) на стек, pop - снимает со стека.

Перепишем с использованием этого стека функцию, которая разбиралась в курсе "PHP: массивы". Напомню задачу:

Необходимо реализовать функцию, которая проверяет, что парные символы сбалансированы. То есть каждый открывающий символ имеет закрывающий, и они не перекрываются, например, так: [{]}. К таким символам в нашем случае относятся <>, {}, () []. Входом в функцию может быть ()<>{}. Такой пример проходит проверку, а вот этот уже нет: [({)}]. Здесь происходит перекрытие фигурных и круглых скобок.
*/

function checkIfBalanced(string $expression): boolean
{
    // инициализируем стек
    $stack = new Ds\Stack();
    // инициализируем список открывающих элементов
    $startSymbols = ['{', '(', '<', '['];
    // инициализируем список пар
    $pairs = ['{}', '()', '<>', '[]'];

    // Проходим по строке от первого до последнего символа
    for ($i = 0; $i < strlen($expression); $i++) {
        $curr = $expression[$i];
        // Если текущий символ находится в списке открывающих символов, то заносим его в стек
        if (in_array($curr, $startSymbols)) {
            $stack->push($curr);
        } else { // Если элемент не входит в список открывающих, то считаем, что это закрывающий символ
            $prev = $stack->pop();
            // Составляем из этих символов пару
            $pair = "{$prev}{$curr}";
            // Проверяем, что она входит в список $pairs. Если входит, то все правильно, двигаемся дальше; если нет,
            // то это автоматически означает, что символы не сбалансированы
            if (!in_array($pair, $pairs)) {
                return false;
            }
        };
    }

    // Если стек оказался пустым после обхода строки, то значит все хорошо
    return sizeof($stack) == 0;
}

/*
По большому счету, ничего не поменялось. Кода не стало меньше, он не стал проще. С другой стороны, такой подход более канонический для PHP.

/**
Реализуйте функцию compare, которая сравнивает две строчки набранные в редакторе. Если они равны то возвращает true, иначе - false. Особенность строчек в том они могут содержать символ #, который означает нажатие клавиши Backspace. То есть перед самим сравнением, нужно вычислить реальную строчку отображенную в редакторе.
**/

compare('ab#c', 'ab#c'); // true
compare('ab##', 'c#d#'); // true
compare('a#c', 'b'); // false


function compare($str1, $str2)
{
    $getRealString = function ($str) {
        $stack = new \Ds\Stack();

        for ($i = 0; $i < strlen($str); $i++) {
            $sign = $str[$i];
            if ($sign == '#') {
                $stack->pop();
            } else {
                $stack->push($sign);
            }
        }
        return implode('', $stack->toArray());
    };
    
    return $getRealString($str1) == $getRealString($str2);
}

#2:

function compare($text1, $text2)
{
    $evaluatedText1 = evaluate($text1);
    $evaluatedText2 = evaluate($text2);

    return $evaluatedText1 === $evaluatedText2;
}

function evaluate($text)
{
    $stack = new \Ds\Stack();
    for ($i = 0; $i < mb_strlen($text); $i++) {
        $current = $text[$i];
        if ($current == '#') {
            $stack->pop();
        } else {
            $stack->push($current);
        }
    }

    return implode('', $stack->toArray());
}



# Collect 

В курсе по работе с массивами я упоминал библиотку Collect, позволяющую манипулировать в объектном стиле. Она содержит более 100 операций, решающих большинство распростаненных задач по манипулированию коллекциями. Крайне рекомендую использовать ее во всех ваших проектах как одну из базовых зависимостей.

Пример ниже показывает, как выполнить flatten, используя Collect. Напомню, что flatten распрямляет массивы, вытаскивая элементы из вложенных на верхний уровень.
*/

$collection = collect(['name' => 'taylor', 'languages' => ['php', 'javascript']]);
$flattened = $collection->flatten();

// Извлечение массива
$flattened->all(); // => ['taylor', 'php', 'javascript'];

/*
Всего три строчки, но очень много смысла. Попробуем разобраться. В первой строчке создается объект типа Collection. Создается необычным способом - вместо new Collection мы видим обычную функцию. Такой трюк служит одной единственной цели - сделать код компактнее. Это наглядный пример использования паттерна Фабрика.

Объект, который возвращает функция collect, содержит исходную коллекцию внутри себя и предоставляет свой собственный интерфейс для ее изменения. Создав объект, мы можем начать пользоваться самой библиотекой. В примере выше выполняется метод flatten, который возвращает новую коллекцию. Причем под коллекцией понимается не массив, а именно объект типа Collection, что позволяет продолжить обработку без необходимости повторного оборачивания в collect. Кроме того, каждый метод в Collection всегда возвращает новую коллекцию и никогда не модифицирует исходную. Такой подход позволяет переиспользовать промежуточные результаты, не боясь случайно сломать код. В примере выше это означает, что сама $collection не изменилась (и не изменится никогда). А значит, мы можем ее использовать повторно уже для других вычислений.
*/

$collection = collect(['name' => 'taylor', 'languages' => ['php', 'javascript']]);
$excepted = $collection->except(['name']); // исключаем ключи
$flattened = $collection->flatten();
$collection->all(); // => ['name' => 'taylor', 'languages' => ['php', 'javascript']]
$excepted->all(); // => ['languages' => ['php', 'javascript']]
$flattened->all(); // => ['taylor', 'php', 'javascript']

/*
В последней строчке $flattened->all() из объекта извлекается результирующий массив. Подобный код нужен почти всегда, когда нативная (встроенная в язык) структура оборачивается в объект. Когда все операции выполнены, тогда обычно нам требуется готовый массив для продолжения работы.

Collect содержит внутри себя все те функции высшего порядка, с которыми мы познакомились ранее, это map, filter и reduce.
*/

// Map

$collection = collect([1, 2, 3, 4, 5]);

$multiplied = $collection->map(function ($item, $key) {
    return $item * 2;
});

$multiplied->all(); // [2, 4, 6, 8, 10]

// Filter

$collection = collect([1, 2, 3, 4]);

$filtered = $collection->filter(function ($value, $key) {
    return $value > 2;
});

$filtered->all(); // [3, 4]

// Reduce

$collection = collect([1, 2, 3]);

$total = $collection->reduce(function ($carry, $item) {
    return $carry + $item;
}); // 6

/*
Fluent Interface
Посмотрите на то, как организована цепочка вызовов в коде ниже.
*/

$result = collect(['taylor', 'abigail', null])
->map(function ($name) {
    // переводим в верхний регистр
    return strtoupper($name);
})
->reject(function ($name) {
    // отфильтровываем пустые
    return empty($name);
});

// выводим коллекцию на экран
$result->dump(); // => ['TAYLOR', 'ABIGAIL']

/*
Схематично цепочка выглядит так: $collection->map(...)->reject(...). Мы уже рассматривали подобный код, когда один объект возвращает другой, но тогда речь шла про то, что объект одного типа возвращает объект другого типа, у которого есть свои методы. В данном же примере методы возвращают объект того же типа (возникает ощущение что возвращается сам объект, но в измененной форме). В теории такой подход дает возможность строить цепочки неограниченной длины: $collection->map(...)->map(...)->map(...). Такую цепочку вызовов принято называть fluent interface (текучий интерфейс).

Кстати в том же JavaScript такие цепочки - основной способ строить вычисления на коллекциях.
*/

[0, -2, 4].map(n => n ** 2).filter(n => n > 3); // [4, 16]

/*
Query Builder
Query Builder - широко распространенный паттерн проектирования, позволяющий собирать сложные запросы по частям. Чаще всего он встречается при работе с базами данных для сбора sql, либо для коллекций, как в примерах данного урока. Этот паттерн в ОО-языках реализуется с помощью fluent interface.
*/

// laravel query builder
$price = DB::table('orders')
                ->where('finalized', 1)
                ->avg('price');
/*                
Его удобство проявляется особенно сильно в тех местах, где логика построения запросов условная. Например, фильтрация товаров в интернет-магазине. Без Query Builder такую выборку реализовать крайне трудно.

# Fluent Interface

Fluent Interface удобен для создания DSL. Domain Specific Language (Предметно-ориентированный язык) — язык, специализированный под конкретную область применения. Структура такого языка отражает специфику решаемых с его помощью задач. Яркий пример подобного языка — библиотека Jquery, с которой знакомо большинство программистов (или хотя бы слышали о ней).
*/
$('#test').css('color', '#333').height(200);
/*
На техническом уровне есть ровно два способа создать такой интерфейс.

This
Первый способ основан на возврате $this из методов, которые участвуют в построении цепочек. $this — ссылка на тот объект, в контексте которого вызывается метод, а, следовательно, его можно возвращать как обычное значение.
*/
class Coll
{
    private $coll;

    public function __construct(array $coll)
    {
        $this->coll = $coll;
    }

    public function map(callable $fn)
    {
      $this->coll = array_map($fn, $this->coll);

      return $this;
    }

    public function filter(callable $fn)
    {
      $this->coll = array_filter($this->coll, $fn);

      return $this;
    }

    // Возвращает саму коллекцию, а не this. Этот метод всегда последний в цепочке вызовов Coll.
    public function all()
    {
        return $this->coll;
    }
}

$cars = new Coll([
  ['model' => 'rapid', 'year' => 2016],
  ['model' => 'rio', 'year' => 2013],
  ['model' => 'mondeo', 'year' => 2011],
  ['model' => 'octavia', 'year' => 2014]
]);

$cars->filter(function ($car) { return $car['year'] > 2013; })
     ->map(function ($car) { return $car['model']; });
$cars->all(); // [rapid, octavia]

/*
У этого способа есть один серьезный недостаток — объект изменяется. Это значит, что нельзя взять и просто так переиспользовать объект-коллекцию для разных выборок, потому что они начнут накладываться друг на друга.

На практике часто используется другой подход, с которым мы уже познакомились в прошлом курсе. Все, что нужно сделать — добавить немного функциональности в ооп, то есть возвращать не $this, а создавать новый объект того же типа с обновленной коллекцией.
*/

class Coll
{
    private $coll;

    public function __construct(array $coll)
    {
        $this->coll = $coll;
    }

    public function map(callable $fn)
    {
      $coll = array_map($fn, $this->coll);

      return new Coll($coll);
    }

    public function filter(callable $fn)
    {
      $coll = array_filter($this->coll, $fn);

      return new Coll($coll);
    }

    // Возвращает саму коллекцию, а не this. Этот метод всегда последний в цепочке вызовов Coll.
    public function all()
    {
        return $this->coll;
    }
}

$cars = new Coll([
  ['model' => 'rapid', 'year' => 2016],
  ['model' => 'rio', 'year' => 2013],
  ['model' => 'mondeo', 'year' => 2011],
  ['model' => 'octavia', 'year' => 2014]
]);

$filteredCars = $cars->filter(function ($car) { return $car['year'] > 2013; });
$mappedCars = $filteredCars->map(function ($car) { return $car['model']; });
$mappedCars->all(); // [rapid, octavia]
$cars->all();
// [
//   ['model' => 'rapid', 'year' => 2016],
//   ['model' => 'rio', 'year' => 2013],
//   ['model' => 'mondeo', 'year' => 2011],
//   ['model' => 'octavia', 'year' => 2014]
// ]

/*
Теперь каждый вызов возвращает новый объект. Такой код значительно безопаснее в использовании и позволяет без проблем переиспользовать новые коллекции. Изменение одной, не приведет к автоматическому изменению всех остальных.
*/

class Coll
{
    // ...

    public function map(callable $fn)
    {
      $coll = array_map($fn, $this->coll);

      return new Coll($coll);
    }

    // ...
}

/*
В каждом методе, который участвует в построении Fluent Interface, последняя строчка всегда содержит один и тот же вызов: new Coll($coll). Ее можно записать проще, не дублируя названия класса. Помните как в прыдудщем курсе использовался self для работы со статическими членами класса? Так вот self работает и с обычными методами, вызов new self($coll) идентичен вызову new Coll($coll), другими словами вместо self подставляется текущий класс. У такого вызова есть еще одно преимущество, о котором мы поговорим в следующем ООП курсе, в теме наследования. В двух словах self реализуется посредством позднего связывания и при наследовании раскрывается в тот класс, с которым прямо сейчас идет работа.

Текучий интерфейс: https://ru.wikipedia.org/wiki/Fluent_interface


# Carbon

Для работы с датами в PHP есть три пути.

Использовать обычные функции http://php.net/manual/en/ref.datetime.php
Использовать встроенные классы, например, http://php.net/manual/en/class.datetimeimmutable.php
Воспользоваться сторонней библиотекой
Первый вариант подходит только для примитивных рассчетов. Не потому, что функции плохи, а потому, что в PHP их мало и ими неудобно пользоваться (интерфейс для машин, а не для людей). Встроенные классы тоже не сильно облегчают задачу. Они работают на низком уровне и простые операции в стиле "получить дату, которая была неделю назад" становятся целым приключением.

В этом уроке мы рассмотрим третий вариант. Самым популярным сторонним решением для работы с датами в PHP является библиотека Carbon (http://carbon.nesbot.com/).
*/
use Carbon\Carbon;

// выдало текущую дату на момент написания урока
printf("Now: %s", Carbon::now()); // Now: 2018-04-21 13:31:56


/*
В целом принцип работы этой библиотеки совпадает с принципом работы Collect. Создавая объект, мы как бы "оборачиваем" дату, делая ее внутренним состоянием объекта. Затем выполняем необходимые операции, используя соответствующие методы. Когда нам снова понадобится дата, то мы сможем ее извлечь.

Библиотека Carbon обширна и включает в себя невероятно большое количество методов. Мы рассмотрим буквально несколько, а за остальными добро пожаловать в официальную документацию.

Определение выходного дня
*/
if (Carbon::now()->isWeekend()) {
    echo 'Party!';
}

// Без Carbon
// if (date('D') == 'Sat' || date('D') == 'Sun') {
//    echo "Today is Saturday or Sunday.";
// }

// Вывод
Carbon::create(2001, 4, 21, 12)->diffForHumans(); // 1 month ago

// Манипулирование датами
$nextSummerOlympics = Carbon::createFromDate(2016)->addYears(4);
// date("F j Y", mktime(0, 0, 0, 1, 1, 2016 + 4));

/*
Fluent Setters
Carbon предоставляет Fluent интерфейс для генерации дат, причем даже несколько видов таких интерфейсов. Его полезность проявляется в местах, где построение дат - динамическое.
*/

$dt = Carbon::now();

$dt->year(1975)->month(5)->day(21)->hour(22)->minute(32)->second(5)->toDateTimeString();
$dt->setDate(1975, 5, 21)->setTime(22, 32, 5)->toDateTimeString();
$dt->setDate(1975, 5, 21)->setTimeFromTimeString('22:32:05')->toDateTimeString();
$dt->setDateTime(1975, 5, 21, 22, 32, 5)->toDateTimeString();

$dt->timestamp(169957925)->timezone('Europe/London');

/*
Сравнение дат
Отдельного внимания заслуживает сравнение дат, которое учитывает часовые пояса.
*/
echo Carbon::now()->tzName;                        // America/Toronto
$first = Carbon::create(2012, 9, 5, 23, 26, 11);
$second = Carbon::create(2012, 9, 5, 20, 26, 11, 'America/Vancouver');

echo $first->toDateTimeString();                   // 2012-09-05 23:26:11
echo $first->tzName;                               // America/Toronto
echo $second->toDateTimeString();                  // 2012-09-05 20:26:11
echo $second->tzName;                              // America/Vancouver

var_dump($first->eq($second));                     // bool(true)
var_dump($first->ne($second));                     // bool(false)
var_dump($first->gt($second));                     // bool(false)
var_dump($first->gte($second));                    // bool(true)
var_dump($first->lt($second));                     // bool(false)
var_dump($first->lte($second));                    // bool(true)


// Благодаря наличию Spaceship Operator (https://wiki.php.net/rfc/combined-comparison-operator) в PHP версий старше 7.1, код выше можно переписать, используя обычные операции сравнения.

var_dump($first == $second);                       // bool(false)
var_dump($first != $second);                       // bool(true)
var_dump($first > $second);                        // bool(false)
var_dump($first >= $second);                       // bool(false)
var_dump($first < $second);                        // bool(true)
var_dump($first <= $second);                       // bool(true)

/*
Дополнительные материалы:
Carbon Docs: https://carbon.nesbot.com/docs/


# Stringy

PHP долгое время не работал с многобайтовыми кодировками, такими как utf-8.
*/
strlen('привет'); // 12

/*
Даже если попробовать выполнить любую операцию над строкой, включающей не ASCII-символы, станет видно, что функции по-прежнему не умеют обрабатывать такие строки. Дело в том, что в целях соблюдения обратной совместимости, в PHP было создано отдельное подмножество функций, имеющих аналогичные названия, но с префиксом mb_.
*/
mb_strlen('привет'); // 6
/*
Такая ситуация очень неприятна и из популярных языков присутствует, пожалуй, только в PHP. В остальных языках есть ровно один набор функций, работающий со всеми кодировками. Минимизировать проблему можно использованием только функций с префиксом mb_, так как они прекрасно работают и для английского алфавита, и вообще для любых строк.

Вторая проблема, уже типичная - функций довольно мало и они низкоуровневые. Например, проверить то, что строка начинается с определенной подстроки можно только с помощью функции strpos.
*/

// Обязательно проверять строго на равенство нулю
strpos('start', 'st') === 0; // true

/*
Такой код, мало того, что сложен (не очевидно, что он делает), так еще и является постоянным источником ошибок из-за неявного приведения типов.

Stringy
Библиотека Stringy предоставляет унифицированный объектно-ориентированный интерфейс для работы со строчками. Она работает как типичный builder, например, Collect.
*/

use function Stringy\create as s;

s('fòôbàř')->toUpperCase(); // 'FÒÔBÀŘ'

/*
Применение методов к обернутой строке всегда возвращает обернутую строку. Такое поведение добавляет много полезных возможностей.
*/

// Цепочки

s('fòô     bàř')->collapseWhitespace()->swapCase(); // FÒÔ BÀŘ


// Итерацию с помощью foreach

$stringy = s('fòôbàř');
foreach ($stringy as $char) {
  echo $char;
} // fòôbàř


// Функция count

$stringy = s('fòô');
count($stringy);  // 3

/*
Кроме того, объект, возвращаемый функцией s, реализует магический метод toString, а это значит, что не придется заниматься преобразованием типов, как в случае с Collect. Каждый раз, когда объект используется как строка, на его месте оказывается строка.

Всего в библиотеке около 100 функций https://github.com/danielstjules/Stringy.



/**
Реализуйте класс Circle для описания кругов. У круга есть только одно свойство - его радиус. Реализуйте методы getArea и getCircumference, которые возвращают площадь и периметр круга соответственно.
**/
$circle = new Circle(10);

class Circle
{
    private $radius;

    public function __construct($radius)
    {
        $this->radius = $radius;
    }

    public function getArea()
    {
        return pi() * ($this->radius ** 2);
    }

    public function getCircumference()
    {
       return 2 * pi() * $this->radius; 
    }

}


/**
Реализуйте генератор рандомных чисел, представленный классом Random. Интерфейс объекта включает в себя три функции:

Конструктор. Принимает на вход seed, начальное число генератора псевдослучайных чисел
getNext — метод, возврающающий новое случайное число
reset — метод, сбрасывающий генератор на начальное значение
Простейший способ реализовать случайные числа — линейный конгруэнтный метод https://ru.wikipedia.org/wiki/Линейный_конгруэнтный_метод.
**/

$seq = new Random(100);
$result1 = $seq->getNext();
$result2 = $seq->getNext();

$result1 != $result2; // => true

$seq->reset();

$result21 = $seq->getNext();
$result22 = $seq->getNext();

$result1 == $result21; // => true
$result2 == $result22; // => true


class Random
{
    protected $seed;
    protected $init;

    public function __construct($seed)
    {
        $this->seed = $seed;
        $this->init = $seed;
    }

    public function reset()
    {
        $this->seed = $this->init;
    }

    public function getNext()
    {
        $a = 45 + $this->init;
        $c = 21 + $this->init;
        $m = 67 + $this->init;

        $this->seed = ($a * $this->seed + $c) % $m;

        return $this->seed;
    }
}


/**
Реализуйте класс Square для описания квадратов. У квадрата есть только одно свойство — сторона. Реализуйте метод getSide, возвращающий значение стороны.
**/

$square = new Square(10);
$square->getSide(); // 10

/**
Реализуйте класс SquaresGenerator со статическим методом generate, принимающим два параметра: сторону и количество экземпляров квадрата, которые нужно создать. Функция должна вернуть массив из квадратов.
**/

$squares = SquaresGenerator::generate(3, 2); // [new Square(3), new Square(3)];


class Square
{
    private $side;

    public function __construct($side)
    {
        $this->side = $side;
    }

    public function getSide()
    {
        return $this->side;
    }
}


class SquaresGenerator
{
    public static function generate($side, $count = 5)
    {
        $squares = [];
        for ($i = 0; $i < $count; $i++) {
            $squares[] = new Square($side);
        }

        return $squares;
    }
}









/*******************************/

// запись сеттеров в 1 строку:

Class User 
{
    private $name;
    private $age;

    public function __construct(string $name, string $age) 
    {
        $this->name = $name;
        $this->age = $age;
    }

    public function setName(string $name): User
    {
        $this->name = $name;
        return $this;
    }

    public function setAge(string $age): User
    {
        $this->age = $age;
        return $this;
    }   
}

$user = new User('Max', '21');
$user->setName('Jorn')->setAge('25');

interface PersonInterface // указываем только публичные методы
{
    public function get(): string;
    public function set(string $name);
}

interface CityInterface
{
    public function addPerson(Person $person);
    public function getPerson(): array;
}

class Person implements PersonInterface
{
    private $name;

    public function get(): string
    {
        return $this->name;
    }

    public function set(string $value)
    {
        $this->name = $value;
    }
}

class City implements CityInterface
{
    private $persons = [];

    public function addPerson(Person $person)
    {
        $this->persons[] = $person->get(); 
    }

    public function getPerson(): array
    {
        return $this->persons;
    }
}

$person = new Person();
$person->set('Misha');

$person2 = new Person();
$person2->set('Vanya');

$city = new City();
$city->addPerson($person);
$city->addPerson($person2);
$city->getPerson(); // => [0]=> 'Misha', [1]=>'Vanya'


abstract class BaseModel 
{
        public function selectAll(): string
        {
            return 'SELECT * FROM ' . $this->getTableName();
        }

        public function db(string $sql)
        {
            // TODO: db реализацию сделать!
        }

        abstract public function getTableName():string // у потомков реализация данного метода отличается
}

class Article extends BaseModel
{
    public function getTableName(): string
    {
        return 'task';
    }
}

$task = new Atricle();
echo $task->selectAll();

// трейд - механизм, реализующий повторное использование кода. Решает проблему отсутствия множественного наследования.

class Article
{
    public $sql;
    public function executeSql() // реализация методов идентична
    {
        return $this->sql;
    }   
}

class User
{
    public $sql;
    public function executeSql() // реализация методов идентична
    {
        return $this->sql;  
    }
}

// Реализация метода executeSql в классах индентична, а значит можно использовать трейт:

trait BaseModel
{
    public $sql;
    public function executeSql() // реализация методов идентична
    {
        return $this->sql;  
    }

    public function selectAllFromDB()
    {
        $this->sql = 'SELECT * FROM' . $this->getTableName();
    }   

    abstruct public function getTableName(): string;
}

class Article
{
    use BaseModel; // можно перечислить несколько трейтов через ','
    public function getTableName()
    {
        return 'articles';
    }
}

class User 
{
    use BaseModel;
    public function getTableName()
    {
        return 'users';
    }
    
}

$article = new Article();
$article->selectAllFromDB();
echo $article->executeSql(); // => SELECT * FROM articles

$user = new User();
$user->selectAllFromDB();
echo $user->executeSql(); // => SELECT * FROM users


require 'vendor/autoload.php';

class User
{
    public $sql;

    public function addUser(string $login, string $password)
    {
        if(strlen($login) < 3 || strlen($login) > 15) {
            return false;
        }

        if(strlen($password) < 3 || strlen($password) > 6) {
            return false;
        }

        $this->sql = "INSERT INTO users VALUES('', {$login}, {$pasword})";

        return true;
    }
}

$user = new User();
$result = $user->addUser('Misha', '1234');
if ($result === true) {
    echo 'user was added';
} else {
    echo 'fail';
}

// Тоже самое использую Exceptions:

class User
{
    public $sql;

    public function addUser(string $login, string $password)
    {
        if(strlen($login) < 3 || strlen($login) > 15) {
            throw new Exception('Wrong login');
        }
        
        if(strlen($password) < 3 || strlen($password) > 6) {
            hrow new Exception('Wrong password');
        }

        $this->sql = "INSERT INTO users VALUES('', {$login}, {$pasword})";
        
        return true;
    }
}

try {
    $user = new User();
    $result = $user->addUser('Misha', '1234');
    echo 'user was added';  
} catch(Exception $e) {
    die('Fail');
}


// Чтобы каждый раз не писать конструкцию try/catch лучше создать отдельный класс:

class UserLoginException extends Exception
{
    
}

class UserPasswordException extends Exception
{
    
}

class User
{
    public $sql;

    public function addUser(string $login, string $password)
    {
        if(strlen($login) < 3 || strlen($login) > 15) {
            throw new UserLoginException;
        }

        if(strlen($password) < 3 || strlen($password) > 6) {
            throw new UserPasswordException;
        }

        $this->sql = "INSERT INTO users VALUES('', {$login}, {$pasword})";
        
        return true;
    }
}

try {
    $user = new User();
    $result = $user->addUser('Misha', '1234');
    echo 'user was added';  
} catch(UserLoginException $e) {
    die('Wrong login');
} catch(UserPasswordException $e) {
    die('Wrong password');
}


// В этом варианте получается много catch, поэтому:

class UserException extends Exception
{
    
}

class UserLoginException extends UserException
{
    $protected $message = 'wrong login';
}

class UserPasswordException extends UserException
{
    $protected $message = 'wrong password'; 
}

class User
{
    public $sql;

    public function addUser(string $login, string $password)
    {
        if(strlen($login) < 3 || strlen($login) > 15) {
            throw new UserLoginException;
        }

        if(strlen($password) < 3 || strlen($password) > 6) {
            throw new UserPasswordException;
        }

        $this->sql = "INSERT INTO users VALUES('', {$login}, {$pasword})";
        
        return true;
    }
}

try {
    $user = new User();
    $result = $user->addUser('Misha', '1234');
    echo 'user was added';  
} catch(UserException $e) {
    die($e->getMessage());
}

/*******************************/



# http://php.net/manual/ru/language.oop5.phps
get_class($obj); // возращает класс объекта

# 1: 

// file theory/Guest.php

namespace Theory;

final class Guest implements UserInterface // final - предотвратить  переопределение класса в дочерних классах
{
    public function isGuest()
    {
        return true;
    }

    public function getFullName()
    {
        return 'Guest';
    }
 }


// file theory/UserInterface.php

namespace Theory;

interface UserInterface
{
    public function isGuest();
    public function getFullName();  
}


// file theory/UserInterface.php

namespace Theory;

interface MemberInterface
{
    public function __construct($id, $firstName, $lastName);
    public function getId();    
    public function canScanUserList();  
}



// file theory/User.php

namespace Theory;

class User implements UserInterface, MemberInterface
{
    private $id;
    private $firstName;
    protected $lastName;

    public function __construct($id, $firstName, $lastName)
    {
        $this->id = $id;
        $this->firstName = $firstName;
        $this->lastName = $lastName;
    }

    final public function isGuest() // метод переопределить нельзя
    {
        return false;
    }

    final public function getId() // метод переопределить нельзя
    {
        return $this->id;
    }   

    public function getFullName()
    {
        return $this->firstName . " " . $this->lastName;
    }

    public function canScanUserList()
    {
        return false;
    }
}


// file theory/Teacher.php

namespace Theory;

class Teacher extends UserInterface
{
    public function getCourses()
    {
        return [];
    }

    public function getFullName()
    {
        return 'Teacher: ' . parent::getFullName(); // for __construct - parent::__construct()
    }
}


// file theory/HrManager.php

namespace Theory;

class HrManager extends User
{
    public function getCandidates()
    {
        return [];
    }

    public function canScanUserList()
    {
        return true;
    }   

    public function getFullName()
    {
        return "{$this->lastName} {$this->firstName}";
    }   
}


# 2

/*
Абстрактный класс может не содержать абстрактных методов
Абстрактный класс может наследоваться от абстрактного класса

С абстрактными классами в php есть одна интересная особенность. Если этот класс реализует (не полностью) интерфейс, то определения методов из интерфейса становятся абстрактными методами в этом классе.
*/

// file theory/CasheInterface.php

namespace Theory;

interface CasheInterface
{
    public function __construct($options);
    public function get($key);
    public function set($key, $value);
}

// Пример:
// $cashe = new DbCashe($options);
// $cashe->set('user', 3);
// 3 == $cashe->get('user');


// file theory/Cashe.php

namespace Theory;

abstract class Cashe implements CasheInterface
{
    protected $options;

    public function __construct($options)
    {
        $this->options = $options;
        $this->connect();
    }

    abstrat protected function connect();
}

// file theory/DbCashe.php

namespace Theory;

class DbCashe extends Cache
{
    public function get($key)
    {
        return $this->connection->get($key);
    }

    public function set($key, $value)
    {
        return $this->connection->set($key, $value);
    }

    protected function connect()
    {
        // ...
    }
}

# 3
// file theory/index.php
namespace Theory;

require_once 'Enumarable.php';
require_once 'Router.php';

$router = new Router();
$router->addRouter('root', '/');
$router->addRouter('users', '/users');
$router->addRouter('new-user', '/users/new');
$router->addRouter('new-photos', '/users/{id}/photos');
$router->addRouter('new-user-photo', '/users/{id}/photos/new');

echo "Routes count: {$router->count()\n}"; // количество маршрутов
echo "Is `/users a member? : {$router->isMember('/users')\n}"; // => 1
echo "Is `/photos a member? : {$router->isMember('/photos')\n}"; // => 


// file theory/Router.php

namespace Theory;

class Router
{
    use Enumarable; // используем трейт. Можно использовать несколько, перечислив через ','

    private $options;
    private $routes = [];

    public function __construct($options = [])
    {
        $this->options = $options;
    }

    public function addRoute($name, $url)
    {
        $this->routes[$name] = $url;
    }

    public function each($lambda)
    {
        foreach ($this->routes as $value) {
            $lambda($value);
        }
    }
}


// file theory/Router.php

namespace Theory;

trait Enumarable
{
    function count()
    {
        $count = 0;
        $this->each(function ($element) use (&$count) {
            $count++;
        });
        
        return $count;
    }
    
    function isMember($obj)
    {
        $isMember = false;
        $this->each(function ($element) use ($objm &$isMember)) {
            if ($element == $obj) {
                $isMember = true;
            }
        };
        
        return $isMember;
    }
}

#4

/*
Полезно использовать статические свойства и методы:
Когда у класса есть метаинформация используемая его объектами
Если создание объектов комплексная операция (нужно произвести какие-то вычисления)
*/

function Parser
{
    public static $formats = ['xml', 'html', 'json'];
    
    public static function factory($options)
    {
        $parser = new self($args);
        return $parser;
    }
    
    public static function getStaticValue()
    {
        return self::$formats;
    }
    
    public function callStaticFunction()
    {
        return self::getStaticValueFromStatic();
    }
}

print_r(Parser::$formats);
print_r(Parser::getStaticValueFromStatic());

$parser = new Parset();
print_r($parser->getStaticValue());
print_r($parser->callStaticFunction());


#5

function foo($arg)
{
    if (is_string($arg)) {
        return -1;      
    }
    return;
}

function bar($arg)
{
    if (-1 == foo($arg)) {
        return -1;
    }
    return;
}

echo bar('foo'); // => -1


namespace Theory;

function myReadFile($filepath)
{
    if (!file_exists($filepath)) {
        throw new \Exception("file '{$filepath}' doesn`t exist");
    }
}

function readFolder($folderPath)
{
    //NOTE: write logic here
    return [myReadFile($folderPath)];
}

function tryReadFile()
{
    try {
        $bodies = readFolder("path/to/Folder");
        return $bodies;
    } catch (\Exception $e) { // наи
        echo $e->getMessage();
        return [];
    }
}

$result = tryReadFile();
print_r($result);



namespace Thery;

$handle = fopen($filepath, "r");

try {
    $data = fread($handle, filesize($filepath));
} finally { // Выполняется в любом случае, независимо от того было исключение или нет. Отсюда можно бросать исключение
    fclose($handle);
}


# 6 Динамическое создание свойств
namespace Theory;

class DynamicProps
{
    private $data = [];

    public $declared = 1;
    private $hidden = 2;

    public function __set($name, $value)
    {
        $this->data[$name] = $value;
    }

    public function __get($name)
    {
        return $this->data[$name];
    }

    public function getHidden()
    {
        return $this->hidden;
    }

    public function __isset(); // проверяет существование свойства
    public function __unset(); // удаляет свойтсво
}

$obj = new DynamicProps();
$obj->customKey = 'value2';
echo $obj->customKey;
isset($obj->customKey); // если реализован магический метод __isset
unset($obj->customKey); // если реализован магический метод __unset



/**
Реализуйте функцию compare, которая сравнивает переданных пользователей на основе их идентификаторов. При этом функция должна убедиться, что переданные объекты - пользователи.
**/

use function App\UserFunctions\compare;

$user1 = new User();
$user1->id = 1;

$user2 = new User();
$user2->id = 1;

compare($user1, $user2); // => true

$cat = new Cat();
$user2->id = 1;

compare($user1, $cat); // => false


function compare(User $user1, User $user2)
{
    return $user1->id === $user2->id;
}

/**
Реализуйте функцию toStd, которая принимает на вход ассоциативнвый массив и ввозвращает объект типа stdClass такой же структуры. Выполните задачу проставляя ключи и значения вручную без использования преобразования типа.
**/

$data = [
    'key' => 'value',
    'key2' => 'value2',
];
$config = toStd($data);

$config->key; // value
$config->key2; // value2


function toStd($data)
{
    $std = new \stdClass();
    foreach ($data as $key => $value) {
        $std->$key = $value;
    }

    return $std;
}


# 7 Переопределение методов 

namespace Theory;
/*
Вызовы через __call работают медленнее обычных вызовов
Код с использованием __call сложнее в отладке (реального метода не существует)
__call($name, $args);
preg_match("/findBy(.*)/", $finder, $outputArray);
*/
$repository = new repository('users');
$repository ->findByEmail('admin@exapmple.com');
$repository->findByEmail('John');
$repository->findByNameAndAge('John', 18);

#8

namespace Theory;

class Base
{
    public static function who()
    {
        echo __CLASS__ . "\n";
    }

    public static function test()
    {
        self::who(); // привязывает к текущему классу
        static::who(); // позднее статическое связывание
    }
}

class Child extends Base
{
    // public static function who()
    // {
    //  echo __CLASS__ . "\n";
    // }    
}

echo Child::who(); // Theory\Base - 2 раза;
echo Child::who(); /* => если раскоменторовать => 
Theory\Base 
Theory\Child 
*/


#9

/*
http://php.net/manual/ru/function.spl-autoload.php
http://php.net/manual/ru/language.oop5.autoload.php
*/

namespace Theory;


__autoload(); // DEPRECATED!

// #1
spl_autoload_extensions(".php");
spl_autoload_register(); // если namespace соответствует папке

// #2
spl_autoload_register(function($class) {
    $path = dirname(__FILE__) . "/" .strtolower(str_replace("\\", "/", $class));
    spl_autoload($path); // загрузка класса
});



$app = new \ns\Application();
var_dump($app);


<?

#1
/*
Реализуйте функцию buildRange, которая переводит входные данные в удобный для построения графика формат.

На вход эта функция принимает массив данных. Каждая запись массива представляет из себя объект типа [ 'value' => 14, 'date' => '02.08.2018' ]. Например:
*/
$data = [
  [ 'value' => 14, 'date' => '02.08.2018' ],
  [ 'value' => 43, 'date' => '03.08.2018' ],
  [ 'value' => 38, 'date' => '05.08.2018' ],
];

/*
Вторым и третьим параметрами функция принимает даты (в форме строк типа 'YYYY-MM-DD') начала и конца периода:

$begin = '2018-08-01';
$end = '2018-08-06';
Диапазон дат задаёт размер выходного массива, который должна сгенерить реализуемая функция. Правила формирования итогового массива:

он заполняется записями по всем дням из диапазона begin - end
в него включаются только те записи из входного массива, даты которых попадают в диапазон
если во входном массиве нет данных для какого-то дня из диапазона, то в свойство value записи этого дня установить значение 0
<?php

$result = buildRange(data, beginDate, endDate);

// OUTPUT
// [ [ 'value' => 0, 'date' => '01.08.2018' ],
//   [ 'value' => 14, 'date' => '02.08.2018' ],
//   [ 'value' => 43, date => '03.08.2018' ],
//   [ 'value' => 0, 'date' => '04.08.2018' ],
//   [ 'value' => 38, 'date' => '05.08.2018' ],
//   [ 'value' => 0, 'date' => '06.08.2018' ] ]

Подсказки
Функции из библиотеки Collect, которые могут пригодиться: keyBy.
Функции из библиотеки Carbon, которые могут пригодиться: \Carbon\CarbonPeriod::create.
*/

namespace App\Dates;

// BEGIN (write your solution here)

// END



namespace App\Tests;

use function App\Dates\buildRange;
use PHPUnit\Framework\TestCase;

class DatesTest extends TestCase
{
    public function testGetRange()
    {
        $dates = [
          [ 'value' => 14, 'date' => '02.08.2018' ],
          [ 'value' => 43, 'date' => '03.08.2018' ],
          [ 'value' => 38, 'date' => '05.08.2018' ],
        ];
        $beginDate = '2018-08-01';
        $endDate = '2018-08-10';
        $expected = [
          [ 'value' => 0, 'date' => '01.08.2018' ],
          [ 'value' => 14, 'date' => '02.08.2018' ],
          [ 'value' => 43, 'date' => '03.08.2018' ],
          [ 'value' => 0, 'date' => '04.08.2018' ],
          [ 'value' => 38, 'date' => '05.08.2018' ],
          [ 'value' => 0, 'date' => '06.08.2018' ],
          [ 'value' => 0, 'date' => '07.08.2018' ],
          [ 'value' => 0, 'date' => '08.08.2018' ],
          [ 'value' => 0, 'date' => '09.08.2018' ],
          [ 'value' => 0, 'date' => '10.08.2018' ],
        ];

        $actual = buildRange($dates, $beginDate, $endDate);
        $this->assertEquals($expected, $actual);
    }
}


#2

/*
В этой задаче необходимо реализовать ленивую коллекцию https://ru.wikipedia.org/wiki/Отложенная_инициализация

src\Enumerable.php
Реализуйте класс Enumerable, который работает похожим образом, что и Collect, но предназначен для обработки коллекций ассоциативных массивов. Основная особенность работы данного класса заключается в том, что он использует lazy вариант обработки.
*/

$elements = [
    ['key' => 'value', 'year' => 1932],
    ['key' => '', 'year' => 1100],
    ['key' => 'value', 'year' => 32]
];

$coll = Enumerable::wrap($elements);
$newColl = $coll->where('key', 'value')->where('year', 1932);
$newCall->all(); // ['key' => 'value', 'year' => 1932]

/*
Подсказки
Функции, которые нужно реализовать, описаны в интерфейсе EnumerableInterface
Усложнённый вариант: добавьте мемоизацию https://ru.wikipedia.org/wiki/Мемоизация
*/

// file: app/src/EnumerableInterface.php 

namespace App;

interface EnumerableInterface
{
    public static function wrap($elements);
    public function where($key, $value);
    public function all();
}


// file: app/src/Enumerable.php

namespace App;

// BEGIN (write your solution here)

// END



// file: app/tests/EnumerableTest.php

namespace App\Tests;

use App\Enumerable;
use PHPUnit\Framework\TestCase;

class EnumerableTest extends TestCase
{
    public function testWhere()
    {
        $coll = Enumerable::wrap([]);
        $this->assertEquals([], $coll->all());

        $elements = [
            ['key' => 'value'],
            ['key' => '']
        ];
        $coll = Enumerable::wrap($elements);
        $result = $coll->where('key', 'value');
        $expected = [
            ['key' => 'value']
        ];
        $this->assertEquals($expected, $result->all());
        $this->assertEquals($elements, $coll->all());
    }
}


#3

/*
Пьяница — карточная игра, в которой побеждает тот игрок, который собирает все карты. В нашей задаче используется модификация игры с двумя игроками. Игрокам раздаётся равное количество карт. Игроки не смотрят в свои карты, а кладут их в стопку рядом с собой. Затем каждый игрок снимает верхнюю карту и показывает её сопернику. Тот игрок, чья карта оказалась большего номинала, берёт обе карты и кладёт их к себе в колоду снизу (так что своя карта идёт первой). Если карты имеют одинаковый номинал, то они выкидываются из игры. В игре возможны три исхода:

У обоих игроков не осталось карт
Игра не может закончиться
Победил один из игроков
src\Drunkard.php
Реализуйте класс Drunkard с функцией run, которая принимает на вход два списка чисел, которые представляют собой карты для первого и второго игроков.

Если выиграл первый игрок, то метод должен вернуть First player. Round: <номер раунда>.
Если выиграл второй игрок, то метод должен вернуть Second player. Round: <номер раунда>.
Если у игроков не осталось карт, то метод должен вернуть Botva!
Если за 100 раундов не удалось выявить победителя то также возвращается Botva!
Реальные примеры смотрите в тестах.

Подсказки
Воспользуйтесь классом \Ds\Deque для работы с колодами
*/

// file: app/src/Drunkard.php 

namespace App;

use Ds\Deque;

// BEGIN (write your solution here)

// END


// file: app/tests/DrunkardTest.php

namespace App\Tests;

use App\Drunkard;
use PHPUnit\Framework\TestCase;

class DrunkardTest extends TestCase
{
    public function testRun()
    {
        $game = new Drunkard();
        $result = $game->run([1], [2]);
        $this->assertEquals('Second player. Round: 1', $result);

        $result = $game->run([2], [1]);
        $this->assertEquals('First player. Round: 1', $result);

        $result = $game->run([1], [1]);
        $this->assertEquals('Botva!', $result);

        $result = $game->run([1, 2], [3, 2]);
        $this->assertEquals('Second player. Round: 2', $result);

        $result = $game->run([1, 3], [2, 1]);
        $this->assertEquals('First player. Round: 4', $result);
    }
}


#4

/*
Реализуйте функцию getQuestions, которая принимает на вход текст (полученный из редактора) и возвращает список вопросов извлеченных из этого текста разделенных переводом строки.

Входящий текст разбит на строки и может содержать любые пробельные символы. Некоторые из этих строк являются вопросами. Они определяются по последнему символу, который должен равняться знаку ?.
*/

$text = <<<HEREDOC
lala\r\nr
ehu?
\n \t
i see you
/r \n
one two?\r\n\n
HEREDOC;

getQuestions($text);
// ehu?
// one two?


// file: app/src/Normalizer.php

namespace App\Normalizer;

use function Stringy\create as s;

// BEGIN (write your solution here)

// END

// file: app/tests/NormalizerTest.php 

namespace App\Tests;

use function App\Normalizer\getQuestions;
use PHPUnit\Framework\TestCase;

class NormalizerTest extends TestCase
{
    public function testGetQuestions()
    {
        $text1 = <<<HEREDOC
lala\r\nr
ehu?
\n \t
i see you
/r \n
one two?\r\n\n
HEREDOC;
        $actual1 = getQuestions($text1);

        $expected1 = "ehu?\none two?";
        $this->assertEquals($expected1, $actual1);
    }
}

    
#5

/*
Booking — процесс бронирования чего-либо. В интернете существует множество сайтов, предлагающих бронирование машин, квартир, домов, самолётов и многого другого. Несмотря на то, что такие сайты предлагают разные услуги, букинг везде работает почти идентично. Выбираются нужные даты и, если они свободны, производится бронирование.

src\Booking.php
Реализуйте класс Booking, который позволяет бронировать номер отеля на определённые даты. Единственный интерфейс класса — функция book, которая принимает на вход две даты в текстовом формате. Если бронирование возможно, то метод возвращает true и выполняет бронирование (даты записываются во внутреннее состояние объекта).

Подсказки
По обычаям гостиничного сервиса время заселения в номер — после полудня первого дня, а время выселения — до полудня последнего дня. Конкретные часы варьируются в разных отелях. Но в данной практике это не важно, главное понять принцип, по которому указываются даты:
*/

$booking = new Booking();

// забронировать номер на два дня
$booking->book('10-11-2008', '12-11-2008');

// бронь невозможна, 11-го числа номер будет занят
$booking->book('11-11-2008', '15-11-2008');

// бронь возможна, потому что 12-го числа номер освободится
$booking->book('12-11-2008', '13-11-2008');

// бронь невозможна, съём, сроком менее одного дня, обычно не практикуется
$booking->book('17-11-2008', '17-11-2008');

// бронь возможна, съём номера на один день
$booking->book('17-11-2008', '18-11-2008');

$booking = new Booking();
$booking->book('11-11-2008', '13-11-2008'); // true
$booking->book('12-11-2008', '12-11-2008'); // false
$booking->book('10-11-2008', '12-11-2008'); // false
$booking->book('12-11-2008', '14-11-2008'); // false
$booking->book('10-11-2008', '11-11-2008'); // true
$booking->book('13-11-2008', '14-11-2008'); // true


// file: app/src/Booking.php

namespace App;

use Carbon\Carbon;

// BEGIN (write your solution here)

// END


// file: app/tests/BookingTest.php

namespace App\Tests;

use PHPUnit\Framework\TestCase;
use App\Booking;

class BookingTest extends TestCase
{
    public function testBook()
    {
        $booking = new Booking();
        $result1 = $booking->book('11-11-2008', '13-11-2008');
        $this->assertTrue($result1);

        $result2 = $booking->book('12-11-2008', '12-11-2008');
        $this->assertFalse($result2);

        $result3 = $booking->book('10-11-2008', '12-11-2008');
        $this->assertFalse($result3);

        $result4 = $booking->book('12-11-2008', '14-11-2008');
        $this->assertFalse($result4);

        $result5 = $booking->book('10-11-2008', '11-11-2008');
        $this->assertTrue($result5);

        $result6 = $booking->book('13-11-2008', '13-11-2008');
        $this->assertFalse($result6);

        $result7 = $booking->book('13-11-2008', '14-11-2008');
        $this->assertTrue($result7);
    }
}

#6

/*
Дисклеймер - эту задачу можно решить огромным числом способов. Почти наверняка ваш способ будет не такой как решение учителя.

Для отработки fluent interface в задаче используется библиотека Collect. Мы не даем никаких подсказок насчет того, какие функции нужно использовать. Как минимум вы знаете главную тройку map, filter и reduce. Их вполне достаточно, но можно и лучше если внимательно поизучать функции в документации Collect.

src\Normalizer.php
Реализуйте функцию normalize которая принимает на вход список городов, производит внутри некоторые преобразования и возвращает структуру определенного формата.

Входные данные
*/

$raw = [
    [
        'name' => 'istambul',
        'country' => 'turkey'
    ],
    [
        'name' => 'Moscow ',
        'country' => ' Russia'
    ],
    [
        'name' => 'iStambul',
        'country' => 'tUrkey'
    ],
    [
        'name' => 'antalia',
        'country' => 'turkeY '
    ],
    [
        'name' => 'samarA',
        'country' => '  ruSsiA'
    ],
];
/*
Входная структура представляет из себя список городов, где каждый город это ассоциативный массив с ключами name и country. Значения в этих ключах не нормализованы. Они могут быть в любом регистре и содержать начальные и концевые пробелы. Сами города могут дублироваться в рамках одной страны.

Результат
*/

$actual = normalize($raw);
// $expected = [
//     'russia' => [
//         'moscow', 'samara'
//     ],
//     'turkey' => [
//         'antalia', 'istambul'
//     ]
// ];

/*
Конечная структура - ассоциативный массив, в котором ключ это страна, а значение - список имен городов отсортированный по именам. Сама структура отсортирована по городам. Дублей городов в выходной структуре быть не должно, а сами страны и города должны быть записаны в нижнем регистре без ведущих и концевых пробелов.
*/

// file: app/src/Normalizer.php

namespace App\Normalizer;

// BEGIN (write your solution here)

// END


// file: app/tests/NormalizerTest.php

namespace App\Tests;

use function App\Normalizer\normalize;
use PHPUnit\Framework\TestCase;

class NormalizeTest extends TestCase
{
    public function testNormalize()
    {
        $raw = [
            [
                'name' => 'istambul',
                'country' => 'turkey'
            ],
            [
                'name' => 'Moscow ',
                'country' => ' Russia'
            ],
            [
                'name' => 'iStambul',
                'country' => 'tUrkey'
            ],
            [
                'name' => 'antalia',
                'country' => 'turkeY '
            ],
            [
                'name' => 'samarA',
                'country' => '  ruSsiA'
            ],
        ];

        $actual = normalize($raw);
        $expected = [
            'russia' => [
                'moscow', 'samara'
            ],
            'turkey' => [
                'antalia', 'istambul'
            ]
        ];
        $this->assertEquals($expected, $actual);
    }

    public function testNormalize2()
    {
        $raw = [
            [
                'name' => 'pariS ',
                'country' => ' france'
            ],
            [
                'name' => ' madrid',
                'country' => ' sPain'
            ],
            [
                'name' => 'valencia',
                'country' => 'spain'
            ],
            [
                'name' => 'marcel',
                'country' => 'france'
            ],
            [
                'name' => ' madrid',
                'country' => ' sPain'
            ],
        ];

        $actual = normalize($raw);
        $expected = [
            'france' => [
                'marcel', 'paris'
            ],
            'spain' => [
                'madrid', 'valencia'
            ]
        ];
        $this->assertEquals($expected, $actual);
    }
}

#7

/*
Реализуйте класс DeckOfCards, который описывает колоду карт и умеет её мешать.

Конструктор класса принимает на вход массив, в котором перечислены номиналы карт в единственном экземпляре, например, [6, 7, 8, 9, 10, 'king'].

Реализуйте публичный метод getShuffled, с помощью которого можно получить полную колоду в виде отсортированного случайным образом массива.

Примечания
В "полной" колоде каждая карта встречается 4 раза — для простоты не учитываем масть.
Примеры
*/

$deck = new DeckOfCards([2, 3]);
$deck->getShuffled(); // [2, 3, 3, 3, 2, 3, 2, 2]
$deck->getShuffled(); // [3, 3, 2, 2, 2, 3, 3, 2]

/*
Подсказки
Используйте функцию collect для оборачивания массивов
Документация по доступным функциям https://laravel.com/docs/5.6/collections
*/

// file: app/src/DeckOfCards.php

namespace App;

// BEGIN (write your solution here)

// END



// file: app/tests/DeckOfCardsTest.php 

namespace App\Tests;

use App\DeckOfCards;
use PHPUnit\Framework\TestCase;

class DeckOfCardsTest extends TestCase
{
    public function testGetShuffled1()
    {
        $expected = [2, 2, 2, 2, 3, 3, 3, 3];
        $deck = new DeckOfCards([2, 3]);
        $result1 = $deck->getShuffled();
        $result2 = $deck->getShuffled();
        $this->assertNotEquals($result1, $result2);

        sort($result1);
        $this->assertEquals($expected, $result1);

        sort($result2);
        $this->assertEquals($expected, $result2);
    }

    public function testGetShuffled2()
    {
        $expected = [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9];
        $deck = new DeckOfCards([8, 9, 7]);
        $result1 = $deck->getShuffled();
        $result2 = $deck->getShuffled();
        $this->assertNotEquals($result1, $result2);

        sort($result1);
        $this->assertEquals($expected, $result1);

        sort($result2);
        $this->assertEquals($expected, $result2);
    }
}