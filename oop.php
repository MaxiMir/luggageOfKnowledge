<?
############### ООП ###############

/*
Описание объектов рассматриваемой области и связей между ними называется онтологией предметной области. Эту онтологию хорошо знают эксперты соответствующей области (в бухгалтерии — бухгалтер, в обучении — преподаватель), но в отличие от программистов, они часто представляют ее на интуитивном уровне, неформально. На практике, программисты (или бизнес-аналитики и менеджеры) общаются с заказчиками, которые могут сами выступать в роли экспертов и строят вместе с ними формальную онтологию (этот процесс происходит постоянно в процессе развития проекта и не выделяется в отдельный этап проектирования). То есть выделяют конкретные термины, договариваются о том что они означают и как связаны друг с другом. Затем, используя ER-модель (https://ru.wikipedia.org/wiki/ER-модель), программист формирует необходимую модель данных. ER-модель — используется при высокоуровневом (концептуальном) проектировании баз данных. На этом этапе уже проявляются зачатки архитектуры будущего приложения.

Кстати, далеко не всегда можно однозначно сказать какая связь существует между двумя сущностями. Иногда программисты думают наперед и сразу формируют более сложные связи, например m2m, а не o2m, что сказывается на сложности кода. Чем сложнее связь, тем больше кода и выше стоимость ее создания и поддержки. Сложность связей можно описать так (правее — сложнее): o2o, o2m, m2m. Иногда программисты ошибаются при выборе той или иной связи, что обычно говорит о недостаточно хорошем понимании предметной области. Приведу интересный пример. Предположим, что в системе нужно реализовать пользователя и заграничный паспорт. Интуитивно кажется, что между этими понятиями связь один к одному, ведь один пользователь может иметь один заграничный паспорт. Так? Не совсем, паспорт может поменяться, если он был утерян или закончился срок действия. К тому же, в некоторых странах (в России недавно приняли такой закон) разрешено владение одновременно несколькими заграничными паспортами.

С другой стороны, реальный мир всегда сложнее и полнее чем любая модель и задача программиста состоит не в том, чтобы создать универсальную и всеобъемлющую модель некоторой области, а в том, чтобы понять потребности конкретного бизнеса, выделить для них только значимые части рассматриваемой предметной области и перенести ее в код.

В зависимости от языка меняется способ представления сущностей в коде. В некоторых определяются типы (используя АТД, интерфейсы или классы), в других структуры. Третьи вообще не предоставляют никаких вариантов, кроме словарей (ассоциативных массивов). То самое понятие ООП имеет непосредственное отношение к рассматриваемой теме. 

Проблемно-ориентированное проектирование - https://ru.wikipedia.org/wiki/

Ментальное программирование:
https://www.youtube.com/watch?v=EEq1wdM2M2w
https://www.youtube.com/watch?v=Hk_uSvADUIo
Simple Made Easy:
https://www.infoq.com/presentations/Simple-Made-Easy


data hiding - Скрытие структуры данных за счет взаимодействия с ней только посредством функций

Интерфейсом называют набор функций (имена и их сигнатуры, то есть количество и типы входящих параметров, а также возвращаемое значение), не зависящих от конкретной реализации. Такое определение один в один совпадает с понятием абстрактного типа данных. Например, для точек интерфейсными являются все функции, которые мы реализовывали в практике, и которые описывались в теории. Но функции бывают не только интерфейсные, но и вспомогательные, которые не предназначены для вызывающего кода и используются исключительно внутри абстракции.
*/

function makeUser($name, $birthday)
{
    return [
        'name' => $name,
        'birthday' => $birthday
    ];
}

function getAge($user)
{
    return calculateAge($user['birthday']);
}

function isAdult($user)
{
    return getAge($user) >= 18;
}

// Внутренняя функция не являющаяся частью интерфейса абстракции User
function calculateAge($birthday)
{
    $secondsInYear = 31556926;
    return floor((time() - strtotime($birthday)) / $secondsInYear);
}

// PHP существует конструкция имеющая имя Interface. Она используется для явного описания интерфейсов, а также выполняет ряд дополнительных функций.



// Рациональные числа в PHP не поддерживаются, поэтому построить абстракцию для них придется самостоятельно. Как обычно, нам понадобятся конструктор и селекторы:

$num = makeRational(1, 2); // одна вторая
$numer = getNumer($num); // => 1
$denom = getDenom($num); // => 2


function makeRational($numer, $denom)
{
    return "{$numer}/{$denom}";
}

function getNumer($rational)
{
    return explode('/', $rational)[0];
}

function getDenom($rational)
{
    return explode('/', $rational)[1];
}

print_r(makeRational(10, 3)); // => 10/3

function mul($rational1, $rational2)
{
    return makeRational(
        getNumer($rational1) * getNumer($rational2),
        getDenom($rational1) * getDenom($rational2)
    );
}

// Абстракция, благодаря data hiding, позволяет нам не думать о деталях реализации и сосредоточиться на ее использовании. Более того, при необходимости реализацию абстракции можно всегда переписать, не боясь сломать использующий ее код (почти). Но есть еще одна важная причина, по которой нужно использовать абстракцию — соблюдение инвариантов.

# Инвариант в программировании — логическое выражение, определяющее непротиворечивость состояния (набора данных).

