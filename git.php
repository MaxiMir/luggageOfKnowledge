Публикация пакета
До того как мы непосредственно приступим к написанию самих игр, нам нужно подготовить composer-пакет и научиться его публиковать.

На этом этапе наш пакет будет представлять из себя программу, которая после установки становится доступной по имени brain-games и при вызове выводит на экран приветствие.

Инициализация пакета
Ссылки
https://habrahabr.ru/post/105495/
https://www.sao.ru/hq/sts/linux/doc/lnag/3.html#run_program
https://goo.gl/p7IdS8
https://habrahabr.ru/post/145946/

Задачи
Зарегистрируйтесь на сайте https://packagist.org/, это необходимо для возможности публиковать собственные пакеты
Подготовьте операционную систему в соответствии с нашими рекомендациями
Установите php последней версии и composer, так чтобы он был доступен глобально по команде composer (см. здесь)
Инициализируйте ваш php-пакет внутри папки с проектом, используя команду composer init.
Создайте в папке bin исполняемый файл (говорят бинарник) brain-games.
Сделайте так, чтобы запуск bin/brain-games выводил на экран строку:
  $ bin/brain-games
  Welcome to the Brain Games!


Такой вариант запуска будет работать только в том случае, если файл brain-games является исполняемым, а также в начале файла прописан шебанг с правильно указанным интерпретатором php. Подробнее об этих аспектах нужно прочитать по ссылкам выше.


Публикация в packagist
Код, лежащий на гитхабе, это уже хорошо, но еще недостаточно для того, чтобы другие могли им воспользоваться. Одной из функций composer является публикация пакетов (и обновление) в packagist https://packagist.org/. Это большой каталог php пакетов. Каждый раз, когда вы набираете composer require <vendor>/<package>, то идет установка именно из этого каталога.

В этой части вашей задачей будет подготовка пакета к публикации и, собственно, сама публикация в общем каталоге.  

Ссылки
Packagist ( https://packagist.org/about)- как публиковать пакеты (и интегрироваться с гитхабом)
Полностью настроенный php пакет (https://github.com/hexlet-boilerplates/php-package)- пример, в котором есть все от и до. В любой непонятной ситуации сравнивайте свое решение с тем, что сделано в этом шаблоне.
Семантическое версионирование (http://semver.org/lang/ru/)
Как работать с bin в Composer (https://getcomposer.org/doc/articles/vendor-binaries.md)


Задачи
Добавьте созданный bin (brain-games) в composer.json:
  "bin": [
    "bin/brain-games"
  ]
Загрузите свой пакет на packagist по ссылке https://packagist.org/packages/submit
Приложите к шагу аскинему с записанной установкой пакета (глобально) и вызова brain-games как обычной программы
Подсказки
Обратите внимание на то как делается автозагрузка в эталонном пакете в бине.
*/
 


<?php
############### GIT ######################

gitk // дефолтный UI редакторd

git config --global user.name "Max"
git config --global user.email mmirrev@example.com


# Создание нового репозитория

$ mkdir Desktop/git_exercise/
$ cd Desktop/git_exercise/
$ git init	


# Определение состояния

$ git status // =>

/*
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt

Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать.
*/


# Подготовка файлов

$ git add hello.txt // добавить файл на коммит кандидат - начать индексировать файл. Здесь это hello.txt

$ git add * // добавить все Untracked файлы на индексацию
$ git add . // добавить все Untracked файлы из текущей директории на индексацию


$ git status // =>

/*
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt

Файл готов к коммиту.
*/

git add index.php // файл index.txt (индексировался) был переименован в index.php, а значит добавляем его на индексацию



# Коммит (фиксация изменений)

$ git commit -m "Initial commit." // Эта команда создаст новый коммит со всеми изменениями из области подготовки (добавление файла hello.txt). Ключ -m и сообщение «Initial commit.» — это созданное пользователем описание всех изменений, включенных в коммит. 






### Удаленные репозитории

# Подключение к удаленному репозиторию

git remote add origin https://github.com/MaxiMir/luggageOfKnowledge.git // связать наш локальный репозиторий с репозиторием на GitHub


# Отправка изменений на сервер

/* Пересылаем наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого — push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
*/

$ git push origin master // =>

/*
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
*/


# Клонирование репозитория

// Сейчас другие пользователи GitHub могут просматривать ваш репозиторий. Они могут скачать из него данные и получить полностью работоспособную копию вашего проекта при помощи команды clone.

$ git clone https://github.com/tutorialzine/awesome-project.git


# Запрос изменений с сервера

// Если вы сделали изменения в вашем репозитории, другие пользователи могут скачать изменения при помощи команды pull.

$ git pull origin master // =>

/*
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.

Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.
*/



## Ветвление

# Создание новой ветки

$ git branch amazing_new_feature // Это создаст новую ветку, пока что точную копию ветки master.


# Переключение между ветками

$ git branch
amazing_new_feature
* master

// master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.

$ git checkout amazing_new_feature


# Слияние веток

// Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:

$ git add feature.txt
$ git commit -m "New feature complete."

// Изменения завершены, теперь мы можем переключиться обратно на ветку master.

$ git checkout master

$ git merge amazing_new_feature // теперь ветка master актуальна. Ветка amazing_new_feature больше не нужна, и ее можно удалить:

$ git branch -d awesome_new_feature


## Отслеживание изменений, сделанных в коммитах

$ git log // список всех коммитов и их идентификаторов =>

/*
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date: Mon May 30 17:15:28 2016 +0300
New feature complete

commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt

commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date: Sat May 28 17:52:14 2016 +0300
Initial commit
*/

$ git show b10cc123 // посмотреть, что нового появилось в коммите =>

/*
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
*/

$ git diff 09bd8cc..ba25c0ff // разница между двумя коммитами =>

/*
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
*/

git difftool // запускает графический клиент, в котором наглядно сопоставляет все изменения в коммитах.


## Возвращение файла к предыдущему состоянию

$ git checkout 09bd8cc1 hello.txt


## Исправление коммита

/*
Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу HEAD:
*/
$ git revert HEAD

// Для остальных будем использовать идентификаторы:

$ git revert b10cc123

// При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.


## Разрешение конфликтов при слиянии

/*
Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:
*/

for(var i=0; i<arr.length; i++) {
console.log(arr[i]);


// Тим предпочитает forEach:

arr.forEach(function(item) {
console.log(item);
});

// Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

$ git merge tim_branch
/*
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
*/

// Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:

<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.

// Над разделителем ======= мы видим последний (HEAD) коммит, а под ним — конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());

// Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

$ git add -A
$ git commit -m "Array printing conflict resolved."

// Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).

## Настройка .gitignore

/*
Вот хорошие примеры файлов, которые нужно игнорировать:

Логи
Артефакты систем сборки
Папки node_modules в проектах node.js
Папки, созданные IDE, например, Netbeans или IntelliJ
Разнообразные заметки разработчика.

Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
*/

*.log
build/
node_modules/
.idea/
my_notes.txt

// Cимвол слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.