<?

############### GIT ######################

gitk // дефолтный UI редактор

git config --global user.name "Max"
git config --global user.email mmirrev@mail.ru


>>>>> Создание нового репозитория <<<<<

$ mkdir Desktop/git_exercise/
$ cd Desktop/git_exercise/
$ git init	


>>>>> Определение состояния <<<<<

$ git status // =>

/*
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt

Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать.
*/


>>>>> Подготовка файлов <<<<<

$ git add * // добавить все Untracked файлы на индексацию
$ git add . // добавить все Untracked файлы из текущей директории на индексацию
$ git add hello.txt // добавить файл на коммит кандидат - начать индексировать файл. Здесь это hello.txt

$ git status // =>

/*
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt

Файл готов к коммиту
*/

git add index.php // файл index.txt (индексировался) был переименован в index.php, а значит добавляем его на индексацию


>>>>> Коммит (фиксация изменений) <<<<<

$ git commit -m "Initial commit." // Эта команда создаст новый коммит со всеми изменениями из области подготовки (добавление файла). Ключ -m и сообщение «Initial commit.» — это созданное пользователем описание всех изменений, включенных в коммит. 



###### Удаленные репозитории ######

>>>>> Подключение к удаленному репозиторию <<<<<

git remote add origin https://github.com/MaxiMir/luggageOfKnowledge.git // связать наш локальный репозиторий с репозиторием на GitHub
git remote add origin git@github.com:MaxiMir/luggageOfKnowledge.git // через SSH


>>>>> Отправка изменений на сервер <<<<<

/* Пересылаем наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого — push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
*/

$ git push origin master // =>

/*
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
*/


>>>>> Клонирование репозитория <<<<<

// Сейчас другие пользователи GitHub могут просматривать ваш репозиторий. Они могут скачать из него данные и получить полностью работоспособную копию вашего проекта при помощи команды clone.

$ git clone https://github.com/tutorialzine/awesome-project.git


>>>>> Запрос изменений с сервера <<<<<

// Если вы сделали изменения в вашем репозитории, другие пользователи могут скачать изменения при помощи команды pull.

$ git pull origin master // =>

/*
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.

Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.
*/

$ git pull --rebase origin master // вытягивает все с удаленного репозитория и поверх изменений на удаленном репозитории наложит локальные изменения 


$ git stash // положить в `корзину` локальные изменения
$ git pull --rebase origin master
$ git stash pop // достать из `корзины` и применить последний добавленный stash. После чего он удаляется из корзины. 
$ git shash list // просмотр `корзины` 
$ git shash show // просмотр последнего изменения из `корзины`
$ git shash apply // применить последнее изменение из `корзины`
$ git shash drop // удалить последнее изменение из `корзины`



###### Ветвление ######

>>>>> Создание новой ветки <<<<<

$ git branch amazing_new_feature // Это создаст новую ветку, пока что точную копию ветки master.


>>>>> Переключение между ветками <<<<<

$ git branch 
amazing_new_feature
* master

// master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.

$ git checkout amazing_new_feature


>>>>> Слияние веток <<<<<

// Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:

$ git add feature.txt
$ git commit -m "New feature complete."

// Изменения завершены, теперь мы можем переключиться обратно на ветку master.

$ git checkout master

$ git merge amazing_new_feature // теперь ветка master актуальна. Ветка amazing_new_feature больше не нужна, и ее можно удалить:

$ git branch -D awesome_new_feature



###### Отслеживание изменений, сделанных в коммитах ######

$ git log // список всех коммитов и их идентификаторов =>

/*
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date: Mon May 30 17:15:28 2016 +0300
New feature complete

commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt

commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date: Sat May 28 17:52:14 2016 +0300
Initial commit
*/

$ git show b10cc123 // посмотреть, что нового появилось в коммите =>

/*
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
*/

$ git diff 09bd8cc..ba25c0ff // разница между двумя коммитами =>

/*
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
*/

git difftool // запускает графический клиент, в котором наглядно сопоставляет все изменения в коммитах.



###### Возвращение файла к предыдущему состоянию ######

$ git checkout 09bd8cc1 hello.txt


###### Исправление коммита ######

/*
Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу HEAD:
*/

$ git revert HEAD

// Для остальных будем использовать идентификаторы:

$ git revert b10cc123

// При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.


###### Разрешение конфликтов при слиянии ######

/*
Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:
*/

for(var i=0; i<arr.length; i++) {
	console.log(arr[i]);
}

// Тим предпочитает forEach:

arr.forEach(function(item) {
	console.log(item);
});

// Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

$ git merge tim_branch
/*
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
*/

// Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:

<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>>  <<<<<Tim's commit.

// Над разделителем ======= мы видим последний (HEAD) коммит, а под ним — конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());

// Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

$ git add -A
$ git commit -m "Array printing conflict resolved."

// Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).


###### Настройка .gitignore ######

/*
Вот хорошие примеры файлов, которые нужно игнорировать:

Логи
Артефакты систем сборки
Папки node_modules в проектах node.js
Папки, созданные IDE, например, Netbeans или IntelliJ
Разнообразные заметки разработчика.

Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
*/

*.log
build/
node_modules/
.idea/
my_notes.txt

// Cимвол слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.



###### Стиль именования коммитов ######

/*
# Указываем тип коммита
Есть несколько заранее определенных типов:
	feature — используется при добавлении новой функциональности уровня приложения
	fix — если исправили какую-то серьезную багу
	docs — всё, что касается документации
	style — исправляем опечатки, исправляем форматирование
	refactor — рефакторинг кода приложения
	test — всё, что связано с тестированием
	chore — обычное обслуживание кода
*/

>>>>> Указываем область действия (scope) <<<<<

/*
Сразу после типа коммита без всяких пробелов указываем в скобках область, на которую распространяется наш коммит. После этого пишем наш стандартный коммит.

Например, может быть область видимости модуля:
refactor(audio-controls) use common library for all controls

Или область видимости файла:
chore(Gruntfile.js) add watch task
*/



# Я сделал ошибку в своем коммите. Что делать?

/*
Сценарий 1

Например, вы сделали коммит нескольких файлов и поняли, что введенное вами сообщение коммита не слишком понятное. Вы хотите его изменить. Чтобы это сделать, вам нужно использовать команду git commit —amend
*/

git commit --amend -m “Новое сообщение коммита”

/*
Сценарий 2

Скажем, вы хотели сделать коммит 6 файлов, но по ошибке внесли только 5. Можно, конечно, создать новый коммит и добавить 6-й файл.

В этом подходе нет ничего плохого. Но чтобы ваша история коммитов была аккуратнее, будет лучше каким-то образом добавить этот файл к предыдущему коммиту. Это также можно сделать с помощью команды git commit —amend:
*/

git add file6git 
commit --amend --no-edit
—no-edit означает, что сообщение коммита не меняется.

/*
Сценарий 3

Когда бы вы ни сделали коммит в Git, к нему будет привязано имя автора и email. Вообще, эти данные указываются при первоначальной настройке Git. Об этих деталях не стоит волноваться при каждом коммите.

Но может так случиться, что в конкретном проекте вы захотите использовать другой email ID. Сконфигурировать email id для этого проекта можно следующей командой:
*/

git config user.email “ваш email id”

/*
Памятка

Используйте команду amend только в своем локальном репозитории. Использование amend для удаленного репозитория может создать много путаницы.
*/