<?

####### Python #######


# Документация
/*
Документация на русском (неофициальная, неполная) https://pythoner.name/documentation/reference
Документация на английском (официальная, полная) https://docs.python.org/3/
*/

# Типы данных и переменные

# числа

number1 = 42
number2 = -1000.005

# строки

string1 = "string"
string2 = 'string (another)'
long_string = '''very
"long" string with various 'quotes'
inside'''

# логические значения

x = True
y = False


# Преобразование типов
one = int('234')
two = str(34)


# Операции

# Арифметические операции
1 + 5 - 8 * 3 / 2 % 4

# Логические операции
True or False and not True

# Создание переменных
string = 'i am a string'

# Обращение к символам строки
string[0]  # i
print("-> {}".format(string))  # -> i am a string
print('-> ' + string)          # -> i am a string


# Условные конструкции
if a > b:
    print('a больше, чем b')
elif a == b:
    print('a равен b')
else:
    print('a меньше, чем b')

result = 'yes' if a > b else 'no'


# Циклы
i = 1
while i <= 10:
    i = i + 1
    print(i)
    if i > 5:
        break


# Функции

# Определение функции
def get(string, index=0):
    return string[index]

# Вызов функции
get('lala', 3)

/*
src/solution.py
Реализуйте функцию binary, которая возвращает двоичное представление десятичного числа в виде строки.

Алгоритм
Перевод числа из десятичной системы в двоичную делается по следующему алгоритму:

Исходное число (number) делится пополам.
Остаток от деления (modulo) записывается в начало строки (result).
Исходным числом становится число полученное по формуле: number // 2.
Если исходное число (number) больше нуля, то повторяем с первого пункта.
Если исходное число равно нулю, то возвращаем (result).

10 / 2  5 0
 5 / 2  2 1
 2 / 2  1 0
          1
-> 1010

Примеры

binary(0)  # '0'
binary(1)  # '1'
binary(5)  # '101'


Подсказки
Перед добавлением в строку числа нужно превратить в строки str(modulo)
*/

// FILE: /app/src/solution.py
def binary(number):
    if not number:
        return '0'
    binary_number = ''
    while number:
        bit = number % 2
        binary_number = str(bit) + binary_number
        number = number // 2
    return binary_number


// FILE: /app/tests/test_solution.py
import unittest

import solution


class TestBinary(unittest.TestCase):

    cases = [
        ['0', 0],
        ['1', 1],
        ['101', 5],
        ['110', 6],
        ['1011', 11],
        ['1100101', 101],
        ['100100101001', 2345],
    ]

    def test_cases(self):
        for expectation, argument in self.cases:
            self.assertEqual(1, 1)



>>>>>> Отладка <<<<<<

/*
Один из наиболее достоверных способов убедиться в том, что человек разбирается в программировании — посмотреть на то, как он отлаживает программу, то есть анализирует возникающие ошибки и устраняет их. Навык отладки (дебага, debug) не появляется сам по себе, его необходимо развивать и начинать это делать нужно как можно раньше. Этому весьма способствует настройка локальной среды разработки и повторение всего того, что делается в курсах, у себя на компьютере. Следующие курсы как раз помогают проделать эти шаги.

Первое, что вам понадобится для отладки — это хотя бы минимальное знание английского языка и умение пользоваться словарём. В отличие от документации языка, которую можно найти на русском, сообщения об ошибках будут всегда написаны на английском. Не пытайтесь отгадывать или менять код методом тыка в надежде, что он заработает. Прочитайте сообщение об ошибке, поймите его. Понимание — это ключевое действие, на основе которого можно планировать дальнейшие шаги.

Traceback (most recent call last):
  File "users.py", line 4, in <module>
    main()
  File "users.py", line 2, in main
    create()
NameError: name 'create' is not defined


Вывод ошибок делится на две части: непосредственно сообщение об ошибке и трейсбэк (traceback). Traceback — это список всех вызовов функций от запуска программы вплоть до того места, где произошла ошибка. Трейсбэк — очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа и какие функции вызывались. Отладка всегда сводится к двум вещам:

1. Перевести сообщение об ошибке
2. Найти в трейсбэке то место в своем коде, в котором произошла ошибка.

Каждая запись в трейсбэке представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. В рамках одного трейсбэка возможны (и часто встречаются) ситуации, когда часть функций вызывается где-то в библиотеках, которые вы не писали, но используете, а часть — в вашем коде.

# Типы ошибок
Наиболее простые и понятные ошибки — синтаксические. Они связаны исключительно с тем, что код записан неверно, например, забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствует фраза "SyntaxError: …". Для их исправления нужно открыть то место в коде, на которое указывает ошибка, и внимательно на него посмотреть.

Traceback (most recent call last):
  File "users.py", line 2
    print("Hello" + "world')
                           ^
SyntaxError: EOL while scanning string literal


Ещё одна большая группа ошибок называется ошибками программирования. К ним, например, относятся:

- вызов несуществующей функции
- использование необъявленной переменной
- передача неверных аргументов в функции, например, аргументов, имеющих неверный тип

Эти ошибки исправить труднее, чем синтаксические. Обычно они возникают в результате неправильной логики в другом, более раннем вызове.

Последний тип ошибок — логические ошибки. Исправить такие ошибки бывает крайне сложно, так как программа продолжает работать, но выдаёт неверный результат. Причём, обычно программа выдаёт неверный результат не всегда, а только лишь для некоторых входных данных. В подавляющем большинстве случаев проблема кроется в неверной логике: скажем, если перепутана операция, и вместо сложения выполняется вычитание.
*/
# Функция должна считать сумму чисел, но считает разность:
def sum(a, b):
    return a - b

# при таком вызове ошибка неочевидна, потому что
# и при сложении и при вычитании будет один и тот же результат
sum(4, 0)  # 4

# Отладка

/*
Существует множество способов отладки программ. Но какой бы способ вы не выбрали, общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.

Рассмотрим конкретный пример. Ниже описана функция, которая считает сумму чисел от числа start до числа finish. Если начало равно трём, а конец — пяти, то программа должна вычислить: 3 + 4 + 5.
*/
def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        result += n
        n += 1
    return result

/*
В этом коде допущена ошибка. Вы её видите? Если очень постараться, ошибку можно заметить, но на это никогда не стоит надеяться. Новички часто думают, что они невнимательны, и очень расстраиваются, когда допускают такие ошибки. Хочу вас успокоить: опытные разработчики допускают такие ошибки не реже новичков. Важно не то, что вы их допускаете, а то, что вы способны отладить этот код (и сделать это быстро). Этим отличаются опытные разработчики от начинающих. Никогда не пытайтесь найти ошибку с помощью "медитации" над кодом, сверля его взглядом. Если быстрая проверка не дала ответа, то приступайте к отладке.

На Хекслете, в обсуждении уроков, ученики часто нам пишут: "этот код не работает", и показывают свой код. Вероятно, начинающие разработчики думают, что опытные могут понять, в чём ошибка и найти её, просто посмотрев на код. Но это совсем не так. Глядя на такой код, невозможно понять, а что, собственно, пошло не так. И я уже не говорю про нахождение самой ошибки. Нам также нужно увидеть сообщение об ошибке и начать отладку.

Глядя на код функции sum_of_series замечаем, что основных переменных там две: n и result — именно они меняются в цикле. Из этого можно сделать ровно один вывод: нужно явно посмотреть, какие значения им даются на каждой итерации. После этого найти ошибку не составит труда.

Один из способов отслеживать значения переменных во время выполнения кода связан с использованием специальных программ-отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживая любые изменения. Подробнее о том, как их использовать можно прочитать во множестве статей (гуглить "python pdb").
*/    

# Отладочная печать

/*
В среде Хекслета отладчика нет, поэтому здесь используется другой подход (но выполняющий ту же задачу) — отладочная печать. Суть такая же, как и в визуальном отладчике, но для вывода значений переменных используется обычная печать на экран:
*/

def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        print('new iteration !!!!')
        print(n)
        result += n
        n += 1
        print(result)
    return result

sum_of_series(3, 5)

# new iteration !!!!
# 3
# 3
# new iteration !!!!
# 4
# 7

/*
То, что печатается на экран, отображается во вкладке OUTPUT, на которую автоматически переключается редактор во время проверки. Из этого вывода сразу можно понять, что итераций цикла на одну меньше, чем нужно. Почему-то не выполняется сложение для последнего числа, которое обозначено как finish. И действительно, если посмотреть на определение, то видно, что там используется n < finish вместо n <= finish.

# Дополнительные материалы
Как найти ошибки в коде? https://help.hexlet.io/article/7-how-to-debug-code
pdb — The Python Debugger https://docs.python.org/3/library/pdb.html
*/ 



>>>>>> Модули <<<<<<

/*
Программы на Python содержат тысячи, десятки тысяч и сотни тысяч строк кода (есть проекты с миллионами). В таких условиях одним файлом с кодом не обойдёшься — его нужно разбивать на части. Для получения доступа к коду, который находится в других файлах, в Python реализован механизм модулей.

# Модули и импортирование
Итак, файл с кодом на Python называется модулем. Имя модуля соответствует имени файла, поэтому файлы в Python принято называть в стиле "snake_case" (отметьте иронию: Python — питон — змея — snake — snake_case). Одни модули могут использовать содержимое других, если импортируют эти другие модули с помощью инструкции import.

Строго говоря, в Python импортировать модули можно несколькими способами:

импортировать сам модуль
импортировать отдельные определения из модуля
импортировать всё содержимое модуля сразу


# Импортирование модуля

Рассмотрим применение первого способа — импортирование модуля целиком. Главное удобство упоминания модуля по имени: глядя на код, мы сразу видим, что используемая переменная или вызываемая функция — это часть модуля.

Синтаксис импорта: import <имя_модуля (без суффикса ".py")>

Всё просто: после ключевого слова import указываем имя модуля (файла). Но при этом суффикс .py в имени надо опустить. То есть, к примеру, для модуля с именем my_module.py в инструкции импорта достаточно прописать my_module, а полный вид инструкции будет таким: import my_module.

В модуле (файле) с именем greeting.py определим функцию say_hi и переменную name:
*/

# file: greeting.py
def say_hi():
    print('Hi!')

name = 'Bob'

// А в модуле с именем main.py сделаем импорт содержимого модуля greeting.py:

# file: main.py
import greeting  # заметьте, расширение ".py" не указывается!

print(greeting.name)  # => Bob
greeting.say_hi()     # => Hi!

/*
Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это greeting. К содержимому же модуля можно обратиться, как говорят, "через точку". Причём можно как получить доступ к переменным (greeting.name), так и вызывать функции модуля (greeting.say_hi).

# Импортирование отдельных определений

Синтаксис импорта: from <имя_модуля (без суффикса ".py")> import <список определений>

Иногда из всего модуля нужна пара функций или переменных, а имя модуля слишком длинное, чтобы писать его каждый раз. Здесь нам может пригодиться следующий вариант использования инструкции import:
*/

# file: main.py
from greeting import say_hi, name

print(name)  # используем переменную
say_hi()     # вызываем функцию

/*
Здесь после ключевого слова from указано имя модуля, а затем после ключевого слова import — имена определений из этого модуля, которые мы в дальнейшем хотим использовать напрямую (а не "через точку").

В следующем уроке мы рассмотрим третий вариант импортирования модуля ("импорт всего содержимого") и в целом немного углубим наши познания в этой теме.
*/




>>>>>> Модули поглубже <<<<<<

/*
Продолжим знакомиться с системой модулей языка Python. Но для начала…

# Немного терминологии
В предыдущем уроке несколько раз встречалось словосочетание "через точку". Так часто говорят для краткости. Однако для такой формы записи имён определений (module.name) существует и официальный термин: квалифицированное имя от слова "квалифицировать" ("qualify"). Соответственно, "импорт модуля целиком" (см. прошлый урок) официально называется квалифицированным импортом.

Также стоит отметить, что в Python все строчки с import принято располагать в самом начале кода модуля. Такой набор строчек часто называют "блок импортов", хотя синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой. Нужна эта группировка во многом для того, чтобы можно было быстро найти, что в текущем модуле откуда пришло — при работе с чужим (и даже своим!) кодом подобным часто приходится заниматься.

# Импорт всего содержимого модуля
Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:
*/
from some_module import *
from another_module import *

/*
Здесь из модулей some_module и another_module импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за *!

Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.

# Сочетание способов импортирования
Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!

Давайте рассмотрим пример.

В модуле computation.py определим функцию и переменные:
*/

# file: computation.py
PI = 3.1415926
E = 2.7182818

def pi_times(x):
    return x + PI

// А в модуле main.py сделаем разными способами импорты из модуля computation.py:    

# file: main.py
import computation
from computation import PI, E
from computation import pi_times

print(PI)
print(computation.E)
print(pi_times(2))
print(computation.pi_times(E))

/*
Из кода видно, что:

оба способа импорта использованы совместно
импортировать отдельные определения можно в несколько заходов
если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы
*/

>>>>>> Пакеты <<<<<<

/*
Мы уже знаем, что в Python код хранится в отдельных файлах, называемых модулями. Но если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько модулей "по смыслу". Или же мы захотим вынести часть модулей из проекта с целью использования оных в других проектах. Для объединения модулей в группы и служат пакеты (packages).

Итак, пакет — это папка (далее "каталог") с файлами модулей, имеющая имя в формате "snake_case" и содержащая, помимо прочего, специальный модуль с именем "__init__.py". Именно наличие этого специального файла подсказывает интерпретатору Python, что каталог следует воспринимать именно как пакет.

# Простейший пакет

Давайте рассмотрим пример простейшего пакета. Пусть пакет состоит из каталога package и модуля __init__.py внутри этого каталога:

package/
└── __init__.py
Файл __init__.py пусть содержит код:
*/

# file __init__.py
NAME = 'super_package'

// Это, хотя и небольшой, но уже полноценный пакет. Его можно импортировать так же, как мы импортировали бы модуль:

import package

print(package.NAME)

/*
Заметьте — мы не импортировали файл __init__.py непосредственно. При первом обращении к пакету Python автоматически импортирует модуль __init__.py в этом пакете. Поэтому, очевидно, нельзя импортировать "просто каталог" — ведь каталог без файла __init__.py не будет полноценным пакетом!

# Содержимое пакета
С простым пакетом всё ясно — его можно использовать как модуль. Но давайте уже перейдём к группировке в пакете нескольких модулей! Для этого в пакет положим ещё два модуля:

package/
├── constants.py
├── functions.py
└── __init__.py
Содержимое модуля constants.py:
*/
# file constants.py
PERSON = 'Alice'

// Содержимое модуля functions.py:
# file functions.py
def greet(who):
    print('Hello, ' + who + '!')

// Когда пакет содержит другие модули, кроме __init__.py, таковые можно импортировать по их именам. В главе про модули упоминались два варианта импортирования: квалифицированный импорт и импортирование отдельных определений. Квалифицированный импорт в данном случае будет выглядеть так:

import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

// Этот вариант самый понятный: в строчке вызова функции greet сразу видно, откуда пришла функция, а откуда — её аргумент. Но писать имя пакета и имя модуля каждый раз — утомительно! Давайте импортируем сами функцию и аргумент:

from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!

// Так строчка вызова функции выглядит гораздо лучше! Но помните, что тому, кто будет читать этот код в дальнейшем, потребуется посмотреть в блок импортов, чтобы узнать, откуда функция и константа появились.

>>>>>>>> Модуль random <<<<<<<<
/*
Python знаменит тем, что поставляется в комплекте с "батарейками" - так называют модули и пакеты, составляющие стандартную библиотеку. Более того, батареек в поставке Пайтона изрядное количество! Настоящий питонист (pythonista) - так мы, программисты на Python, себя называем - обязан хорошо ориентироваться в стандартной библиотеке, ведь это знание позволяет экономить время и силы. В этом уроке мы познакомимся с первой батарейкой - модулем random.

При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из некоего множества значение. Случайные значения полезны, когда мы разрабатываем компьютерные игры, генерируем изображения и звук, и даже просто пишем тесты.

Любое значение в компьютере может быть представлено в виде набора чисел, поэтому получение случайных значений всегда предполагает использование Генератора Случайных Чисел, ГСЧ. ГСЧ бывают программными (специализированные программы) и аппаратными (специализированные устройства), но программист обычно работает с некоторой обобщённой "обёрткой" - модулем или пакетом, который скрывает ненужные детали.

Модуль random предоставляет множество функций, полезных в разных ситуациях, но мы пока остановимся на двух:

randint, генерация целого числа в заданном диапазоне,
choice, выбор случайного элемента из заданного набора.

# Генерация случайных чисел
Для того, чтобы сгенерировать случайное число, нам нужно импортировать функцию randint из модуля random:
*/
from random import randint

// Теперь мы можем сгенерировать число от 1 до 100:
random_number = randint(1, 100)

// При вызове randint с такими границами диапазона может "выпасть" и 1 и 100 - обе границы диапазона включены и об этом следует помнить. Когда это может быть важно? Давайте рассмотрим другой пример - выбор случайного символа некоторой строки:

string = 'abcde'
random_index = randint(0, len(string) - 1)
char = string[random_index]

/*
Строка в переменной string имеет длину 5. Но мы помним, что символы строки индексируются с нуля, поэтому если сгенерировать индекс так randint(0, 5), то в какой-то момент мы получим значение 5 и при попытке взять символ по этому индексу мы увидим ошибку IndexError: индекс последнего элемента в строке равен 4! Вот поэтому в коде выше из длины вычитается единица.

# Выбор случайного элемента
Выше мы рассмотрели пример, в котором выбирался случайный символ строки. Эта задача возникает достаточно часто, поэтому в модуле random существует функция choice. С использованием этой функции выбор символа строки будет выглядеть так:
*/

from random import choice

string = 'abcde'
char = choice(string)

/*
При использовании choice не нужно думать о границах генерируемых индексов. И даже о самих индексах думать не нужно - функция сама знает, как правильно и безопасно выбирать элементы! Правда, придётся заботиться о том, чтобы строка, из который мы выбираем символы, не была пустой, иначе мы получим ошибку IndexError: Cannot choose from an empty sequence ("Нельзя просто так взять и выбрать, если выбирать не из чего").

Пока мы можем использовать choice только со строками, ведь это единственный тип, значения которого могут содержать несколько элементов. Но в дальнейшем мы познакомимся и с другими составными типами - и с многими из таких типов функция choice тоже может работать!

# Случайна ли случайность?
Строго говоря, генерируемые числа у компьютера получаются не полностью случайными, поэтому большинство ГСЧ представляют собой генераторы псевдослучайных чисел. И хотя для простоты приставку "псевдо-" часто опускают (как поступили и мы), о ней не стоит забывать. Дело в том, что некоторые алгоритмы требуют максимально случайной генерации чисел. Одна из областей с такими высокими требованиями к качеству случайности — криптография (шифрование). Представьте, что вы сгенерировали случайный пароль, длинный и сложный, а злоумышленник, пользуясь тем, что при определённых условиях можно воспроизвести ту же последовательность случайных чисел, получил тот же пароль! Вот поэтому существует большое количество специализированных ГСЧ, безопасных для использования в шифровании и создание таких генераторов - это важная, сложная и интересная работа.

# Ссылки
Модуль random https://docs.python.org/3.6/library/random.html
ГСЧ https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел
*/

>>>>>> Кортежи <<<<<<<
/*
До этого момента мы встречались только с примитивными типами — строка, число, булев тип. Ещё нам знакомы функции и модули с пакетами (да, в Python модули и пакеты, это тоже значения специальных встроенных типов). Но часто в программировании приходится создавать более сложные, чем числа и строки, значения и манипулировать такими значениями. Именно поэтому во многих языках программирования есть составные типы. Значение составного типа может состоять как из значений примитивных типов, так и из значений других составных типов, таким образом составные типы позволяют описывать сущности произвольной сложности — и шахматные доски, и космические ракеты!

В этом уроке мы познакомимся с самым простым, но очень полезным составным типом — кортежем (в англоязычных текстах оный известен, как tuple).

# Кортежи
Кортеж — это несколько значений, записанных через запятую. Да, всё очень просто! Вот несколько примеров:
*/
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

/*
Определять кортежи очень просто, сложности могут возникнуть только с кортежами, содержащими ровно один элемент. Если мы просто укажем значение в скобках, то Python подумает, что мы хотим посчитать арифметическое выражение со скобками:
*/
not_a_tuple = (42)  # 42

// Чтобы сказать пайтону, что мы хотим создать именно кортеж, нужно поставить после элемента кортежа запятую:

tuple = (42,)  # (42,)

/*
Да, форма записи довольно необычная, но вы привыкнете :)

# Возврат нескольких значений из функции
Кортежи очень полезны, когда нам нужно вернуть из функции сразу несколько значений. Так, функция, которая принимает два аргумента-числа и возвращает одновременно результат деления нацело и остаток от деления, будет выглядеть так:
*/

def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)

/*
# Получение элементов кортежа по индексу
Выше мы только создавали кортежи. Теперь научимся их разбирать! В простейшем случае достаточно обратиться к элементу кортежа по индексу:
*/

name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

// Также у кортежа есть длина, которую, как и для строки, можно получить с помощью функции len:

tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2

/*
# Деструктуризация
Обращение по индексу, это не самый удобный способ работы с кортежами. Дело в том, что кортежи часто содержат значения разных типов, и помнить, по какому индексу что лежит — очень непросто. Но есть способ лучше! Как мы кортеж собираем, так его можно и разобрать:
*/

name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42

/*
Именно таким способом принято получать и сразу разбирать значения, которые возвращает функция (если таковая возвращает несколько значений, конечно):
*/
(quotient, modulo) = div_mod(13, 4)

// Соответственно кортеж из одного элемента нужно разбирать так:
(a,) = (42,)
a  # 42

/*
Если же после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную a кортеж запишется целиком, т.е. ничего не распакуется! Всегда помните о запятых!

# Кортежи, множественное присваивание и обмен значениями
Благодаря тому, что кортежи легко собирать и разбирать, в Python удобно делать такие вещи, как множественное присваивание. Смотрите:
*/
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3

// Используя множественное присваивание, можно провернуть интересный трюк: обмен значениями между двумя переменными. Вот код:

a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100

/*
Cтрочку (a, b) = (b, a) нужно понимать как "присвоить в а и b значения из кортежа, состоящего из значений переменных b и a".

# Ссылки
Кортеж https://ru.wikipedia.org/wiki/Кортеж_(информатика)
*/


>>>>>> История развития языка Python <<<<<<

/*
Итак, мы учимся языку Python. Для начала стоит определиться с названием. Правильно говорить "Пайтон" с ударением на первом слоге — язык назван в честь известного комедийного шоу "Летающий Цирк Монти Пайтона", т.е. Пайтон — это фамилия, а фамилию человека принято произносить так, как это делает носитель фамилии!

Ещё пара сухих фактов:

Первый релиз интерпретатора языка Python был представлен в далёком 1991г,
Автор языка — Гвидо ван Россум.
Сам по себе язык — это не то же самое, что его интерпретаторы. Но основная реализация языка — CPython — настолько распространена, что почти всегда, когда мы слышим "Python", подразумевается именно она. Наши курсы тоже будут касаться именно CPython, это стоит иметь в виду!

# Самое начало
Python появился, чтобы заменить собой язык ABC, в работе над которым принимал участие будущий автор пайтона Гвидо ван Россум. Представленный в 1991 году Python версии 0.9.0 вобрал в себя многие идеи из существовавших на тот момент языков: например, взяв систему модулей из языка Modula-3. Элементы функционального программирования (их мы будем изучать в следующих курсах!) — функции map, filter, reduce — появились в языке тоже довольно рано, в версии 1.0.

Стоит отметить, что Пайтон изначально позиционировался как "язык для каждого", поэтому большой упор делался на читаемость кода и лаконичность синтаксиса. В версии 2.0 появились знаменитые "списковые включения" ("list comprehensions"), позаимствованные из языков SETL и Haskell. В этой же версии сборщик мусора (механизм автоматического управления памятью) научился работать с циклическими структурами. С ними мы также познакомимся в последующих курсах.

# Py2 vs Py3
Python, как язык, непрерывно развивается с самого начала времени своего существования. На данный момент в основном используются версии языка, начинающиеся с "3".

Первый релиз "третьего пайтона" (python3, py3) вышел ещё в 2008 году, но переход на это семейство версий со "второго пайтона" (python2, py2) происходил (кое-где всё ещё происходит!) "со скрипом". Дело в том, что py3 не полностью обратно совместим с кодом, написанным для py2, т.е. мы не можем просто заменить интерпретатор — нам потребуется внести определённые изменения в код! На такой шаг можно пойти, если наш проект — живой. Но с проектами, находящимися в состоянии "только поддержка" (такие проекты ещё называют legacy), такой фокус не пройдёт — обычно просто некому заниматься адаптацией. А ведь legacy-проекты — это не всегда лишь конечные приложения, в такой ситуации могут оказаться и библиотеки. Именно из-за невозможности отказаться от нужных, но существующих в состоянии legacy, библиотек многие проекты долго оставались несовместимыми с py3.

К счастью, сейчас большая часть библиотек, достаточно популярных и полезных в повседневной жизни разработчика, успешно переведена на py3, и новые проекты нужно делать именно на какой-то из версий этого семейства (сейчас рекомендуемая версия — это Python 3.7.x). Более того, py2 скоро перестанет быть безопасным для широкого использования! Дело в том, что техническая поддержка py2 — т.е. устранение уязвимостей и критических ошибок — с 2020г перестанет осуществляться. А мы ведь не хотим подвергать угрозе свои детища!

# Системный Python
Работая с Python, стоит иметь в виду, что Python распространён не только в виде языка, на котором пишутся конечные проекты: этот язык часто используется для автоматизации различных задач, скажем, по системному администрированию (Ansible — один из примеров написанного на Python ПО, используемого при администрировании). Поэтому python часто уже присутствует в установленных операционных системах.

Особенно велика вероятность обнаружить в системе установленный Python, когда речь идёт об ОС семейства Linux — а именно, какая-то из версий Linux будет скорее всего установлена на машину, на которой вы захотите запустить сервер своего web-приложения или многопользовательской игры (да, такие тоже пишут на Python!). Тут-то и кроется проблема: установленный вместе с операционной системой Python может быть тем самым "вторым пайтоном" — да, такое, увы, пока встречается. И заменить его будет нельзя, ведь замена может привести к выходу из строя всей ОС.

Но не пугайтесь, в курсе про настройку окружения вы узнаете, как использовать в проекте нужную версию Python и не бояться сломать что-то другое!
*/

/**@@@
src/solution.py
Реализуйте функцию sort_pair, которая принимает пару (кортеж из двух значений) и возвращает пару, значения которой расположенны строго в порядке возрастания.

Пример:
*/

# обратите внимание на скобки у аргумента функции
sort_pair((5, 1)) == (1, 5)
sort_pair((2, 2)) == (2, 2)
sort_pair((7, 8)) == (7, 8)


// FILE /app/src/solution.py:
def sort_pair(pair):
    (first, second) = pair
    if first > second:
        return (second, first)
    return pair


/**@@@
src/package/__init__.py
Дан пакет следующей структуры:

$ tree package
package/
├── __init__.py
├── functions.py
└── names.py
Добавьте в __init__.py блок импортов таким образом, чтобы можно было импортировать package и получить доступ

к константе NAME из package.names
к функции greet из package.functions
Если задание будет выполнено успешно, то следующий код должен будет работать:
*/    

from package import greet, NAME

greet(NAME)  # 'Hello, Bob!'


// FILE: /app/src/__init__.py:
from package.names import NAME
from package.functions import greet


// FILE: /app/src/functions.py:
def greet(name):
    return 'Hello, {}!'.format(name)

// FILE: /app/src/names.py:
NAME = 'Bob'
