####### Python #######
	 
'''
Документация на русском (неофициальная, неполная) https://pythoner.name/documentation/reference
Документация на английском (официальная, полная) https://docs.python.org/3/
'''

#@ Типы данных и переменные

# числа

number1 = 42
number2 = -1000.005

# строки

string1 = "string"
string2 = 'string (another)'
long_string = '''very
"long" string with various 'quotes'
inside'''

# логические значения

x = True
y = False


#@ Преобразование типов
one = int('234')
two = str(34)


#@ Операции

# Арифметические операции
1 + 5 - 8 * 3 / 2 % 4

# Логические операции
True or False and not True

# Создание переменных
string = 'i am a string'

# Обращение к символам строки
string[0]  # i
print("-> {}".format(string)) # -> i am a string
print('-> ' + string) # -> i am a string


# Условные конструкции
if a > b:
	 print('a больше, чем b')
elif a == b:
    print('a равен b')
else:
	 print('a меньше, чем b')

result = 'yes' if a > b else 'no'


# Циклы
i = 1
while i <= 10:
    i = i + 1
    print(i)
    if i > 5:
        break


# Функции

# Определение функции
def get(string, index=0):
    return string[index]

# Вызов функции
get('lala', 3)


'''
src/solution.py
Реализуйте функцию binary, которая возвращает двоичное представление десятичного числа в виде строки.

Алгоритм
Перевод числа из десятичной системы в двоичную делается по следующему алгоритму:

Исходное число (number) делится пополам.
Остаток от деления (modulo) записывается в начало строки (result).
Исходным числом становится число полученное по формуле: number // 2.
Если исходное число (number) больше нуля, то повторяем с первого пункта.
Если исходное число равно нулю, то возвращаем (result).

10 / 2  5 0
 5 / 2  2 1
 2 / 2  1 0
          1
-> 1010

Примеры
'''

binary(0)  # '0'
binary(1)  # '1'
binary(5)  # '101'

'''
Подсказки
Перед добавлением в строку числа нужно превратить в строки str(modulo)
'''

# FILE: /app/src/solution.py

def binary(number):
    if not number:
        return '0'
    binary_number = ''
    while number:
        bit = number % 2
        binary_number = str(bit) + binary_number
        number = number // 2
    return binary_number


# FILE: /app/tests/test_solution.py
import unittest

import solution

class TestBinary(unittest.TestCase):

    cases = [
		 ['0', 0],
		 ['1', 1],
		 ['101', 5],
		 ['110', 6],
		 ['1011', 11],
		 ['1100101', 101],
		 ['100100101001', 2345],
	 ]

    def test_cases(self):
        for expectation, argument in self.cases:
            self.assertEqual(1, 1)



'''*@@@
src/solution.py
Реализуйте и функцию is_power_of_three, которая определяет, является ли переданное число натуральной степенью тройки. Например, число 27 — это третья степень: 3 ** 3, а 81 — это четвёртая: 3 ** 4.

>>> is_power_of_three(1)
True
>>> is_power_of_three(2)
False
>>> is_power_of_three(9)
True
'''

def is_power_of_three(number):
    counter = 1  # 3 ** 0
    while counter < number:
		  counter *= 3
    return counter == number


	
'''*@@@
Реализуйте функцию fib, находящую положительные Числа Фибоначчи. Аргументом функции является порядковый номер числа.
'''
def fib(index):
    if index <= 0:
        result = 0
    elif index == 1:
        result = 1
    else:
        result = fib(index - 1) + fib(index - 2)
    return result


'''*@@@
Реализуйте функцию binary_sum, которая принимает на вход два двоичных числа (в виде строк) и возвращает их сумму. Результат (вычисленная сумма) также должен быть бинарным числом в виде строки.

Посмотрите примеры работы функции:
'''

binary_sum('10', '1')      # 11
binary_sum('1101', '101')  # 10010

def binary_sum(number_a, number_b):
    binary_a = int(number_a, base=2)
    binary_b = int(number_b, base=2)
    return bin(binary_a + binary_b).replace('0b', '')


'''*@@@
Реализуйте функцию fizz_buzz, которая возвращает строку с числами (через пробел) в диапазоне от begin до end включительно. При этом:

> Если число делится без остатка на 3, то вместо него выводится слово Fizz
> Если число делится без остатка на 5, то вместо него выводится слово Buzz
> Если число делится без остатка и на 3, и на 5, то вместо числа выводится слово FizzBuzz
> В остальных случаях в строку добавляется само число
Функция принимает два параметра (begin и end), определяющих начало и конец диапазона (включительно). Если диапазон пуст (в случае, когда begin > end), то функция возвращает пустую строку.
'''

def fizz_buzz(start, stop):
    result = ''
    while start <= stop:
        if result:
            result += ' '
        if start % 15 == 0:
            result += 'FizzBuzz'
        elif start % 3 == 0:
            result += 'Fizz'
        elif start % 5 == 0:
            result += 'Buzz'
        else:
            result += str(start)
        start += 1
    return result




'''*@@@
Реализуйте функцию is_palindrome, которая принимает на вход слово, определяет является ли оно палиндромом и возвращает логическое значение.

Примеры использования:
'''

is_palindrome('radar')  # True
is_palindrome('a')      # True
is_palindrome('abs')    # False

def is_palindrome(string):
    start = 0
    end = len(string) - 1
    while end - start > 0:
        if string[start] != string[end]:
            return False
        start += 1
        end -= 1
    return True


'''*@@@
В этом испытании вы будете работать с "тройками" — кортежами из трёх элементов. Вам предстоит реализовать две функции, которые "вращают" тройку влево и вправо. Как это выглядит, вы можете понять из пары примеров:

>>> triple = ('A', 'B', 'C')
>>> rotate_left(triple)
('B', 'C', 'A')
>>> rotate_right(triple)
('C', 'A', 'B')
'''

def rotate_left(triple):
    elem1, elem2, elem3 = triple
    return (elem2, elem3, elem1)


def rotate_right(triple):
    elem1, elem2, elem3 = triple
    return (elem3, elem1, elem2)


#>>>>>> Отладка <<<<<<

'''
Один из наиболее достоверных способов убедиться в том, что человек разбирается в программировании — посмотреть на то, как он отлаживает программу, то есть анализирует возникающие ошибки и устраняет их. Навык отладки (дебага, debug) не появляется сам по себе, его необходимо развивать и начинать это делать нужно как можно раньше. Этому весьма способствует настройка локальной среды разработки и повторение всего того, что делается в курсах, у себя на компьютере. Следующие курсы как раз помогают проделать эти шаги.

Первое, что вам понадобится для отладки — это хотя бы минимальное знание английского языка и умение пользоваться словарём. В отличие от документации языка, которую можно найти на русском, сообщения об ошибках будут всегда написаны на английском. Не пытайтесь отгадывать или менять код методом тыка в надежде, что он заработает. Прочитайте сообщение об ошибке, поймите его. Понимание — это ключевое действие, на основе которого можно планировать дальнейшие шаги.

Traceback (most recent call last):
  File "users.py", line 4, in <module>
    main()
  File "users.py", line 2, in main
    create()
NameError: name 'create' is not defined


Вывод ошибок делится на две части: непосредственно сообщение об ошибке и трейсбэк (traceback). Traceback — это список всех вызовов функций от запуска программы вплоть до того места, где произошла ошибка. Трейсбэк — очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа и какие функции вызывались. Отладка всегда сводится к двум вещам:

1. Перевести сообщение об ошибке
2. Найти в трейсбэке то место в своем коде, в котором произошла ошибка.

Каждая запись в трейсбэке представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. В рамках одного трейсбэка возможны (и часто встречаются) ситуации, когда часть функций вызывается где-то в библиотеках, которые вы не писали, но используете, а часть — в вашем коде.

# Типы ошибок
Наиболее простые и понятные ошибки — синтаксические. Они связаны исключительно с тем, что код записан неверно, например, забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствует фраза "SyntaxError: …". Для их исправления нужно открыть то место в коде, на которое указывает ошибка, и внимательно на него посмотреть.

Traceback (most recent call last):
  File "users.py", line 2
    print("Hello" + "world')
                           ^
SyntaxError: EOL while scanning string literal


Ещё одна большая группа ошибок называется ошибками программирования. К ним, например, относятся:

- вызов несуществующей функции
	 - использование необъявленной переменной
	 - передача неверных аргументов в функции, например, аргументов, имеющих неверный тип

Эти ошибки исправить труднее, чем синтаксические. Обычно они возникают в результате неправильной логики в другом, более раннем вызове.

	 Последний тип ошибок — логические ошибки. Исправить такие ошибки бывает крайне сложно, так как программа продолжает работать, но выдаёт неверный результат. Причём, обычно программа выдаёт неверный результат не всегда, а только лишь для некоторых входных данных. В подавляющем большинстве случаев проблема кроется в неверной логике: скажем, если перепутана операция, и вместо сложения выполняется вычитание.
'''

# Функция должна считать сумму чисел, но считает разность:
def sum(a, b):
    return a - b

# при таком вызове ошибка неочевидна, потому что
# и при сложении и при вычитании будет один и тот же результат
sum(4, 0)  # 4

# Отладка

'''
Существует множество способов отладки программ. Но какой бы способ вы не выбрали, общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.

	 Рассмотрим конкретный пример. Ниже описана функция, которая считает сумму чисел от числа start до числа finish. Если начало равно трём, а конец — пяти, то программа должна вычислить: 3 + 4 + 5.
'''
def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        result += n
        n += 1
    return result

'''
В этом коде допущена ошибка. Вы её видите? Если очень постараться, ошибку можно заметить, но на это никогда не стоит надеяться. Новички часто думают, что они невнимательны, и очень расстраиваются, когда допускают такие ошибки. Хочу вас успокоить: опытные разработчики допускают такие ошибки не реже новичков. Важно не то, что вы их допускаете, а то, что вы способны отладить этот код (и сделать это быстро). Этим отличаются опытные разработчики от начинающих. Никогда не пытайтесь найти ошибку с помощью "медитации" над кодом, сверля его взглядом. Если быстрая проверка не дала ответа, то приступайте к отладке.

	 На Хекслете, в обсуждении уроков, ученики часто нам пишут: "этот код не работает", и показывают свой код. Вероятно, начинающие разработчики думают, что опытные могут понять, в чём ошибка и найти её, просто посмотрев на код. Но это совсем не так. Глядя на такой код, невозможно понять, а что, собственно, пошло не так. И я уже не говорю про нахождение самой ошибки. Нам также нужно увидеть сообщение об ошибке и начать отладку.

	 Глядя на код функции sum_of_series замечаем, что основных переменных там две: n и result — именно они меняются в цикле. Из этого можно сделать ровно один вывод: нужно явно посмотреть, какие значения им даются на каждой итерации. После этого найти ошибку не составит труда.

	 Один из способов отслеживать значения переменных во время выполнения кода связан с использованием специальных программ-отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживая любые изменения. Подробнее о том, как их использовать можно прочитать во множестве статей (гуглить "python pdb").
'''

# Отладочная печать

'''
В среде Хекслета отладчика нет, поэтому здесь используется другой подход (но выполняющий ту же задачу) — отладочная печать. Суть такая же, как и в визуальном отладчике, но для вывода значений переменных используется обычная печать на экран:
'''

def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        print('new iteration !!!!')
        print(n)
        result += n
        n += 1
        print(result)
    return result

sum_of_series(3, 5)

# new iteration !!!!
# 3
# 3
# new iteration !!!!
# 4
# 7

'''
То, что печатается на экран, отображается во вкладке OUTPUT, на которую автоматически переключается редактор во время проверки. Из этого вывода сразу можно понять, что итераций цикла на одну меньше, чем нужно. Почему-то не выполняется сложение для последнего числа, которое обозначено как finish. И действительно, если посмотреть на определение, то видно, что там используется n < finish вместо n <= finish.

# Дополнительные материалы
	 Как найти ошибки в коде? https://help.hexlet.io/article/7-how-to-debug-code
		 pdb — The Python Debugger https://docs.python.org/3/library/pdb.html
'''



>>>>>> Модули <<<<<<

'''
Программы на Python содержат тысячи, десятки тысяч и сотни тысяч строк кода (есть проекты с миллионами). В таких условиях одним файлом с кодом не обойдёшься — его нужно разбивать на части. Для получения доступа к коду, который находится в других файлах, в Python реализован механизм модулей.

# Модули и импортирование
	 Итак, файл с кодом на Python называется модулем. Имя модуля соответствует имени файла, поэтому файлы в Python принято называть в стиле "snake_case" (отметьте иронию: Python — питон — змея — snake — snake_case). Одни модули могут использовать содержимое других, если импортируют эти другие модули с помощью инструкции import.

	 Строго говоря, в Python импортировать модули можно несколькими способами:

импортировать сам модуль
импортировать отдельные определения из модуля
импортировать всё содержимое модуля сразу


# Импортирование модуля

Рассмотрим применение первого способа — импортирование модуля целиком. Главное удобство упоминания модуля по имени: глядя на код, мы сразу видим, что используемая переменная или вызываемая функция — это часть модуля.

	 Синтаксис импорта: import <имя_модуля (без суффикса ".py")>

Всё просто: после ключевого слова import указываем имя модуля (файла). Но при этом суффикс .py в имени надо опустить. То есть, к примеру, для модуля с именем my_module.py в инструкции импорта достаточно прописать my_module, а полный вид инструкции будет таким: import my_module.

	 В модуле (файле) с именем greeting.py определим функцию say_hi и переменную name:
'''

# file: greeting.py
def say_hi():
    print('Hi!')

name = 'Bob'

// А в модуле с именем main.py сделаем импорт содержимого модуля greeting.py:

# file: main.py
import greeting  # заметьте, расширение ".py" не указывается!

print(greeting.name)  # => Bob
greeting.say_hi()     # => Hi!

'''
Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это greeting. К содержимому же модуля можно обратиться, как говорят, "через точку". Причём можно как получить доступ к переменным (greeting.name), так и вызывать функции модуля (greeting.say_hi).

# Импортирование отдельных определений

	 Синтаксис импорта: from <имя_модуля (без суффикса ".py")> import <список определений>

	 Иногда из всего модуля нужна пара функций или переменных, а имя модуля слишком длинное, чтобы писать его каждый раз. Здесь нам может пригодиться следующий вариант использования инструкции import:
'''

# file: main.py
from greeting import say_hi, name

print(name)  # используем переменную
say_hi()     # вызываем функцию

'''
Здесь после ключевого слова from указано имя модуля, а затем после ключевого слова import — имена определений из этого модуля, которые мы в дальнейшем хотим использовать напрямую (а не "через точку").

В следующем уроке мы рассмотрим третий вариант импортирования модуля ("импорт всего содержимого") и в целом немного углубим наши познания в этой теме.
'''




>>>>>> Модули поглубже <<<<<<

'''
Продолжим знакомиться с системой модулей языка Python. Но для начала…

# Немного терминологии
В предыдущем уроке несколько раз встречалось словосочетание "через точку". Так часто говорят для краткости. Однако для такой формы записи имён определений (module.name) существует и официальный термин: квалифицированное имя от слова "квалифицировать" ("qualify"). Соответственно, "импорт модуля целиком" (см. прошлый урок) официально называется квалифицированным импортом.

	 Также стоит отметить, что в Python все строчки с import принято располагать в самом начале кода модуля. Такой набор строчек часто называют "блок импортов", хотя синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой. Нужна эта группировка во многом для того, чтобы можно было быстро найти, что в текущем модуле откуда пришло — при работе с чужим (и даже своим!) кодом подобным часто приходится заниматься.

# Импорт всего содержимого модуля
	 Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:
'''
from some_module import *
from another_module import *

'''
Здесь из модулей some_module и another_module импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за *!

	 Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.

# Сочетание способов импортирования
	 Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!

	 Давайте рассмотрим пример.

	 В модуле computation.py определим функцию и переменные:
'''

# file: computation.py
PI = 3.1415926
E = 2.7182818

def pi_times(x):
    return x + PI

// А в модуле main.py сделаем разными способами импорты из модуля computation.py:

# file: main.py
import computation
from computation import PI, E
from computation import pi_times

print(PI)
print(computation.E)
print(pi_times(2))
print(computation.pi_times(E))

'''
Из кода видно, что:

оба способа импорта использованы совместно
импортировать отдельные определения можно в несколько заходов
если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы
'''

>>>>>> Пакеты <<<<<<

'''
Мы уже знаем, что в Python код хранится в отдельных файлах, называемых модулями. Но если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько модулей "по смыслу". Или же мы захотим вынести часть модулей из проекта с целью использования оных в других проектах. Для объединения модулей в группы и служат пакеты (packages).

	 Итак, пакет — это папка (далее "каталог") с файлами модулей, имеющая имя в формате "snake_case" и содержащая, помимо прочего, специальный модуль с именем "__init__.py". Именно наличие этого специального файла подсказывает интерпретатору Python, что каталог следует воспринимать именно как пакет.

# Простейший пакет

	 Давайте рассмотрим пример простейшего пакета. Пусть пакет состоит из каталога package и модуля __init__.py внутри этого каталога:

package/
└── __init__.py
Файл __init__.py пусть содержит код:
'''

# file __init__.py
NAME = 'super_package'

// Это, хотя и небольшой, но уже полноценный пакет. Его можно импортировать так же, как мы импортировали бы модуль:

import package

print(package.NAME)

'''
Заметьте — мы не импортировали файл __init__.py непосредственно. При первом обращении к пакету Python автоматически импортирует модуль __init__.py в этом пакете. Поэтому, очевидно, нельзя импортировать "просто каталог" — ведь каталог без файла __init__.py не будет полноценным пакетом!

# Содержимое пакета
	 С простым пакетом всё ясно — его можно использовать как модуль. Но давайте уже перейдём к группировке в пакете нескольких модулей! Для этого в пакет положим ещё два модуля:

package/
├── constants.py
├── functions.py
└── __init__.py
Содержимое модуля constants.py:
'''
# file constants.py
PERSON = 'Alice'

// Содержимое модуля functions.py:
# file functions.py
def greet(who):
    print('Hello, ' + who + '!')

// Когда пакет содержит другие модули, кроме __init__.py, таковые можно импортировать по их именам. В главе про модули упоминались два варианта импортирования: квалифицированный импорт и импортирование отдельных определений. Квалифицированный импорт в данном случае будет выглядеть так:

import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

// Этот вариант самый понятный: в строчке вызова функции greet сразу видно, откуда пришла функция, а откуда — её аргумент. Но писать имя пакета и имя модуля каждый раз — утомительно! Давайте импортируем сами функцию и аргумент:

from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!

// Так строчка вызова функции выглядит гораздо лучше! Но помните, что тому, кто будет читать этот код в дальнейшем, потребуется посмотреть в блок импортов, чтобы узнать, откуда функция и константа появились.

>>>>>>>> Модуль random <<<<<<<<
'''
Python знаменит тем, что поставляется в комплекте с "батарейками" - так называют модули и пакеты, составляющие стандартную библиотеку. Более того, батареек в поставке Пайтона изрядное количество! Настоящий питонист (pythonista) - так мы, программисты на Python, себя называем - обязан хорошо ориентироваться в стандартной библиотеке, ведь это знание позволяет экономить время и силы. В этом уроке мы познакомимся с первой батарейкой - модулем random.

	 При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из некоего множества значение. Случайные значения полезны, когда мы разрабатываем компьютерные игры, генерируем изображения и звук, и даже просто пишем тесты.

	 Любое значение в компьютере может быть представлено в виде набора чисел, поэтому получение случайных значений всегда предполагает использование Генератора Случайных Чисел, ГСЧ. ГСЧ бывают программными (специализированные программы) и аппаратными (специализированные устройства), но программист обычно работает с некоторой обобщённой "обёрткой" - модулем или пакетом, который скрывает ненужные детали.

	 Модуль random предоставляет множество функций, полезных в разных ситуациях, но мы пока остановимся на двух:

randint, генерация целого числа в заданном диапазоне,
choice, выбор случайного элемента из заданного набора.

# Генерация случайных чисел
	 Для того, чтобы сгенерировать случайное число, нам нужно импортировать функцию randint из модуля random:
'''
from random import randint

// Теперь мы можем сгенерировать число от 1 до 100:
random_number = randint(1, 100)

// При вызове randint с такими границами диапазона может "выпасть" и 1 и 100 - обе границы диапазона включены и об этом следует помнить. Когда это может быть важно? Давайте рассмотрим другой пример - выбор случайного символа некоторой строки:

string = 'abcde'
random_index = randint(0, len(string) - 1)
char = string[random_index]

'''
Строка в переменной string имеет длину 5. Но мы помним, что символы строки индексируются с нуля, поэтому если сгенерировать индекс так randint(0, 5), то в какой-то момент мы получим значение 5 и при попытке взять символ по этому индексу мы увидим ошибку IndexError: индекс последнего элемента в строке равен 4! Вот поэтому в коде выше из длины вычитается единица.

# Выбор случайного элемента
	 Выше мы рассмотрели пример, в котором выбирался случайный символ строки. Эта задача возникает достаточно часто, поэтому в модуле random существует функция choice. С использованием этой функции выбор символа строки будет выглядеть так:
'''

from random import choice

string = 'abcde'
char = choice(string)

'''
При использовании choice не нужно думать о границах генерируемых индексов. И даже о самих индексах думать не нужно - функция сама знает, как правильно и безопасно выбирать элементы! Правда, придётся заботиться о том, чтобы строка, из который мы выбираем символы, не была пустой, иначе мы получим ошибку IndexError: Cannot choose from an empty sequence ("Нельзя просто так взять и выбрать, если выбирать не из чего").
	
		 Пока мы можем использовать choice только со строками, ведь это единственный тип, значения которого могут содержать несколько элементов. Но в дальнейшем мы познакомимся и с другими составными типами - и с многими из таких типов функция choice тоже может работать!

# Случайна ли случайность?
	 Строго говоря, генерируемые числа у компьютера получаются не полностью случайными, поэтому большинство ГСЧ представляют собой генераторы псевдослучайных чисел. И хотя для простоты приставку "псевдо-" часто опускают (как поступили и мы), о ней не стоит забывать. Дело в том, что некоторые алгоритмы требуют максимально случайной генерации чисел. Одна из областей с такими высокими требованиями к качеству случайности — криптография (шифрование). Представьте, что вы сгенерировали случайный пароль, длинный и сложный, а злоумышленник, пользуясь тем, что при определённых условиях можно воспроизвести ту же последовательность случайных чисел, получил тот же пароль! Вот поэтому существует большое количество специализированных ГСЧ, безопасных для использования в шифровании и создание таких генераторов - это важная, сложная и интересная работа.

# Ссылки
	 Модуль random https://docs.python.org/3.6/library/random.html
ГСЧ https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел
'''

>>>>>> Кортежи <<<<<<<
'''
До этого момента мы встречались только с примитивными типами — строка, число, булев тип. Ещё нам знакомы функции и модули с пакетами (да, в Python модули и пакеты, это тоже значения специальных встроенных типов). Но часто в программировании приходится создавать более сложные, чем числа и строки, значения и манипулировать такими значениями. Именно поэтому во многих языках программирования есть составные типы. Значение составного типа может состоять как из значений примитивных типов, так и из значений других составных типов, таким образом составные типы позволяют описывать сущности произвольной сложности — и шахматные доски, и космические ракеты!

	 В этом уроке мы познакомимся с самым простым, но очень полезным составным типом — кортежем (в англоязычных текстах оный известен, как tuple).

# Кортежи
Кортеж — это несколько значений, записанных через запятую. Да, всё очень просто! Вот несколько примеров:
'''
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

'''
Определять кортежи очень просто, сложности могут возникнуть только с кортежами, содержащими ровно один элемент. Если мы просто укажем значение в скобках, то Python подумает, что мы хотим посчитать арифметическое выражение со скобками:
'''
not_a_tuple = (42)  # 42

// Чтобы сказать пайтону, что мы хотим создать именно кортеж, нужно поставить после элемента кортежа запятую:

tuple = (42,)  # (42,)

'''
Да, форма записи довольно необычная, но вы привыкнете :)

# Возврат нескольких значений из функции
Кортежи очень полезны, когда нам нужно вернуть из функции сразу несколько значений. Так, функция, которая принимает два аргумента-числа и возвращает одновременно результат деления нацело и остаток от деления, будет выглядеть так:
'''

def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)

'''
# Получение элементов кортежа по индексу
Выше мы только создавали кортежи. Теперь научимся их разбирать! В простейшем случае достаточно обратиться к элементу кортежа по индексу:
'''

name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

// Также у кортежа есть длина, которую, как и для строки, можно получить с помощью функции len:

tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2

'''
# Деструктуризация
Обращение по индексу, это не самый удобный способ работы с кортежами. Дело в том, что кортежи часто содержат значения разных типов, и помнить, по какому индексу что лежит — очень непросто. Но есть способ лучше! Как мы кортеж собираем, так его можно и разобрать:
'''

name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42

'''
Именно таким способом принято получать и сразу разбирать значения, которые возвращает функция (если таковая возвращает несколько значений, конечно):
'''
(quotient, modulo) = div_mod(13, 4)

// Соответственно кортеж из одного элемента нужно разбирать так:
(a,) = (42,)
a  # 42

'''
Если же после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную a кортеж запишется целиком, т.е. ничего не распакуется! Всегда помните о запятых!

# Кортежи, множественное присваивание и обмен значениями
	 Благодаря тому, что кортежи легко собирать и разбирать, в Python удобно делать такие вещи, как множественное присваивание. Смотрите:
'''
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3

// Используя множественное присваивание, можно провернуть интересный трюк: обмен значениями между двумя переменными. Вот код:

a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100

'''
Cтрочку (a, b) = (b, a) нужно понимать как "присвоить в а и b значения из кортежа, состоящего из значений переменных b и a".

# Ссылки
	 Кортеж https://ru.wikipedia.org/wiki/Кортеж_(информатика)
'''


>>>>>> История развития языка Python <<<<<<

'''
Итак, мы учимся языку Python. Для начала стоит определиться с названием. Правильно говорить "Пайтон" с ударением на первом слоге — язык назван в честь известного комедийного шоу "Летающий Цирк Монти Пайтона", т.е. Пайтон — это фамилия, а фамилию человека принято произносить так, как это делает носитель фамилии!

	 Ещё пара сухих фактов:

Первый релиз интерпретатора языка Python был представлен в далёком 1991г,
Автор языка — Гвидо ван Россум.
	 Сам по себе язык — это не то же самое, что его интерпретаторы. Но основная реализация языка — CPython — настолько распространена, что почти всегда, когда мы слышим "Python", подразумевается именно она. Наши курсы тоже будут касаться именно CPython, это стоит иметь в виду!

# Самое начало
	 Python появился, чтобы заменить собой язык ABC, в работе над которым принимал участие будущий автор пайтона Гвидо ван Россум. Представленный в 1991 году Python версии 0.9.0 вобрал в себя многие идеи из существовавших на тот момент языков: например, взяв систему модулей из языка Modula-3. Элементы функционального программирования (их мы будем изучать в следующих курсах!) — функции map, filter, reduce — появились в языке тоже довольно рано, в версии 1.0.

	 Стоит отметить, что Пайтон изначально позиционировался как "язык для каждого", поэтому большой упор делался на читаемость кода и лаконичность синтаксиса. В версии 2.0 появились знаменитые "списковые включения" ("list comprehensions"), позаимствованные из языков SETL и Haskell. В этой же версии сборщик мусора (механизм автоматического управления памятью) научился работать с циклическими структурами. С ними мы также познакомимся в последующих курсах.

# Py2 vs Py3
	 Python, как язык, непрерывно развивается с самого начала времени своего существования. На данный момент в основном используются версии языка, начинающиеся с "3".

	 Первый релиз "третьего пайтона" (python3, py3) вышел ещё в 2008 году, но переход на это семейство версий со "второго пайтона" (python2, py2) происходил (кое-где всё ещё происходит!) "со скрипом". Дело в том, что py3 не полностью обратно совместим с кодом, написанным для py2, т.е. мы не можем просто заменить интерпретатор — нам потребуется внести определённые изменения в код! На такой шаг можно пойти, если наш проект — живой. Но с проектами, находящимися в состоянии "только поддержка" (такие проекты ещё называют legacy), такой фокус не пройдёт — обычно просто некому заниматься адаптацией. А ведь legacy-проекты — это не всегда лишь конечные приложения, в такой ситуации могут оказаться и библиотеки. Именно из-за невозможности отказаться от нужных, но существующих в состоянии legacy, библиотек многие проекты долго оставались несовместимыми с py3.

	 К счастью, сейчас большая часть библиотек, достаточно популярных и полезных в повседневной жизни разработчика, успешно переведена на py3, и новые проекты нужно делать именно на какой-то из версий этого семейства (сейчас рекомендуемая версия — это Python 3.7.x). Более того, py2 скоро перестанет быть безопасным для широкого использования! Дело в том, что техническая поддержка py2 — т.е. устранение уязвимостей и критических ошибок — с 2020г перестанет осуществляться. А мы ведь не хотим подвергать угрозе свои детища!

# Системный Python
	 Работая с Python, стоит иметь в виду, что Python распространён не только в виде языка, на котором пишутся конечные проекты: этот язык часто используется для автоматизации различных задач, скажем, по системному администрированию (Ansible — один из примеров написанного на Python ПО, используемого при администрировании). Поэтому python часто уже присутствует в установленных операционных системах.

	 Особенно велика вероятность обнаружить в системе установленный Python, когда речь идёт об ОС семейства Linux — а именно, какая-то из версий Linux будет скорее всего установлена на машину, на которой вы захотите запустить сервер своего web-приложения или многопользовательской игры (да, такие тоже пишут на Python!). Тут-то и кроется проблема: установленный вместе с операционной системой Python может быть тем самым "вторым пайтоном" — да, такое, увы, пока встречается. И заменить его будет нельзя, ведь замена может привести к выходу из строя всей ОС.

	 Но не пугайтесь, в курсе про настройку окружения вы узнаете, как использовать в проекте нужную версию Python и не бояться сломать что-то другое!
'''

'''*@@@
	 src/solution.py
Реализуйте функцию sort_pair, которая принимает пару (кортеж из двух значений) и возвращает пару, значения которой расположенны строго в порядке возрастания.

	 Пример:
'''

# обратите внимание на скобки у аргумента функции
sort_pair((5, 1)) == (1, 5)
sort_pair((2, 2)) == (2, 2)
sort_pair((7, 8)) == (7, 8)


// FILE /app/src/solution.py:
def sort_pair(pair):
    (first, second) = pair
    if first > second:
        return (second, first)
    return pair


'''*@@@
	 src/package/__init__.py
Дан пакет следующей структуры:

$ tree package
package/
├── __init__.py
├── functions.py
└── names.py
Добавьте в __init__.py блок импортов таким образом, чтобы можно было импортировать package и получить доступ

к константе NAME из package.names
к функции greet из package.functions
Если задание будет выполнено успешно, то следующий код должен будет работать:
'''

from package import greet, NAME

greet(NAME)  # 'Hello, Bob!'


// FILE: /app/src/__init__.py:
from package.names import NAME
from package.functions import greet


// FILE: /app/src/functions.py:
def greet(name):
    return 'Hello, {}!'.format(name)

// FILE: /app/src/names.py:
NAME = 'Bob'




'>>>>>> HTTP <<<<<<

'''
Популярный вопрос на собеседовании веб-разработчиков часто звучит так: «Что происходит после того, как в браузер ввели адрес сайта?». Подробный ответ на этот вопрос можно найти здесь. Главное, что хочет услышать собеседующий — ваш уровень понимания HTTP (Hyper-Text Transferring Protocol).

Для начала пару слов о том, что такое протокол. Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. HTTP — это набор правил, который известен и вашему компьютеру и физически отдалённому компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передаётся информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
'''
$ curl --head -v code-basics.ru
	 * Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
	 * Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
	 > User-Agent: curl/7.54.0
	 > Accept: *'''
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

'''
http нужно не просто знать, но и уметь делать сырые http-запросы — не косвенно через браузер, а самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.

# Для чего требуется знание http?
	 Работа с формами, загрузка файлов, перенаправления.
	 Аутентификация целиком зависит от http.
	 Извлечение информации о запросе (например, определение браузера, из которого был выполнен запрос).
Увеличение производительности. Кеширование.
	 Обеспечение безопасности. http — текстовый протокол без шифрования, он не безопасен.

# https
	 Кроме http, в сети всё большее распространение получает https. Каждый пользователь сети должен знать, что нельзя выполнять действия, связанные с любыми секретными данными (например кредитками), на страницах, работающих по протоколу http. В таком случае любой человек, имеющий доступ к оборудованию, которое лежит между вами и сервером, обслуживающим сайт, сможет прочитать эти данные. Обратите внимание, что на популярных сайтах страницы оплаты всегда отдаются по https. В свою очередь, умение работать с https сразу добавляет новые понятия:

Шифрование, асимметричное шифрование
Сертификаты
Цифровая подпись

# TCP/IP
Но одним http обойтись не получится. Дело в том, что http существует не сам по себе, а поверх стека протоколов TCP/IP. Базовое знание сетей важно по следующим причинам:

Безопасность. Очень легко совершить ошибку и быть взломанным.
	 Отладка. Немалая часть вопросов запуска и конфигурирования сайтов и их частей (в том числе базы данных) связана с сетевыми сокетами. Не зная сети вы будете останавливаться на любой простейшей проблеме без понимания, что вообще делать.

# DNS
	 Ещё один столп веба — DNS, служба доменных имён. Каждый раз, когда мы вбиваем адрес в браузер, он выполняет DNS запросы к соответствующим серверам для выяснения того, какой ip-адрес принадлежит сайту. Дело в том, что соединение с сервером идёт по tcp/ip, а не по http. http начинает работать уже после того, как было установлено tcp соединение. Знание DNS важно по следующим причинам:

Зная DNS вы сможете не только купить домен, но и привязать его к вашему серверу
Почта для домена, верификация вашего проекта различными сервисами — всё это работает через возможности DNS
Опять же, отладка. Нередко проблемы загрузки связаны с DNS.
'''<?

####### Python #######

#@ Документация
'''
Документация на русском (неофициальная, неполная) https://pythoner.name/documentation/reference
Документация на английском (официальная, полная) https://docs.python.org/3/
'''

#@ Типы данных и переменные

# числа

number1 = 42
number2 = -1000.005

# строки

string1 = "string"
string2 = 'string (another)'
long_string = '''very
"long" string with various 'quotes'
inside'''

# логические значения

x = True
y = False


#@ Преобразование типов
one = int('234')
two = str(34)


#@ Операции

# Арифметические операции
1 + 5 - 8 * 3 / 2 % 4

# Логические операции
True or False and not True

# Создание переменных
string = 'i am a string'

# Обращение к символам строки
string[0]  # i
print("-> {}".format(string))  # -> i am a string
print('-> ' + string)          # -> i am a string


# Условные конструкции
if a > b:
    print('a больше, чем b')
elif a == b:
    print('a равен b')
else:
    print('a меньше, чем b')

result = 'yes' if a > b else 'no'


# Циклы
i = 1
while i <= 10:
    i = i + 1
    print(i)
    if i > 5:
        break


# Функции

# Определение функции
def get(string, index=0):
    return string[index]

# Вызов функции
get('lala', 3)

'''
src/solution.py
Реализуйте функцию binary, которая возвращает двоичное представление десятичного числа в виде строки.

	 Алгоритм
Перевод числа из десятичной системы в двоичную делается по следующему алгоритму:

Исходное число (number) делится пополам.
	 Остаток от деления (modulo) записывается в начало строки (result).
	 Исходным числом становится число полученное по формуле: number // 2.
Если исходное число (number) больше нуля, то повторяем с первого пункта.
	 Если исходное число равно нулю, то возвращаем (result).

	 10 / 2  5 0
 5 / 2  2 1
 2 / 2  1 0
          1
-> 1010

Примеры

binary(0)  # '0'
binary(1)  # '1'
binary(5)  # '101'


Подсказки
Перед добавлением в строку числа нужно превратить в строки str(modulo)
'''

// FILE: /app/src/solution.py
def binary(number):
    if not number:
        return '0'
    binary_number = ''
    while number:
        bit = number % 2
        binary_number = str(bit) + binary_number
        number = number // 2
    return binary_number


// FILE: /app/tests/test_solution.py
import unittest

import solution


class TestBinary(unittest.TestCase):

    cases = [
        ['0', 0],
        ['1', 1],
        ['101', 5],
        ['110', 6],
        ['1011', 11],
        ['1100101', 101],
        ['100100101001', 2345],
    ]

    def test_cases(self):
        for expectation, argument in self.cases:
            self.assertEqual(1, 1)



'''*@@@
	 src/solution.py
Реализуйте и функцию is_power_of_three, которая определяет, является ли переданное число натуральной степенью тройки. Например, число 27 — это третья степень: 3 ** 3, а 81 — это четвёртая: 3 ** 4.

	 >>> is_power_of_three(1)
True
>>> is_power_of_three(2)
False
>>> is_power_of_three(9)
True
 '''

def is_power_of_three(number):
    counter = 1  # 3 ** 0
    while counter < number:
		  counter *= 3
    return counter == number
	
		 
		 
	
>>>>>> Отладка <<<<<<

'''
Один из наиболее достоверных способов убедиться в том, что человек разбирается в программировании — посмотреть на то, как он отлаживает программу, то есть анализирует возникающие ошибки и устраняет их. Навык отладки (дебага, debug) не появляется сам по себе, его необходимо развивать и начинать это делать нужно как можно раньше. Этому весьма способствует настройка локальной среды разработки и повторение всего того, что делается в курсах, у себя на компьютере. Следующие курсы как раз помогают проделать эти шаги.

	 Первое, что вам понадобится для отладки — это хотя бы минимальное знание английского языка и умение пользоваться словарём. В отличие от документации языка, которую можно найти на русском, сообщения об ошибках будут всегда написаны на английском. Не пытайтесь отгадывать или менять код методом тыка в надежде, что он заработает. Прочитайте сообщение об ошибке, поймите его. Понимание — это ключевое действие, на основе которого можно планировать дальнейшие шаги.

	 Traceback (most recent call last):
  File "users.py", line 4, in <module>
    main()
  File "users.py", line 2, in main
    create()
NameError: name 'create' is not defined


Вывод ошибок делится на две части: непосредственно сообщение об ошибке и трейсбэк (traceback). Traceback — это список всех вызовов функций от запуска программы вплоть до того места, где произошла ошибка. Трейсбэк — очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа и какие функции вызывались. Отладка всегда сводится к двум вещам:

1. Перевести сообщение об ошибке
2. Найти в трейсбэке то место в своем коде, в котором произошла ошибка.

	 Каждая запись в трейсбэке представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. В рамках одного трейсбэка возможны (и часто встречаются) ситуации, когда часть функций вызывается где-то в библиотеках, которые вы не писали, но используете, а часть — в вашем коде.

# Типы ошибок
	 Наиболее простые и понятные ошибки — синтаксические. Они связаны исключительно с тем, что код записан неверно, например, забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствует фраза "SyntaxError: …". Для их исправления нужно открыть то место в коде, на которое указывает ошибка, и внимательно на него посмотреть.

	 Traceback (most recent call last):
  File "users.py", line 2
    print("Hello" + "world')
                           ^
SyntaxError: EOL while scanning string literal


Ещё одна большая группа ошибок называется ошибками программирования. К ним, например, относятся:

- вызов несуществующей функции
- использование необъявленной переменной
- передача неверных аргументов в функции, например, аргументов, имеющих неверный тип

Эти ошибки исправить труднее, чем синтаксические. Обычно они возникают в результате неправильной логики в другом, более раннем вызове.

Последний тип ошибок — логические ошибки. Исправить такие ошибки бывает крайне сложно, так как программа продолжает работать, но выдаёт неверный результат. Причём, обычно программа выдаёт неверный результат не всегда, а только лишь для некоторых входных данных. В подавляющем большинстве случаев проблема кроется в неверной логике: скажем, если перепутана операция, и вместо сложения выполняется вычитание.
'''
# Функция должна считать сумму чисел, но считает разность:
def sum(a, b):
    return a - b

# при таком вызове ошибка неочевидна, потому что
# и при сложении и при вычитании будет один и тот же результат
sum(4, 0)  # 4

# Отладка

'''
Существует множество способов отладки программ. Но какой бы способ вы не выбрали, общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.

Рассмотрим конкретный пример. Ниже описана функция, которая считает сумму чисел от числа start до числа finish. Если начало равно трём, а конец — пяти, то программа должна вычислить: 3 + 4 + 5.
'''
def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        result += n
        n += 1
    return result

'''
В этом коде допущена ошибка. Вы её видите? Если очень постараться, ошибку можно заметить, но на это никогда не стоит надеяться. Новички часто думают, что они невнимательны, и очень расстраиваются, когда допускают такие ошибки. Хочу вас успокоить: опытные разработчики допускают такие ошибки не реже новичков. Важно не то, что вы их допускаете, а то, что вы способны отладить этот код (и сделать это быстро). Этим отличаются опытные разработчики от начинающих. Никогда не пытайтесь найти ошибку с помощью "медитации" над кодом, сверля его взглядом. Если быстрая проверка не дала ответа, то приступайте к отладке.

На Хекслете, в обсуждении уроков, ученики часто нам пишут: "этот код не работает", и показывают свой код. Вероятно, начинающие разработчики думают, что опытные могут понять, в чём ошибка и найти её, просто посмотрев на код. Но это совсем не так. Глядя на такой код, невозможно понять, а что, собственно, пошло не так. И я уже не говорю про нахождение самой ошибки. Нам также нужно увидеть сообщение об ошибке и начать отладку.

Глядя на код функции sum_of_series замечаем, что основных переменных там две: n и result — именно они меняются в цикле. Из этого можно сделать ровно один вывод: нужно явно посмотреть, какие значения им даются на каждой итерации. После этого найти ошибку не составит труда.

Один из способов отслеживать значения переменных во время выполнения кода связан с использованием специальных программ-отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживая любые изменения. Подробнее о том, как их использовать можно прочитать во множестве статей (гуглить "python pdb").
'''

# Отладочная печать

'''
В среде Хекслета отладчика нет, поэтому здесь используется другой подход (но выполняющий ту же задачу) — отладочная печать. Суть такая же, как и в визуальном отладчике, но для вывода значений переменных используется обычная печать на экран:
'''

def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        print('new iteration !!!!')
        print(n)
        result += n
        n += 1
        print(result)
    return result

sum_of_series(3, 5)

# new iteration !!!!
# 3
# 3
# new iteration !!!!
# 4
# 7

'''
То, что печатается на экран, отображается во вкладке OUTPUT, на которую автоматически переключается редактор во время проверки. Из этого вывода сразу можно понять, что итераций цикла на одну меньше, чем нужно. Почему-то не выполняется сложение для последнего числа, которое обозначено как finish. И действительно, если посмотреть на определение, то видно, что там используется n < finish вместо n <= finish.

# Дополнительные материалы
Как найти ошибки в коде? https://help.hexlet.io/article/7-how-to-debug-code
pdb — The Python Debugger https://docs.python.org/3/library/pdb.html
'''



>>>>>> Модули <<<<<<

'''
Программы на Python содержат тысячи, десятки тысяч и сотни тысяч строк кода (есть проекты с миллионами). В таких условиях одним файлом с кодом не обойдёшься — его нужно разбивать на части. Для получения доступа к коду, который находится в других файлах, в Python реализован механизм модулей.

# Модули и импортирование
Итак, файл с кодом на Python называется модулем. Имя модуля соответствует имени файла, поэтому файлы в Python принято называть в стиле "snake_case" (отметьте иронию: Python — питон — змея — snake — snake_case). Одни модули могут использовать содержимое других, если импортируют эти другие модули с помощью инструкции import.

Строго говоря, в Python импортировать модули можно несколькими способами:

импортировать сам модуль
импортировать отдельные определения из модуля
импортировать всё содержимое модуля сразу


# Импортирование модуля

Рассмотрим применение первого способа — импортирование модуля целиком. Главное удобство упоминания модуля по имени: глядя на код, мы сразу видим, что используемая переменная или вызываемая функция — это часть модуля.

Синтаксис импорта: import <имя_модуля (без суффикса ".py")>

Всё просто: после ключевого слова import указываем имя модуля (файла). Но при этом суффикс .py в имени надо опустить. То есть, к примеру, для модуля с именем my_module.py в инструкции импорта достаточно прописать my_module, а полный вид инструкции будет таким: import my_module.

В модуле (файле) с именем greeting.py определим функцию say_hi и переменную name:
'''

# file: greeting.py
def say_hi():
    print('Hi!')

name = 'Bob'

// А в модуле с именем main.py сделаем импорт содержимого модуля greeting.py:

# file: main.py
import greeting  # заметьте, расширение ".py" не указывается!

print(greeting.name)  # => Bob
greeting.say_hi()     # => Hi!

'''
Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это greeting. К содержимому же модуля можно обратиться, как говорят, "через точку". Причём можно как получить доступ к переменным (greeting.name), так и вызывать функции модуля (greeting.say_hi).

# Импортирование отдельных определений

Синтаксис импорта: from <имя_модуля (без суффикса ".py")> import <список определений>

Иногда из всего модуля нужна пара функций или переменных, а имя модуля слишком длинное, чтобы писать его каждый раз. Здесь нам может пригодиться следующий вариант использования инструкции import:
'''

# file: main.py
from greeting import say_hi, name

print(name)  # используем переменную
say_hi()     # вызываем функцию

'''
Здесь после ключевого слова from указано имя модуля, а затем после ключевого слова import — имена определений из этого модуля, которые мы в дальнейшем хотим использовать напрямую (а не "через точку").

В следующем уроке мы рассмотрим третий вариант импортирования модуля ("импорт всего содержимого") и в целом немного углубим наши познания в этой теме.
'''




>>>>>> Модули поглубже <<<<<<

'''
Продолжим знакомиться с системой модулей языка Python. Но для начала…

# Немного терминологии
В предыдущем уроке несколько раз встречалось словосочетание "через точку". Так часто говорят для краткости. Однако для такой формы записи имён определений (module.name) существует и официальный термин: квалифицированное имя от слова "квалифицировать" ("qualify"). Соответственно, "импорт модуля целиком" (см. прошлый урок) официально называется квалифицированным импортом.

Также стоит отметить, что в Python все строчки с import принято располагать в самом начале кода модуля. Такой набор строчек часто называют "блок импортов", хотя синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой. Нужна эта группировка во многом для того, чтобы можно было быстро найти, что в текущем модуле откуда пришло — при работе с чужим (и даже своим!) кодом подобным часто приходится заниматься.

# Импорт всего содержимого модуля
Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:
'''
from some_module import *
from another_module import *

'''
Здесь из модулей some_module и another_module импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за *!

Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.

# Сочетание способов импортирования
Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!

Давайте рассмотрим пример.

В модуле computation.py определим функцию и переменные:
'''

# file: computation.py
PI = 3.1415926
E = 2.7182818

def pi_times(x):
    return x + PI

// А в модуле main.py сделаем разными способами импорты из модуля computation.py:

# file: main.py
import computation
from computation import PI, E
from computation import pi_times

print(PI)
print(computation.E)
print(pi_times(2))
print(computation.pi_times(E))

'''
Из кода видно, что:

оба способа импорта использованы совместно
импортировать отдельные определения можно в несколько заходов
если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы
'''

>>>>>> Пакеты <<<<<<

'''
Мы уже знаем, что в Python код хранится в отдельных файлах, называемых модулями. Но если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько модулей "по смыслу". Или же мы захотим вынести часть модулей из проекта с целью использования оных в других проектах. Для объединения модулей в группы и служат пакеты (packages).

Итак, пакет — это папка (далее "каталог") с файлами модулей, имеющая имя в формате "snake_case" и содержащая, помимо прочего, специальный модуль с именем "__init__.py". Именно наличие этого специального файла подсказывает интерпретатору Python, что каталог следует воспринимать именно как пакет.

# Простейший пакет

Давайте рассмотрим пример простейшего пакета. Пусть пакет состоит из каталога package и модуля __init__.py внутри этого каталога:

package/
└── __init__.py
Файл __init__.py пусть содержит код:
'''

# file __init__.py
NAME = 'super_package'

// Это, хотя и небольшой, но уже полноценный пакет. Его можно импортировать так же, как мы импортировали бы модуль:

import package

print(package.NAME)

'''
Заметьте — мы не импортировали файл __init__.py непосредственно. При первом обращении к пакету Python автоматически импортирует модуль __init__.py в этом пакете. Поэтому, очевидно, нельзя импортировать "просто каталог" — ведь каталог без файла __init__.py не будет полноценным пакетом!

# Содержимое пакета
С простым пакетом всё ясно — его можно использовать как модуль. Но давайте уже перейдём к группировке в пакете нескольких модулей! Для этого в пакет положим ещё два модуля:

package/
├── constants.py
├── functions.py
└── __init__.py
Содержимое модуля constants.py:
'''
# file constants.py
PERSON = 'Alice'

// Содержимое модуля functions.py:
# file functions.py
def greet(who):
    print('Hello, ' + who + '!')

// Когда пакет содержит другие модули, кроме __init__.py, таковые можно импортировать по их именам. В главе про модули упоминались два варианта импортирования: квалифицированный импорт и импортирование отдельных определений. Квалифицированный импорт в данном случае будет выглядеть так:

import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

// Этот вариант самый понятный: в строчке вызова функции greet сразу видно, откуда пришла функция, а откуда — её аргумент. Но писать имя пакета и имя модуля каждый раз — утомительно! Давайте импортируем сами функцию и аргумент:

from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!

// Так строчка вызова функции выглядит гораздо лучше! Но помните, что тому, кто будет читать этот код в дальнейшем, потребуется посмотреть в блок импортов, чтобы узнать, откуда функция и константа появились.

>>>>>>>> Модуль random <<<<<<<<
'''
Python знаменит тем, что поставляется в комплекте с "батарейками" - так называют модули и пакеты, составляющие стандартную библиотеку. Более того, батареек в поставке Пайтона изрядное количество! Настоящий питонист (pythonista) - так мы, программисты на Python, себя называем - обязан хорошо ориентироваться в стандартной библиотеке, ведь это знание позволяет экономить время и силы. В этом уроке мы познакомимся с первой батарейкой - модулем random.

При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из некоего множества значение. Случайные значения полезны, когда мы разрабатываем компьютерные игры, генерируем изображения и звук, и даже просто пишем тесты.

Любое значение в компьютере может быть представлено в виде набора чисел, поэтому получение случайных значений всегда предполагает использование Генератора Случайных Чисел, ГСЧ. ГСЧ бывают программными (специализированные программы) и аппаратными (специализированные устройства), но программист обычно работает с некоторой обобщённой "обёрткой" - модулем или пакетом, который скрывает ненужные детали.

Модуль random предоставляет множество функций, полезных в разных ситуациях, но мы пока остановимся на двух:

randint, генерация целого числа в заданном диапазоне,
choice, выбор случайного элемента из заданного набора.

# Генерация случайных чисел
Для того, чтобы сгенерировать случайное число, нам нужно импортировать функцию randint из модуля random:
'''
from random import randint

// Теперь мы можем сгенерировать число от 1 до 100:
random_number = randint(1, 100)

// При вызове randint с такими границами диапазона может "выпасть" и 1 и 100 - обе границы диапазона включены и об этом следует помнить. Когда это может быть важно? Давайте рассмотрим другой пример - выбор случайного символа некоторой строки:

string = 'abcde'
random_index = randint(0, len(string) - 1)
char = string[random_index]

'''
Строка в переменной string имеет длину 5. Но мы помним, что символы строки индексируются с нуля, поэтому если сгенерировать индекс так randint(0, 5), то в какой-то момент мы получим значение 5 и при попытке взять символ по этому индексу мы увидим ошибку IndexError: индекс последнего элемента в строке равен 4! Вот поэтому в коде выше из длины вычитается единица.

# Выбор случайного элемента
Выше мы рассмотрели пример, в котором выбирался случайный символ строки. Эта задача возникает достаточно часто, поэтому в модуле random существует функция choice. С использованием этой функции выбор символа строки будет выглядеть так:
'''

from random import choice

string = 'abcde'
char = choice(string)

'''
При использовании choice не нужно думать о границах генерируемых индексов. И даже о самих индексах думать не нужно - функция сама знает, как правильно и безопасно выбирать элементы! Правда, придётся заботиться о том, чтобы строка, из который мы выбираем символы, не была пустой, иначе мы получим ошибку IndexError: Cannot choose from an empty sequence ("Нельзя просто так взять и выбрать, если выбирать не из чего").

Пока мы можем использовать choice только со строками, ведь это единственный тип, значения которого могут содержать несколько элементов. Но в дальнейшем мы познакомимся и с другими составными типами - и с многими из таких типов функция choice тоже может работать!

# Случайна ли случайность?
Строго говоря, генерируемые числа у компьютера получаются не полностью случайными, поэтому большинство ГСЧ представляют собой генераторы псевдослучайных чисел. И хотя для простоты приставку "псевдо-" часто опускают (как поступили и мы), о ней не стоит забывать. Дело в том, что некоторые алгоритмы требуют максимально случайной генерации чисел. Одна из областей с такими высокими требованиями к качеству случайности — криптография (шифрование). Представьте, что вы сгенерировали случайный пароль, длинный и сложный, а злоумышленник, пользуясь тем, что при определённых условиях можно воспроизвести ту же последовательность случайных чисел, получил тот же пароль! Вот поэтому существует большое количество специализированных ГСЧ, безопасных для использования в шифровании и создание таких генераторов - это важная, сложная и интересная работа.

# Ссылки
Модуль random https://docs.python.org/3.6/library/random.html
ГСЧ https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел
'''

>>>>>> Кортежи <<<<<<<
'''
До этого момента мы встречались только с примитивными типами — строка, число, булев тип. Ещё нам знакомы функции и модули с пакетами (да, в Python модули и пакеты, это тоже значения специальных встроенных типов). Но часто в программировании приходится создавать более сложные, чем числа и строки, значения и манипулировать такими значениями. Именно поэтому во многих языках программирования есть составные типы. Значение составного типа может состоять как из значений примитивных типов, так и из значений других составных типов, таким образом составные типы позволяют описывать сущности произвольной сложности — и шахматные доски, и космические ракеты!

В этом уроке мы познакомимся с самым простым, но очень полезным составным типом — кортежем (в англоязычных текстах оный известен, как tuple).

# Кортежи
Кортеж — это несколько значений, записанных через запятую. Да, всё очень просто! Вот несколько примеров:
'''
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

'''
Определять кортежи очень просто, сложности могут возникнуть только с кортежами, содержащими ровно один элемент. Если мы просто укажем значение в скобках, то Python подумает, что мы хотим посчитать арифметическое выражение со скобками:
'''
not_a_tuple = (42)  # 42

// Чтобы сказать пайтону, что мы хотим создать именно кортеж, нужно поставить после элемента кортежа запятую:

tuple = (42,)  # (42,)

'''
Да, форма записи довольно необычная, но вы привыкнете :)

# Возврат нескольких значений из функции
Кортежи очень полезны, когда нам нужно вернуть из функции сразу несколько значений. Так, функция, которая принимает два аргумента-числа и возвращает одновременно результат деления нацело и остаток от деления, будет выглядеть так:
'''

def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)

'''
# Получение элементов кортежа по индексу
Выше мы только создавали кортежи. Теперь научимся их разбирать! В простейшем случае достаточно обратиться к элементу кортежа по индексу:
'''

name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

// Также у кортежа есть длина, которую, как и для строки, можно получить с помощью функции len:

tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2

'''
# Деструктуризация
Обращение по индексу, это не самый удобный способ работы с кортежами. Дело в том, что кортежи часто содержат значения разных типов, и помнить, по какому индексу что лежит — очень непросто. Но есть способ лучше! Как мы кортеж собираем, так его можно и разобрать:
'''

name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42

'''
Именно таким способом принято получать и сразу разбирать значения, которые возвращает функция (если таковая возвращает несколько значений, конечно):
'''
(quotient, modulo) = div_mod(13, 4)

// Соответственно кортеж из одного элемента нужно разбирать так:
(a,) = (42,)
a  # 42

'''
Если же после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную a кортеж запишется целиком, т.е. ничего не распакуется! Всегда помните о запятых!

# Кортежи, множественное присваивание и обмен значениями
Благодаря тому, что кортежи легко собирать и разбирать, в Python удобно делать такие вещи, как множественное присваивание. Смотрите:
'''
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3

// Используя множественное присваивание, можно провернуть интересный трюк: обмен значениями между двумя переменными. Вот код:

a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100

'''
Cтрочку (a, b) = (b, a) нужно понимать как "присвоить в а и b значения из кортежа, состоящего из значений переменных b и a".

# Ссылки
Кортеж https://ru.wikipedia.org/wiki/Кортеж_(информатика)
'''


>>>>>> История развития языка Python <<<<<<

'''
Итак, мы учимся языку Python. Для начала стоит определиться с названием. Правильно говорить "Пайтон" с ударением на первом слоге — язык назван в честь известного комедийного шоу "Летающий Цирк Монти Пайтона", т.е. Пайтон — это фамилия, а фамилию человека принято произносить так, как это делает носитель фамилии!

Ещё пара сухих фактов:

Первый релиз интерпретатора языка Python был представлен в далёком 1991г,
Автор языка — Гвидо ван Россум.
Сам по себе язык — это не то же самое, что его интерпретаторы. Но основная реализация языка — CPython — настолько распространена, что почти всегда, когда мы слышим "Python", подразумевается именно она. Наши курсы тоже будут касаться именно CPython, это стоит иметь в виду!

# Самое начало
Python появился, чтобы заменить собой язык ABC, в работе над которым принимал участие будущий автор пайтона Гвидо ван Россум. Представленный в 1991 году Python версии 0.9.0 вобрал в себя многие идеи из существовавших на тот момент языков: например, взяв систему модулей из языка Modula-3. Элементы функционального программирования (их мы будем изучать в следующих курсах!) — функции map, filter, reduce — появились в языке тоже довольно рано, в версии 1.0.

Стоит отметить, что Пайтон изначально позиционировался как "язык для каждого", поэтому большой упор делался на читаемость кода и лаконичность синтаксиса. В версии 2.0 появились знаменитые "списковые включения" ("list comprehensions"), позаимствованные из языков SETL и Haskell. В этой же версии сборщик мусора (механизм автоматического управления памятью) научился работать с циклическими структурами. С ними мы также познакомимся в последующих курсах.

# Py2 vs Py3
Python, как язык, непрерывно развивается с самого начала времени своего существования. На данный момент в основном используются версии языка, начинающиеся с "3".

Первый релиз "третьего пайтона" (python3, py3) вышел ещё в 2008 году, но переход на это семейство версий со "второго пайтона" (python2, py2) происходил (кое-где всё ещё происходит!) "со скрипом". Дело в том, что py3 не полностью обратно совместим с кодом, написанным для py2, т.е. мы не можем просто заменить интерпретатор — нам потребуется внести определённые изменения в код! На такой шаг можно пойти, если наш проект — живой. Но с проектами, находящимися в состоянии "только поддержка" (такие проекты ещё называют legacy), такой фокус не пройдёт — обычно просто некому заниматься адаптацией. А ведь legacy-проекты — это не всегда лишь конечные приложения, в такой ситуации могут оказаться и библиотеки. Именно из-за невозможности отказаться от нужных, но существующих в состоянии legacy, библиотек многие проекты долго оставались несовместимыми с py3.

К счастью, сейчас большая часть библиотек, достаточно популярных и полезных в повседневной жизни разработчика, успешно переведена на py3, и новые проекты нужно делать именно на какой-то из версий этого семейства (сейчас рекомендуемая версия — это Python 3.7.x). Более того, py2 скоро перестанет быть безопасным для широкого использования! Дело в том, что техническая поддержка py2 — т.е. устранение уязвимостей и критических ошибок — с 2020г перестанет осуществляться. А мы ведь не хотим подвергать угрозе свои детища!

# Системный Python
Работая с Python, стоит иметь в виду, что Python распространён не только в виде языка, на котором пишутся конечные проекты: этот язык часто используется для автоматизации различных задач, скажем, по системному администрированию (Ansible — один из примеров написанного на Python ПО, используемого при администрировании). Поэтому python часто уже присутствует в установленных операционных системах.

Особенно велика вероятность обнаружить в системе установленный Python, когда речь идёт об ОС семейства Linux — а именно, какая-то из версий Linux будет скорее всего установлена на машину, на которой вы захотите запустить сервер своего web-приложения или многопользовательской игры (да, такие тоже пишут на Python!). Тут-то и кроется проблема: установленный вместе с операционной системой Python может быть тем самым "вторым пайтоном" — да, такое, увы, пока встречается. И заменить его будет нельзя, ведь замена может привести к выходу из строя всей ОС.

Но не пугайтесь, в курсе про настройку окружения вы узнаете, как использовать в проекте нужную версию Python и не бояться сломать что-то другое!
'''

'''*@@@
src/solution.py
Реализуйте функцию sort_pair, которая принимает пару (кортеж из двух значений) и возвращает пару, значения которой расположенны строго в порядке возрастания.

Пример:
'''

# обратите внимание на скобки у аргумента функции
sort_pair((5, 1)) == (1, 5)
sort_pair((2, 2)) == (2, 2)
sort_pair((7, 8)) == (7, 8)


// FILE /app/src/solution.py:
def sort_pair(pair):
    (first, second) = pair
    if first > second:
        return (second, first)
    return pair


'''*@@@
src/package/__init__.py
Дан пакет следующей структуры:

$ tree package
package/
├── __init__.py
├── functions.py
└── names.py
Добавьте в __init__.py блок импортов таким образом, чтобы можно было импортировать package и получить доступ

к константе NAME из package.names
к функции greet из package.functions
Если задание будет выполнено успешно, то следующий код должен будет работать:
'''

from package import greet, NAME

greet(NAME)  # 'Hello, Bob!'


// FILE: /app/src/__init__.py:
from package.names import NAME
from package.functions import greet


// FILE: /app/src/functions.py:
def greet(name):
    return 'Hello, {}!'.format(name)

// FILE: /app/src/names.py:
NAME = 'Bob'




'>>>>>> HTTP <<<<<<

'''
Популярный вопрос на собеседовании веб-разработчиков часто звучит так: «Что происходит после того, как в браузер ввели адрес сайта?». Подробный ответ на этот вопрос можно найти здесь. Главное, что хочет услышать собеседующий — ваш уровень понимания HTTP (Hyper-Text Transferring Protocol).

Для начала пару слов о том, что такое протокол. Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. HTTP — это набор правил, который известен и вашему компьютеру и физически отдалённому компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передаётся информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
'''
$ curl --head -v code-basics.ru
* Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
* Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
> User-Agent: curl/7.54.0
> Accept: *'''
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

'''
http нужно не просто знать, но и уметь делать сырые http-запросы — не косвенно через браузер, а самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.

# Для чего требуется знание http?
Работа с формами, загрузка файлов, перенаправления.
Аутентификация целиком зависит от http.
Извлечение информации о запросе (например, определение браузера, из которого был выполнен запрос).
Увеличение производительности. Кеширование.
Обеспечение безопасности. http — текстовый протокол без шифрования, он не безопасен.

# https
Кроме http, в сети всё большее распространение получает https. Каждый пользователь сети должен знать, что нельзя выполнять действия, связанные с любыми секретными данными (например кредитками), на страницах, работающих по протоколу http. В таком случае любой человек, имеющий доступ к оборудованию, которое лежит между вами и сервером, обслуживающим сайт, сможет прочитать эти данные. Обратите внимание, что на популярных сайтах страницы оплаты всегда отдаются по https. В свою очередь, умение работать с https сразу добавляет новые понятия:

Шифрование, асимметричное шифрование
Сертификаты
Цифровая подпись

# TCP/IP
Но одним http обойтись не получится. Дело в том, что http существует не сам по себе, а поверх стека протоколов TCP/IP. Базовое знание сетей важно по следующим причинам:

Безопасность. Очень легко совершить ошибку и быть взломанным.
Отладка. Немалая часть вопросов запуска и конфигурирования сайтов и их частей (в том числе базы данных) связана с сетевыми сокетами. Не зная сети вы будете останавливаться на любой простейшей проблеме без понимания, что вообще делать.

# DNS
Ещё один столп веба — DNS, служба доменных имён. Каждый раз, когда мы вбиваем адрес в браузер, он выполняет DNS запросы к соответствующим серверам для выяснения того, какой ip-адрес принадлежит сайту. Дело в том, что соединение с сервером идёт по tcp/ip, а не по http. http начинает работать уже после того, как было установлено tcp соединение. Знание DNS важно по следующим причинам:

Зная DNS вы сможете не только купить домен, но и привязать его к вашему серверу
Почта для домена, верификация вашего проекта различными сервисами — всё это работает через возможности DNS
Опять же, отладка. Нередко проблемы загрузки связаны с DNS.
'''



############## Python: Настройка окружения ##############

'''
Мы поддерживаем репозиторий python-package https://github.com/hexlet-boilerplates/python-package — так называемую заготовку, содержащую базовую структуру нового проекта на Python. Вы всегда можете подглядывать в него и делать по аналогии.


#@ Установка Python

Ubuntu
$ sudo apt update
$ sudo apt install python3

macOS
# https://brew.sh/index_ru.html
$ brew install python

Наберите в терминале python3 --version. Вывод должен быть примерно такой:
Python 3.6.8



#@ pyenv

Совсем другой способ установки Python — утилита pyenv https://github.com/pyenv/pyenv (для пользователей Windows нужна особая версия утилиты - pyenv-win). Кроме установки любых версий Python, эта утилита позволяет удобно переключаться между версиями. Такое может быть нужно когда вы одновременно работаете над несколькими проектами, требующими разные версии Python.


#@ REPL

Python поставляется со встроенным REPL. REPL – это программа, которая работает как командная оболочка (программу REPL ещё называют интерактивным интерпретатором Python), предназначенная для ввода и выполнения кода на языке Python. Акроним REPL расшифровывается так:

Read — прочитать ввод от пользователя,
Eval — выполнить введённый код,
Print — распечатать на экран результат,
Loop — снова войти в режим ожидания.

Для запуска REPL достаточно набрать:
$ python3

Теперь можно выполнять код на Python и сразу же смотреть на результат его выполнения. Наберите любой корректный код на Python, например такой:

30 + 12

REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из REPL нужно вместо ввода кода нажать Ctrl + D.

#@ Встроенная документация

Язык Python прямо на уровне синтаксиса поддерживает дополнение кода документацией. Основным средством документирования являются так называемые "строки документации" ("docstrings"). Документированная функция выглядит так:
'''
def add(x, y):
    """Add one argument to another."""
    return x + y

'''
Из таких docstrings генерируется online-документация. А ещё эта документация доступна для просмотра прямо в REPL! Для просмотра документации служит функция help. Давайте объявим функцию add в REPL, попробуем её вызвать, а затем посмотрим описание нашей функции и нескольких встроенных.
'''



# >>>>>> Подробнее о Python <<<<<<
'''
Язык программирования

С одной стороны, языком программирования называют правила (синтаксические и семантические), по которым записывается и работает исходный код. В отличие от естественных языков, эти правила достаточно строги. Любая мельчайшая ошибка и код либо не запустится, либо запустится, но не заработает, как ожидается. Например, в Python нельзя написать my name = 5 (с пробелом в имени переменной). Эти правила существуют не только в книгах, но и в головах конкретных программистов и разработчиков языка. Часто весь свод правил, называемый спецификацией, существует в виде отдельного специального документа.

С другой стороны, языком программирования называют программу, которая непосредственно запускает (или компилирует) наш код. В предыдущем уроке мы как раз установили такую. Обычно её называют средой выполнения, иногда "рантаймом" ("runtime"), если речь идёт про интерпретацию. Среда выполнения — конкретное воплощение спецификации, по-другому называемое реализацией (или implementation). Реализаций конкретного языка может существовать несколько, но часто существует так называемая эталонная реализация (или reference implementation), на которую могут равняться другие. Различные реализации могут разрабатываться разными людьми и компаниями.

У Python нет выделенной спецификации, но есть эталонная реализация, называемая CPython (интерпретатор Python, реализованный на языке C). Если вы слышите, что кто-то говорит Python, то скорее всего имеется в виду именно эталонная реализация. Прочие же реализации обычно имеют свои названия. Например, реализация языка, предназначенная для запуска программ на платформе .NET, называется IronPython https://ironpython.net/.
'''

#@ Python

'''
Python — интерпретируемый язык программирования с сильной динамической типизацией. Разберём эти слова по отдельности.
'''

#@ Интерпретируемый

'''
У Python отсутствует стадия компиляции в машинный код, которая присутствует, скажем, у языков C, Rust, Go. Программа исполняется интерпретатором шаг за шагом, а не запускается напрямую на процессоре компьютера. Поэтому для запуска программы на Python всегда нужна среда исполнения (интерпретатор) — только она может выполнять Python-программы.

Строго говоря, у Python есть фаза компиляции, во время которой код из текста преобразуется в специальное представление, называемое "байткод" ("bytecode"), а затем уже этот байткод передаётся в интерпретатор. Но внешне Python ведёт себя именно как интерпретируемый язык программирования: интерпретатор при запуске вашей программы загружает из файлов её (программы) исходный код, преобразует для удобства в байткод (при этом проверяются ошибки синтаксиса), а дальше начинает исполнять по шагам.
'''


#@ Динамическая типизация

'''
В динамически типизированных языках проверка типов, доступности функций и переменных производится интерпретатором во время выполнения кода. Поэтому, если мы случайно ошиблись и, например, вызвали несуществующую функцию, то ошибка всплывёт только во время вызова этой функции! В статически же типизированных языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение (слово "статический" как раз означает, что программа не выполняется). Обычно статическими проверками занимаются компиляторы, но существуют и выделенные инструменты статической проверки кода, так называемые статические анализаторы кода. Для некоторых языков с динамической типизацией такие анализаторы тоже существуют, но отслеживают значительно меньшее число ошибок.
'''

#@ Сильная типизация

'''
Сильная типизация означает то, что Python старается не приводить типы (преобразовывать значения одних типов в значения других) автоматически. Это означает, что Python не даст сложить число со строкой: при попытке сделать что-то подобное мы получим ошибку. Далеко не все языки с динамической типизацией столь педантичны в силу различных причин. Но Python в этом вопросе принципиален и требует, чтобы любые преобразования типов были явными (т.е. программист использовал в каждом конкретном случае соответствующие функции-преобразователи).
'''


# >>>>>> Пакеты и индексы <<<<<<

'''
В какой-то момент разработчик понимает, что код, который он написал, может быть полезен другим. Это может быть библиотека полезных функций или готовая программа, но в любом случае автор оной обычно хочет, чтобы его творение было удобно и просто использовать. Так вот, питонисты делятся между собой кодом с помощью… пакетов!
'''

#@ Опять пакеты

'''
В рамках курса по основам Python уже упоминались пакеты (packages). Тогда пакеты описывались, как наборы модулей и вложенных пакетов. Но это не единственное значение слова "пакет" в Python-мире.

В более широком смысле пакет — это некая единица обмена кодом между разработчиками. Python-пакет содержит и исходный код (как раз в виде пакета в узком смысле, поэтому и название общее), и так называемые метаданные — дополнительную информацию о пакете. Метаданные описывают

предназначение пакета
версию пакета
совместимость с разными версиями Python
лицензию (software license), под которой распространяется пакет
список и версии зависимостей пакета (об этом поговорим позже)
и многое другое.
'''

#@ Индекс

'''
Предположим, что мы имеем готовый пакет (а мы в итоге обязательно научимся их создавать), но как им поделиться с миром? Как правило, собранный пакет представляет собой обычный файл и в принципе его можно просто передать другому человеку — это даже сработает! А если вдруг окажется, что наш пакет требует каких-то других пакетов для своей работы? Вот тут-то и начнутся сложности — нужно будет приложить к нашему пакету дополнительные пакеты, которые могут потребовать ещё больше пакетов и т.д. и т.п.

Для упрощения жизни как авторов пакетов, так и пользователей оных существуют так называемые репозитории пакетов. Только в Python их принято называть индексами. Помимо предоставления пакетов, индексы также могут обладать интерфейсом для поиска пакетов, знакомства с их описанием — проще говоря, предоставляют интерфейс пользователя (обычно в виде web-сайта).

Самый популярный индекс пакетов, это PyPI, Python Package Index. Чаще всего вы будете работать именно с ним. Но есть и другие индексы и большинство инструментов работы с пакетами могут работать с разными индексами. Отдельные индексы, к примеру, используются многими компаниями для размещения пакетов, которые не являются открытыми (open source).

Ещё один полезный индекс — Test PyPI. Это специальный индекс пакетов, который принято использовать для обучения работы с системой пакетирования Python. Ведь не очень красиво выставлять на всеобщее обозрение сотни и даже тысячи учебных пакетов: они будут попадаться в поиске, "занимать" имена, которые могли бы иметь действительно полезные пакеты, другими словами — "замусоривать" основной индекс. Тестовый индекс работает точно так же, как основной PyPI – позволяет пакеты выкладывать и скачивать – но периодически удаляет все данные.
'''

#@ Индексы vs GitHub, BitBucket и прочие хранилища кода
'''
В наши дни некоторые репозитории пакетов не хранят пакеты своими силами, а берут на себя только индексацию и управление метаданными пакетов, код же предлагается хранить на GitHub, BitBucket, GitLab, другими словами — в хранилищах исходного кода.

Такой подход в целом работает для интерпретируемых языков, ведь для того, чтобы использовать код пакета, нужно всё равно иметь доступ к исходному коду. Но хранение кода на сторонних по отношению к источнику метаданных (индексу, в случае Python) обладает рядом недостатков.

Во-первых, опубликованным кодом владеет только автор кода. Автор может даже удалить свой репозиторий, а информация о пакете в индексе сохранится. И те, кто начал использовать "сломанный" пакет, столкнутся с невозможностью сборки своих проектов.

Во-вторых, ни GitHub, ни другие хранилища Git-репозиториев не могут гарантировать неизменность данных в репозитории при использовании одних только тегов и веток — а именно такой способ привязки состояния кода к информации в индексе и используется чаще всего — ведь любой обладатель доступа к репозиторию может "переписать историю". И даже если привязывать версии пакетов в индексе к hash-суммам коммитов в Git, то изменение в истории приведёт к первой проблеме — версия пакета будет ссылаться на несуществующий источник кода (при переписывании истории hash-суммы коммитов тоже поменяются).

Обе озвученные причины приводят к тому, что ломается важное свойство системы пакетирования — воспроизводимость сборки. Воспроизводимость здесь означает, что любой проект, содержащий точное описание своих зависимостей, "соберётся" (в случае Python — запустится) в любой момент времени, даже если проект использует очень старые версии пакетов и интерпретатора!

Централизованный индекс, самостоятельно хранящий все версии всех пакетов в неизменяемом виде, даёт значительно больше гарантий, что мы сможем собрать наш старый проект, когда бы мы этого не захотели.

# Дополнительные материалы
PyPI https://pypi.org/
Test PyPI https://test.pypi.org/
'''


# >>>>>> distutils, setuptools, pip <<<<<<
'''
На прошлом уроке мы познакомились с пакетами и индексами, давайте же узнаем, как устанавливать пакеты из индекса! Для установки, обновления и удаления пакетов часто применяются так называемые пакетные менеджеры (или менеджеры пакетов). Один такой мы рассмотрим, но сначала немного поговорим о фундаменте системы пакетирования Python.
'''

#@ distutils и setuptools

'''
В поставку Python входит distutils, пакет, отвечающий за создание дистрибутивов — архивов кода, которые могут быть распакованы в целевом окружении и установлены так, чтобы интерпретатор Python "увидел" распакованный код. При создании пакета программист создаёт в корневой директории будущего пакета файл setup.py в котором импортирует из модуля distutils функцию setup и вызывает её. Таким образом каждый пакет содержит в себе программу для управления собой!

Подробнее о том, как работает distutils, можно почитать в официальной документации к пакету https://docs.python.org/3/library/distutils.html, а мы сразу двинемся дальше. Дело в том, что пакет distutils появился довольно давно и сейчас сам по себе не очень удобен в использовании. Гораздо чаще используется надстройка над distutils, пакет setuptools.

Пакеты, собранные с помощью setuptools, уже умеют предоставлять metadata: описание, версию, и самое главное — собственные зависимости! Пакеты, которые не зависят ни от чего, кроме самого Python, настолько редки, что без setuptools — можно сказать, "жизни нет". Про этот пакет стоит знать и со временем нужно будет научиться его использовать (опять же, с помощью документации), но в рамках этого курса мы будем рассматривать более простой инструмент для создания пакетов и загрузки их в индекс — poetry, с которым мы познакомимся попозже.

После того, как пакет создан и загружен в индекс, его можно скачать, распаковать во временную директорию, оттуда запустить python3 setup.py install и пакет установится. Но это слишком утомительный и непростой путь, есть способ лучше!
'''

#@ pip

'''
Каким бы способом пакет не был создан и загружен в индекс, его нужно скачивать и устанавливать, а по необходимости — и со всеми зависимостями. Сейчас этим в основном занимается специальная программа pip — The Python Package Installer.

pip — большая и сложная программа. Обо всех возможностях вы, как всегда, сможете почитать в документации https://pip.pypa.io/. Мы же рассмотрим только самую важную функцию pip — установку пакетов. В следующем уроке мы установим сам pip и с помощью него установим в окружение первый пакет!

# Дополнительные материалы
distutils - Building and installing Python modules https://docs.python.org/3/library/distutils.html
setuptools - Collection of enhancements to the Python distutils https://setuptools.readthedocs.io/
pip - The Python Package Installer https://pip.pypa.io/
'''


# >>>>>> Установка pip <<<<<<

#@ Установка pip
'''
Если вы используете macOS или Windows и устанавливали Python согласно нашим рекомендациям, то pip будет установлен вместе с интерпретатором. На Ubuntu его нужно поставить отдельно:

$ sudo apt update
$ sudo apt install python3-pip
'''

#@ Запуск pip
'''
pip можно запускать непосредственно командой pip. Но лучше воспользоваться более длинной командой, которая гарантировано вызовет самую свежую установленную версию pip для нужной версии Python — в системе уже может быть установлен Py2 с соответствующей версией pip, как правило, довольно старой.

Итак, вызываем pip:

$ python3 -m pip --version

При показе своей версии pip также сообщает, куда установлен он сам и на какой версии Python он был запущен.

Обратите внимание на структуру команды, которую мы вызывали:

$ python3 -m pip --version

Эта команда означает "python3, запусти модуль (-m) с именем pip как программу с параметром --version". Если вы в дальнейшем увидите в документации к pip команды, вроде pip help, то смело вызывайте python -m pip help — результат будет нужный!
'''

#@ Установка первого пакета

'''
Установим же первый пакет! Пусть это будет пакет cowsay https://pypi.org/project/cowsay, но устанавливать мы его будем сразу в пользовательское окружение. Причин для установки туда есть несколько:

мы не помешаем своими пакетами другим пользователям системы,
нам не потребуются права администратора (у пользователя их может и не быть),
мы не поломаем саму операционную систему случайной установкой более свежего пакета, чем тот, который требуется системе для нормальной работы (особенно это важно в Linux, где многие системные задачи решаются с помощью Python).
Итак, установка cowsay:

$ python3 -m pip install --user cowsay

Во-первых, мы видим, что пакет установился и стал доступен интерпретатору. Во-вторых, пакет — забавный :)

Флаг –-user команды pip install сообщает pip, что мы хотим установить пакет в глобальное окружение текущего пользователя. Если этот флаг не указать, то pip установит пакет в общесистемное окружение. Старайтесь не делать так!
'''

#@ pip, точки входа и PATH

'''
Установленный пакет cowsay, как мы видели выше, может быть использован из кода. Но этот пакет имеет ещё и так называемую точку входа (или entry point).

Точки входа, это готовые к исполнению программы, содержащиеся в пакете. Если у пакета есть таковые, то pip создаст для каждой специальный исполняемый скрипт, который позволит удобно запускать программу из командной оболочки. Но нужно помнить, что путь до директории, в которую pip помещает такие скрипты (на Linux это ~/.local/bin) нужно добавить в PATH! Если путь прописан правильно, то скрипт для cowsay должен работать так:

$ cowsay hi
$ exit

Точка входа, это всегда Python-модуль, пригодный для запуска в роли программы (такие программы называют ещё исполняемыми файлами, позже мы рассмотрим, как такие делать). Создаваемые pip'ом скрипты внутри вызывают python3 -m имя_модуля, поэтому установленный нами cowsay можно запускать точно также:

$ python3 -m cowsay python
'''

#@ Всегда свежий pip!
'''
Как вы могли уже догадаться, сам pip, это тоже точка входа одноимённого пакета pip, поэтому мы его запускаем командой python3 -m pip. А ещё pip может устанавливать и, что более важно, обновлять! Вы можете установить свежий pip в пользовательское окружение (именно туда, чтобы не сломать системный pip) с помощью такой команды:

$ python3 -m pip install --user --upgrade pip

Флаг --upgrade позволит обновить уже установленный пакет, если в индексе найдётся более новая версия.

# Дополнительные материалы
pip - The Python Package Installer https://pip.pypa.io/
'''



# >>>>>> pip и альтернативные источники пакетов <<<<<<

'''
На прошлом уроке мы установили пакет cowsay. Если не уточнить иное специально, pip устанавливает пакеты из основного индекса — PyPI. Оттуда был взят и пакет cowsay.

В большинстве случаев PyPI — это именно тот источник пакетов, который нам нужен. Но бывают случаи, когда пакет находится в альтернативном индексе — например, внутрикорпоративном — или же вообще ещё не опубликован ни в одном индексе, а просто загружен на GitHub. Pip умеет работать и с альтернативными индексами и с репозиториями, содержащими исходный код пакетов. Рассмотрим оба варианта.
'''

#@ Альтернативные индексы пакетов

'''
Если вызывать команду pip install с опцией --index-url <url>, то pip будет искать пакет и все его зависимости в индексе по указанному url. Давайте попробуем установить пакет из специального тренировочного индекса Test PyPI http://test.pypi.org/:

$ python3 -m pip install --user --index-url https://test.pypi.org/simple dogesay

$ dogesay foo bar baz

Заметьте, что url индекса указан в виде что-то-там/simple — именно так по соглашению должны именоваться индексы.

Test PyPI содержит плюс-минус все пакеты, которые есть в основном PyPI, но обычно держателям локальных индексов не хочется держать у себя копии всех версий всех пакетов — хочется хранить только свои пакеты, а все внешние зависимости получать из другого индекса (обычно это уже общий PyPI). У pip и для такого случая есть опция! Всего-то и нужно в дополнение к --index-url указать --extra-index-url <url>. В такой конфигурации pip ищет каждый пакет в первом индексе, а если не найдёт, то обращается ко второму, дополнительному индексу. Команда целиком может выглядеть так:

$ python3 -m pip install --user --index-url https://test.pypi.org/simple --extra-index-url https://pypi.org/simple dogesay
'''

#@ Установка пакетов из репозиториев на GitHub

'''
Иногда пакет не хочется выкладывать на PyPI, скажем, по причине того, что пакет ещё совсем "сырой", но при этом нужно проверить, как пакет работает и устанавливается ли вообще. В подобных случаях пакеты устанавливают прямо из git-репозиториев. Давайте установим с помощью pip наш учебный hexlet-boilerplates/python-package https://github.com/hexlet-boilerplates/python-package:

$ python3 -m pip install --user git+https://github.com/hexlet-boilerplates/python-package.git

Здесь вместо имени пакета указывается тот же url, который вы использовали бы при клонировании репозитория, но дополненный приставкой git+. Эта приставка подсказывает pip, что по url расположен Git-репозиторий — не обязательно размещённый на GitHub.

Во время установки пакета, pip вызывает git clone для клонирования репозитория во временную папку. Если репозиторий закрытый, то у вас будут запрошены имя пользователя и пароль для доступа к репозиторию — это работает и с приватными репозиториями GitHub!

Управлять установкой пакетов из систем контроля версий (да, систем — pip поддерживает не только Git!) можно очень гибко, например, указывать ветки, теги или хэши коммитов, по которым расположена желаемая версия пакета. Подробнее можно почитать тут https://pip.pypa.io/en/stable/reference/pip_install/#vcs-support.

Мы рассмотрели далеко не все виды источников пакетов, да и саму команду pip install рассмотрели очень поверхностно. По возможности рекомендуем изучить эту и прочие команды pip самостоятельно, ведь pip — один из ключевых инструментов разработчика на Python!

# Дополнительные материалы
pip - The Python Package Installer https://pip.pypa.io/
Test PyPI https://test.pypi.org/
Python package example (boilerplate) https://github.com/hexlet-boilerplates/python-package
'''



# >>>>>> Виртуальные окружения <<<<<<

'''
Как уже говорилось ранее, pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет оный сначала в пользовательском окружении, затем в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python программ. Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами: разные проекты могут иметь разные наборы зависимостей. Ещё более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные её версии — конфликт версий.

Очевидно, что как минимум разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных "песочницах". Такой механизм существует и называется виртуальные окружения.
'''

#@ Устройство виртуальных окружений

'''
Каждое виртуальное окружение представляет собой директорию, содержимое которой структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:

$ tree env
env
├── bin
│   ├── activate
│   …
│   ├── pip
│   …
│   └── python3 -> …/python3
├── lib
│   └── python3.6
│       └── site-packages
│           ├── pip
│           │   ├── …
│           …
│           └── setuptools-40.6.2.dist-info
│               ├── …
…


В директории виртуального окружения находится директория bin/ внутри которой находится копия (или символическая ссылка на оригинал) интерпретатора под именем python3, а рядом с ней находится копия исполняемого файла pip. В соседней директории по пути lib/python3.6/site-packages находятся библиотеки, уже установленные в окружение: только что созданное окружение как правило имеет установленный пакет pip (а исполняемый файл bin/pip — его точка входа), а также пакет setuptools — эти два пакета составляют "необходимый минимум" для разработки проекта на Python.

При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из папки bin. Дело в том, что интерпретатор Python, когда находится в окружении, знает, что по относительному (к директории bin) пути ../lib/python3.6 находятся все доступные пакеты. И копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая желанная изоляция!
'''

#@ Создание виртуального окружения

'''
Конечно же, вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.

В macOS и Windows этот модуль, как и pip, входит в поставку Python. На Ubuntu же его нужно установить отдельно командой

$ sudo apt install python3-venv
Проверим, что модуль установлен и пригоден к использованию:

$ python3 -m venv --help

Создаётся окружение командой python3 -m venv имя_окружения. Давайте создадим одно и установим в это окружение пакет cowsay:

/tmp$ python3 -m venv first_venv
/tmp$ first_venv/bin/pip install cowsay
/tmp$ first_venv/bin/cowsay hello
/tmp$ first_venv/bin/pyth
/tmp$ first_venv/bin/python
>>> import cowsay
>>> cowsay.tux

Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay, а также сам пакет становится доступен интерпретатору, но только тому, что запущен из окружения.

В принципе в таком виде виртуальное окружение уже можно использовать полноценно. Но вводить команды с префиксом first_env/bin/ не очень-то хочется, и есть способ упростить вызов команд, доступных в окружении — активация.
'''

#@ Активация окружения

'''
При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Этот сценарий нужно выполнить:

> на macOS и Ubuntu вызвать команду
$ source first_venv/bin/activate

На Ubuntu активация выглядит следующим образом:

/tmp$ source first_venv/bin/activate
(first_venv) /tmp$ cowsay hello
>>> import cowsay
>>> cowsay.tux('imported')

Вы можете заметить, что после активации отпала необходимость указывать путь до вызываемого исполняемого файла — cowsay и python в аскинеме вызываются без префикса, но это всё те же команды из окружения!

Ещё вы могли заметить, что приглашение оболочки изменилось: в нём стало отображаться имя окружения. Этот трюк работает на macOS и Ubuntu и позволяет всегда видеть, что мы находимся в виртуальном окружении.

Деактивация же окружения делается командой deactivate, которая становится доступна после активации.

Активирование и деактивация окружения влияют только на текущую сессию (заметны только в этом конкретном терминале). Что позволяет иметь несколько окружений и активировать их одновременно в разных окнах терминала.
'''

#@ Итого

'''
Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.
'''

#@ Ссылки

'''
https://docs.python.org/3/library/venv.html https://docs.python.org/3/library/venv.html официальная документация по модулю venv.

https://pipxproject.github.io/pipx/ установщик Python-программ, размещающий каждую программу в её собственном виртуальном окружении, но скрывающий от конечного пользователя такие "излишние тонкости": пользователь получает сразу доступную оболочке команду — отличный способ устанавливать для постоянного использования штуки, вроде cowsay и dogesay.
'''


# >>>>>> Cкрипты <<<<<<

'''
Любая программа должна быть когда-нибудь запущена, иначе зачем её вообще писать? В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код, всю работу делает интерпретатор, которому достаточно подать на вход скрипт (англ. script) — так часто называют программы на интерпретируемых языках, представляющие из себя простые последовательности команд, которые компьютеру нужно выполнить. Часто языки, которые максимально упрощают написание скриптов (как говорят, "скриптование") и их запуск, называют "скриптовыми языками" или же "языками для написания сценариев" (слово "script" на русский переводится как "сценарий").
'''

#@ Скрипты на Python

'''
Python отлично подходит на роль скриптового языка: последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто — мы просто пишем команды одну за другой в файл:
'''

# file <script.py>
print('Hello, world!')
print('This is a python-script!')

'''
а затем просто вызываем интерпретатор с полученным файлом на входе:
$ python3 script.py
Hello, world!
This is a python-script!

Эта простота использования вместе с большим количеством полезных модулей и функций, входящих в поставку Python, делают последний хорошим инструментом для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием!
'''

#@ Скрипты и shebang

'''
В unix-подобных операционных системах (macOS, Linux, BSD etc) командные оболочки умеют запускать скрипты на любых языках, в т.ч. и на Python, если эти скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария. Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang, от названий первых двух символов такой строчки: # называется "sharp", а ! - "bang!".

Типичный shebang выглядит так:

#!/usr/bin/python3

где после символов #! идёт путь до интерпретатора. Командная оболочка при запуске скрипта, содержащего shebang, читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно будет не указывать:

$ cat script.py
#!/usr/bin/python3
print('Hello!')

$ chmod +x script.py

$ ./script.py
Hello!
'''

#@ Shebang и разные версии Python

'''
shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении — а в работе вы практически всегда будете их использовать — путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях! Как же сделать так, чтобы скрипт запускался всегда с нужной версией Python? Есть способ добиться такой универсальности: нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.

Эта программа умеет находить и запускать программы с учётом переменных https://ru.hexlet.io/courses/cli-basics/lessons/environment-variables/theory_unitокружения и, т.к. при активации виртуального окружения модифицируется переменная $PATH, то env будет запускать именно ту версию интерпретатора, которая нам нужна (она просто найдётся раньше, т.к. путь до исполняемых файлов окружения добавляется в начало $PATH).

Итак, представляем правильный способ указывать shebang в проектах на python! Встречайте:
'''

#!/usr/bin/env python3
print('Hello!')

'''
Путь до env указан конкретный потому, что эта программа практически всегда располагается именно там и не встречается в нескольких версиях :) А запомнить это правило написания shebang очень легко — "вызываем python3 с учётом окружения" ("env", это сокращение от "environment"/"окружение").
'''


# >>>>>> Cкрипты <<<<<<
'''
Как писать скрипты, мы уже узнали. Теперь представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нём появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать, скажем, функцию из этого модуля в другом модуле. Значит, нужно импортировать!
'''

#@ Импортирование скриптов
'''
Давайте же смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:
'''

# file <first_script.py>

def greet(who):
    print('Hello, {}!'.format(who))

greet('Bob')
greet('Ann')

'''
А так — новый скрипт, в котором мы хотим переиспользовать функцию greet из первого модуля (скрипты — тоже модули):
'''

# file <second_script.py>

from first_script import greet

greet('Thomas')

'''
Запустим первый скрипт, а затем — второй (оба файла расположены в текущей директории):

$ python3 first_script.py
Hello, Bob!
Hello, Ann!
$ python3 second_script.py
Hello, Bob!
Hello, Ann!
Hello, Thomas!

Что мы видим — при выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию! Такова цена за простоту написания скриптов! Поскольку файл первого скрипта содержит не только определения, но и непосредственные действия (statements), то при загрузке файла (которая происходит при импорте модуля) эти действия будут выполнены. Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы или того хуже — запускаются межконтинентальные ракеты!

Выходит, нам нужно как-то различать ситуации когда

1. модуль выполняется как скрипт (выполняем побочные действия),
2. модуль или его содержимое импортируются (не выполняем побочные действия).

Для этого нам понадобится немного магии!
'''

#@ Специальная переменная __name__

'''
Машинерия импортирования при загрузке модуля в первый раз (первый для текущего запуска интерпретатора) добавляет в этот модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная __name__.

Не стоит пугаться такого странного имени аж с четыремя символами подчёркивания: такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный питонист помнит наизусть пару десятков таких переменных, а ещё про эти переменные любят спрашивать на собеседованиях.

Что же хранит переменная __name__ в каждом конкретном случае? В этом и весь секрет!

> Если происходит обычный импорт, то эта переменная содержит полное имя модуля (полностью квалифицированное).

> Если же происходит запуск в качестве скрипта, то переменная получает специальное значение — строку '__main__'.

Глядя на значение этой переменной, можем отличать "запуск" от импортирования.

Слово "main" используется во многих языках для именования функции, которая вызывается автоматически при старте программы, потому и в Python это слово используется в похожем смысле

Давайте вернёмся к нашему примеру и перепишем first_script.py с применением этого нового знания:
'''

# file <first_script.py>

def greet(who):
    print('Hello, {}!'.format(who))

if __name__ == '__main__':
    greet('Bob')
    greet('Ann')

'''
Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль. Это победа!
'''

#@ Функция main

'''
Наш first_script.py уже достаточно хорош. Но мы можем его ещё чуть-чуть улучшить.

В теле условия if __name__… у нас перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много. И, как вы бы догадались, может статься, что мы захотим переиспользовать и этот кусок кода! Скажу даже больше, такое происходит нередко. Поэтому существует соглашение: в теле условия if __name__… делают всего один вызов функции без аргументов main, которую объявляют выше в этом же модуле (само условие принято располагать в самом конце модуля скрипта).

С учётом всех описанных рекомендаций финальная версия скрипта first_script.py будет выглядеть так:
'''

#!/usr/bin/env python3

def greet(who):
    print('Hello, {}!'.format(who))

def main():
    greet('Bob')
    greet('Ann')

if __name__ == '__main__':
    main()


'''
Такой скрипт можно:
> запускать непосредственно;
> запускать из других скриптов, вызывая функцию main;
> использовать как библиотеку.
'''

#@ Запускаемые пакеты

'''
Рассмотрим немного экзотический, но всё же встречающийся случай — запуск пакета. Могло бы показаться, что раз при загрузке пакета всегда загружается модуль __init__.py, то и функцию main, и условие нужно располагать в нём. Но авторы по ряду причин решили реализовать запуск пакетов несколько иначе: при загрузке пакета пред запуском ищется модуль __main__.py и выполняется, как скрипт. Здесь мы не будем углубляться в причины, побудившие авторов языка сделать именно так, и просто запомним, что исполняемые пакеты всегда содержат скрипт __main__.py.

Когда же может понадобится запуск пакета? Сходу можно представить такой пример. Пусть мы имели один небольшой скрипт. Со временем кода в нём становилось всё больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать. Мы решили превратить один модуль в пакет, содержащий несколько. Но как такой пакет в дальнейшем запускать? Вот для этого мы и можем использовать модуль __main__.py!

# Ссылки
Полный список того, что добавляет в модуль машинерия импортирования https://docs.python.org/3/reference/import.html#import-related-module-attributes

Имя 'main' и его значение https://docs.python.org/3/library/__main__.html#module-__main__
'''


# >>>>>> Доступный инструментарий для работы с Python-проектами. <<<<<<

#@ О важности выбора инструментария

'''
Сам по себе язык программирования мало интересен, если для него нет подходящего интерпретатора или компилятора. Но программы нужно не только запускать — их нужно доставлять до пользователя. Да и редкая программа бывает сразу готова, поэтому единожды доставленную программу нужно обновлять. А ещё её нужно продолжать разрабатывать — иногда в течении нескольких лет. Поэтому периодически возникают ситуации, когда нужно обновить какие-то сторонние библиотеки, а иногда и сам компилятор или интерпретатор. Для решения вышеперечисленных задач применительно к Python в разное время появились и развились различные инструменты. О некоторых из них ниже пойдёт речь.

Большинство инструментов имеет хорошую документацию, поэтому в рамках курса не будет дублироваться эта информация. Цель урока — дать общее представление, а местами предоставить и право выбора, какой инструмент выбрать среди доступных.

Но для начала познакомимся с новой концепцией — lock-файлами.
'''

#@ lock-файлы

'''
Обычно, при разработке автор некоторой библиотеки или программы так или иначе указывает версии сторонних пакетов, которые требуются для работы его творения. Обычно версия не закрепляется жёстко, вместо этого указывается диапазон версий, в пределах которого можно ожидать, что совместимость разных частей кода не нарушится. Именно для этого часто используется семантическое версионирование https://habr.com/ru/company/Voximplant/blog/281593/.

Однако случается, что либо диапазон версий бывает указан слишком широкий, либо семантическое версионирование оказывается применено неверно, или же просто в какой-то версии некоего пакета оказывается ошибка. Возникает ситуация, когда проект работает как нужно не на любом из сочетаний разных версий пакетов, а на некотором вполне конкретном.

lock-файл как раз и предназначен для того, чтобы в дополнение к перечню пакетов с "нечёткими" версиями, таки зафиксировать список конкретных версий, которые в данный момент для проекта подходят! В том или ином виде lock-files сейчас используются большинством современных пакетных менеджеров для разных языков программирования.
'''

#@ pyenv, средство управления разными версиями интерпретатора.

'''
Даже на этапе обучения важно иметь актуальную версию интерпретатора. И Python, будучи языком, который давно начали использовать для нужд автоматизации, часто бывает доступен в каталогах пакетов различных ОС. Однако пакеты как правило содержат только CPython (а ведь есть и другие реализации интерпретаторов Python, очень полезные в различных ситуациях), и далеко не всегда "свежий".

Авторы библиотек часто вынуждены поддерживать несколько версий Python и проверять, что новые изменения, вносимые в код, не сказываются на работоспособности оного при работе с разными версиями Python.

Т.о. на одной машине может быть установлено несколько разных реализаций Python и каждая — в более чем одном варианте. А управлять всем этим "серпентарием" призван pyenv https://github.com/pyenv/pyenv. Как бы вы не использовали Python, вам стоит научиться использовать этот инструмент.
'''

#@ pipenv, "инструментарий для людей"

'''
Да, авторы pipenv https://docs.pipenv.org/ так про своё детище и пишут. Что же это за штука? pipenv берёт на себя

> управление пакетами, т.е. заменяет pip (но использует "под капотом");
> создание виртуальных окружений (c "под капотом" venv);
> работу с зависимостями, контроль за версионированием и обновлением оных, построение графа зависимостей;
> воспроизводимость сборки (через использование тех самых lock-файлов).

pipenv — инструмент мощный, но требующий умения использовать distutils/setuptools для описания процесса сборки пакета с проектом. Новичкам может быть сложно освоить именно этот аспект использования в остальном достаточно удобной программы.

По ссылке выше вы найдёте сайт с подробнейшей документацией, советую хотя бы заглянуть туда.
'''


#@ poetry, ещё один человечный инструмент разработки

'''
В наших курсах и проектах я рекомендую использовать именно poetry. Также именно с помощью poetry оформлен наш python package boilerplate https://github.com/hexlet-boilerplates/python-package. Что же это за инструмент?

poetry https://poetry.eustace.io/, это сравнительно молодой проект, упрощающий разработку на Python. В целом он решает все те же проблемы (и тоже использует lock-файлы), что решает и pipenv, но в отличие от последнего, берёт на себя сборку пакетов. Более того, вместе с poetry вам не нужно глубоко погружаться в изучение distutils/setuptools — оные вообще не используются при описании poetry-пакета!

Документация у poetry компактная, но очень понятная. Описана и рекомендуемая структура директорий в типичном проекте и использование альтернативных индексов и многие другие аспекты — и всё это снабжено примерами! Проходите по ссылке выше и знакомьтесь.

Важно: напоминаю, я буду предполагать в дальнейших курсах и проектах использование именно poetry!
'''

#@ ipython, REPL, которого мы заслужили!

'''
Python REPL довольно удобен, а главное — всегда доступен. Но использовать его для ввода большого кол-ва кода неудобно (даже многострочный код не поредактируешь нормально!). Однако REPL в Python сделан модульным и существует несколько "улучшенных версий", наиболее популярная из которых — IPython https://ipython.readthedocs.io/.

IPython имеет
> подсветку синтаксиса,
> удобное автодополнение модулей для импортирования и определений в модулях,
> подсказки по аргументам функций и отображение документации,
> и многое-многое другое!

Большинство разработчиков, занимающихся анализом данных, проводят в IPython большую часть своего рабочего времени — настолько это мощная и полезная оболочка!
'''

#@ Всего не охватить...

'''
Вокруг базового инструментария Python за десятилетия существования языка было создано огромное количество полезностей. И благодаря тому, что в Python-мире правила хорошего тона предполагают тщательное документирование кода и сам синтаксис к этому располагает (всё те же docstrings), практически любой инструмент можно освоить самостоятельно — стоит лишь проявить любопытство! Всегда можно открыть сайт PyPI и пройтись по списку тем (topics), чтобы найти интересные проекты, способные сильно упростить жизнь и просто сделать процесс разработки и изучения более приятным!
'''




# >>>>>> Списки. <<<<<<

'''
Список — структура данных, предназначенная для хранения упорядоченных наборов элементов. Слово "упорядоченные" в данном случае означает, что элементы структуры хранятся в том порядке, в котором они были добавлены.

Элементы списка индексированы, т.е. имеют порядковый номер. Нумерация всегда начинается с нуля и всегда монотонна: у каждого последующего элемента индекс возрастает на единицу (как ещё говорят, нумерация элементов сквозная). При удалении элементов из середины списка (или даже из его начала), а также при вставке элементов в середину индексы пересчитываются и указанные выше свойства нумерации сохраняются.
'''

#@ Иммутабельность и мутабельность

'''
Мы уже знаем, что при конкатенации двух строк получается новая строка, а при сложении двух чисел получается новое число.

Рассмотренные ранее кортежи
> позволяют сгруппировать элементы, а затем разобрать группу на составляющие,
> могут быть собраны в кортеж большего размера,
> не позволяют менять состав элементов — только создание новых кортежей из элементов старых.

Таким образом все рассмотренные нами ранее типы и структуры данных — строки, числа, булевы значения, кортежи — иммутабельны (immutable), то есть будучи единожды созданными, уже не изменяются.

Списки — первая структура данных, которая может изменять своё содержимое "по месту" ("in place"). Такие объекты называют мутабельными (mutable). При этом некоторая часть операций над списками всё же создаёт новые списки на основе старых.
'''



# >>>>>> Создание списков <<<<<<

'''
Списки встроены в Python и поэтому язык предоставляет специальный синтаксис для объявления списков: списковые литералы.

Кортежи, описанные ранее, тоже встроены в язык и создаются с помощью своих собственных литералов — тех самых выражений в круглых скобках (("foo", 42) — литерал кортежа).

Создадим несколько списков, в т.ч. и один пустой:
'''

nummbers = [1, 2, 3]
strings = ["foo", "bar"]
booleans = [True, False]
empty_list = []

'''
Пока всё очень похоже на кортежи, только скобки квадратные вместо круглых.

Но на прошлом уроке я уже отмечал, что списки — мутабельные, т.е. могут изменяться со временем. Научимся же изменять списки путём добавления элементов в конец!

>>> l = [1, 2, 3]
>>> l
[1, 2, 3]
>>> l.append(4)
>>> l.append(5)
>>> l
[1, 2, 3, 4, 5]
>>> l.extend([6, 7, 8])
>>> l
[1, 2, 3, 4, 5, 6, 7, 8]
'''

#@ Списки — объекты

'''
В примере выше демонстрируется новый вид синтаксиса — вызов метода объекта.

Объекты — это такие сущности, которые могут хранить в себе некие данные (в т.ч. и другие объекты). А ещё объекты сами знают, как с хранимыми данными обращаться — как говорят, обладают поведением. Поведение объекта заключается в предоставлении методов — особого вида функций, которые всегда каким-либо образом относятся к объекту-владельцу. Вызов метода похож на вызов функции, только выглядит как "объект.метод(...)", т.е. мы всегда видим, метод какого объекта вызывается.

Об объектах, методах и элементах Объектно Ориентированного Программирования (ООП) мы поговорим в отдельном курсе. Пока же достаточно знать, что методы похожи на функции, могут модифицировать объект (а большинство объектов в Python - мутабельное) или же просто возвращать какую-то информацию об объекте.
'''

#@ Методы append и extend

'''
Итак, в коде выше список l — объект списка, а append и extend — методы объекта списка.
> append добавляет один элемент в свой список,
> extend добавляет все элементы из списка-аргумента в свой список.

Оба метода добавляют элементы в конец списка. И оба метода возвращают None, т.е. у этих методов-функций нет полезного результата — вся польза от вызова этих методов заключается в изменении связанного объекта!

Новички, в первый раз знакомящиеся с методами списка, часто совершают такую ошибку:

>>> l = [1]
>>> l = l.append(2)
>>> l
>>> # а где список?
>>> print(l)
None

Здесь во второй строке гипотетический автор кода хотел присвоить в переменную l дополненный список, но в переменной оказалось значение None (его вернул append).

Суть сей басни такова: нужно помнить, что метод может всегда возвращать None — и тем не менее влиять на мир, изменяя ассоциированный (говорят связанный или bounded) объект.
'''


# >>>>>> Ссылки <<<<<<

'''
Пока вы работали с иммутабельными значениями, способ, с помощью которого в Python эти значения передаются в функции и сохраняются в переменных, не был столь интересен. Но теперь вы учитесь работать с мутабельными объектами, а значит настало время узнать, что в Python всё передаётся по ссылке. Что же такое ссылка? Разберёмся. Но начнём знакомство со старших братьев ссылки — адреса и указателя.

Все данные, с которыми работает программа, находятся в оперативной памяти компьютера. Чтобы иметь доступ к некоторому участку памяти, нужно знать адрес этого участка.

В языках с ручным управлением памятью (C, C++ и другие) необходимо постоянно следить за тем, что память по адресу выделена и ещё не освобождена: в таких языках программист явно запрашивает у операционной системы нужное ему количество памяти. ОС в ответ на запрос выделяет участок в общей оперативной памяти, закрепляет этот блок за попросившим доступ и возвращает указатель, по сути представляющий собой тот самый адрес. Получив указатель, программист может сохранить что-то в выделенную память. По окончанию работы выделенные участки нужно освобождать — сообщать ОС, что память свободна и может быть использована для чего-то другого. Если обратиться по указателю к участку памяти, который ещё не выделен или уже освобождён, программа завершится с ошибкой!

Python является языком с автоматическим управлением памятью. Как только программисту требуется создать некое значение, требуемое количество памяти выделяется средой исполнения (runtime) автоматически, значение сохраняется в эту память и программисту возвращается ссылка на сохранённое значение. А как только данные перестают использоваться, память будет освобождена — также автоматически. Таким образом ссылки выполняют ту же роль, что и указатели в упомянутых выше языках. Но пользоваться ссылками всегда безопасно: ссылка не может указывать на память, не готовую к использованию. Более того, программисту на Python не нужно отдельно получать память и отдельно заполнять её — данные размещаются в памяти всё той же средой исполнения.

Итак, мы знаем, что когда мы создаём некое значение, мы получаем от runtime именно ссылку на него. Ссылок на одно и то же значение в любой момент времени может быть сколько-угодно. Python экономит усилия и всегда и везде передаёт любые значения по ссылкам — создаёт новые ссылки на существующие данные. Даже переменные, это всего лишь имена, привязанные к ссылкам. И при вызове функции с передачей ей аргументов, передаются не сами значения, а только ссылки на них — по одной новой ссылке на каждое значение. Когда же выполнение функции завершится, ненужные ссылки уничтожаются. И как только исчезает последняя ссылка на некое значение, среда исполнения понимает, что и само значение больше никому не нужно и его можно удалить из памяти (освободив таким образом место). Этим занимается специальный механизм среды исполнения, так называемый счётчик ссылок (reference counter).

Использование подсчёта ссылок позволяет Пайтону экономить изрядное количество памяти при передаче между разными частями программы длинных строк или больших чисел: не нужно копировать данные с места на место, как это делается в некоторых других языках. Но есть и обратная сторона медали. Передавая некоторому коду ссылку на изменяемый объект, мы не можем запретить этому коду изменить объект в процессе выполнения. Это в некоторых случаях затрудняет отладку кода и усложняет его чтение. Об этой особенности Python всегда нужно помнить.

В следующем уроке вы увидите, как передача ссылок может себя проявлять неожиданным для новичка образом.
'''



# >>>>>> Ссылки и мутабельность <<<<<<

'''
На прошлом уроке я ввёл понятие ссылки и упомянул, что в Пайтоне всё и всегда передаётся по ссылке. Поэкспериментируем со списком, как с первым известным нам изменяемым объектом. Но для начала нужно узнать об паре полезных для наших экспериментов инструментов — функции id и операторе is.
'''

#@ id и is

'''
Если обратиться к описанию функции (help(id)), то документация скажет:

id(obj, /)
    Return the identity of an object.

    This is guaranteed to be unique among simultaneously existing objects.

Функция id возвращает уникальный идентификатор объекта, который вы ей передаёте в качестве аргумента (помним, по ссылке!). Идентификатор — это обычное число. Но каждый отдельный объект имеет уникальный идентификатор, т.е. любые два разных объекта всегда будут иметь отличающиеся идентификаторы. И пусть идентификаторы не сохраняются от одного запуска Python к другому, но в рамках одного запуска связь объекта и идентификатора нерушима. Поэтому идентификаторы удобно использовать чтобы отслеживать передачи ссылок на объект между разными участками кода — идентификатор объекта будет одним и тем же, по какой бы ссылке мы к объекту не обращались.

>>> a = "some string"
>>> b = a
>>> id(a)
139739990935280
>>> id(b)
139739990935280
>>> a is b
True

Когда мы "присваиваем значение одной переменной другой", фактически создаётся новая именованная ссылка на исходное значение. Поэтому id(a) и id(b) возвращают одинаковый результат.

Оператор is проверяет равенство идентификаторов своих операндов. В данном примере обе переменные ссылаются на один объект, поэтому проверка a is b даёт True.

Проверка на равенство идентификаторов — очень быстрая. И особенно удобно ей пользоваться, когда мы имеем дело с так называемыми объектами-одиночками (singleton objects). Самые известные одиночки в Python, это True, False и None. Поэтому проверка на равенство None обычно пишется так:

...
if foo is None:
    ...

'''

#@ Списки, кортежи и ссылки

'''
Посмотрите на этот пример:
>>> a = [1, 2, 3]
>>> b = a
>>> a.append(4)
>>> b
[1, 2, 3, 4]

Что мы видим — поменяли "список a", а изменился ещё и "список b"! В действительности же нет никаких двух списков, есть две ссылки на один! Продолжим:

>>> a = []
>>> l = [a, a]
>>> a.append(1)
>>> l
[[1], [1]]

Здесь, как вы могли догадаться, в списке хранятся две ссылки на один и тот же объект — мутабельный к тому же. Именно в этом состоит тонкость работы со ссылками: когда мы получаем откуда-то ссылку, мы не можем быть уверены, что объект не будет меняться со временем без нашего участия!

А помните, я говорил, что кортеж не может изменяться? А как вам такое:

>>> a = []
>>> pair = (a, a)
>>> pair[0].append(1)
>>> pair[1].append(2)
>>> pair
([1, 2], [1, 2])


Значения в кортеже поменялось?! И всё же я говорил правду: настоящее содержимое кортежа — это ссылки на значения. И эти ссылки меняться не могут. Но могут меняться сами объекты по этим ссылкам!

Ещё интереснее наблюдать за списками и кортежами, создаваемыми с помощью специального синтаксиса — умножения списка или кортежа на число. Если умножить список или кортеж на число n, то мы получим новую коллекцию соответствующего типа, состоящую из n повторов элементов исходной коллекции. Вот несколько примеров:

>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> ('foo', 'bar') * 2
('foo', 'bar', 'foo', 'bar')
>>> [[]] * 5
[[], [], [], [], []]
>>> ((),) * 5
((), (), (), (), ())

Теперь, если мы вспомним, что коллекции — всегда коллекции ссылок, то можно будет догадаться о том, как такие "растиражированные" коллекции будут себя вести при изменении мутабельных элементов. Смотрите:

>>> t = ([], [], []) * 3
>>> t
([], [], [], [], [], [], [], [], [])
>>> t[0].append(42)
>>> t[1].append(0)
>>> t
([42], [0], [], [42], [0], [], [42], [0], [])

Запустите REPL и воспроизведите пример, а затем с помощью id и is посмотрите, какие элементы кортежа на какие объекты ссылаются.
'''

#@ Ссылки и присваивание

'''
Мы увидели, что в список можно добавить несколько ссылок на один объект. И что переменные — те же ссылки, просто именованные.

Но что происходит с переменными и элементами списка при присваивании? Посмотрим:

>>> a = "foo"
>>> id(a)
139739990954536
>>> a += "bar"
>>> a
'foobar'
>>> id(a)
139739952783688

Этот пример показывает, что имя переменной не жёстко связано со ссылкой на значение. Присваивание переменной (а += это вид присваивания) может поменять одну ссылку на другую. Это свойство присуще и элементам списка:

>>> a = "foo"
>>> l = [a, a]
>>> l[0] is l[1]
True
>>> l[0] += "bar"
>>> l
['foobar', 'foo']
>>> l[0] is l[1]
False

Здесь сначала два элемента списка ссылаются на одно значение. Но после присваивания нового значения первому элементу, связь элемента с изначальным значением разрывается и под конец элементы ссылаются на разные значения.
'''

#@@@
'''
src/solution.py
Вам необходимо реализовать функцию duplicate, которая должна принимать в качестве аргумента список и удваивать этот список "по месту" (вам нужно будет изменять исходный объект списка. Помним: список передаётся по ссылке!). Удваивание здесь означает, что после применения к нему функции список должен иметь копию всех элементов, добавленную в конец (см. пример ниже).

Пример

>>> l = [1, 2]
>>> duplicate(l)  # ничего не возвращается!
>>> l
[1, 2, 1, 2]
'''


def duplicate(items):
    items.extend(items)




# >>>>>> Модификация списков поэлементно, сортировка, разворачивание <<<<<<

'''
Как вы помните элементы списков индексированы, т.е. каждый элемент имеет порядковый номер. Первый элемент имеет индекс 0, последний — len(list) - 1.

Функция len возвращает длину списка, но работает она с различными типами, например — со строками и кортежами.

Элементы списка можно получать и заменять через присваивание по их индексу. Если указать отрицательный индекс, то элементы будут браться с конца и последний элемент списка будет иметь отрицательный индекс -1 (-0, увы, использовать не получится). Вот пара примеров использования индексов со списком:

>>> l = [0] * 3
>>> l[0], l[1] = 10, 32
>>> l[-1] = l[0] + l[1]
>>> l
[10, 32, 42]

Обратите внимание, что я создал список клонированием нулей. Так делать безопасно, потому что числа в Python — иммутабельные. Впрочем, все модификации списка я сделал через присваивание, поэтому ничего неожиданного я бы не получил, даже если бы использовал мутабельные объекты.
'''

#@ pop и insert

'''
Итак, получать и заменять элементы по одному мы умеем. Неплохо бы ещё уметь удалять старые элементы и вставлять в середину списка новые. За это отвечают методы pop и insert соответственно. pop удаляет элемент по индексу. Если не указать индекс, то удаляется последний элемент. При этом pop возвращает значение элемента, который удаляет:

>>> l = [1, 2, 3]
>>> l.pop()
3
>>> l
[1, 2]
>>> l.pop(0)
1
>>> l
[2]

А вот пример использования insert:

>>> l = [1, 2, 3]
>>> l.insert(1, 100)
>>> l
[1, 100, 2, 3]
>>> l.insert(-1, 200)
>>> l
[1, 100, 2, 200, 3]


insert всегда вставляет новый элемент перед элементом с указанным индексом относительно начала списка, вне зависимости от того, откуда мы индекс отсчитывали — от начала или от конца. И insert(-1, ..) вставляет элемент перед последним элементом!

Раз insert всегда добавляет перед, получается, что использовать insert для добавления в самый конец не получится. Но для этого у нас уже есть append.
'''

#@ Ошибки индексации

'''
Если попытаться вызвать pop() у пустого списка или указать индекс за пределами индексов существующих элементов, вы получите ошибку IndexError:

>>> l = []
>>> l.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: pop from empty list

А вот insert более терпим к некорректным индексам и просто добавляет элементы с соответствующего края:

>>> l = [0]
>>> l.insert(-500, 1)
>>> l.insert(1000, 2)
>>> l
[1, 0, 2]


Однако полагаться на это не стоит — индексы всё же лучше держать под контролем!
'''

#@ Сортировка и разворачивание

'''
Списки чего-либо периодически приходится сортировать, а иногда и разворачивать. Желательно уметь это делать эффективно. Поэтому список уже имеет встроенные средства для выполнения обеих задач — методы sort и reverse. Оба метода изменяют список по месту (in place). Посмотрим на несколько примеров:


>>> l = [1, 3, 7, 2, 10, 8]
>>> l.sort()
>>> l
[1, 2, 3, 7, 8, 10]
>>> l.reverse()
>>> l
[10, 8, 7, 3, 2, 1]


Оба метода могут работать без параметров. В случае reverse нечего и параметризовывать: разворачивание — это всегда разворачивание. А вот сортировка может производиться по разным критериям. Если вызывать sort без параметров, то элементы сортируются в порядке возрастания. Однако методу можно передать параметр-функцию, которая будет возвращать критерий сортировки (т.н. ключ или key). Функция будет вызвана по одному разу для каждого элемента списка, после чего элементы будут отсортированы по возрастанию значения ключа. Давайте объявим функцию, которая будет возвращать остаток от деления аргумента на два, и используем её в роли ключа:

Оба метода могут работать без параметров. В случае reverse нечего и параметризовывать: разворачивание — это всегда разворачивание. А вот сортировка может производиться по разным критериям. Если вызывать sort без параметров, то элементы сортируются в порядке возрастания. Однако методу можно передать параметр-функцию, которая будет возвращать критерий сортировки (т.н. ключ или key). Функция будет вызвана по одному разу для каждого элемента списка, после чего элементы будут отсортированы по возрастанию значения ключа. Давайте объявим функцию, которая будет возвращать остаток от деления аргумента на два, и используем её в роли ключа:


>>> def mod2(x):
...     return x % 2
...
>>> l = [1, 2, 3, 6, 5, 4]
>>> l.sort(key=mod2)
>>> l
[2, 6, 4, 1, 3, 5]


Обратите внимание, что функцию в метод sort я передал по имени параметра. Такой синтаксис мы рассмотрим позже, но поэкспериментировать с методом sort и разными функциями-ключами вы уже сможете, указывая их по аналогии.

Функция mod2 вернула для чётных и нечётных чисел 0 и 1 соответственно. Поэтому в начале списка оказались сначала чётные числа.

Интересно, что в пределах своей группы числа сохранили порядок: 6 шла в списке перед 4, и это взаимное расположение сохранилось. Умение сохранить относительный порядок элементов, которые уже отсортированы (относительно друг друга) — важная характеристика алгоритма сортировки! Называется она стабильностью, сортировка же в этом случае называется стабильной сортировкой — и в Python сортировка именно такая.

Функция-ключ не обязана возвращать числа — она может возвращать любые значения, которые Python умеет сравнивать. Давайте в предыдущем примере усложним функцию-ключ:


>>> def key(x):
...     return (x % 2, x)
...
>>> l = [1, 2, 3, 6, 5, 4]
>>> l.sort(key=key)
>>> l
[2, 4, 6, 1, 3, 5]


Теперь числа разбиты на группы и при этом ещё и отсортированы внутри групп! Когда Python сравнивает кортежи, он сравнивает сначала первые элементы, а если те равны — вторые и т.д. Значения сравниваются, пока не найдётся первое неравенство. Либо пока не кончится один из кортежей — в этом случае более короткий будет "меньше". Вот несколько примеров:


>>> (1, 2, 3) < (1, 2, 4)
True
>>> (1, 1) < (1, 1, 1)
True
>>> (1, 2) > (1, 1, 1)
True
>>> (3, 4, 5) == (3, 4, 5)
True

Домашнее задание

У меня нет цели рассказать про все доступные методы списков, я показываю лишь общие принципы. Я не рассказал про методы count, remove, index: оставляю изучение этих методов вам. Напоминаю, посмотреть документацию можно прямо в REPL с помощью функции help. Только для просмотра информации о методе объекта, нужно передавать метод вместе с объектом: help([].count).




#@@@
src/solution.py
Вам нужно реализовать функцию rotate, которая должна принимать список в качестве аргумента и делать над ним следующее преобразование (список нужно изменять "на месте"!): последний элемент списка должен быть перемещён в начало списка (см. пример ниже). Если функция получает пустой список, то изменять его она не должна.

Для решения используйте методы insert и pop.

Пример

>>> l = [1, 2, 3]
>>> rotate(l)
>>> l
[3, 1, 2]
'''

def rotate(items):
    if items:
        items.insert(0, items.pop(-1))





# >>>>>> Срезы <<<<<<

'''
Работать с одиночными элементами вы уже умеете. Настало время перейти к очень интересному инструменту, который Pytnon предоставляет для работы с целыми подмножествами элементов списка: к так называемым срезам (slices).
'''

#@ Синтаксис описания срезов

'''
Срезы встроены в язык и снабжены своим собственным синтаксисом — настолько широко они используются. Срез записывается так же, как записывается обращение к элементу списка по индексу:

some_list[START:STOP:STEP]

Всего у среза три параметра:
> START — индекс первого элемента в выборке,
> STOP — индекс элемента списка, перед которым срез должен закончиться (т.е. сам элемент с индексом STOP не будет входить в выборку),
> STEP — шаг прироста выбираемых индексов.

Математически говоря, индексы элементов, которые будут выбраны, входят в множество

[START, START + STEP, START + 2 STEP, .., STOP)

Например, срез [3:20:5] означает выборку индексов [3, 8, 13, 18].

При этом любой из трёх параметров среза может быть опущен и вместо соответствующего параметра будет выбрано некое значение по умолчанию:

> умолчательный START означает "от начала списка",
> умолчательный STOP означает "до конца списка" (включительно),
> умолчательный STEP означает "брать каждый элемент".

Вот несколько примеров с разными наборами параметров:

[:]/[::] — "весь список",
[::2] — "нечётные по порядку элементы",
[1::2] — "чётные по порядку элементы",
[::-1] — "все элементы в обратном порядке",
[5:] — "все элементы, начиная с шестого",
[:5] — "все элементы, не доходя до шестого",
[-2:1:-1] — "все элементы от предпоследнего до второго в обратном порядке" (во всех случаях выборки от большего индекса к меньшему нужно указывать шаг!).

Срезы могут работать в двух режимах: собственно выборка и присваивание.
'''

#@ Выборка элементов

'''
Срезы-выборки работают со списками, кортежами, строками. Результатом применения выборки всегда становится новое значение соответствующего типа — список, кортеж, строка. Пример:

>>> 'hello'[2:]
'llo'
>>> (1, "foo", True, None)[2:]
(True, None)
>>> [1, 2, 3, 4, 5][2:]
[3, 4, 5]


Сразу сделаю несколько замечаний по использованию выборок:
> Так как кортежи чаще всего содержат разнородные элементы, срезы для них менее полезны, чем распаковка и перепаковка: тяжело удерживать в голове типы элементов вместе с индексами.
> Т.к. при выборке по срезу [:] создаётся новая копия списка, то именно так обычно список питонисты и копируют :)
> Нужно помнить, что хоть срез и порождает новый список или кортеж, для каждого выбранного элемента копируется только ссылка!
'''

#@ Присваивание срезу

'''
В отличие от строк и кортежей списки могут изменяться по месту. Одним из вариантов модификации является присваивание срезу. Срезу с указанным шагом можно присвоить список, содержащий соответствующее — то же, что и в срезе — кол-во новых элементов. Пример:

>>> l = [1, 2, 3, 4, 5, 6]
>>> l[::2] = [0, 0, 0]
>>> l
[0, 2, 0, 4, 0, 6]

Внимание, если вы попробуете присвоить срезу с шагом не то количество элементов, вы получите ошибку:

>>> l = [1, 2, 3, 4]
>>> l[::2] = [5, 6, 7]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: attempt to assign sequence of size 3 to extended slice of size 2


Если же срез непрерывный, т.е. шаг не указан и индексы идут подряд, то свободы нам даётся больше. Такому срезу можно присвоить как больше элементов — тогда список вырастет — так и меньше, что приведёт к урезанию списка. Примеры:

>>> l = [1, 2, 3]
>>> l[2:] = [4, 5]
>>> l
[1, 2, 4, 5]
>>> l[1:-1] = [100]
>>> l
[1, 100, 5]
>>> l[:] = []
>>> l
[]

Сначала список растёт, потом уменьшается, а под конец вообще становится пустым — и всё с помощью компактного, но мощного синтаксиса срезов.
'''

#@ Срезы — значения

'''
Хоть срезы и имеют специальную поддержку со стороны синтаксиса, но мы можем создавать и использовать срезы сами по себе — как обычные значения.

Значение среза можно сконструировать с помощью функции slice:

>>> first_two = slice(2)
>>> each_odd = slice(None, None, 2)
>>> each_odd
slice(None, None, 2)
>>> l = [1, 2, 3, 4, 5]
>>> l[first_two]
[1, 2]
>>> l[each_odd]
[1, 3, 5]

Функция slice принимает от одного до трёх параметров — те самые START, STOP и STEP. Если вы хотите "пропустить" один из параметров, то подставьте вместо него None.

None можно использовать и в записи срезов в квадратных скобках. Там None так же будет означать пропуск значения!

И конечно же на месте параметров среза могут быть любые выражения, лишь бы эти выражения вычислялись в целые числа или None.

'''

#@ Соотношение START и STOP

'''
В срезе элемент с индексом STOP не попадает в выборку, в отличие от элемента с индексом START. У такого поведения есть особенность: какой бы мы не выбрали неотрицательный индекс n для любого списка — даже выходящий за его пределы — указанное равенство будет соблюдаться:
'''

l == l[:n] + l[n:]

'''
Пример:

>>> s = 'Hello!'
>>> s[:2] + s[2:]
'Hello!'
>>> s[:4] + s[4:]
'Hello!'
>>> s[:0] + s[0:] == s
True
>>> s[:100] + s[100:] == s
True

Это свойство удобно использовать, когда вы разбираете некий текст: вам достаточно двигать позицию "разрезания" строки на начало и остаток, не заботясь о том, что какая-либо информация на границе разрезания потеряется!



#@@@
src/solution.py
В этом упражнении вам нужно будет реализовать две функции — rotated_left и rotated_right. Каждая функция должна

принять список, кортеж или строку в качестве аргумента,
с помощью срезов и конкатенации получить новое значение того же типа,
вернуть это значение.
Отличаются функции лишь "направлением поворота" (см. примеры ниже).

Т.к. и строки, и списки с кортежами разрешают конкатенацию и срезы, ваш код не должен проверять тип аргумента — нужно обойтись только лишь срезами и конкатенацией!

Обратите внимание: имена функций содержат глагол с окончанием ed — в пайтоне подобным образом часто называют функции, возвращающие новое значение на основе старого.

Примеры
При вращении влево первый элемент перемещается в конец:

>>> rotated_left("ABCD")
"BCDA"

При вращении вправо последний элемент перемещается в начало:

>>> rotated_right([1, 2, 3, 4])
[4, 1, 2, 3]
'''

def rotated_right(items):
    return items[-1:] + items[:-1]


def rotated_left(items):
    return items[1:] + items[:1]



# >>>>>> Срезы <<<<<<

'''
Ранее мы рассматривали цикл while. Эта конструкция предназначена для повторения некоего набора действий — всё, что выходит за рамки "бездумного" повторения, как правило, требует дополнительных средств для хранения состояния. Пример: счётчик, который мы изменяем в цикле. И при работе с коллекциями нам нужно как-то выбирать, с каким элементом мы работаем в текущей итерации. Так что же, использовать переменную счётчик каждый раз? Любой программист всегда стремится автоматизировать рутинную работу, и авторы языков — не исключение. Поэтому в Python для работы с коллекциями существует другой вид цикла — цикл for.

Стоит сразу отметить, что этот цикл не похож на циклы с тем же названием в других языках программирования. Во многих языках этот цикл всего лишь дополняет условие завершения цикла переменной-счётчиком. Python в стремлении сделать удобно пошёл дальше, поэтому в этом языке цикл for сразу перебирает элементы входной коллекции и думать об индексе чаще всего вообще не нужно.
'''

#@ Синтаксис

# Цикл for устроен очень просто:
for element in collection:
    print(element)  # this is body of cycle

'''
Заметьте, в простейшем случае у цикла даже нет явного условия завершения: цикл просто останавливается, когда в коллекции заканчиваются элементы!

Пример выше сработает для кортежей и списков — в этом случае будут выведены все элементы. А если проитерировать (так называют обход коллекции — позже вы узнаете, почему) строку, то переменная цикла (в коде выше это element) будет поочерёдно содержать все символы строки. Пример:

>>> for c in 'Hello!':
...     print(c)
...
H
e
l
l
o
!

Но что же делать, если нам нужно не просто получить элементы списка один за другим, но и изменить эти элементы? Ведь для этого нам понадобится индекс каждого элемента! На этот случай в Python есть удобная функция enumerate ("пронумеровать"). Эта функция снабжает каждый элемент индексом, складывая каждый индекс вместе с элементом в кортеж. Кортежи эти, как правило, прямо в первой строке цикла и распаковывают:


>>> items = ['foo', 'bar', 'baz']
>>> for (index, elem) in enumerate(items):
...     items[index] = elem + '!'
...
>>> items
['foo!', 'bar!', 'baz!']

В этом цикле мы заменили каждый элемент оригинальным значением, дополненным строкой '!'. Этот код можно было написать и несколько иначе:

>>> items = ['foo', 'bar', 'baz']
>>> for (index, _) in enumerate(items):
...     items[index] += '!'
...
>>> items
['foo!', 'bar!', 'baz!']

В этот раз мы вообще не используем сами элементы — только их индексы. Поэтому вместо переменной цикла, в которую распаковываются элементы, у нас стоит прочерк. Это не какая-то особая переменная, а всего лишь соглашение: в Python часто незначимые в данном контексте вещи "спихивают" в переменную _.

Заметьте: хоть в последнем примере речь и шла об индексах, но мы всё равно не использовали длину коллекции — enumerate тоже знает, где остановиться (в конце исходной коллекции).
'''

#@ Управление циклом с помощью break и continue.

'''
Иногда не нужно доходить до конца коллекции. Пример: поиск элемента, удовлетворяющего некоему условию. Как только мы нашли первый подходящий элемент, нам неплохо бы сэкономить ресурсы и завершить цикл. Такой ранний выход из цикла делается с помощью команды break. Вот цикл поиска первого положительного числа:

>>> items = [-2, 0, -10, 3, 5, -1]
>>> for item in items:
...     if item > 0:
...         break
...
>>> item
3

Как вы могли заметить, переменная цикла оказалась доступна и после его завершения. Однако если коллекция окажется пустой, то переменная не будет определена — имейте это в виду!

Этот код, кажется, работает, как надо. Однако если в списке не встретится ни одного положительного числа, то в переменной item окажется просто последний элемент списка! Как же понять, что мы ничего не нашли? На помощь приходит else — да, в Python у цикла for тоже есть такая ветка! В цикле else выполняется, если цикл так и не прервался с помощью break. Для алгоритмов поиска — идеальный вариант! Перепишем наш пример с применением else:

>>> items = [-2, 0, -10, -1]
>>> for item in items:
...     if item > 0:
...         break
... else:
...     item = None
...
>>> print(item)
None

Победа!

Теперь представим ситуацию, что мы в процессе выполнения тела цикла поняли, что остаток тела выполнять незачем и можно сразу перейти к следующей итерации. Для перехода к следующей итерации предназначена команда continue. Её использование продемонстрирует следующий пример: мы читаем строки содержащие строчки кода, но нам не нужно обрабатывать код тех строчек, которые начинаются с символа #. Вот так будет выглядеть код:

>>> lines_of_code = [
... '# begin of example',
... 'echo 123',
... 'cd foo',
... '# end']
>>> for line in lines_of_code:
...     if line[:1] == '#':
...         continue
...     # here we process a code
...     print(line)
...
echo 123
cd foo

Конечно же мы могли бы обойтись условной конструкцией. Однако в этом случае код, обрабатывающий нужные строки, был бы вложен глубже. А нам нужно стремиться держать вложенность кода в разумных пределах, иначе код очень быстро станет очень сложным для прочтения.
'''

#@ break, continue, else и цикл while

'''
Да, и ветка else, и команды break и continue — доступны и для цикла while! Вот комплексный пример, демонстрирующий все эти возможности:
'''

tries = 3
while tries:
    print('>>> ', end='')
    command = input()
    if not command:
        continue
    if command in ('echo', 'cd', 'help'):
        break
    print('Unknown command!')
    tries -= 1
else:
    print('Too many bad tries!')
    command = None

'''
Этот код просит пользователя ввести одну из команд, игнорирует пустой ввод, ограничивает кол-во попыток ввода. Подумайте, какая часть тела цикла за что отвечает.
'''

#@ Цикл for и изменяемые коллекции

'''
Хочу вас предостеречь от изменения состава списка во время обхода его же в цикле for. Если вы будете удалять элементы из списка, по которому проходитесь — или даже всего лишь добавлять новые элементы в конец — результат может быть неожиданным, вплоть до завершения программы с ошибкой! Лучше наполнять новый список в процессе обхода старого.

Если же вы хотите обязательно изменить состав исходного списка (объекта по ссылке), то либо обходите в цикле копию списка
'''

for x in original_list[:]:
    original_list.pop(0)  # и т.п.


# либо создайте временный список, а потом очистите исходный и добавьте элементы из временного

new_list = []
for x in original_list:
    ...
original_list[:] = []  # удаляем старое содержимое
original_list.extend(new_list)

'''
Естественно можно скомбинировать эти два варианта и сначала сделать копию, потом очистить оригинал, и затем уже в цикле обхода копии добавлять новые элементы.


#@
src/solution.py
В этом упражнении вы будете реализовывать классический цикл поиска. Функция find_index, которую вам предстоит написать, должна принимать значение и нечто, по чему можно итерироваться — строку, список, кортеж. В ответ функция должна вернуть индекс первого элемента итерируемой последовательности, равного заданному значению. Если же значение в последовательности не встречается или же последовательность окажется пустой, функция должна вернуть None.

>>> find_index('t', 'cat')
2
>>> find_index(5, [1, 2, 3, 4, 5, 6, 7])
4
>>> find_index(42, []) is None
True
>>> find_index('!', 'abc') is None
True
'''

def find_index(value, items):
    for index, item in enumerate(items):
        if item == value:
            return index



#@ Итераторы

'''
На предыдущем уроке мы рассмотрели цикл for и в тексте встретился термин "итерирование". И если в других языках это слово могут применять к любым циклам, то в Python у этого слова есть и другое значение: итерирование — это взаимодействие с неким объектом, поддерживающим протокол итерации.

Для начала разберём, что же такое протокол в контексте Пайтона. Протоколом называют набор определенных действий над объектом. И если некий объект "А" позволяет совершать над собой действия, описанные неким протоколом "Б", то говорят: "объект А реализует протокол Б" или "объект А поддерживает протокол Б". В последующих курсах вы узнаете, что различных протоколов в Python — множество. Даже многие синтаксические конструкции языка работают для самых разных объектов сходным образом именно потому, что объекты реализуют специальные протоколы. Так мы можем в шаблон подставлять не только строки, но и значения других типов, потому что эти типы реализуют протокол приведения к строке! В Python протоколы встречаются на каждом шагу.
'''

#@ Протокол итерации

'''
Протокол итерации — один из самых важных протоколов в Python. Ведь именно он позволяет циклу for работать с самыми разными коллекциями единообразно. В чём же заключается этот протокол? Протокол требует от объекта быть итерируемым (iterable), т.е. иметь специальный метод __iter__ (да, в Python не только файлы принято называть в таком стиле). Если у iterable-объекта вызвать метод __iter__, то метод должен вернуть новый специальный объект — так называемый итератор (iterator). А итератор, в свою очередь, должен иметь метод __next__.

Звучит сложно, но давайте рассмотрим живой пример — итерирование списка. Список — итерируемый, поэтому нам подходит. Итак, создадим список и итератор для него:

>>> l = [1,2,3,5,8,11]
>>> i = iter(l)
>>> i
<list_iterator object at 0x7f517843a240>

Я вызвал для списка функцию iter, но на самом деле эта функция просто вызывает у списка соответствующий метод __iter__. Это сделано для удобства чтения кода, ведь читать имена вроде __foo__ не очень удобно. Некоторые другие функции делают что-то подобное, например функция len. Большинство же специальных методов с похожими именами вызывается внутри каких-то языковых конструкций и не предназначено для вызова напрямую.

Теперь у нас есть итератор i, попробуем повызывать у него метод __next__ как напрямую, так и с помощью более удобной функции next:


>>> i.__next__()
1
>>> i.__next__()
2
>>> next(i)
3
>>> next(i)
5


Как мы видим, при каждом вызове метод возвращает очередной элемент исходного списка. А между вызовами он помнит свою позицию в списке. Т.о. итератор выполняет роль "курсора" в вашем редакторе текста: если нажимать стрелки, то курсор перемещается и указывает на новое место в тексте. Только итератор — это курсор, умеющий перемещаться только в одну сторону.

Но что же произойдёт, когда элементы в списке кончатся? Проверим:

>>> next(i)
8
>>> next(i)
11
>>> next(i)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

Когда итератор достиг конца исходного списка, последующий вызов next привёл к специальной ошибке StopIteration. Только в данном случае это не ошибка, ведь всё когда-нибудь заканчивается! StopIteration — это исключение (exception). Об исключениях мы поговорим позже, а пока нужно лишь знать, что те средства языка, которые работают на основе протокола итерации, знают, как реагировать на это конкретное исключение. Например, цикл for "молча" завершает работу :)

Теперь вы уже можете представить, как на самом деле работает цикл for. Он получает у iterable объекта новый итератор, а затем вызывает у итератора метод __next__ до тех пор, пока не будет выброшено исключение StopIteration. Интересно, не правда ли? Но дальше будет ещё интереснее!
'''

#@ Цикл for и итераторы

'''
Что же будет, если сначала получить итератор потом передать циклу for? Такое возможно, ведь цикл for достаточно умён — он понимает, что можно сразу начать вызывать __next__!

Давайте напишем функцию, ищущую в цикле первую строку, длина которой больше пяти символов:
'''

def search_long_string(source):
    for item in source:
        if len(item) >= 5:
            return item


#@ А теперь создадим список, содержащий несколько подходящих строк и запустим функцию для этого списка пару раз:

'''
>>> animals = ['cat', 'mole', 'tiger', 'lion', 'camel']
>>> search_long_string(animals)
'tiger'
>>> search_long_string(animals)
'tiger'

Функция оба раза вернула одну и ту же строку, ведь мы передали в неё iterable, а значит цикл for создавал каждый раз новый итератор.

Но давайте же создадим итератор сами и передадим в функцию уже его:

>>> animals = ['cat', 'mole', 'tiger', 'lion', 'camel']
>>> cursor = iter(animals)
>>> search_long_string(cursor)
'tiger'
>>> search_long_string(cursor)
'camel'
>>> search_long_string(cursor)
>>> search_long_string(cursor)
>>>

Уже интереснее! Итератор запомнил состояние между вызовами функций, и мы нашли оба длинных слова. Последующие вызовы функции не вернули ничего (вернули None), потому что итератор дошёл до конца (и запомнил это).

А ведь итераторов для одного и того же списка можно создать несколько! И каждый будет помнить свою позицию! Работая с кодом на Python вы непременно увидите и не раз интересные применения протокола итерации. А поэкспериментировать прямо в REPL вы можете уже сейчас!
'''

#@ Генераторы

'''
В Python не только коллекции являются iterable. Ещё существуют так называемые генераторы (generators). Что же такое генератор? Генератор — это iterable, элементы которого не хранятся в нём, но создаются по мере необходимости. Для примера возьмём генератор range. Вот как он работает:

>>> numbers = range(3, 11, 2)
>>> for n in numbers:
...     print(n)
...
3
5
7
9
>>> list(numbers)
[3, 5, 7, 9]

Здесь range генерирует последовательность чисел от 3 до (но не включая) 11 с шагом 2 (шаг и начальное значения можно опускать, тогда счёт будет производиться от нуля и с шагом в единицу). Цикл for итерирует числа. Затем я использую функцию list, чтобы получить список — эта функция может принять в качестве единственного аргумента iterable или iterator, элементы которого сложит во вновь созданный список.

Функция list накапливает значения в список, а tuple — в кортеж.

range представляет собой перезапускаемый генератор. Для такого генератора можно создавать сколько угодно итераторов, и для каждого из них значения будут генерироваться заново.

Существуют и не перезапускаемые генераторы. Эти при вызове метода __iter__ всегда возвращают один и тот же итератор. Поэтому по значениям такого генератора можно пройтись только один раз! Примером такого генератора является enumerate, который мы рассматривали на прошлом уроке. Давайте ещё раз взглянем на него:

>>> l = enumerate("asdf")
>>> list(l)
[(0, 'a'), (1, 's'), (2, 'd'), (3, 'f')]
>>> list(l)
[]


Вторая попытка проитерировать объект в переменной l ничего не даёт, т.к. генератор уже отработал один проход.

А вот ещё один встроенный генератор — zip. Этот генератор принимает на входе несколько iterable или iterators и поэлементно группирует в кортежи. Демонстрация:


>>> keys = ["foo", "bar", "baz"]
>>> values = [1, 2, 3, 4]
>>> for k, v in zip(keys, values):
...     print(k, "=", v)
...
foo = 1
bar = 2
baz = 3
>>> z = zip(range(10), "hello", [True, False])
>>> list(z)
[(0, 'h', True), (1, 'e', False)]
>>> list(z)
[]

Пример демонстрирует два момента:
> zip — не перезапускаемый,
> zip — перестаёт генерировать кортежи, как только заканчиваются элементы в любом из источников.
'''

#@ Генераторы и ленивые вычисления

'''
Большая часть языков программирования выполняет код в том порядке, в котором элементы кода написаны. Инструкции выполняются сверху вниз, выражения вычисляются после того, как будут вычислены их составляющие, функции вызываются после того, как будут вычислены их аргументы. Такая модель исполнения называется энергичной (eager).

Существует и ленивая (lazy) модель вычисления. В рамках этой модели вычисления производятся только тогда, когда их результат становится действительно нужен. Т.к. в любой программе при разных входных данных могут быть не нужны отдельные вычисления, то ленивая модель вычисления может дать определённые преимущества: то, что не нужно — не будет вычислено. Т.о. ленивость можно рассматривать как своего рода оптимизацию.

Python, как язык с энергичной моделью вычисления, практически всегда и всё вычисляет сразу. Однако отдельные элементы ленивости присутствуют и в Пайтоне. Генераторы — один из таких элементов. Генераторы производят элементы только по мере необходимости. И даже целые конструкции, собранные из генераторов — эдакие конвейеры, собирающие составные значения — производят сборку по одному изделию за раз!

Так составной генератор zip(range(100000000), "abc") не генерирует все сто миллионов чисел, ведь строка "abc" слишком коротка, чтобы образовать столько пар. Но даже и этих пар не будет, если результат вычисления этого выражения не будет проитерирован! Так ленивость позволяет экономить память при обработке больших потоков данных — нам не нужно загружать все данные целиком, достаточно загружать и обрабатывать их небольшими порциями.

#@ Ссылки

itertools https://docs.python.org/3/library/itertools.html — очень полезный модуль стандартной библиотеки. Содержит множество функций для создания итераторов и дальнейшей работы с ними.



#@
src/solution.py
Цель данного упражнения — реализовать функцию find_second_index. В этом упражнении вам пригодится функция find_index, которую вы реализовали в прошлом упражнении. Напоминаю, эта функция возвращает индекс первого элемента последовательности, равного заданному значению. Функция find_second_index же должна возвращать индекс второго подходящего элемента в последовательности. Если подходящих элементов в последовательности меньше двух или же последовательность пуста, нужно всё так же возвращать None.

>>> find_second_index('b', 'bob')
2
>>> find_second_index('a', 'cat') is None
True

Новую функцию вам следует реализовывать с помощью уже имеющейся find_index. И не забудьте, что итератор сохраняет позицию, в которой остановился обход — это знание поможет вам в решении поставленной задачи!
'''

def find_index(value, items):
    for index, item in enumerate(items):
        if item == value:
            return index

def find_second_index(value, items):
    iterator = iter(items)
    first = find_index(value, iterator)
    second = find_index(value, iterator)
    if second is not None:
        return first + second + 1


# >>>>>> Итоги <<<<<<

'''
В рамках курса вы узнали о списках и том, как ими пользоваться. Однако в курсе был описан преимущественно императивный подход к работе со списками: списки модифицировались "по месту" путём выполнения некоторых последовательностей действий, т.е. вы объясняли компьютеру каким образом получить нужный результат. Этот подход позволяет использовать списки эффективно, и вы, используя его, будете писать программы, работающие быстро.

Однако императивный подход — не единственный. Есть и другие подходы. Например, декларативный — этот описывает в коде, что вы хотите получить в итоге. Немного к нему я уже прикоснулся, рассказав про генераторы. В последующих курсах вы узнаете, как реализовывать генераторы, а также узнаете о других инструментах декларативного программирования коллекций.

Полезно и "понимание разницы между iterable и iterator". Позже вы узнаете о других коллекциях. И эти коллекции тоже реализуют протокол итерации, поэтому использовать тот же цикл for получится и с ними. Удобно!

Помимо списков вы узнали и о таких концепциях, как ссылки и протоколы. Понимание того, что многие синтаксические конструкции работают на основе протоколов, поможет вам проектировать свои типы данных так, что с ними будет удобно и приятно работать и вам, и другим программистам. А знание того, что объекты всегда передаются по ссылке, поможет в отладке объекто-ориентированного кода и многопоточных приложений.

Также вопросы на понимание работы со ссылками и использование различных протоколов часто задают на собеседованиях! Про итераторы тоже спрашивают :)
'''

'''

'''

'''

'''

'''

'''

'''

'''

'''

'''

'''
