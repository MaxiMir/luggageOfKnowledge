####### Python #######
	 
'''
Документация на русском (неофициальная, неполная) https://pythoner.name/documentation/reference
Документация на английском (официальная, полная) https://docs.python.org/3/
'''

#@ Типы данных и переменные

# числа

number1 = 42
number2 = -1000.005

# строки

string1 = "string"
string2 = 'string (another)'
long_string = '''very
"long" string with various 'quotes'
inside'''

# логические значения

x = True
y = False


#@ Преобразование типов
one = int('234')
two = str(34)


#@ Операции

# Арифметические операции
1 + 5 - 8 * 3 / 2 % 4

# Логические операции
True or False and not True

# Создание переменных
string = 'i am a string'

# Обращение к символам строки
string[0]  # i
print("-> {}".format(string)) # -> i am a string
print('-> ' + string) # -> i am a string


# Условные конструкции
if a > b:
	 print('a больше, чем b')
elif a == b:
    print('a равен b')
else:
	 print('a меньше, чем b')

result = 'yes' if a > b else 'no'


# Циклы
i = 1
while i <= 10:
    i = i + 1
    print(i)
    if i > 5:
        break


# Функции

# Определение функции
def get(string, index=0):
    return string[index]

# Вызов функции
get('lala', 3)


'''
src/solution.py
Реализуйте функцию binary, которая возвращает двоичное представление десятичного числа в виде строки.

Алгоритм
Перевод числа из десятичной системы в двоичную делается по следующему алгоритму:

Исходное число (number) делится пополам.
Остаток от деления (modulo) записывается в начало строки (result).
Исходным числом становится число полученное по формуле: number // 2.
Если исходное число (number) больше нуля, то повторяем с первого пункта.
Если исходное число равно нулю, то возвращаем (result).

10 / 2  5 0
 5 / 2  2 1
 2 / 2  1 0
          1
-> 1010

Примеры
'''

binary(0)  # '0'
binary(1)  # '1'
binary(5)  # '101'

'''
Подсказки
Перед добавлением в строку числа нужно превратить в строки str(modulo)
'''

# FILE: /app/src/solution.py

def binary(number):
    if not number:
        return '0'
    binary_number = ''
    while number:
        bit = number % 2
        binary_number = str(bit) + binary_number
        number = number // 2
    return binary_number


# FILE: /app/tests/test_solution.py
import unittest

import solution

class TestBinary(unittest.TestCase):

    cases = [
		 ['0', 0],
		 ['1', 1],
		 ['101', 5],
		 ['110', 6],
		 ['1011', 11],
		 ['1100101', 101],
		 ['100100101001', 2345],
	 ]

    def test_cases(self):
        for expectation, argument in self.cases:
            self.assertEqual(1, 1)



'''*@@@
src/solution.py
Реализуйте и функцию is_power_of_three, которая определяет, является ли переданное число натуральной степенью тройки. Например, число 27 — это третья степень: 3 ** 3, а 81 — это четвёртая: 3 ** 4.

>>> is_power_of_three(1)
True
>>> is_power_of_three(2)
False
>>> is_power_of_three(9)
True
'''

def is_power_of_three(number):
    counter = 1  # 3 ** 0
    while counter < number:
		  counter *= 3
    return counter == number


	
'''*@@@
Реализуйте функцию fib, находящую положительные Числа Фибоначчи. Аргументом функции является порядковый номер числа.
'''
def fib(index):
    if index <= 0:
        result = 0
    elif index == 1:
        result = 1
    else:
        result = fib(index - 1) + fib(index - 2)
    return result


'''*@@@
Реализуйте функцию binary_sum, которая принимает на вход два двоичных числа (в виде строк) и возвращает их сумму. Результат (вычисленная сумма) также должен быть бинарным числом в виде строки.

Посмотрите примеры работы функции:
'''

binary_sum('10', '1')      # 11
binary_sum('1101', '101')  # 10010

def binary_sum(number_a, number_b):
    binary_a = int(number_a, base=2)
    binary_b = int(number_b, base=2)
    return bin(binary_a + binary_b).replace('0b', '')


'''*@@@
Реализуйте функцию fizz_buzz, которая возвращает строку с числами (через пробел) в диапазоне от begin до end включительно. При этом:

> Если число делится без остатка на 3, то вместо него выводится слово Fizz
> Если число делится без остатка на 5, то вместо него выводится слово Buzz
> Если число делится без остатка и на 3, и на 5, то вместо числа выводится слово FizzBuzz
> В остальных случаях в строку добавляется само число
Функция принимает два параметра (begin и end), определяющих начало и конец диапазона (включительно). Если диапазон пуст (в случае, когда begin > end), то функция возвращает пустую строку.
'''

def fizz_buzz(start, stop):
    result = ''
    while start <= stop:
        if result:
            result += ' '
        if start % 15 == 0:
            result += 'FizzBuzz'
        elif start % 3 == 0:
            result += 'Fizz'
        elif start % 5 == 0:
            result += 'Buzz'
        else:
            result += str(start)
        start += 1
    return result




'''*@@@
Реализуйте функцию is_palindrome, которая принимает на вход слово, определяет является ли оно палиндромом и возвращает логическое значение.

Примеры использования:
'''

is_palindrome('radar')  # True
is_palindrome('a')      # True
is_palindrome('abs')    # False

def is_palindrome(string):
    start = 0
    end = len(string) - 1
    while end - start > 0:
        if string[start] != string[end]:
            return False
        start += 1
        end -= 1
    return True


'''*@@@
В этом испытании вы будете работать с "тройками" — кортежами из трёх элементов. Вам предстоит реализовать две функции, которые "вращают" тройку влево и вправо. Как это выглядит, вы можете понять из пары примеров:

>>> triple = ('A', 'B', 'C')
>>> rotate_left(triple)
('B', 'C', 'A')
>>> rotate_right(triple)
('C', 'A', 'B')
'''

def rotate_left(triple):
    elem1, elem2, elem3 = triple
    return (elem2, elem3, elem1)


def rotate_right(triple):
    elem1, elem2, elem3 = triple
    return (elem3, elem1, elem2)


#>>>>>> Отладка <<<<<<

'''
Один из наиболее достоверных способов убедиться в том, что человек разбирается в программировании — посмотреть на то, как он отлаживает программу, то есть анализирует возникающие ошибки и устраняет их. Навык отладки (дебага, debug) не появляется сам по себе, его необходимо развивать и начинать это делать нужно как можно раньше. Этому весьма способствует настройка локальной среды разработки и повторение всего того, что делается в курсах, у себя на компьютере. Следующие курсы как раз помогают проделать эти шаги.

Первое, что вам понадобится для отладки — это хотя бы минимальное знание английского языка и умение пользоваться словарём. В отличие от документации языка, которую можно найти на русском, сообщения об ошибках будут всегда написаны на английском. Не пытайтесь отгадывать или менять код методом тыка в надежде, что он заработает. Прочитайте сообщение об ошибке, поймите его. Понимание — это ключевое действие, на основе которого можно планировать дальнейшие шаги.

Traceback (most recent call last):
  File "users.py", line 4, in <module>
    main()
  File "users.py", line 2, in main
    create()
NameError: name 'create' is not defined


Вывод ошибок делится на две части: непосредственно сообщение об ошибке и трейсбэк (traceback). Traceback — это список всех вызовов функций от запуска программы вплоть до того места, где произошла ошибка. Трейсбэк — очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа и какие функции вызывались. Отладка всегда сводится к двум вещам:

1. Перевести сообщение об ошибке
2. Найти в трейсбэке то место в своем коде, в котором произошла ошибка.

Каждая запись в трейсбэке представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. В рамках одного трейсбэка возможны (и часто встречаются) ситуации, когда часть функций вызывается где-то в библиотеках, которые вы не писали, но используете, а часть — в вашем коде.

# Типы ошибок
Наиболее простые и понятные ошибки — синтаксические. Они связаны исключительно с тем, что код записан неверно, например, забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствует фраза "SyntaxError: …". Для их исправления нужно открыть то место в коде, на которое указывает ошибка, и внимательно на него посмотреть.

Traceback (most recent call last):
  File "users.py", line 2
    print("Hello" + "world')
                           ^
SyntaxError: EOL while scanning string literal


Ещё одна большая группа ошибок называется ошибками программирования. К ним, например, относятся:

- вызов несуществующей функции
	 - использование необъявленной переменной
	 - передача неверных аргументов в функции, например, аргументов, имеющих неверный тип

Эти ошибки исправить труднее, чем синтаксические. Обычно они возникают в результате неправильной логики в другом, более раннем вызове.

	 Последний тип ошибок — логические ошибки. Исправить такие ошибки бывает крайне сложно, так как программа продолжает работать, но выдаёт неверный результат. Причём, обычно программа выдаёт неверный результат не всегда, а только лишь для некоторых входных данных. В подавляющем большинстве случаев проблема кроется в неверной логике: скажем, если перепутана операция, и вместо сложения выполняется вычитание.
'''

# Функция должна считать сумму чисел, но считает разность:
def sum(a, b):
    return a - b

# при таком вызове ошибка неочевидна, потому что
# и при сложении и при вычитании будет один и тот же результат
sum(4, 0)  # 4

# Отладка

'''
Существует множество способов отладки программ. Но какой бы способ вы не выбрали, общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.

	 Рассмотрим конкретный пример. Ниже описана функция, которая считает сумму чисел от числа start до числа finish. Если начало равно трём, а конец — пяти, то программа должна вычислить: 3 + 4 + 5.
'''
def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        result += n
        n += 1
    return result

'''
В этом коде допущена ошибка. Вы её видите? Если очень постараться, ошибку можно заметить, но на это никогда не стоит надеяться. Новички часто думают, что они невнимательны, и очень расстраиваются, когда допускают такие ошибки. Хочу вас успокоить: опытные разработчики допускают такие ошибки не реже новичков. Важно не то, что вы их допускаете, а то, что вы способны отладить этот код (и сделать это быстро). Этим отличаются опытные разработчики от начинающих. Никогда не пытайтесь найти ошибку с помощью "медитации" над кодом, сверля его взглядом. Если быстрая проверка не дала ответа, то приступайте к отладке.

	 На Хекслете, в обсуждении уроков, ученики часто нам пишут: "этот код не работает", и показывают свой код. Вероятно, начинающие разработчики думают, что опытные могут понять, в чём ошибка и найти её, просто посмотрев на код. Но это совсем не так. Глядя на такой код, невозможно понять, а что, собственно, пошло не так. И я уже не говорю про нахождение самой ошибки. Нам также нужно увидеть сообщение об ошибке и начать отладку.

	 Глядя на код функции sum_of_series замечаем, что основных переменных там две: n и result — именно они меняются в цикле. Из этого можно сделать ровно один вывод: нужно явно посмотреть, какие значения им даются на каждой итерации. После этого найти ошибку не составит труда.

	 Один из способов отслеживать значения переменных во время выполнения кода связан с использованием специальных программ-отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживая любые изменения. Подробнее о том, как их использовать можно прочитать во множестве статей (гуглить "python pdb").
'''

# Отладочная печать

'''
В среде Хекслета отладчика нет, поэтому здесь используется другой подход (но выполняющий ту же задачу) — отладочная печать. Суть такая же, как и в визуальном отладчике, но для вывода значений переменных используется обычная печать на экран:
'''

def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        print('new iteration !!!!')
        print(n)
        result += n
        n += 1
        print(result)
    return result

sum_of_series(3, 5)

# new iteration !!!!
# 3
# 3
# new iteration !!!!
# 4
# 7

'''
То, что печатается на экран, отображается во вкладке OUTPUT, на которую автоматически переключается редактор во время проверки. Из этого вывода сразу можно понять, что итераций цикла на одну меньше, чем нужно. Почему-то не выполняется сложение для последнего числа, которое обозначено как finish. И действительно, если посмотреть на определение, то видно, что там используется n < finish вместо n <= finish.

# Дополнительные материалы
	 Как найти ошибки в коде? https://help.hexlet.io/article/7-how-to-debug-code
		 pdb — The Python Debugger https://docs.python.org/3/library/pdb.html
'''



>>>>>> Модули <<<<<<

'''
Программы на Python содержат тысячи, десятки тысяч и сотни тысяч строк кода (есть проекты с миллионами). В таких условиях одним файлом с кодом не обойдёшься — его нужно разбивать на части. Для получения доступа к коду, который находится в других файлах, в Python реализован механизм модулей.

# Модули и импортирование
	 Итак, файл с кодом на Python называется модулем. Имя модуля соответствует имени файла, поэтому файлы в Python принято называть в стиле "snake_case" (отметьте иронию: Python — питон — змея — snake — snake_case). Одни модули могут использовать содержимое других, если импортируют эти другие модули с помощью инструкции import.

	 Строго говоря, в Python импортировать модули можно несколькими способами:

импортировать сам модуль
импортировать отдельные определения из модуля
импортировать всё содержимое модуля сразу


# Импортирование модуля

Рассмотрим применение первого способа — импортирование модуля целиком. Главное удобство упоминания модуля по имени: глядя на код, мы сразу видим, что используемая переменная или вызываемая функция — это часть модуля.

	 Синтаксис импорта: import <имя_модуля (без суффикса ".py")>

Всё просто: после ключевого слова import указываем имя модуля (файла). Но при этом суффикс .py в имени надо опустить. То есть, к примеру, для модуля с именем my_module.py в инструкции импорта достаточно прописать my_module, а полный вид инструкции будет таким: import my_module.

	 В модуле (файле) с именем greeting.py определим функцию say_hi и переменную name:
'''

# file: greeting.py
def say_hi():
    print('Hi!')

name = 'Bob'

// А в модуле с именем main.py сделаем импорт содержимого модуля greeting.py:

# file: main.py
import greeting  # заметьте, расширение ".py" не указывается!

print(greeting.name)  # => Bob
greeting.say_hi()     # => Hi!

'''
Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это greeting. К содержимому же модуля можно обратиться, как говорят, "через точку". Причём можно как получить доступ к переменным (greeting.name), так и вызывать функции модуля (greeting.say_hi).

# Импортирование отдельных определений

	 Синтаксис импорта: from <имя_модуля (без суффикса ".py")> import <список определений>

	 Иногда из всего модуля нужна пара функций или переменных, а имя модуля слишком длинное, чтобы писать его каждый раз. Здесь нам может пригодиться следующий вариант использования инструкции import:
'''

# file: main.py
from greeting import say_hi, name

print(name)  # используем переменную
say_hi()     # вызываем функцию

'''
Здесь после ключевого слова from указано имя модуля, а затем после ключевого слова import — имена определений из этого модуля, которые мы в дальнейшем хотим использовать напрямую (а не "через точку").

В следующем уроке мы рассмотрим третий вариант импортирования модуля ("импорт всего содержимого") и в целом немного углубим наши познания в этой теме.
'''




>>>>>> Модули поглубже <<<<<<

'''
Продолжим знакомиться с системой модулей языка Python. Но для начала…

# Немного терминологии
В предыдущем уроке несколько раз встречалось словосочетание "через точку". Так часто говорят для краткости. Однако для такой формы записи имён определений (module.name) существует и официальный термин: квалифицированное имя от слова "квалифицировать" ("qualify"). Соответственно, "импорт модуля целиком" (см. прошлый урок) официально называется квалифицированным импортом.

	 Также стоит отметить, что в Python все строчки с import принято располагать в самом начале кода модуля. Такой набор строчек часто называют "блок импортов", хотя синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой. Нужна эта группировка во многом для того, чтобы можно было быстро найти, что в текущем модуле откуда пришло — при работе с чужим (и даже своим!) кодом подобным часто приходится заниматься.

# Импорт всего содержимого модуля
	 Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:
'''
from some_module import *
from another_module import *

'''
Здесь из модулей some_module и another_module импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за *!

	 Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.

# Сочетание способов импортирования
	 Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!

	 Давайте рассмотрим пример.

	 В модуле computation.py определим функцию и переменные:
'''

# file: computation.py
PI = 3.1415926
E = 2.7182818

def pi_times(x):
    return x + PI

// А в модуле main.py сделаем разными способами импорты из модуля computation.py:

# file: main.py
import computation
from computation import PI, E
from computation import pi_times

print(PI)
print(computation.E)
print(pi_times(2))
print(computation.pi_times(E))

'''
Из кода видно, что:

оба способа импорта использованы совместно
импортировать отдельные определения можно в несколько заходов
если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы
'''

>>>>>> Пакеты <<<<<<

'''
Мы уже знаем, что в Python код хранится в отдельных файлах, называемых модулями. Но если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько модулей "по смыслу". Или же мы захотим вынести часть модулей из проекта с целью использования оных в других проектах. Для объединения модулей в группы и служат пакеты (packages).

	 Итак, пакет — это папка (далее "каталог") с файлами модулей, имеющая имя в формате "snake_case" и содержащая, помимо прочего, специальный модуль с именем "__init__.py". Именно наличие этого специального файла подсказывает интерпретатору Python, что каталог следует воспринимать именно как пакет.

# Простейший пакет

	 Давайте рассмотрим пример простейшего пакета. Пусть пакет состоит из каталога package и модуля __init__.py внутри этого каталога:

package/
└── __init__.py
Файл __init__.py пусть содержит код:
'''

# file __init__.py
NAME = 'super_package'

// Это, хотя и небольшой, но уже полноценный пакет. Его можно импортировать так же, как мы импортировали бы модуль:

import package

print(package.NAME)

'''
Заметьте — мы не импортировали файл __init__.py непосредственно. При первом обращении к пакету Python автоматически импортирует модуль __init__.py в этом пакете. Поэтому, очевидно, нельзя импортировать "просто каталог" — ведь каталог без файла __init__.py не будет полноценным пакетом!

# Содержимое пакета
	 С простым пакетом всё ясно — его можно использовать как модуль. Но давайте уже перейдём к группировке в пакете нескольких модулей! Для этого в пакет положим ещё два модуля:

package/
├── constants.py
├── functions.py
└── __init__.py
Содержимое модуля constants.py:
'''
# file constants.py
PERSON = 'Alice'

// Содержимое модуля functions.py:
# file functions.py
def greet(who):
    print('Hello, ' + who + '!')

// Когда пакет содержит другие модули, кроме __init__.py, таковые можно импортировать по их именам. В главе про модули упоминались два варианта импортирования: квалифицированный импорт и импортирование отдельных определений. Квалифицированный импорт в данном случае будет выглядеть так:

import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

// Этот вариант самый понятный: в строчке вызова функции greet сразу видно, откуда пришла функция, а откуда — её аргумент. Но писать имя пакета и имя модуля каждый раз — утомительно! Давайте импортируем сами функцию и аргумент:

from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!

// Так строчка вызова функции выглядит гораздо лучше! Но помните, что тому, кто будет читать этот код в дальнейшем, потребуется посмотреть в блок импортов, чтобы узнать, откуда функция и константа появились.

>>>>>>>> Модуль random <<<<<<<<
'''
Python знаменит тем, что поставляется в комплекте с "батарейками" - так называют модули и пакеты, составляющие стандартную библиотеку. Более того, батареек в поставке Пайтона изрядное количество! Настоящий питонист (pythonista) - так мы, программисты на Python, себя называем - обязан хорошо ориентироваться в стандартной библиотеке, ведь это знание позволяет экономить время и силы. В этом уроке мы познакомимся с первой батарейкой - модулем random.

	 При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из некоего множества значение. Случайные значения полезны, когда мы разрабатываем компьютерные игры, генерируем изображения и звук, и даже просто пишем тесты.

	 Любое значение в компьютере может быть представлено в виде набора чисел, поэтому получение случайных значений всегда предполагает использование Генератора Случайных Чисел, ГСЧ. ГСЧ бывают программными (специализированные программы) и аппаратными (специализированные устройства), но программист обычно работает с некоторой обобщённой "обёрткой" - модулем или пакетом, который скрывает ненужные детали.

	 Модуль random предоставляет множество функций, полезных в разных ситуациях, но мы пока остановимся на двух:

randint, генерация целого числа в заданном диапазоне,
choice, выбор случайного элемента из заданного набора.

# Генерация случайных чисел
	 Для того, чтобы сгенерировать случайное число, нам нужно импортировать функцию randint из модуля random:
'''
from random import randint

// Теперь мы можем сгенерировать число от 1 до 100:
random_number = randint(1, 100)

// При вызове randint с такими границами диапазона может "выпасть" и 1 и 100 - обе границы диапазона включены и об этом следует помнить. Когда это может быть важно? Давайте рассмотрим другой пример - выбор случайного символа некоторой строки:

string = 'abcde'
random_index = randint(0, len(string) - 1)
char = string[random_index]

'''
Строка в переменной string имеет длину 5. Но мы помним, что символы строки индексируются с нуля, поэтому если сгенерировать индекс так randint(0, 5), то в какой-то момент мы получим значение 5 и при попытке взять символ по этому индексу мы увидим ошибку IndexError: индекс последнего элемента в строке равен 4! Вот поэтому в коде выше из длины вычитается единица.

# Выбор случайного элемента
	 Выше мы рассмотрели пример, в котором выбирался случайный символ строки. Эта задача возникает достаточно часто, поэтому в модуле random существует функция choice. С использованием этой функции выбор символа строки будет выглядеть так:
'''

from random import choice

string = 'abcde'
char = choice(string)

'''
При использовании choice не нужно думать о границах генерируемых индексов. И даже о самих индексах думать не нужно - функция сама знает, как правильно и безопасно выбирать элементы! Правда, придётся заботиться о том, чтобы строка, из который мы выбираем символы, не была пустой, иначе мы получим ошибку IndexError: Cannot choose from an empty sequence ("Нельзя просто так взять и выбрать, если выбирать не из чего").
	
		 Пока мы можем использовать choice только со строками, ведь это единственный тип, значения которого могут содержать несколько элементов. Но в дальнейшем мы познакомимся и с другими составными типами - и с многими из таких типов функция choice тоже может работать!

# Случайна ли случайность?
	 Строго говоря, генерируемые числа у компьютера получаются не полностью случайными, поэтому большинство ГСЧ представляют собой генераторы псевдослучайных чисел. И хотя для простоты приставку "псевдо-" часто опускают (как поступили и мы), о ней не стоит забывать. Дело в том, что некоторые алгоритмы требуют максимально случайной генерации чисел. Одна из областей с такими высокими требованиями к качеству случайности — криптография (шифрование). Представьте, что вы сгенерировали случайный пароль, длинный и сложный, а злоумышленник, пользуясь тем, что при определённых условиях можно воспроизвести ту же последовательность случайных чисел, получил тот же пароль! Вот поэтому существует большое количество специализированных ГСЧ, безопасных для использования в шифровании и создание таких генераторов - это важная, сложная и интересная работа.

# Ссылки
	 Модуль random https://docs.python.org/3.6/library/random.html
ГСЧ https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел
'''

>>>>>> Кортежи <<<<<<<
'''
До этого момента мы встречались только с примитивными типами — строка, число, булев тип. Ещё нам знакомы функции и модули с пакетами (да, в Python модули и пакеты, это тоже значения специальных встроенных типов). Но часто в программировании приходится создавать более сложные, чем числа и строки, значения и манипулировать такими значениями. Именно поэтому во многих языках программирования есть составные типы. Значение составного типа может состоять как из значений примитивных типов, так и из значений других составных типов, таким образом составные типы позволяют описывать сущности произвольной сложности — и шахматные доски, и космические ракеты!

	 В этом уроке мы познакомимся с самым простым, но очень полезным составным типом — кортежем (в англоязычных текстах оный известен, как tuple).

# Кортежи
Кортеж — это несколько значений, записанных через запятую. Да, всё очень просто! Вот несколько примеров:
'''
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

'''
Определять кортежи очень просто, сложности могут возникнуть только с кортежами, содержащими ровно один элемент. Если мы просто укажем значение в скобках, то Python подумает, что мы хотим посчитать арифметическое выражение со скобками:
'''
not_a_tuple = (42)  # 42

// Чтобы сказать пайтону, что мы хотим создать именно кортеж, нужно поставить после элемента кортежа запятую:

tuple = (42,)  # (42,)

'''
Да, форма записи довольно необычная, но вы привыкнете :)

# Возврат нескольких значений из функции
Кортежи очень полезны, когда нам нужно вернуть из функции сразу несколько значений. Так, функция, которая принимает два аргумента-числа и возвращает одновременно результат деления нацело и остаток от деления, будет выглядеть так:
'''

def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)

'''
# Получение элементов кортежа по индексу
Выше мы только создавали кортежи. Теперь научимся их разбирать! В простейшем случае достаточно обратиться к элементу кортежа по индексу:
'''

name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

// Также у кортежа есть длина, которую, как и для строки, можно получить с помощью функции len:

tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2

'''
# Деструктуризация
Обращение по индексу, это не самый удобный способ работы с кортежами. Дело в том, что кортежи часто содержат значения разных типов, и помнить, по какому индексу что лежит — очень непросто. Но есть способ лучше! Как мы кортеж собираем, так его можно и разобрать:
'''

name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42

'''
Именно таким способом принято получать и сразу разбирать значения, которые возвращает функция (если таковая возвращает несколько значений, конечно):
'''
(quotient, modulo) = div_mod(13, 4)

// Соответственно кортеж из одного элемента нужно разбирать так:
(a,) = (42,)
a  # 42

'''
Если же после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную a кортеж запишется целиком, т.е. ничего не распакуется! Всегда помните о запятых!

# Кортежи, множественное присваивание и обмен значениями
	 Благодаря тому, что кортежи легко собирать и разбирать, в Python удобно делать такие вещи, как множественное присваивание. Смотрите:
'''
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3

// Используя множественное присваивание, можно провернуть интересный трюк: обмен значениями между двумя переменными. Вот код:

a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100

'''
Cтрочку (a, b) = (b, a) нужно понимать как "присвоить в а и b значения из кортежа, состоящего из значений переменных b и a".

# Ссылки
	 Кортеж https://ru.wikipedia.org/wiki/Кортеж_(информатика)
'''


>>>>>> История развития языка Python <<<<<<

'''
Итак, мы учимся языку Python. Для начала стоит определиться с названием. Правильно говорить "Пайтон" с ударением на первом слоге — язык назван в честь известного комедийного шоу "Летающий Цирк Монти Пайтона", т.е. Пайтон — это фамилия, а фамилию человека принято произносить так, как это делает носитель фамилии!

	 Ещё пара сухих фактов:

Первый релиз интерпретатора языка Python был представлен в далёком 1991г,
Автор языка — Гвидо ван Россум.
	 Сам по себе язык — это не то же самое, что его интерпретаторы. Но основная реализация языка — CPython — настолько распространена, что почти всегда, когда мы слышим "Python", подразумевается именно она. Наши курсы тоже будут касаться именно CPython, это стоит иметь в виду!

# Самое начало
	 Python появился, чтобы заменить собой язык ABC, в работе над которым принимал участие будущий автор пайтона Гвидо ван Россум. Представленный в 1991 году Python версии 0.9.0 вобрал в себя многие идеи из существовавших на тот момент языков: например, взяв систему модулей из языка Modula-3. Элементы функционального программирования (их мы будем изучать в следующих курсах!) — функции map, filter, reduce — появились в языке тоже довольно рано, в версии 1.0.

	 Стоит отметить, что Пайтон изначально позиционировался как "язык для каждого", поэтому большой упор делался на читаемость кода и лаконичность синтаксиса. В версии 2.0 появились знаменитые "списковые включения" ("list comprehensions"), позаимствованные из языков SETL и Haskell. В этой же версии сборщик мусора (механизм автоматического управления памятью) научился работать с циклическими структурами. С ними мы также познакомимся в последующих курсах.

# Py2 vs Py3
	 Python, как язык, непрерывно развивается с самого начала времени своего существования. На данный момент в основном используются версии языка, начинающиеся с "3".

	 Первый релиз "третьего пайтона" (python3, py3) вышел ещё в 2008 году, но переход на это семейство версий со "второго пайтона" (python2, py2) происходил (кое-где всё ещё происходит!) "со скрипом". Дело в том, что py3 не полностью обратно совместим с кодом, написанным для py2, т.е. мы не можем просто заменить интерпретатор — нам потребуется внести определённые изменения в код! На такой шаг можно пойти, если наш проект — живой. Но с проектами, находящимися в состоянии "только поддержка" (такие проекты ещё называют legacy), такой фокус не пройдёт — обычно просто некому заниматься адаптацией. А ведь legacy-проекты — это не всегда лишь конечные приложения, в такой ситуации могут оказаться и библиотеки. Именно из-за невозможности отказаться от нужных, но существующих в состоянии legacy, библиотек многие проекты долго оставались несовместимыми с py3.

	 К счастью, сейчас большая часть библиотек, достаточно популярных и полезных в повседневной жизни разработчика, успешно переведена на py3, и новые проекты нужно делать именно на какой-то из версий этого семейства (сейчас рекомендуемая версия — это Python 3.7.x). Более того, py2 скоро перестанет быть безопасным для широкого использования! Дело в том, что техническая поддержка py2 — т.е. устранение уязвимостей и критических ошибок — с 2020г перестанет осуществляться. А мы ведь не хотим подвергать угрозе свои детища!

# Системный Python
	 Работая с Python, стоит иметь в виду, что Python распространён не только в виде языка, на котором пишутся конечные проекты: этот язык часто используется для автоматизации различных задач, скажем, по системному администрированию (Ansible — один из примеров написанного на Python ПО, используемого при администрировании). Поэтому python часто уже присутствует в установленных операционных системах.

	 Особенно велика вероятность обнаружить в системе установленный Python, когда речь идёт об ОС семейства Linux — а именно, какая-то из версий Linux будет скорее всего установлена на машину, на которой вы захотите запустить сервер своего web-приложения или многопользовательской игры (да, такие тоже пишут на Python!). Тут-то и кроется проблема: установленный вместе с операционной системой Python может быть тем самым "вторым пайтоном" — да, такое, увы, пока встречается. И заменить его будет нельзя, ведь замена может привести к выходу из строя всей ОС.

	 Но не пугайтесь, в курсе про настройку окружения вы узнаете, как использовать в проекте нужную версию Python и не бояться сломать что-то другое!
'''

'''*@@@
	 src/solution.py
Реализуйте функцию sort_pair, которая принимает пару (кортеж из двух значений) и возвращает пару, значения которой расположенны строго в порядке возрастания.

	 Пример:
'''

# обратите внимание на скобки у аргумента функции
sort_pair((5, 1)) == (1, 5)
sort_pair((2, 2)) == (2, 2)
sort_pair((7, 8)) == (7, 8)


// FILE /app/src/solution.py:
def sort_pair(pair):
    (first, second) = pair
    if first > second:
        return (second, first)
    return pair


'''*@@@
	 src/package/__init__.py
Дан пакет следующей структуры:

$ tree package
package/
├── __init__.py
├── functions.py
└── names.py
Добавьте в __init__.py блок импортов таким образом, чтобы можно было импортировать package и получить доступ

к константе NAME из package.names
к функции greet из package.functions
Если задание будет выполнено успешно, то следующий код должен будет работать:
'''

from package import greet, NAME

greet(NAME)  # 'Hello, Bob!'


// FILE: /app/src/__init__.py:
from package.names import NAME
from package.functions import greet


// FILE: /app/src/functions.py:
def greet(name):
    return 'Hello, {}!'.format(name)

// FILE: /app/src/names.py:
NAME = 'Bob'




'>>>>>> HTTP <<<<<<

'''
Популярный вопрос на собеседовании веб-разработчиков часто звучит так: «Что происходит после того, как в браузер ввели адрес сайта?». Подробный ответ на этот вопрос можно найти здесь. Главное, что хочет услышать собеседующий — ваш уровень понимания HTTP (Hyper-Text Transferring Protocol).

Для начала пару слов о том, что такое протокол. Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. HTTP — это набор правил, который известен и вашему компьютеру и физически отдалённому компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передаётся информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
'''
$ curl --head -v code-basics.ru
	 * Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
	 * Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
	 > User-Agent: curl/7.54.0
	 > Accept: *'''
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

'''
http нужно не просто знать, но и уметь делать сырые http-запросы — не косвенно через браузер, а самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.

# Для чего требуется знание http?
	 Работа с формами, загрузка файлов, перенаправления.
	 Аутентификация целиком зависит от http.
	 Извлечение информации о запросе (например, определение браузера, из которого был выполнен запрос).
Увеличение производительности. Кеширование.
	 Обеспечение безопасности. http — текстовый протокол без шифрования, он не безопасен.

# https
	 Кроме http, в сети всё большее распространение получает https. Каждый пользователь сети должен знать, что нельзя выполнять действия, связанные с любыми секретными данными (например кредитками), на страницах, работающих по протоколу http. В таком случае любой человек, имеющий доступ к оборудованию, которое лежит между вами и сервером, обслуживающим сайт, сможет прочитать эти данные. Обратите внимание, что на популярных сайтах страницы оплаты всегда отдаются по https. В свою очередь, умение работать с https сразу добавляет новые понятия:

Шифрование, асимметричное шифрование
Сертификаты
Цифровая подпись

# TCP/IP
Но одним http обойтись не получится. Дело в том, что http существует не сам по себе, а поверх стека протоколов TCP/IP. Базовое знание сетей важно по следующим причинам:

Безопасность. Очень легко совершить ошибку и быть взломанным.
	 Отладка. Немалая часть вопросов запуска и конфигурирования сайтов и их частей (в том числе базы данных) связана с сетевыми сокетами. Не зная сети вы будете останавливаться на любой простейшей проблеме без понимания, что вообще делать.

# DNS
	 Ещё один столп веба — DNS, служба доменных имён. Каждый раз, когда мы вбиваем адрес в браузер, он выполняет DNS запросы к соответствующим серверам для выяснения того, какой ip-адрес принадлежит сайту. Дело в том, что соединение с сервером идёт по tcp/ip, а не по http. http начинает работать уже после того, как было установлено tcp соединение. Знание DNS важно по следующим причинам:

Зная DNS вы сможете не только купить домен, но и привязать его к вашему серверу
Почта для домена, верификация вашего проекта различными сервисами — всё это работает через возможности DNS
Опять же, отладка. Нередко проблемы загрузки связаны с DNS.
'''<?

####### Python #######

#@ Документация
'''
Документация на русском (неофициальная, неполная) https://pythoner.name/documentation/reference
Документация на английском (официальная, полная) https://docs.python.org/3/
'''

#@ Типы данных и переменные

# числа

number1 = 42
number2 = -1000.005

# строки

string1 = "string"
string2 = 'string (another)'
long_string = '''very
"long" string with various 'quotes'
inside'''

# логические значения

x = True
y = False


#@ Преобразование типов
one = int('234')
two = str(34)


#@ Операции

# Арифметические операции
1 + 5 - 8 * 3 / 2 % 4

# Логические операции
True or False and not True

# Создание переменных
string = 'i am a string'

# Обращение к символам строки
string[0]  # i
print("-> {}".format(string))  # -> i am a string
print('-> ' + string)          # -> i am a string


# Условные конструкции
if a > b:
    print('a больше, чем b')
elif a == b:
    print('a равен b')
else:
    print('a меньше, чем b')

result = 'yes' if a > b else 'no'


# Циклы
i = 1
while i <= 10:
    i = i + 1
    print(i)
    if i > 5:
        break


# Функции

# Определение функции
def get(string, index=0):
    return string[index]

# Вызов функции
get('lala', 3)

'''
src/solution.py
Реализуйте функцию binary, которая возвращает двоичное представление десятичного числа в виде строки.

	 Алгоритм
Перевод числа из десятичной системы в двоичную делается по следующему алгоритму:

Исходное число (number) делится пополам.
	 Остаток от деления (modulo) записывается в начало строки (result).
	 Исходным числом становится число полученное по формуле: number // 2.
Если исходное число (number) больше нуля, то повторяем с первого пункта.
	 Если исходное число равно нулю, то возвращаем (result).

	 10 / 2  5 0
 5 / 2  2 1
 2 / 2  1 0
          1
-> 1010

Примеры

binary(0)  # '0'
binary(1)  # '1'
binary(5)  # '101'


Подсказки
Перед добавлением в строку числа нужно превратить в строки str(modulo)
'''

// FILE: /app/src/solution.py
def binary(number):
    if not number:
        return '0'
    binary_number = ''
    while number:
        bit = number % 2
        binary_number = str(bit) + binary_number
        number = number // 2
    return binary_number


// FILE: /app/tests/test_solution.py
import unittest

import solution


class TestBinary(unittest.TestCase):

    cases = [
        ['0', 0],
        ['1', 1],
        ['101', 5],
        ['110', 6],
        ['1011', 11],
        ['1100101', 101],
        ['100100101001', 2345],
    ]

    def test_cases(self):
        for expectation, argument in self.cases:
            self.assertEqual(1, 1)



'''*@@@
	 src/solution.py
Реализуйте и функцию is_power_of_three, которая определяет, является ли переданное число натуральной степенью тройки. Например, число 27 — это третья степень: 3 ** 3, а 81 — это четвёртая: 3 ** 4.

	 >>> is_power_of_three(1)
True
>>> is_power_of_three(2)
False
>>> is_power_of_three(9)
True
 '''

def is_power_of_three(number):
    counter = 1  # 3 ** 0
    while counter < number:
		  counter *= 3
    return counter == number
	
		 
		 
	
>>>>>> Отладка <<<<<<

'''
Один из наиболее достоверных способов убедиться в том, что человек разбирается в программировании — посмотреть на то, как он отлаживает программу, то есть анализирует возникающие ошибки и устраняет их. Навык отладки (дебага, debug) не появляется сам по себе, его необходимо развивать и начинать это делать нужно как можно раньше. Этому весьма способствует настройка локальной среды разработки и повторение всего того, что делается в курсах, у себя на компьютере. Следующие курсы как раз помогают проделать эти шаги.

	 Первое, что вам понадобится для отладки — это хотя бы минимальное знание английского языка и умение пользоваться словарём. В отличие от документации языка, которую можно найти на русском, сообщения об ошибках будут всегда написаны на английском. Не пытайтесь отгадывать или менять код методом тыка в надежде, что он заработает. Прочитайте сообщение об ошибке, поймите его. Понимание — это ключевое действие, на основе которого можно планировать дальнейшие шаги.

	 Traceback (most recent call last):
  File "users.py", line 4, in <module>
    main()
  File "users.py", line 2, in main
    create()
NameError: name 'create' is not defined


Вывод ошибок делится на две части: непосредственно сообщение об ошибке и трейсбэк (traceback). Traceback — это список всех вызовов функций от запуска программы вплоть до того места, где произошла ошибка. Трейсбэк — очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа и какие функции вызывались. Отладка всегда сводится к двум вещам:

1. Перевести сообщение об ошибке
2. Найти в трейсбэке то место в своем коде, в котором произошла ошибка.

	 Каждая запись в трейсбэке представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. В рамках одного трейсбэка возможны (и часто встречаются) ситуации, когда часть функций вызывается где-то в библиотеках, которые вы не писали, но используете, а часть — в вашем коде.

# Типы ошибок
	 Наиболее простые и понятные ошибки — синтаксические. Они связаны исключительно с тем, что код записан неверно, например, забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствует фраза "SyntaxError: …". Для их исправления нужно открыть то место в коде, на которое указывает ошибка, и внимательно на него посмотреть.

	 Traceback (most recent call last):
  File "users.py", line 2
    print("Hello" + "world')
                           ^
SyntaxError: EOL while scanning string literal


Ещё одна большая группа ошибок называется ошибками программирования. К ним, например, относятся:

- вызов несуществующей функции
- использование необъявленной переменной
- передача неверных аргументов в функции, например, аргументов, имеющих неверный тип

Эти ошибки исправить труднее, чем синтаксические. Обычно они возникают в результате неправильной логики в другом, более раннем вызове.

Последний тип ошибок — логические ошибки. Исправить такие ошибки бывает крайне сложно, так как программа продолжает работать, но выдаёт неверный результат. Причём, обычно программа выдаёт неверный результат не всегда, а только лишь для некоторых входных данных. В подавляющем большинстве случаев проблема кроется в неверной логике: скажем, если перепутана операция, и вместо сложения выполняется вычитание.
'''
# Функция должна считать сумму чисел, но считает разность:
def sum(a, b):
    return a - b

# при таком вызове ошибка неочевидна, потому что
# и при сложении и при вычитании будет один и тот же результат
sum(4, 0)  # 4

# Отладка

'''
Существует множество способов отладки программ. Но какой бы способ вы не выбрали, общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.

Рассмотрим конкретный пример. Ниже описана функция, которая считает сумму чисел от числа start до числа finish. Если начало равно трём, а конец — пяти, то программа должна вычислить: 3 + 4 + 5.
'''
def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        result += n
        n += 1
    return result

'''
В этом коде допущена ошибка. Вы её видите? Если очень постараться, ошибку можно заметить, но на это никогда не стоит надеяться. Новички часто думают, что они невнимательны, и очень расстраиваются, когда допускают такие ошибки. Хочу вас успокоить: опытные разработчики допускают такие ошибки не реже новичков. Важно не то, что вы их допускаете, а то, что вы способны отладить этот код (и сделать это быстро). Этим отличаются опытные разработчики от начинающих. Никогда не пытайтесь найти ошибку с помощью "медитации" над кодом, сверля его взглядом. Если быстрая проверка не дала ответа, то приступайте к отладке.

На Хекслете, в обсуждении уроков, ученики часто нам пишут: "этот код не работает", и показывают свой код. Вероятно, начинающие разработчики думают, что опытные могут понять, в чём ошибка и найти её, просто посмотрев на код. Но это совсем не так. Глядя на такой код, невозможно понять, а что, собственно, пошло не так. И я уже не говорю про нахождение самой ошибки. Нам также нужно увидеть сообщение об ошибке и начать отладку.

Глядя на код функции sum_of_series замечаем, что основных переменных там две: n и result — именно они меняются в цикле. Из этого можно сделать ровно один вывод: нужно явно посмотреть, какие значения им даются на каждой итерации. После этого найти ошибку не составит труда.

Один из способов отслеживать значения переменных во время выполнения кода связан с использованием специальных программ-отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживая любые изменения. Подробнее о том, как их использовать можно прочитать во множестве статей (гуглить "python pdb").
'''

# Отладочная печать

'''
В среде Хекслета отладчика нет, поэтому здесь используется другой подход (но выполняющий ту же задачу) — отладочная печать. Суть такая же, как и в визуальном отладчике, но для вывода значений переменных используется обычная печать на экран:
'''

def sum_of_series(start, finish):
    result = 0
    n = start
    while n < finish:
        print('new iteration !!!!')
        print(n)
        result += n
        n += 1
        print(result)
    return result

sum_of_series(3, 5)

# new iteration !!!!
# 3
# 3
# new iteration !!!!
# 4
# 7

'''
То, что печатается на экран, отображается во вкладке OUTPUT, на которую автоматически переключается редактор во время проверки. Из этого вывода сразу можно понять, что итераций цикла на одну меньше, чем нужно. Почему-то не выполняется сложение для последнего числа, которое обозначено как finish. И действительно, если посмотреть на определение, то видно, что там используется n < finish вместо n <= finish.

# Дополнительные материалы
Как найти ошибки в коде? https://help.hexlet.io/article/7-how-to-debug-code
pdb — The Python Debugger https://docs.python.org/3/library/pdb.html
'''



>>>>>> Модули <<<<<<

'''
Программы на Python содержат тысячи, десятки тысяч и сотни тысяч строк кода (есть проекты с миллионами). В таких условиях одним файлом с кодом не обойдёшься — его нужно разбивать на части. Для получения доступа к коду, который находится в других файлах, в Python реализован механизм модулей.

# Модули и импортирование
Итак, файл с кодом на Python называется модулем. Имя модуля соответствует имени файла, поэтому файлы в Python принято называть в стиле "snake_case" (отметьте иронию: Python — питон — змея — snake — snake_case). Одни модули могут использовать содержимое других, если импортируют эти другие модули с помощью инструкции import.

Строго говоря, в Python импортировать модули можно несколькими способами:

импортировать сам модуль
импортировать отдельные определения из модуля
импортировать всё содержимое модуля сразу


# Импортирование модуля

Рассмотрим применение первого способа — импортирование модуля целиком. Главное удобство упоминания модуля по имени: глядя на код, мы сразу видим, что используемая переменная или вызываемая функция — это часть модуля.

Синтаксис импорта: import <имя_модуля (без суффикса ".py")>

Всё просто: после ключевого слова import указываем имя модуля (файла). Но при этом суффикс .py в имени надо опустить. То есть, к примеру, для модуля с именем my_module.py в инструкции импорта достаточно прописать my_module, а полный вид инструкции будет таким: import my_module.

В модуле (файле) с именем greeting.py определим функцию say_hi и переменную name:
'''

# file: greeting.py
def say_hi():
    print('Hi!')

name = 'Bob'

// А в модуле с именем main.py сделаем импорт содержимого модуля greeting.py:

# file: main.py
import greeting  # заметьте, расширение ".py" не указывается!

print(greeting.name)  # => Bob
greeting.say_hi()     # => Hi!

'''
Импортирование модуля в таком виде делает модуль доступным по имени — в данном случае это greeting. К содержимому же модуля можно обратиться, как говорят, "через точку". Причём можно как получить доступ к переменным (greeting.name), так и вызывать функции модуля (greeting.say_hi).

# Импортирование отдельных определений

Синтаксис импорта: from <имя_модуля (без суффикса ".py")> import <список определений>

Иногда из всего модуля нужна пара функций или переменных, а имя модуля слишком длинное, чтобы писать его каждый раз. Здесь нам может пригодиться следующий вариант использования инструкции import:
'''

# file: main.py
from greeting import say_hi, name

print(name)  # используем переменную
say_hi()     # вызываем функцию

'''
Здесь после ключевого слова from указано имя модуля, а затем после ключевого слова import — имена определений из этого модуля, которые мы в дальнейшем хотим использовать напрямую (а не "через точку").

В следующем уроке мы рассмотрим третий вариант импортирования модуля ("импорт всего содержимого") и в целом немного углубим наши познания в этой теме.
'''




>>>>>> Модули поглубже <<<<<<

'''
Продолжим знакомиться с системой модулей языка Python. Но для начала…

# Немного терминологии
В предыдущем уроке несколько раз встречалось словосочетание "через точку". Так часто говорят для краткости. Однако для такой формы записи имён определений (module.name) существует и официальный термин: квалифицированное имя от слова "квалифицировать" ("qualify"). Соответственно, "импорт модуля целиком" (см. прошлый урок) официально называется квалифицированным импортом.

Также стоит отметить, что в Python все строчки с import принято располагать в самом начале кода модуля. Такой набор строчек часто называют "блок импортов", хотя синтаксически этот блок никак не выделен — всего лишь обычные строчки одна за другой. Нужна эта группировка во многом для того, чтобы можно было быстро найти, что в текущем модуле откуда пришло — при работе с чужим (и даже своим!) кодом подобным часто приходится заниматься.

# Импорт всего содержимого модуля
Ранее мы познакомились с модулями и рассмотрели два из трёх вариантов импортирования — импорт самого модуля и импорт отдельных определений. Рассмотрим оставшийся вариант — импортирование всего содержимого модуля. Пример:
'''
from some_module import *
from another_module import *

'''
Здесь из модулей some_module и another_module импортируются все определения неявно. Часто после такого импорта программисту становятся доступны десятки переменных, констант, функций и тому подобного. В этом-то и кроется проблема! Когда ниже по коду программист, читающий этот код, встречает некое имя, то ему бывает очень сложно понять, откуда это имя взялось — нельзя, просто взглянув на блок импортов, найти источник. Поиск по коду модуля тоже не помогает — все имена определений, импортированных данным способом, скрываются за *!

Большинство руководств по написанию хорошего кода на Python крайне не рекомендует использовать такой стиль импортирования. Однако в реальном коде такие импорты встречаются, поэтому мы не могли этот вариант не упомянуть.

# Сочетание способов импортирования
Импортирование модуля целиком (т.е. квалифицированное) и импортирование отдельных определений могут сочетаться даже применительно к одному и тому же модулю!

Давайте рассмотрим пример.

В модуле computation.py определим функцию и переменные:
'''

# file: computation.py
PI = 3.1415926
E = 2.7182818

def pi_times(x):
    return x + PI

// А в модуле main.py сделаем разными способами импорты из модуля computation.py:

# file: main.py
import computation
from computation import PI, E
from computation import pi_times

print(PI)
print(computation.E)
print(pi_times(2))
print(computation.pi_times(E))

'''
Из кода видно, что:

оба способа импорта использованы совместно
импортировать отдельные определения можно в несколько заходов
если модуль импортирован по имени, то "через точку" можно получить доступ и к тем определениям, которые уже явно импортированы
'''

>>>>>> Пакеты <<<<<<

'''
Мы уже знаем, что в Python код хранится в отдельных файлах, называемых модулями. Но если начать делить код достаточно большого проекта на модули, то довольно быстро может возникнуть желание сгруппировать несколько модулей "по смыслу". Или же мы захотим вынести часть модулей из проекта с целью использования оных в других проектах. Для объединения модулей в группы и служат пакеты (packages).

Итак, пакет — это папка (далее "каталог") с файлами модулей, имеющая имя в формате "snake_case" и содержащая, помимо прочего, специальный модуль с именем "__init__.py". Именно наличие этого специального файла подсказывает интерпретатору Python, что каталог следует воспринимать именно как пакет.

# Простейший пакет

Давайте рассмотрим пример простейшего пакета. Пусть пакет состоит из каталога package и модуля __init__.py внутри этого каталога:

package/
└── __init__.py
Файл __init__.py пусть содержит код:
'''

# file __init__.py
NAME = 'super_package'

// Это, хотя и небольшой, но уже полноценный пакет. Его можно импортировать так же, как мы импортировали бы модуль:

import package

print(package.NAME)

'''
Заметьте — мы не импортировали файл __init__.py непосредственно. При первом обращении к пакету Python автоматически импортирует модуль __init__.py в этом пакете. Поэтому, очевидно, нельзя импортировать "просто каталог" — ведь каталог без файла __init__.py не будет полноценным пакетом!

# Содержимое пакета
С простым пакетом всё ясно — его можно использовать как модуль. Но давайте уже перейдём к группировке в пакете нескольких модулей! Для этого в пакет положим ещё два модуля:

package/
├── constants.py
├── functions.py
└── __init__.py
Содержимое модуля constants.py:
'''
# file constants.py
PERSON = 'Alice'

// Содержимое модуля functions.py:
# file functions.py
def greet(who):
    print('Hello, ' + who + '!')

// Когда пакет содержит другие модули, кроме __init__.py, таковые можно импортировать по их именам. В главе про модули упоминались два варианта импортирования: квалифицированный импорт и импортирование отдельных определений. Квалифицированный импорт в данном случае будет выглядеть так:

import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

// Этот вариант самый понятный: в строчке вызова функции greet сразу видно, откуда пришла функция, а откуда — её аргумент. Но писать имя пакета и имя модуля каждый раз — утомительно! Давайте импортируем сами функцию и аргумент:

from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!

// Так строчка вызова функции выглядит гораздо лучше! Но помните, что тому, кто будет читать этот код в дальнейшем, потребуется посмотреть в блок импортов, чтобы узнать, откуда функция и константа появились.

>>>>>>>> Модуль random <<<<<<<<
'''
Python знаменит тем, что поставляется в комплекте с "батарейками" - так называют модули и пакеты, составляющие стандартную библиотеку. Более того, батареек в поставке Пайтона изрядное количество! Настоящий питонист (pythonista) - так мы, программисты на Python, себя называем - обязан хорошо ориентироваться в стандартной библиотеке, ведь это знание позволяет экономить время и силы. В этом уроке мы познакомимся с первой батарейкой - модулем random.

При разработке программ довольно часто возникает необходимость получить некоторое случайно выбранное из некоего множества значение. Случайные значения полезны, когда мы разрабатываем компьютерные игры, генерируем изображения и звук, и даже просто пишем тесты.

Любое значение в компьютере может быть представлено в виде набора чисел, поэтому получение случайных значений всегда предполагает использование Генератора Случайных Чисел, ГСЧ. ГСЧ бывают программными (специализированные программы) и аппаратными (специализированные устройства), но программист обычно работает с некоторой обобщённой "обёрткой" - модулем или пакетом, который скрывает ненужные детали.

Модуль random предоставляет множество функций, полезных в разных ситуациях, но мы пока остановимся на двух:

randint, генерация целого числа в заданном диапазоне,
choice, выбор случайного элемента из заданного набора.

# Генерация случайных чисел
Для того, чтобы сгенерировать случайное число, нам нужно импортировать функцию randint из модуля random:
'''
from random import randint

// Теперь мы можем сгенерировать число от 1 до 100:
random_number = randint(1, 100)

// При вызове randint с такими границами диапазона может "выпасть" и 1 и 100 - обе границы диапазона включены и об этом следует помнить. Когда это может быть важно? Давайте рассмотрим другой пример - выбор случайного символа некоторой строки:

string = 'abcde'
random_index = randint(0, len(string) - 1)
char = string[random_index]

'''
Строка в переменной string имеет длину 5. Но мы помним, что символы строки индексируются с нуля, поэтому если сгенерировать индекс так randint(0, 5), то в какой-то момент мы получим значение 5 и при попытке взять символ по этому индексу мы увидим ошибку IndexError: индекс последнего элемента в строке равен 4! Вот поэтому в коде выше из длины вычитается единица.

# Выбор случайного элемента
Выше мы рассмотрели пример, в котором выбирался случайный символ строки. Эта задача возникает достаточно часто, поэтому в модуле random существует функция choice. С использованием этой функции выбор символа строки будет выглядеть так:
'''

from random import choice

string = 'abcde'
char = choice(string)

'''
При использовании choice не нужно думать о границах генерируемых индексов. И даже о самих индексах думать не нужно - функция сама знает, как правильно и безопасно выбирать элементы! Правда, придётся заботиться о том, чтобы строка, из который мы выбираем символы, не была пустой, иначе мы получим ошибку IndexError: Cannot choose from an empty sequence ("Нельзя просто так взять и выбрать, если выбирать не из чего").

Пока мы можем использовать choice только со строками, ведь это единственный тип, значения которого могут содержать несколько элементов. Но в дальнейшем мы познакомимся и с другими составными типами - и с многими из таких типов функция choice тоже может работать!

# Случайна ли случайность?
Строго говоря, генерируемые числа у компьютера получаются не полностью случайными, поэтому большинство ГСЧ представляют собой генераторы псевдослучайных чисел. И хотя для простоты приставку "псевдо-" часто опускают (как поступили и мы), о ней не стоит забывать. Дело в том, что некоторые алгоритмы требуют максимально случайной генерации чисел. Одна из областей с такими высокими требованиями к качеству случайности — криптография (шифрование). Представьте, что вы сгенерировали случайный пароль, длинный и сложный, а злоумышленник, пользуясь тем, что при определённых условиях можно воспроизвести ту же последовательность случайных чисел, получил тот же пароль! Вот поэтому существует большое количество специализированных ГСЧ, безопасных для использования в шифровании и создание таких генераторов - это важная, сложная и интересная работа.

# Ссылки
Модуль random https://docs.python.org/3.6/library/random.html
ГСЧ https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел
'''

>>>>>> Кортежи <<<<<<<
'''
До этого момента мы встречались только с примитивными типами — строка, число, булев тип. Ещё нам знакомы функции и модули с пакетами (да, в Python модули и пакеты, это тоже значения специальных встроенных типов). Но часто в программировании приходится создавать более сложные, чем числа и строки, значения и манипулировать такими значениями. Именно поэтому во многих языках программирования есть составные типы. Значение составного типа может состоять как из значений примитивных типов, так и из значений других составных типов, таким образом составные типы позволяют описывать сущности произвольной сложности — и шахматные доски, и космические ракеты!

В этом уроке мы познакомимся с самым простым, но очень полезным составным типом — кортежем (в англоязычных текстах оный известен, как tuple).

# Кортежи
Кортеж — это несколько значений, записанных через запятую. Да, всё очень просто! Вот несколько примеров:
'''
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

'''
Определять кортежи очень просто, сложности могут возникнуть только с кортежами, содержащими ровно один элемент. Если мы просто укажем значение в скобках, то Python подумает, что мы хотим посчитать арифметическое выражение со скобками:
'''
not_a_tuple = (42)  # 42

// Чтобы сказать пайтону, что мы хотим создать именно кортеж, нужно поставить после элемента кортежа запятую:

tuple = (42,)  # (42,)

'''
Да, форма записи довольно необычная, но вы привыкнете :)

# Возврат нескольких значений из функции
Кортежи очень полезны, когда нам нужно вернуть из функции сразу несколько значений. Так, функция, которая принимает два аргумента-числа и возвращает одновременно результат деления нацело и остаток от деления, будет выглядеть так:
'''

def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)

'''
# Получение элементов кортежа по индексу
Выше мы только создавали кортежи. Теперь научимся их разбирать! В простейшем случае достаточно обратиться к элементу кортежа по индексу:
'''

name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

// Также у кортежа есть длина, которую, как и для строки, можно получить с помощью функции len:

tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2

'''
# Деструктуризация
Обращение по индексу, это не самый удобный способ работы с кортежами. Дело в том, что кортежи часто содержат значения разных типов, и помнить, по какому индексу что лежит — очень непросто. Но есть способ лучше! Как мы кортеж собираем, так его можно и разобрать:
'''

name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42

'''
Именно таким способом принято получать и сразу разбирать значения, которые возвращает функция (если таковая возвращает несколько значений, конечно):
'''
(quotient, modulo) = div_mod(13, 4)

// Соответственно кортеж из одного элемента нужно разбирать так:
(a,) = (42,)
a  # 42

'''
Если же после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную a кортеж запишется целиком, т.е. ничего не распакуется! Всегда помните о запятых!

# Кортежи, множественное присваивание и обмен значениями
Благодаря тому, что кортежи легко собирать и разбирать, в Python удобно делать такие вещи, как множественное присваивание. Смотрите:
'''
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3

// Используя множественное присваивание, можно провернуть интересный трюк: обмен значениями между двумя переменными. Вот код:

a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100

'''
Cтрочку (a, b) = (b, a) нужно понимать как "присвоить в а и b значения из кортежа, состоящего из значений переменных b и a".

# Ссылки
Кортеж https://ru.wikipedia.org/wiki/Кортеж_(информатика)
'''


>>>>>> История развития языка Python <<<<<<

'''
Итак, мы учимся языку Python. Для начала стоит определиться с названием. Правильно говорить "Пайтон" с ударением на первом слоге — язык назван в честь известного комедийного шоу "Летающий Цирк Монти Пайтона", т.е. Пайтон — это фамилия, а фамилию человека принято произносить так, как это делает носитель фамилии!

Ещё пара сухих фактов:

Первый релиз интерпретатора языка Python был представлен в далёком 1991г,
Автор языка — Гвидо ван Россум.
Сам по себе язык — это не то же самое, что его интерпретаторы. Но основная реализация языка — CPython — настолько распространена, что почти всегда, когда мы слышим "Python", подразумевается именно она. Наши курсы тоже будут касаться именно CPython, это стоит иметь в виду!

# Самое начало
Python появился, чтобы заменить собой язык ABC, в работе над которым принимал участие будущий автор пайтона Гвидо ван Россум. Представленный в 1991 году Python версии 0.9.0 вобрал в себя многие идеи из существовавших на тот момент языков: например, взяв систему модулей из языка Modula-3. Элементы функционального программирования (их мы будем изучать в следующих курсах!) — функции map, filter, reduce — появились в языке тоже довольно рано, в версии 1.0.

Стоит отметить, что Пайтон изначально позиционировался как "язык для каждого", поэтому большой упор делался на читаемость кода и лаконичность синтаксиса. В версии 2.0 появились знаменитые "списковые включения" ("list comprehensions"), позаимствованные из языков SETL и Haskell. В этой же версии сборщик мусора (механизм автоматического управления памятью) научился работать с циклическими структурами. С ними мы также познакомимся в последующих курсах.

# Py2 vs Py3
Python, как язык, непрерывно развивается с самого начала времени своего существования. На данный момент в основном используются версии языка, начинающиеся с "3".

Первый релиз "третьего пайтона" (python3, py3) вышел ещё в 2008 году, но переход на это семейство версий со "второго пайтона" (python2, py2) происходил (кое-где всё ещё происходит!) "со скрипом". Дело в том, что py3 не полностью обратно совместим с кодом, написанным для py2, т.е. мы не можем просто заменить интерпретатор — нам потребуется внести определённые изменения в код! На такой шаг можно пойти, если наш проект — живой. Но с проектами, находящимися в состоянии "только поддержка" (такие проекты ещё называют legacy), такой фокус не пройдёт — обычно просто некому заниматься адаптацией. А ведь legacy-проекты — это не всегда лишь конечные приложения, в такой ситуации могут оказаться и библиотеки. Именно из-за невозможности отказаться от нужных, но существующих в состоянии legacy, библиотек многие проекты долго оставались несовместимыми с py3.

К счастью, сейчас большая часть библиотек, достаточно популярных и полезных в повседневной жизни разработчика, успешно переведена на py3, и новые проекты нужно делать именно на какой-то из версий этого семейства (сейчас рекомендуемая версия — это Python 3.7.x). Более того, py2 скоро перестанет быть безопасным для широкого использования! Дело в том, что техническая поддержка py2 — т.е. устранение уязвимостей и критических ошибок — с 2020г перестанет осуществляться. А мы ведь не хотим подвергать угрозе свои детища!

# Системный Python
Работая с Python, стоит иметь в виду, что Python распространён не только в виде языка, на котором пишутся конечные проекты: этот язык часто используется для автоматизации различных задач, скажем, по системному администрированию (Ansible — один из примеров написанного на Python ПО, используемого при администрировании). Поэтому python часто уже присутствует в установленных операционных системах.

Особенно велика вероятность обнаружить в системе установленный Python, когда речь идёт об ОС семейства Linux — а именно, какая-то из версий Linux будет скорее всего установлена на машину, на которой вы захотите запустить сервер своего web-приложения или многопользовательской игры (да, такие тоже пишут на Python!). Тут-то и кроется проблема: установленный вместе с операционной системой Python может быть тем самым "вторым пайтоном" — да, такое, увы, пока встречается. И заменить его будет нельзя, ведь замена может привести к выходу из строя всей ОС.

Но не пугайтесь, в курсе про настройку окружения вы узнаете, как использовать в проекте нужную версию Python и не бояться сломать что-то другое!
'''

'''*@@@
src/solution.py
Реализуйте функцию sort_pair, которая принимает пару (кортеж из двух значений) и возвращает пару, значения которой расположенны строго в порядке возрастания.

Пример:
'''

# обратите внимание на скобки у аргумента функции
sort_pair((5, 1)) == (1, 5)
sort_pair((2, 2)) == (2, 2)
sort_pair((7, 8)) == (7, 8)


// FILE /app/src/solution.py:
def sort_pair(pair):
    (first, second) = pair
    if first > second:
        return (second, first)
    return pair


'''*@@@
src/package/__init__.py
Дан пакет следующей структуры:

$ tree package
package/
├── __init__.py
├── functions.py
└── names.py
Добавьте в __init__.py блок импортов таким образом, чтобы можно было импортировать package и получить доступ

к константе NAME из package.names
к функции greet из package.functions
Если задание будет выполнено успешно, то следующий код должен будет работать:
'''

from package import greet, NAME

greet(NAME)  # 'Hello, Bob!'


// FILE: /app/src/__init__.py:
from package.names import NAME
from package.functions import greet


// FILE: /app/src/functions.py:
def greet(name):
    return 'Hello, {}!'.format(name)

// FILE: /app/src/names.py:
NAME = 'Bob'




'>>>>>> HTTP <<<<<<

'''
Популярный вопрос на собеседовании веб-разработчиков часто звучит так: «Что происходит после того, как в браузер ввели адрес сайта?». Подробный ответ на этот вопрос можно найти здесь. Главное, что хочет услышать собеседующий — ваш уровень понимания HTTP (Hyper-Text Transferring Protocol).

Для начала пару слов о том, что такое протокол. Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. HTTP — это набор правил, который известен и вашему компьютеру и физически отдалённому компьютеру. С помощью него общаются браузер и веб-сервер.

Веб-сервер — программа, установленная на сервере и обслуживающая входящие соединения, например, от браузеров. В рамках такого соединения от браузера передаётся информация о том, какую страницу и какого сайта мы хотим загрузить, а веб-сервер, в свою очередь, возвращает браузеру содержимое страницы этого сайта.

Пример http-сессии (запрос-ответ) через программу curl:
'''
$ curl --head -v code-basics.ru
* Rebuilt URL to: code-basics.ru/
*   Trying 35.157.19.194...
* TCP_NODELAY set
* Connected to code-basics.ru (35.157.19.194) port 80 (#0)
> GET / HTTP/1.1
> Host: code-basics.ru
> User-Agent: curl/7.54.0
> Accept: *'''
>
< HTTP/1.1 200 OK
< Date: Sun, 07 Jan 2018 14:19:00 GMT
< Content-Type: text/html; charset=utf-8
< Content-Length: 5123
< Connection: keep-alive
< server: Cowboy
< cache-control: max-age=0, private, must-revalidate
<
* Connection #0 to host code-basics.ru left intact

'''
http нужно не просто знать, но и уметь делать сырые http-запросы — не косвенно через браузер, а самостоятельно, эмулируя поведение браузера. Для этой задачи используют программу telnet.

# Для чего требуется знание http?
Работа с формами, загрузка файлов, перенаправления.
Аутентификация целиком зависит от http.
Извлечение информации о запросе (например, определение браузера, из которого был выполнен запрос).
Увеличение производительности. Кеширование.
Обеспечение безопасности. http — текстовый протокол без шифрования, он не безопасен.

# https
Кроме http, в сети всё большее распространение получает https. Каждый пользователь сети должен знать, что нельзя выполнять действия, связанные с любыми секретными данными (например кредитками), на страницах, работающих по протоколу http. В таком случае любой человек, имеющий доступ к оборудованию, которое лежит между вами и сервером, обслуживающим сайт, сможет прочитать эти данные. Обратите внимание, что на популярных сайтах страницы оплаты всегда отдаются по https. В свою очередь, умение работать с https сразу добавляет новые понятия:

Шифрование, асимметричное шифрование
Сертификаты
Цифровая подпись

# TCP/IP
Но одним http обойтись не получится. Дело в том, что http существует не сам по себе, а поверх стека протоколов TCP/IP. Базовое знание сетей важно по следующим причинам:

Безопасность. Очень легко совершить ошибку и быть взломанным.
Отладка. Немалая часть вопросов запуска и конфигурирования сайтов и их частей (в том числе базы данных) связана с сетевыми сокетами. Не зная сети вы будете останавливаться на любой простейшей проблеме без понимания, что вообще делать.

# DNS
Ещё один столп веба — DNS, служба доменных имён. Каждый раз, когда мы вбиваем адрес в браузер, он выполняет DNS запросы к соответствующим серверам для выяснения того, какой ip-адрес принадлежит сайту. Дело в том, что соединение с сервером идёт по tcp/ip, а не по http. http начинает работать уже после того, как было установлено tcp соединение. Знание DNS важно по следующим причинам:

Зная DNS вы сможете не только купить домен, но и привязать его к вашему серверу
Почта для домена, верификация вашего проекта различными сервисами — всё это работает через возможности DNS
Опять же, отладка. Нередко проблемы загрузки связаны с DNS.
'''



############## Python: Настройка окружения ##############

'''
Мы поддерживаем репозиторий python-package https://github.com/hexlet-boilerplates/python-package — так называемую заготовку, содержащую базовую структуру нового проекта на Python. Вы всегда можете подглядывать в него и делать по аналогии.


#@ Установка Python

Ubuntu
$ sudo apt update
$ sudo apt install python3

macOS
# https://brew.sh/index_ru.html
$ brew install python

Наберите в терминале python3 --version. Вывод должен быть примерно такой:
Python 3.6.8



#@ pyenv

Совсем другой способ установки Python — утилита pyenv https://github.com/pyenv/pyenv (для пользователей Windows нужна особая версия утилиты - pyenv-win). Кроме установки любых версий Python, эта утилита позволяет удобно переключаться между версиями. Такое может быть нужно когда вы одновременно работаете над несколькими проектами, требующими разные версии Python.


#@ REPL

Python поставляется со встроенным REPL. REPL – это программа, которая работает как командная оболочка (программу REPL ещё называют интерактивным интерпретатором Python), предназначенная для ввода и выполнения кода на языке Python. Акроним REPL расшифровывается так:

Read — прочитать ввод от пользователя,
Eval — выполнить введённый код,
Print — распечатать на экран результат,
Loop — снова войти в режим ожидания.

Для запуска REPL достаточно набрать:
$ python3

Теперь можно выполнять код на Python и сразу же смотреть на результат его выполнения. Наберите любой корректный код на Python, например такой:

30 + 12

REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из REPL нужно вместо ввода кода нажать Ctrl + D.

#@ Встроенная документация

Язык Python прямо на уровне синтаксиса поддерживает дополнение кода документацией. Основным средством документирования являются так называемые "строки документации" ("docstrings"). Документированная функция выглядит так:
'''
def add(x, y):
    """Add one argument to another."""
    return x + y

'''
Из таких docstrings генерируется online-документация. А ещё эта документация доступна для просмотра прямо в REPL! Для просмотра документации служит функция help. Давайте объявим функцию add в REPL, попробуем её вызвать, а затем посмотрим описание нашей функции и нескольких встроенных.
'''



# >>>>>> Подробнее о Python <<<<<<
'''
Язык программирования

С одной стороны, языком программирования называют правила (синтаксические и семантические), по которым записывается и работает исходный код. В отличие от естественных языков, эти правила достаточно строги. Любая мельчайшая ошибка и код либо не запустится, либо запустится, но не заработает, как ожидается. Например, в Python нельзя написать my name = 5 (с пробелом в имени переменной). Эти правила существуют не только в книгах, но и в головах конкретных программистов и разработчиков языка. Часто весь свод правил, называемый спецификацией, существует в виде отдельного специального документа.

С другой стороны, языком программирования называют программу, которая непосредственно запускает (или компилирует) наш код. В предыдущем уроке мы как раз установили такую. Обычно её называют средой выполнения, иногда "рантаймом" ("runtime"), если речь идёт про интерпретацию. Среда выполнения — конкретное воплощение спецификации, по-другому называемое реализацией (или implementation). Реализаций конкретного языка может существовать несколько, но часто существует так называемая эталонная реализация (или reference implementation), на которую могут равняться другие. Различные реализации могут разрабатываться разными людьми и компаниями.

У Python нет выделенной спецификации, но есть эталонная реализация, называемая CPython (интерпретатор Python, реализованный на языке C). Если вы слышите, что кто-то говорит Python, то скорее всего имеется в виду именно эталонная реализация. Прочие же реализации обычно имеют свои названия. Например, реализация языка, предназначенная для запуска программ на платформе .NET, называется IronPython https://ironpython.net/.
'''

#@ Python

'''
Python — интерпретируемый язык программирования с сильной динамической типизацией. Разберём эти слова по отдельности.
'''

#@ Интерпретируемый

'''
У Python отсутствует стадия компиляции в машинный код, которая присутствует, скажем, у языков C, Rust, Go. Программа исполняется интерпретатором шаг за шагом, а не запускается напрямую на процессоре компьютера. Поэтому для запуска программы на Python всегда нужна среда исполнения (интерпретатор) — только она может выполнять Python-программы.

Строго говоря, у Python есть фаза компиляции, во время которой код из текста преобразуется в специальное представление, называемое "байткод" ("bytecode"), а затем уже этот байткод передаётся в интерпретатор. Но внешне Python ведёт себя именно как интерпретируемый язык программирования: интерпретатор при запуске вашей программы загружает из файлов её (программы) исходный код, преобразует для удобства в байткод (при этом проверяются ошибки синтаксиса), а дальше начинает исполнять по шагам.
'''


#@ Динамическая типизация

'''
В динамически типизированных языках проверка типов, доступности функций и переменных производится интерпретатором во время выполнения кода. Поэтому, если мы случайно ошиблись и, например, вызвали несуществующую функцию, то ошибка всплывёт только во время вызова этой функции! В статически же типизированных языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение (слово "статический" как раз означает, что программа не выполняется). Обычно статическими проверками занимаются компиляторы, но существуют и выделенные инструменты статической проверки кода, так называемые статические анализаторы кода. Для некоторых языков с динамической типизацией такие анализаторы тоже существуют, но отслеживают значительно меньшее число ошибок.
'''

#@ Сильная типизация

'''
Сильная типизация означает то, что Python старается не приводить типы (преобразовывать значения одних типов в значения других) автоматически. Это означает, что Python не даст сложить число со строкой: при попытке сделать что-то подобное мы получим ошибку. Далеко не все языки с динамической типизацией столь педантичны в силу различных причин. Но Python в этом вопросе принципиален и требует, чтобы любые преобразования типов были явными (т.е. программист использовал в каждом конкретном случае соответствующие функции-преобразователи).
'''


# >>>>>> Пакеты и индексы <<<<<<

'''
В какой-то момент разработчик понимает, что код, который он написал, может быть полезен другим. Это может быть библиотека полезных функций или готовая программа, но в любом случае автор оной обычно хочет, чтобы его творение было удобно и просто использовать. Так вот, питонисты делятся между собой кодом с помощью… пакетов!
'''

#@ Опять пакеты

'''
В рамках курса по основам Python уже упоминались пакеты (packages). Тогда пакеты описывались, как наборы модулей и вложенных пакетов. Но это не единственное значение слова "пакет" в Python-мире.

В более широком смысле пакет — это некая единица обмена кодом между разработчиками. Python-пакет содержит и исходный код (как раз в виде пакета в узком смысле, поэтому и название общее), и так называемые метаданные — дополнительную информацию о пакете. Метаданные описывают

предназначение пакета
версию пакета
совместимость с разными версиями Python
лицензию (software license), под которой распространяется пакет
список и версии зависимостей пакета (об этом поговорим позже)
и многое другое.
'''

#@ Индекс

'''
Предположим, что мы имеем готовый пакет (а мы в итоге обязательно научимся их создавать), но как им поделиться с миром? Как правило, собранный пакет представляет собой обычный файл и в принципе его можно просто передать другому человеку — это даже сработает! А если вдруг окажется, что наш пакет требует каких-то других пакетов для своей работы? Вот тут-то и начнутся сложности — нужно будет приложить к нашему пакету дополнительные пакеты, которые могут потребовать ещё больше пакетов и т.д. и т.п.

Для упрощения жизни как авторов пакетов, так и пользователей оных существуют так называемые репозитории пакетов. Только в Python их принято называть индексами. Помимо предоставления пакетов, индексы также могут обладать интерфейсом для поиска пакетов, знакомства с их описанием — проще говоря, предоставляют интерфейс пользователя (обычно в виде web-сайта).

Самый популярный индекс пакетов, это PyPI, Python Package Index. Чаще всего вы будете работать именно с ним. Но есть и другие индексы и большинство инструментов работы с пакетами могут работать с разными индексами. Отдельные индексы, к примеру, используются многими компаниями для размещения пакетов, которые не являются открытыми (open source).

Ещё один полезный индекс — Test PyPI. Это специальный индекс пакетов, который принято использовать для обучения работы с системой пакетирования Python. Ведь не очень красиво выставлять на всеобщее обозрение сотни и даже тысячи учебных пакетов: они будут попадаться в поиске, "занимать" имена, которые могли бы иметь действительно полезные пакеты, другими словами — "замусоривать" основной индекс. Тестовый индекс работает точно так же, как основной PyPI – позволяет пакеты выкладывать и скачивать – но периодически удаляет все данные.
'''

#@ Индексы vs GitHub, BitBucket и прочие хранилища кода
'''
В наши дни некоторые репозитории пакетов не хранят пакеты своими силами, а берут на себя только индексацию и управление метаданными пакетов, код же предлагается хранить на GitHub, BitBucket, GitLab, другими словами — в хранилищах исходного кода.

Такой подход в целом работает для интерпретируемых языков, ведь для того, чтобы использовать код пакета, нужно всё равно иметь доступ к исходному коду. Но хранение кода на сторонних по отношению к источнику метаданных (индексу, в случае Python) обладает рядом недостатков.

Во-первых, опубликованным кодом владеет только автор кода. Автор может даже удалить свой репозиторий, а информация о пакете в индексе сохранится. И те, кто начал использовать "сломанный" пакет, столкнутся с невозможностью сборки своих проектов.

Во-вторых, ни GitHub, ни другие хранилища Git-репозиториев не могут гарантировать неизменность данных в репозитории при использовании одних только тегов и веток — а именно такой способ привязки состояния кода к информации в индексе и используется чаще всего — ведь любой обладатель доступа к репозиторию может "переписать историю". И даже если привязывать версии пакетов в индексе к hash-суммам коммитов в Git, то изменение в истории приведёт к первой проблеме — версия пакета будет ссылаться на несуществующий источник кода (при переписывании истории hash-суммы коммитов тоже поменяются).

Обе озвученные причины приводят к тому, что ломается важное свойство системы пакетирования — воспроизводимость сборки. Воспроизводимость здесь означает, что любой проект, содержащий точное описание своих зависимостей, "соберётся" (в случае Python — запустится) в любой момент времени, даже если проект использует очень старые версии пакетов и интерпретатора!

Централизованный индекс, самостоятельно хранящий все версии всех пакетов в неизменяемом виде, даёт значительно больше гарантий, что мы сможем собрать наш старый проект, когда бы мы этого не захотели.

# Дополнительные материалы
PyPI https://pypi.org/
Test PyPI https://test.pypi.org/
'''


# >>>>>> distutils, setuptools, pip <<<<<<
'''
На прошлом уроке мы познакомились с пакетами и индексами, давайте же узнаем, как устанавливать пакеты из индекса! Для установки, обновления и удаления пакетов часто применяются так называемые пакетные менеджеры (или менеджеры пакетов). Один такой мы рассмотрим, но сначала немного поговорим о фундаменте системы пакетирования Python.
'''

#@ distutils и setuptools

'''
В поставку Python входит distutils, пакет, отвечающий за создание дистрибутивов — архивов кода, которые могут быть распакованы в целевом окружении и установлены так, чтобы интерпретатор Python "увидел" распакованный код. При создании пакета программист создаёт в корневой директории будущего пакета файл setup.py в котором импортирует из модуля distutils функцию setup и вызывает её. Таким образом каждый пакет содержит в себе программу для управления собой!

Подробнее о том, как работает distutils, можно почитать в официальной документации к пакету https://docs.python.org/3/library/distutils.html, а мы сразу двинемся дальше. Дело в том, что пакет distutils появился довольно давно и сейчас сам по себе не очень удобен в использовании. Гораздо чаще используется надстройка над distutils, пакет setuptools.

Пакеты, собранные с помощью setuptools, уже умеют предоставлять metadata: описание, версию, и самое главное — собственные зависимости! Пакеты, которые не зависят ни от чего, кроме самого Python, настолько редки, что без setuptools — можно сказать, "жизни нет". Про этот пакет стоит знать и со временем нужно будет научиться его использовать (опять же, с помощью документации), но в рамках этого курса мы будем рассматривать более простой инструмент для создания пакетов и загрузки их в индекс — poetry, с которым мы познакомимся попозже.

После того, как пакет создан и загружен в индекс, его можно скачать, распаковать во временную директорию, оттуда запустить python3 setup.py install и пакет установится. Но это слишком утомительный и непростой путь, есть способ лучше!
'''

#@ pip

'''
Каким бы способом пакет не был создан и загружен в индекс, его нужно скачивать и устанавливать, а по необходимости — и со всеми зависимостями. Сейчас этим в основном занимается специальная программа pip — The Python Package Installer.

pip — большая и сложная программа. Обо всех возможностях вы, как всегда, сможете почитать в документации https://pip.pypa.io/. Мы же рассмотрим только самую важную функцию pip — установку пакетов. В следующем уроке мы установим сам pip и с помощью него установим в окружение первый пакет!

# Дополнительные материалы
distutils - Building and installing Python modules https://docs.python.org/3/library/distutils.html
setuptools - Collection of enhancements to the Python distutils https://setuptools.readthedocs.io/
pip - The Python Package Installer https://pip.pypa.io/
'''


# >>>>>> Установка pip <<<<<<

#@ Установка pip
'''
Если вы используете macOS или Windows и устанавливали Python согласно нашим рекомендациям, то pip будет установлен вместе с интерпретатором. На Ubuntu его нужно поставить отдельно:

$ sudo apt update
$ sudo apt install python3-pip
'''

#@ Запуск pip
'''
pip можно запускать непосредственно командой pip. Но лучше воспользоваться более длинной командой, которая гарантировано вызовет самую свежую установленную версию pip для нужной версии Python — в системе уже может быть установлен Py2 с соответствующей версией pip, как правило, довольно старой.

Итак, вызываем pip:

$ python3 -m pip --version

При показе своей версии pip также сообщает, куда установлен он сам и на какой версии Python он был запущен.

Обратите внимание на структуру команды, которую мы вызывали:

$ python3 -m pip --version

Эта команда означает "python3, запусти модуль (-m) с именем pip как программу с параметром --version". Если вы в дальнейшем увидите в документации к pip команды, вроде pip help, то смело вызывайте python -m pip help — результат будет нужный!
'''

#@ Установка первого пакета

'''
Установим же первый пакет! Пусть это будет пакет cowsay https://pypi.org/project/cowsay, но устанавливать мы его будем сразу в пользовательское окружение. Причин для установки туда есть несколько:

мы не помешаем своими пакетами другим пользователям системы,
нам не потребуются права администратора (у пользователя их может и не быть),
мы не поломаем саму операционную систему случайной установкой более свежего пакета, чем тот, который требуется системе для нормальной работы (особенно это важно в Linux, где многие системные задачи решаются с помощью Python).
Итак, установка cowsay:

$ python3 -m pip install --user cowsay

Во-первых, мы видим, что пакет установился и стал доступен интерпретатору. Во-вторых, пакет — забавный :)

Флаг –-user команды pip install сообщает pip, что мы хотим установить пакет в глобальное окружение текущего пользователя. Если этот флаг не указать, то pip установит пакет в общесистемное окружение. Старайтесь не делать так!
'''

#@ pip, точки входа и PATH

'''
Установленный пакет cowsay, как мы видели выше, может быть использован из кода. Но этот пакет имеет ещё и так называемую точку входа (или entry point).

Точки входа, это готовые к исполнению программы, содержащиеся в пакете. Если у пакета есть таковые, то pip создаст для каждой специальный исполняемый скрипт, который позволит удобно запускать программу из командной оболочки. Но нужно помнить, что путь до директории, в которую pip помещает такие скрипты (на Linux это ~/.local/bin) нужно добавить в PATH! Если путь прописан правильно, то скрипт для cowsay должен работать так:

$ cowsay hi
$ exit

Точка входа, это всегда Python-модуль, пригодный для запуска в роли программы (такие программы называют ещё исполняемыми файлами, позже мы рассмотрим, как такие делать). Создаваемые pip'ом скрипты внутри вызывают python3 -m имя_модуля, поэтому установленный нами cowsay можно запускать точно также:

$ python3 -m cowsay python
'''

#@ Всегда свежий pip!
'''
Как вы могли уже догадаться, сам pip, это тоже точка входа одноимённого пакета pip, поэтому мы его запускаем командой python3 -m pip. А ещё pip может устанавливать и, что более важно, обновлять! Вы можете установить свежий pip в пользовательское окружение (именно туда, чтобы не сломать системный pip) с помощью такой команды:

$ python3 -m pip install --user --upgrade pip

Флаг --upgrade позволит обновить уже установленный пакет, если в индексе найдётся более новая версия.

# Дополнительные материалы
pip - The Python Package Installer https://pip.pypa.io/
'''



# >>>>>> pip и альтернативные источники пакетов <<<<<<

'''
На прошлом уроке мы установили пакет cowsay. Если не уточнить иное специально, pip устанавливает пакеты из основного индекса — PyPI. Оттуда был взят и пакет cowsay.

В большинстве случаев PyPI — это именно тот источник пакетов, который нам нужен. Но бывают случаи, когда пакет находится в альтернативном индексе — например, внутрикорпоративном — или же вообще ещё не опубликован ни в одном индексе, а просто загружен на GitHub. Pip умеет работать и с альтернативными индексами и с репозиториями, содержащими исходный код пакетов. Рассмотрим оба варианта.
'''

#@ Альтернативные индексы пакетов

'''
Если вызывать команду pip install с опцией --index-url <url>, то pip будет искать пакет и все его зависимости в индексе по указанному url. Давайте попробуем установить пакет из специального тренировочного индекса Test PyPI http://test.pypi.org/:

$ python3 -m pip install --user --index-url https://test.pypi.org/simple dogesay

$ dogesay foo bar baz

Заметьте, что url индекса указан в виде что-то-там/simple — именно так по соглашению должны именоваться индексы.

Test PyPI содержит плюс-минус все пакеты, которые есть в основном PyPI, но обычно держателям локальных индексов не хочется держать у себя копии всех версий всех пакетов — хочется хранить только свои пакеты, а все внешние зависимости получать из другого индекса (обычно это уже общий PyPI). У pip и для такого случая есть опция! Всего-то и нужно в дополнение к --index-url указать --extra-index-url <url>. В такой конфигурации pip ищет каждый пакет в первом индексе, а если не найдёт, то обращается ко второму, дополнительному индексу. Команда целиком может выглядеть так:

$ python3 -m pip install --user --index-url https://test.pypi.org/simple --extra-index-url https://pypi.org/simple dogesay
'''

#@ Установка пакетов из репозиториев на GitHub

'''
Иногда пакет не хочется выкладывать на PyPI, скажем, по причине того, что пакет ещё совсем "сырой", но при этом нужно проверить, как пакет работает и устанавливается ли вообще. В подобных случаях пакеты устанавливают прямо из git-репозиториев. Давайте установим с помощью pip наш учебный hexlet-boilerplates/python-package https://github.com/hexlet-boilerplates/python-package:

$ python3 -m pip install --user git+https://github.com/hexlet-boilerplates/python-package.git

Здесь вместо имени пакета указывается тот же url, который вы использовали бы при клонировании репозитория, но дополненный приставкой git+. Эта приставка подсказывает pip, что по url расположен Git-репозиторий — не обязательно размещённый на GitHub.

Во время установки пакета, pip вызывает git clone для клонирования репозитория во временную папку. Если репозиторий закрытый, то у вас будут запрошены имя пользователя и пароль для доступа к репозиторию — это работает и с приватными репозиториями GitHub!

Управлять установкой пакетов из систем контроля версий (да, систем — pip поддерживает не только Git!) можно очень гибко, например, указывать ветки, теги или хэши коммитов, по которым расположена желаемая версия пакета. Подробнее можно почитать тут https://pip.pypa.io/en/stable/reference/pip_install/#vcs-support.

Мы рассмотрели далеко не все виды источников пакетов, да и саму команду pip install рассмотрели очень поверхностно. По возможности рекомендуем изучить эту и прочие команды pip самостоятельно, ведь pip — один из ключевых инструментов разработчика на Python!

# Дополнительные материалы
pip - The Python Package Installer https://pip.pypa.io/
Test PyPI https://test.pypi.org/
Python package example (boilerplate) https://github.com/hexlet-boilerplates/python-package
'''



# >>>>>> Виртуальные окружения <<<<<<

'''
Как уже говорилось ранее, pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет оный сначала в пользовательском окружении, затем в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python программ. Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами: разные проекты могут иметь разные наборы зависимостей. Ещё более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные её версии — конфликт версий.

Очевидно, что как минимум разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных "песочницах". Такой механизм существует и называется виртуальные окружения.
'''

#@ Устройство виртуальных окружений

'''
Каждое виртуальное окружение представляет собой директорию, содержимое которой структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:

$ tree env
env
├── bin
│   ├── activate
│   …
│   ├── pip
│   …
│   └── python3 -> …/python3
├── lib
│   └── python3.6
│       └── site-packages
│           ├── pip
│           │   ├── …
│           …
│           └── setuptools-40.6.2.dist-info
│               ├── …
…


В директории виртуального окружения находится директория bin/ внутри которой находится копия (или символическая ссылка на оригинал) интерпретатора под именем python3, а рядом с ней находится копия исполняемого файла pip. В соседней директории по пути lib/python3.6/site-packages находятся библиотеки, уже установленные в окружение: только что созданное окружение как правило имеет установленный пакет pip (а исполняемый файл bin/pip — его точка входа), а также пакет setuptools — эти два пакета составляют "необходимый минимум" для разработки проекта на Python.

При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из папки bin. Дело в том, что интерпретатор Python, когда находится в окружении, знает, что по относительному (к директории bin) пути ../lib/python3.6 находятся все доступные пакеты. И копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая желанная изоляция!
'''

#@ Создание виртуального окружения

'''
Конечно же, вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.

В macOS и Windows этот модуль, как и pip, входит в поставку Python. На Ubuntu же его нужно установить отдельно командой

$ sudo apt install python3-venv
Проверим, что модуль установлен и пригоден к использованию:

$ python3 -m venv --help

Создаётся окружение командой python3 -m venv имя_окружения. Давайте создадим одно и установим в это окружение пакет cowsay:

/tmp$ python3 -m venv first_venv
/tmp$ first_venv/bin/pip install cowsay
/tmp$ first_venv/bin/cowsay hello
/tmp$ first_venv/bin/pyth
/tmp$ first_venv/bin/python
>>> import cowsay
>>> cowsay.tux

Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay, а также сам пакет становится доступен интерпретатору, но только тому, что запущен из окружения.

В принципе в таком виде виртуальное окружение уже можно использовать полноценно. Но вводить команды с префиксом first_env/bin/ не очень-то хочется, и есть способ упростить вызов команд, доступных в окружении — активация.
'''

#@ Активация окружения

'''
При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Этот сценарий нужно выполнить:

> на macOS и Ubuntu вызвать команду
$ source first_venv/bin/activate

На Ubuntu активация выглядит следующим образом:

/tmp$ source first_venv/bin/activate
(first_venv) /tmp$ cowsay hello
>>> import cowsay
>>> cowsay.tux('imported')

Вы можете заметить, что после активации отпала необходимость указывать путь до вызываемого исполняемого файла — cowsay и python в аскинеме вызываются без префикса, но это всё те же команды из окружения!

Ещё вы могли заметить, что приглашение оболочки изменилось: в нём стало отображаться имя окружения. Этот трюк работает на macOS и Ubuntu и позволяет всегда видеть, что мы находимся в виртуальном окружении.

Деактивация же окружения делается командой deactivate, которая становится доступна после активации.

Активирование и деактивация окружения влияют только на текущую сессию (заметны только в этом конкретном терминале). Что позволяет иметь несколько окружений и активировать их одновременно в разных окнах терминала.
'''

#@ Итого

'''
Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.
'''

#@ Ссылки

'''
https://docs.python.org/3/library/venv.html https://docs.python.org/3/library/venv.html официальная документация по модулю venv.

https://pipxproject.github.io/pipx/ установщик Python-программ, размещающий каждую программу в её собственном виртуальном окружении, но скрывающий от конечного пользователя такие "излишние тонкости": пользователь получает сразу доступную оболочке команду — отличный способ устанавливать для постоянного использования штуки, вроде cowsay и dogesay.
'''


# >>>>>> Cкрипты <<<<<<

'''
Любая программа должна быть когда-нибудь запущена, иначе зачем её вообще писать? В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код, всю работу делает интерпретатор, которому достаточно подать на вход скрипт (англ. script) — так часто называют программы на интерпретируемых языках, представляющие из себя простые последовательности команд, которые компьютеру нужно выполнить. Часто языки, которые максимально упрощают написание скриптов (как говорят, "скриптование") и их запуск, называют "скриптовыми языками" или же "языками для написания сценариев" (слово "script" на русский переводится как "сценарий").
'''

#@ Скрипты на Python

'''
Python отлично подходит на роль скриптового языка: последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто — мы просто пишем команды одну за другой в файл:
'''

# file <script.py>
print('Hello, world!')
print('This is a python-script!')

'''
а затем просто вызываем интерпретатор с полученным файлом на входе:
$ python3 script.py
Hello, world!
This is a python-script!

Эта простота использования вместе с большим количеством полезных модулей и функций, входящих в поставку Python, делают последний хорошим инструментом для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием!
'''

#@ Скрипты и shebang

'''
В unix-подобных операционных системах (macOS, Linux, BSD etc) командные оболочки умеют запускать скрипты на любых языках, в т.ч. и на Python, если эти скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария. Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang, от названий первых двух символов такой строчки: # называется "sharp", а ! - "bang!".

Типичный shebang выглядит так:

#!/usr/bin/python3

где после символов #! идёт путь до интерпретатора. Командная оболочка при запуске скрипта, содержащего shebang, читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно будет не указывать:

$ cat script.py
#!/usr/bin/python3
print('Hello!')

$ chmod +x script.py

$ ./script.py
Hello!
'''

#@ Shebang и разные версии Python

'''
shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении — а в работе вы практически всегда будете их использовать — путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях! Как же сделать так, чтобы скрипт запускался всегда с нужной версией Python? Есть способ добиться такой универсальности: нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.

Эта программа умеет находить и запускать программы с учётом переменных https://ru.hexlet.io/courses/cli-basics/lessons/environment-variables/theory_unitокружения и, т.к. при активации виртуального окружения модифицируется переменная $PATH, то env будет запускать именно ту версию интерпретатора, которая нам нужна (она просто найдётся раньше, т.к. путь до исполняемых файлов окружения добавляется в начало $PATH).

Итак, представляем правильный способ указывать shebang в проектах на python! Встречайте:
'''

#!/usr/bin/env python3
print('Hello!')

'''
Путь до env указан конкретный потому, что эта программа практически всегда располагается именно там и не встречается в нескольких версиях :) А запомнить это правило написания shebang очень легко — "вызываем python3 с учётом окружения" ("env", это сокращение от "environment"/"окружение").
'''


# >>>>>> Cкрипты <<<<<<
'''
Как писать скрипты, мы уже узнали. Теперь представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нём появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать, скажем, функцию из этого модуля в другом модуле. Значит, нужно импортировать!
'''

#@ Импортирование скриптов
'''
Давайте же смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:
'''

# file <first_script.py>

def greet(who):
    print('Hello, {}!'.format(who))

greet('Bob')
greet('Ann')

'''
А так — новый скрипт, в котором мы хотим переиспользовать функцию greet из первого модуля (скрипты — тоже модули):
'''

# file <second_script.py>

from first_script import greet

greet('Thomas')

'''
Запустим первый скрипт, а затем — второй (оба файла расположены в текущей директории):

$ python3 first_script.py
Hello, Bob!
Hello, Ann!
$ python3 second_script.py
Hello, Bob!
Hello, Ann!
Hello, Thomas!

Что мы видим — при выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию! Такова цена за простоту написания скриптов! Поскольку файл первого скрипта содержит не только определения, но и непосредственные действия (statements), то при загрузке файла (которая происходит при импорте модуля) эти действия будут выполнены. Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы или того хуже — запускаются межконтинентальные ракеты!

Выходит, нам нужно как-то различать ситуации когда

1. модуль выполняется как скрипт (выполняем побочные действия),
2. модуль или его содержимое импортируются (не выполняем побочные действия).

Для этого нам понадобится немного магии!
'''

#@ Специальная переменная __name__

'''
Машинерия импортирования при загрузке модуля в первый раз (первый для текущего запуска интерпретатора) добавляет в этот модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная __name__.

Не стоит пугаться такого странного имени аж с четыремя символами подчёркивания: такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный питонист помнит наизусть пару десятков таких переменных, а ещё про эти переменные любят спрашивать на собеседованиях.

Что же хранит переменная __name__ в каждом конкретном случае? В этом и весь секрет!

> Если происходит обычный импорт, то эта переменная содержит полное имя модуля (полностью квалифицированное).

> Если же происходит запуск в качестве скрипта, то переменная получает специальное значение — строку '__main__'.

Глядя на значение этой переменной, можем отличать "запуск" от импортирования.

Слово "main" используется во многих языках для именования функции, которая вызывается автоматически при старте программы, потому и в Python это слово используется в похожем смысле

Давайте вернёмся к нашему примеру и перепишем first_script.py с применением этого нового знания:
'''

# file <first_script.py>

def greet(who):
    print('Hello, {}!'.format(who))

if __name__ == '__main__':
    greet('Bob')
    greet('Ann')

'''
Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль. Это победа!
'''

#@ Функция main

'''
Наш first_script.py уже достаточно хорош. Но мы можем его ещё чуть-чуть улучшить.

В теле условия if __name__… у нас перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много. И, как вы бы догадались, может статься, что мы захотим переиспользовать и этот кусок кода! Скажу даже больше, такое происходит нередко. Поэтому существует соглашение: в теле условия if __name__… делают всего один вызов функции без аргументов main, которую объявляют выше в этом же модуле (само условие принято располагать в самом конце модуля скрипта).

С учётом всех описанных рекомендаций финальная версия скрипта first_script.py будет выглядеть так:
'''

#!/usr/bin/env python3

def greet(who):
    print('Hello, {}!'.format(who))

def main():
    greet('Bob')
    greet('Ann')

if __name__ == '__main__':
    main()


'''
Такой скрипт можно:
> запускать непосредственно;
> запускать из других скриптов, вызывая функцию main;
> использовать как библиотеку.
'''

#@ Запускаемые пакеты

'''
Рассмотрим немного экзотический, но всё же встречающийся случай — запуск пакета. Могло бы показаться, что раз при загрузке пакета всегда загружается модуль __init__.py, то и функцию main, и условие нужно располагать в нём. Но авторы по ряду причин решили реализовать запуск пакетов несколько иначе: при загрузке пакета пред запуском ищется модуль __main__.py и выполняется, как скрипт. Здесь мы не будем углубляться в причины, побудившие авторов языка сделать именно так, и просто запомним, что исполняемые пакеты всегда содержат скрипт __main__.py.

Когда же может понадобится запуск пакета? Сходу можно представить такой пример. Пусть мы имели один небольшой скрипт. Со временем кода в нём становилось всё больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать. Мы решили превратить один модуль в пакет, содержащий несколько. Но как такой пакет в дальнейшем запускать? Вот для этого мы и можем использовать модуль __main__.py!

# Ссылки
Полный список того, что добавляет в модуль машинерия импортирования https://docs.python.org/3/reference/import.html#import-related-module-attributes

Имя 'main' и его значение https://docs.python.org/3/library/__main__.html#module-__main__
'''


# >>>>>> Доступный инструментарий для работы с Python-проектами. <<<<<<

#@ О важности выбора инструментария

'''
Сам по себе язык программирования мало интересен, если для него нет подходящего интерпретатора или компилятора. Но программы нужно не только запускать — их нужно доставлять до пользователя. Да и редкая программа бывает сразу готова, поэтому единожды доставленную программу нужно обновлять. А ещё её нужно продолжать разрабатывать — иногда в течении нескольких лет. Поэтому периодически возникают ситуации, когда нужно обновить какие-то сторонние библиотеки, а иногда и сам компилятор или интерпретатор. Для решения вышеперечисленных задач применительно к Python в разное время появились и развились различные инструменты. О некоторых из них ниже пойдёт речь.

Большинство инструментов имеет хорошую документацию, поэтому в рамках курса не будет дублироваться эта информация. Цель урока — дать общее представление, а местами предоставить и право выбора, какой инструмент выбрать среди доступных.

Но для начала познакомимся с новой концепцией — lock-файлами.
'''

#@ lock-файлы

'''
Обычно, при разработке автор некоторой библиотеки или программы так или иначе указывает версии сторонних пакетов, которые требуются для работы его творения. Обычно версия не закрепляется жёстко, вместо этого указывается диапазон версий, в пределах которого можно ожидать, что совместимость разных частей кода не нарушится. Именно для этого часто используется семантическое версионирование https://habr.com/ru/company/Voximplant/blog/281593/.

Однако случается, что либо диапазон версий бывает указан слишком широкий, либо семантическое версионирование оказывается применено неверно, или же просто в какой-то версии некоего пакета оказывается ошибка. Возникает ситуация, когда проект работает как нужно не на любом из сочетаний разных версий пакетов, а на некотором вполне конкретном.

lock-файл как раз и предназначен для того, чтобы в дополнение к перечню пакетов с "нечёткими" версиями, таки зафиксировать список конкретных версий, которые в данный момент для проекта подходят! В том или ином виде lock-files сейчас используются большинством современных пакетных менеджеров для разных языков программирования.
'''

#@ pyenv, средство управления разными версиями интерпретатора.

'''
Даже на этапе обучения важно иметь актуальную версию интерпретатора. И Python, будучи языком, который давно начали использовать для нужд автоматизации, часто бывает доступен в каталогах пакетов различных ОС. Однако пакеты как правило содержат только CPython (а ведь есть и другие реализации интерпретаторов Python, очень полезные в различных ситуациях), и далеко не всегда "свежий".

Авторы библиотек часто вынуждены поддерживать несколько версий Python и проверять, что новые изменения, вносимые в код, не сказываются на работоспособности оного при работе с разными версиями Python.

Т.о. на одной машине может быть установлено несколько разных реализаций Python и каждая — в более чем одном варианте. А управлять всем этим "серпентарием" призван pyenv https://github.com/pyenv/pyenv. Как бы вы не использовали Python, вам стоит научиться использовать этот инструмент.
'''

#@ pipenv, "инструментарий для людей"

'''
Да, авторы pipenv https://docs.pipenv.org/ так про своё детище и пишут. Что же это за штука? pipenv берёт на себя

> управление пакетами, т.е. заменяет pip (но использует "под капотом");
> создание виртуальных окружений (c "под капотом" venv);
> работу с зависимостями, контроль за версионированием и обновлением оных, построение графа зависимостей;
> воспроизводимость сборки (через использование тех самых lock-файлов).

pipenv — инструмент мощный, но требующий умения использовать distutils/setuptools для описания процесса сборки пакета с проектом. Новичкам может быть сложно освоить именно этот аспект использования в остальном достаточно удобной программы.

По ссылке выше вы найдёте сайт с подробнейшей документацией, советую хотя бы заглянуть туда.
'''


#@ poetry, ещё один человечный инструмент разработки

'''
В наших курсах и проектах я рекомендую использовать именно poetry. Также именно с помощью poetry оформлен наш python package boilerplate https://github.com/hexlet-boilerplates/python-package. Что же это за инструмент?

poetry https://poetry.eustace.io/, это сравнительно молодой проект, упрощающий разработку на Python. В целом он решает все те же проблемы (и тоже использует lock-файлы), что решает и pipenv, но в отличие от последнего, берёт на себя сборку пакетов. Более того, вместе с poetry вам не нужно глубоко погружаться в изучение distutils/setuptools — оные вообще не используются при описании poetry-пакета!

Документация у poetry компактная, но очень понятная. Описана и рекомендуемая структура директорий в типичном проекте и использование альтернативных индексов и многие другие аспекты — и всё это снабжено примерами! Проходите по ссылке выше и знакомьтесь.

Важно: напоминаю, я буду предполагать в дальнейших курсах и проектах использование именно poetry!
'''

#@ ipython, REPL, которого мы заслужили!

'''
Python REPL довольно удобен, а главное — всегда доступен. Но использовать его для ввода большого кол-ва кода неудобно (даже многострочный код не поредактируешь нормально!). Однако REPL в Python сделан модульным и существует несколько "улучшенных версий", наиболее популярная из которых — IPython https://ipython.readthedocs.io/.

IPython имеет
> подсветку синтаксиса,
> удобное автодополнение модулей для импортирования и определений в модулях,
> подсказки по аргументам функций и отображение документации,
> и многое-многое другое!

Большинство разработчиков, занимающихся анализом данных, проводят в IPython большую часть своего рабочего времени — настолько это мощная и полезная оболочка!
'''

#@ Всего не охватить...

'''
Вокруг базового инструментария Python за десятилетия существования языка было создано огромное количество полезностей. И благодаря тому, что в Python-мире правила хорошего тона предполагают тщательное документирование кода и сам синтаксис к этому располагает (всё те же docstrings), практически любой инструмент можно освоить самостоятельно — стоит лишь проявить любопытство! Всегда можно открыть сайт PyPI и пройтись по списку тем (topics), чтобы найти интересные проекты, способные сильно упростить жизнь и просто сделать процесс разработки и изучения более приятным!
'''

