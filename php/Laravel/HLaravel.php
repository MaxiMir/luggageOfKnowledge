<?
	 
	 ####################### Laravel #######################
	 
	 
	 # >>>>>>>>>>>> О курсе <<<<<<<<<<< #

/**
	 Ларавел – популярный веб-фреймворк на PHP, предназначенный для быстрой разработки сайтов. Он сочетает в себе большие возможности сложных фреймворков и простоту написания кода с минимум конфигурирования.
	 
	 В этом курсе, шаг за шагом создается проект под названием hexlet-laravel-blog. Это простой блог, в который можно добавлять статьи и оставлять комментарии.
	 
	 Во время создания мы рассмотрим следующие темы:
	 
	 > Ресурсный (RESTLike) роутинг. Создание CRUD, валидация данных.
	 > Шаблонизатор Blade. Лейаутинг
	 > Управление приложением из командной строки. Tinker.
	 > Интеграционное тестирование, фабрики.
	 > ORM. Создание сущностей. Связи.
	 > Интернационализация (I18n). Правильная работа с текстами.
	 Практика этого курса выполняется в среде Хекслета, но для полноценного погружения, крайне рекомендуется повторять все действия на своем компьютере. Для этого убедитесь что в вашей системе установлен PHP (>= 7.1.3) и Composer.
	 
	 Этот курс сильно опирается на знания, полученные в курсе "PHP: Веб-Разработка". Если вы не знакомы с маршрутами, CRUD, MVC и шаблонизацией, то обязательно пройдите его перед этим курсом

	# Дополнительные материалы
	Homestead (Разработка на Ларавел под Windows) https://laravel.com/docs/6.x/homestead
 */
	 
	 

	 
	 # >>>>>>>>>>>> Hello World <<<<<<<<<<< #
	 
/**
	Проекты на Ларавел создаются из командной строки. Проще всего создать новый проект с помощью команды composer create-project (https://getcomposer.org/doc/03-cli.md#create-project):
	 
	# Перейдите в домашнюю директорию и выполните команду
	$ composer create-project --prefer-dist laravel/laravel hexlet-laravel-blog
	
	Эта команда создаст приложение в директории hexlet-laravel-blog и установит все зависимости, необходимые для работы Ларавел.

	После завершения установки, перейдите в директорию с проектом:
	
	$ cd hexlet-laravel-blog
	
	Ларавел управляется утилитой artisan, которая находится в корне проекта. Она включает в себя десятки команд, упрощающих процесс разработки. Одна из них – это запуск сайта в режиме разработки:
	
	$ php artisan serve
	Laravel development server started: <http://127.0.0.1:8000>
	
	Эта команда запускает встроенный в PHP веб-сервер и настраивает его для работы с Ларавел. Чтобы увидеть сайт, откройте браузер и загрузите http://127.0.0.1:8000. Вы увидите приветственную страницу фреймворка.
	
	Для остановки сервера переключитесь на терминал в котором он запущен и наберите CTRL+C.

	Эта страница нужна только для проверки того, что все работает. Ее код можно будет смело удалить.
*/

	#@ Artisan
	
/**
	Утилита artisan является центральным пультом управления фреймворка. Через artisan мы будем автоматически генерировать код, управлять базой данных, запускать сервер, консоль и многое другое. Чтобы увидеть список всех команд, запустите artisan без аргументов:
	
	$ php artisan
	
	Этот список команд может расширяться как нами, так и разработчиками расширений. На гитхабе можно найти множество полезных дополнений на все случаи жизни.

	В последующих уроках, мы постоянно будет возвращаться к этой утилите и изучать ее возможности. А пока мы с ними не знакомы, попробуйте поиграться с командой inspire:
	
	$ php artisan inspire
	Computer science is no more about computers than astronomy is about telescopes. - Edsger Dijkstra
	$ php artisan inspire
	Simplicity is an acquired taste. - Katharine Gerould
*/

	#@ Структура директорий

/**
	 Современные фреймворки, предназначены для разработки сайтов любых размеров. С одной стороны это хорошо, больше возможностей, с другой, очень легко потеряться в круговороте фич, особенно если это ваш первый фреймворк. Помимо большого числа понятий самого Ларавела, внутри него встроена поддержка фронтенда (js, фронтенд фреймворки), работа со статикой (js, css, media), разные виды кеширования, работа с очередьми, тестирование, логгирование и многое другое.
	 
	 Это не значит что придется использовать сразу все, но, иметь общее представление об этих возможностях нужно. Хотя бы на уровне понимания структуры директорий. Ниже приведена таблица директорий с описанием их содержимого. В этом описании будут встречаться названия, с которыми вы, возможно, не знакомы. Позже мы их разберем.

	 Директория	Описание
	 app			Код приложения. Именно здесь будет расположено большая часть того что пишется разработчиками.
	 
	 bootstrap	Содержит файл app.php, который инициализирует фрейморк. Кроме того, здесь располагается кеш кода, ускоряющий запуск сайта.
	 
	 config	Конфигурация приложения. Параметры доступа к базе данных, настройка отправки почты, логгирования, кеширования, все это происходит здесь
	 
	 database	Ресурсы необходимые для работы с базой данных: миграции, фабрики, сиды.
	 
	 public	Содержит файл index.php, который является входной точкой на сайт. Именно в него попадают все запросы. Еще здесь содержатся подготовленные к раздаче статические файлы: js, css и images
	 
	 resources	Содержит шаблоны и исходные фронтенд файлы, такие как scss, javasript
	 
	 routes	Роутинг приложения
	 
	 storage	Служебная директория, содержит сессионные файлы, логи, файловые кеши, откомпилированные шаблоны (для ускорения)
	 
	 tests	Тесты приложения
	 
	 vendor	Сюда Composer ставит зависимости

	#@ Дополнительные материалы
	Репозиторий готового проекта HexletLaravelBlog https://github.com/hexlet-components/laravel-blog
*/
	 


	 
	 # >>>>>>>>>>>> Запрос-Ответ <<<<<<<<<<< #

/**
	Как и любой серверный веб-фреймворк, Ларавел построен вокруг HTTP. Он принимает запросы, на основе которых формируют и отдает http-ответы. Ларавел берет на себя всю грязную работу: разбор запроса, выбор правильного обработчика, отправку ответа клиенту. Программисту остается выполнить только самый необходимый минимум для добавления новых страниц на сайте.

	В этот минимум входят три вещи:
	> Маршрут. Определяет адрес конкретной страницы или набора страниц на сайте. Маршрут связывает эти адреса с конкретным обработчиком, который будет вызван при запросе этих страниц.

	> Контроллер. Слой кода, в котором расположены обработчики страниц сайта. Они анализируют запрос (если нужно) и формируют ответ, который фреймворк отправляет пользователю.

	> Шаблон. Специальный файл, который используется для формирования HTTP-ответа.

	Маршруты любого проекта на Ларавел хранятся в директории routes. В зависимости от типа маршрута, они могут находиться в разных файлах. Сейчас нас интересует только web.php, этот файл предназначен для описания маршрутов обычных страниц сайта.

	Изначально этот файл содержит только один маршрут, соответствующий главной странице /.
*/
	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
/**
	Функция Route::get($pattern, $action) задает маршрут. Первым параметром она принимает адрес запрашиваемой страницы (или паттерн описывающий группу страниц). В коде выше это адрес главной страницы сайта. Вторым параметром передается обработчик (относится к слою контроллер). Обработчики запросов в Ларавел называют экшенами (action, хотя по-русски это "действие", но так не говорят).

	Кроме метода get, в роутере определены методы для всех глаголов HTTP. В зависимости от глагола HTTP одни и те же адреса могут вести на разные обработчики. Выбор правильного глагола для маршрута определяется его семантикой.
*/
	 Route::post('/posts', function () {
		  // Логика создания поста
	 });

	// В самом простом случае, экшену достаточно вернуть строку, которая станет телом http-ответа. Например если переписать маршрут так:
	 
	 Route::get('/', function () {
		  return 'hello, world!';
	 });
	 
/**
	И обновить страницу, то на экране отобразится фраза hello, world!.
	
	И обновить страницу, то на экране отобразится фраза hello, world!.
	 
	 Однако, в исходном варианте возвращается результат вызова view('welcome'). view($templateName) – глобальная функция, которая принимает на вход имя шаблона и возвращает его содержимое в виде строки. Затем это содержимое возвращается из экшена. Такой подход позволяет отделить обработку запроса, от формирования ответа (в данном случае HTML). Это часть архитектурного подхода MVC.
	 
	 Сам шаблон доступен по пути resources/views/welcome.blade.php. Функция view автоматически подставляет нужные директории, поэтому достаточно указывать имя шаблона. Попробуйте открыть этот шаблон и посмотреть что находится внутри него. Это тот самый HTML, который отображается при заходе на главную страницу.
	 
	 Создадим новую страницу /about. Для этого добавим маршрут, экшен и шаблон:
	 
	 Добавьте в файл routes/web.php новый маршрут и экшен:
*/
	 Route::get('/about', function () {
		  return view('about');
	 });

/**
	 Создайте шаблон resources/views/about.blade.php и добавьте туда следующий HTML:

	 <h1>О блоге</h1>
	 <p>Эксперименты с Ларавелем на Хекслете</p>
	 

	 Теперь если открыть страницу /about то отобразится вновь добавленная страница.

	# Дополнительные материалы
	Логгирование https://laravel.com/docs/6.x/logging#writing-log-messages
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Шаблонизатор Blade <<<<<<<<<<< #
/**
	 Мы знаем из курса по веб-разработке что PHP это не только язык программирования, но и шаблонизатор. Он позволяет мешать PHP код и HTML в одном файле формируя из этого общий ответ в консоль или браузер пользователя. Это одна из важных причин его популярности, но за все приходится платить.
	 
	 Когда создавался PHP, интернет только начинал свой путь. Разработчики PHP ,в то время, о многих вещах либо не знали либо не подумали. Это привело к серьезным проблемам, с которыми придется жить всегда, потому что никто не будет ломать обратную совместимость. К таким проблемам относится безопасность. Обычные PHP шаблоны, по умолчанию, не безопасны. Любой текст из кода вставляется как есть. Это значит, что если специально об этом не подумать, то сайт станет подвержен XSS-атаке. Она выполняется через внедрение JS кода на страницу, который начинает работать, а не отображаться как текст:
	 
	 <!-- Можно передать url.../?query=<script>alert('boom!')</script> -->
	 <!-- При выводе вместо PHP кода подставится тег script который будет выполнен браузером -->
	 <p><?= $_GET['query'] ?></p>
	 
	 Есть способы избежать этого, но все они требуют постоянного внимания. С точки зрения организации безопасной среды это в корне неверно и гарантированно будет приводить к ошибкам. Должно быть ровно наборот: по умолчанию все безопасно и только там где нужно, поведение меняется.
	 
	 Можно ли как-то изменить эту ситуацию? Да, первый путь это изменение самого языка. Этот путь, которым никто никогда не пойдет. Такое изменение гарантированно сломает все существующие сайты. Другой путь – создание шаблонизаторов написанных на PHP. Именно так и делают уже очень много лет.
	 
	 В итоге одна из тех вещей которая помогла PHP взлететь, теперь только мешает и создает у многих несерьезное отношение к языку. До сих пор можно встретить людей которые говорят что PHP это не язык программирования, а шаблонизатор.
	 
	 За время существования PHP были созданы десятки только популярных шаблонизаторов и сотни тех что не взлетели. Со временем они развивались и становились лучше. Когда-то популярный Smarty сейчас уже никто не вспомнит. А вот Blade входящий в состав Laravel знают почти все.
	 
	 Это не отменяет того факта, что до сих пор огромное число сайтов и цмс используют встроенную шаблонизацию PHP. Как по историческим причинам, так и из-за общей низкой культуры разработки и кустарного обучения программированию. Стоит ли говорить о том, что большинство этих сайтов легко взломать.
	 
	 Посмотрите на пример простого Blade-шаблона:
*/
?>
	 
	 <h1>{{ $object->title }}</h1>
	 <p>{{ $object->description }}</p>
	 <pre>
		  {{ $object->code }}
	 </pre>
	 <p>Question submitted at: {{ $object->created_at }}</p>

<?
/**
	 На первый взгляд похоже. Шаблон выглядит как HTML с вкраплениями кода. В отличии от самого PHP в Blade, вставка любого значения выполняется в двойных фигурных скобках {{ ... }}. Это очень похоже на интерполяцию, если сам шаблон рассматривать как строку. За сценой, Blade выполняет дополнительную обработку и экранирует любые данные, вставленные таким образом. Это значит что нам больше не нужно прилагать усилия к обеспечению безопасности в шаблонах.
	 
	 Откуда в этом шаблоне взялся $object? Вспомним код обработчика:
*/
	 
	 Route::get('/about', function () {
		  return view('about');
	 });

/**
	 Такой вариант использования шаблонов подходит только для простых информационных страниц. В которых нет динамического содержимого (получаемого, например, из базы). В большинстве же реальных ситуаций, контроллер получает какие-то данные, обрабатывает их если нужно и передает в шаблон. Делается это крайне просто, достаточно передать ассоциативный массив с данными вторым параметром функции view. В шаблоне каждое значение этого массива становится доступно под именем переменной соответствующей ключу массива:
*/
	 // routes/web.php
	 Route::get('/about', function () {
		  $tags = ['обучение', 'программирование', 'php', 'oop'];
		  return view('about', ['tags' => $tags]);
	 });

?>

	<!-- resources/views/about.blade.php -->
	 <h1>О блоге</h1>
	 <p>Эксперименты с Ларавелем на Хекслете</p>
	 <p>{{ implode(', ', $tags) }}</p>
	 
<?
/*
	 Как видно из примера выше, двойные фигурные скобки позволяют выполнять произвольный PHP код. Главное не злоупотреблять. В основном данные должны быть подготовлены в обработчике до того как они попадут шаблон. Тут стоит сказать отдельно, что PHP, как шаблонизатор, давал слишком много свободы, которая очень влияла на качество кода. При таком использовании PHP, в шаблоне нередко выполнялись SQL-запросы, HTTP-вызовы и тому подобные вещи. По понятным причинам этого делать ни в коем случае нельзя. Шаблоны про отображение, а не про логику работы.
	 
	 Кроме подстановки, в Blade есть директивы. С их помощью реализованы все управляющие конструкции, такие как циклы, условия и другое:
*/
?>
	 @if (count($records) === 1)
		  I have one record!
	 @endif
	 
	 @foreach ($users as $user)
		  <p>This is user {{ $user->id }}</p>
	 @endforeach
<?
/**
	Директивы всегда начинаются со знака @ и часто (но не всегда) имеют закрывающую часть. Синтаксис директив содержит меньше деталей и он проще чем синтаксис чистого PHP. С его помощью можно делать практически все тоже самое что и в самом PHP. Более того, можно сказать что Blade, фактически, является самостоятельным языком программирования. Но лучше про это сразу забыть)

	 Blade имеет встроенную поддержку разных элементов, полезных в шаблонах. То что в PHP шаблонах нужно делать "руками", тут есть сразу. К таким возможностям, например, относится определение первой и последней итерации в цикле:
*/
?>

@foreach ($users as $user)
    <!-- $loop специальная переменная доступная внутри цикла -->
    @if ($loop->first)
        This is the first iteration.
    @endif

    @if ($loop->last)
        This is the last iteration.
    @endif

    <p>This is user {{ $user->id }}</p>
@endforeach

<?
/**
	Кроме указанных структур, директивы Blade поддерживают цикл for, switch isset и некоторые другие, более специфичные.
	
	# Дополнительные материалы
	Blade https://laravel.com/docs/6.x/blade
*/
	 
	 
	 
	 
	 # >>>>>>>>>>>> Макеты (Layout) <<<<<<<<<<< #
	 
/**
	Каждая страница любого сайта, содержит свое собственное содержимое и общие части, такие как футер или боковое меню. Существует два подхода по работе с этими общими частями.
*/

	#@ Включение
	
/**
	До эры фреймворков, фактически, был ровно один способ выделять общие части. Он сводился к созданию двух шаблонов: хедера (шапка сайта) и футера (подвал). Затем, эти шаблоны включались во всех остальных шаблонах, отвечающих за основную часть страницы. Выглядело это так:
*/
?>
	 
	 <?= include('header.php'); ?>
	 
		  <div id="page-content">
				<!-- Тут основная часть -->
		  </div>
	 
	 <?= include('footer.php'); ?>


<?

/**
	 Такой подход все еще популярен в самописных решениях и в популярных CMS. Где-то в силу исторических причин, где-то потому, что его очень просто понять и начать использовать.
	 
	 С другой стороны, у такого подхода слишком много недостатков, из-за которых фреймворки отказались от него:

	> Футер и Хедер хранят куски кода, которые сами по себе не являются правильным HTML. В хедере открывающие теги, в футере закрывающие. Из-за этого крайне легко ошибиться и потом долго искать незакрытый тег.

	> Страница разбитая на хедер и футер не дает увидеть всю картину целиком. Придется скакать туда сюда для понимания того, что из себя представляет страница.

	> Появляется очень много дублирования из-за постоянных вставок хедера и футера

	> Все сильно усложняется, если хедеры и футеры могут быть разными

	> Невозможно обработать ситуацию, когда страницы имеют более сложное разбиение и включение хедера и футера не поможет.
*/

	#@ Макеты
/**
	Это совершенно другой подход при работе с шаблонами. Он строится не от шаблона конкретного обработчика (экшена), а от макета. Макет – это базовая структура страницы, в которую вставляются данные, сгенерированные конкретным обработчиком. Для работы макетов недостаточно стандартных PHP файлов с HTML разметкой. Разработчикам шаблонизаторов приходится придумывать специальные маркеры, которые указывают куда и какой блок можно поместить.

	В Laravel используется шаблонизатор Blade. Фактически, Blade, это свой собственный язык, с помощью которого создаются шаблоны. Blade-специфичные команды в шаблонах начинаются со знака @ и называются директивами. Большинство директив похожи на вызов функций, в которые передаются аргументы.
*/
?>
	 <!-- Хранится в resources/views/layouts/app.blade.php -->
	 <html>
		  <head>
				<title>Hexlet Blog - @yield('title')</title>
		  </head>
		  <body>
				<div class="container">
					 @yield('content')
				</div>
		  </body>
	 </html>
	 
<?
/**
	В макете выше, используется директива @yield. Она указывает на то, куда будет вставлен контент конкретного обработчика.

	 В шаблоне самого обработчика, используется директива @section, которая определяет блок контента. Каждый такой блок имеет собственное имя, что позволяет одновременно делать вставку сразу множества блоков. Это особенно удобно для сложных макетов, где кроме самого контента, есть и другие блоки, специфичные для конкретных страниц.
*/
?>
	 
	 <!-- Хранится в resources/views/about.blade.php -->

	 @extends('layouts.app')

	 <!-- Секция, содержимое которой обычный текст. -->
	 @section('title', 'О блоге')

	 <!-- Секция, содержащая HTML блок. Имеет открывающую и закрывающую часть. -->
	 @section('content')
	 	<h1>О блоге</h1>
	 	<p>Эксперименты с Ларавелем на Хекслете</p>
	 @endsection

<?
/**
	 Директива @extends указывает на макет, внутрь которого должны попасть данные из текущего шаблона. В эту директиву передается путь относительно директории resources/views. Обратите внимание что вместо / используется точка.
	 
	 Далее идут секции. У каждой секции есть имя, благодаря которому можно точечно управлять местом ее отображения. Выше создаются две секции content и title. Одна из них отображается в теге <title>, другая внутри <body> и является центральной контентной частью страницы.
	 
	 Имена выбираются произвольно. Количество секций не ограничено. Количество макетов тоже.
	 
	 Несмотря на наличие макетов, иногда бывает полезно иметь общий шаблон, который вставляется в конкретных местах. Blade позволяет создавать и включать такие шаблоны с помощью директивы @include:
*/
?>
	 <html>
		  <head>
				<title>Hexlet Blog - @yield('title')</title>
				@include('shared.metatags')
		  </head>
		  <body>
				<div class="container">
					 @yield('content')
				</div>
		  </body>
	 </html>

<?
/*
	Код подобный тому что выше, часто встречается в тех проектах где несколько макетов. Как правило, их общие части выносят в обшие шаблоны, которые затем включаются через @include. Хорошей практикой считается помещать общие шаблоны в директорию resources/views/shared. Так легче понять какие шаблоны можно переиспользовать.

	# Самостоятельная работа

	Создайте макет resources/views/layouts/app.blade.php со следующим содержимым:
*/
?>
	 <!doctype html>
	 <html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
		  <head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">
				<title>Hexlet Blog - @yield('title')</title>
				<meta name="csrf-token" content="{{ csrf_token() }}">
				<meta name="csrf-param" content="_token" />
				<link href="{{ asset('css/app.css') }}" rel="stylesheet">
				<script src="{{ asset('js/app.js') }}"></script>
		  </head>
		  <body>
				<div class="container mt-4">
					 <h1>@yield('header')</h1>
					 <div>
						  @yield('content')
					 </div>
				</div>
		  </body>
	 </html>

<?
/*
	 Переделайте шаблон about.blade.php так как показано в уроке (возможно понадобится почистить кеши php artisan view:clear).
	 
	 Прочитайте про CSRF.
	 
	 Зафиксируйте изменения в git (Дальше этот пункт повторяться не будет. Не забывайте фиксировать любые изменения в git)


	# Дополнительные материалы
	Документация Blade https://laravel.com/docs/6.x/blade#template-inheritance
*/

/*@@@
	resources/views/layouts/app.blade.php:
	Добавьте вывод двух секций:
	 Секция header, содержимое которой выводится в заголовке <h1>
	 Секция content, содержимое которой выводится под заголовком в <div>
 
	resources/views/about.blade.php:
	 Подключите макет layouts/app
	 Добавьте в секцию header текст "О блоге"
	 Добавьте в секцию content:

	<p>Эксперименты с Ларавелем на Хекслете</p>

	resources/views/articles.blade.php:
	 Подключите макет layouts/app
	 Добавьте в секцию header текст "Статьи"
	 Добавьте в секцию content:
	 
	 <p>Тут будут статьи</p>
*/

# FILE: resources/views/layouts/app.blade.php:
?>
<!doctype html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
	 <head>
		  <meta charset="utf-8">
		  <meta name="viewport" content="width=device-width, initial-scale=1">
		  <title>Laravel</title>
	 </head>
	 <body>
		  <a href="/">Home</a>
		  <a href="/about">About</a>
		  <a href="/articles">Articles</a>
		  
		  <!-- BEGIN (write your solution here) -->
		  <h1>@yield('header')</h1>
		  <div>
				@yield('content')
		  </div>
		  <!-- END -->
	 </body>
</html>



<?
# FILE: resources/views/about.blade.php:
?>
	 @extends('layouts.app')
 
	 @section('header', 'О блоге')

	 @section('content', '<p>Эксперименты с Ларавелем на Хекслете</p>')

<?
# FILE: resources/views/articles.blade.php:
?>

	 @extends('layouts.app')
	 
	 @section('header', 'Статьи')
	 
	 @section('content', '<p>Тут будут статьи</p>')

<?



	# >>>>>>>>>>>> Консоль (Tinker) <<<<<<<<<<< #
	
/**
	В PHP встроен REPL, который позволяет быстро поэкспериментировать с языком.
	
	$ php -a
	Interactive shell
	
	
	# Некоторые используют его как калькулятор
	php > echo 3 ** 2;
	9
	
	 # Можно вызывать любые функции и смотреть что получится
	 php > echo array_sum([1, 3, 2]);
	 6
	 php >
	
	
	 Для разработчиков, которые никогда не имели с ним дело, может показаться что REPL это игрушка, но это не так. Во многих языках, программисты значительное время проводят в REPL постоянно исследуя код. В мире Lisp языков даже есть понятие REPL-driven development.
	 
	 Сейчас ситуация в PHP стала меняться. В первую очередь благодаря PsySH https://psysh.org/. Это тоже REPL для PHP, но в отличие от встроенного, он значительно мощнее и ориентирован на удобство отладки и исследования (интроспекции) кода. Одна из приятных особенностей этого REPL, в том, что не нужно ставить точку с запятой в конце выражений и результат любого выражения автоматически выводится на экран. А еще цветной вывод.
	
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> 3 ** 2
	=> 9
	
	>>> array_sum([1, 3, 2])
	=> 6
	
	 PsySH умеет конфигурироваться, что позволяет при его старте прогружать в память любой код на PHP. Благодаря этому, разработчики Laravel смогли создать REPL, который позволяет экспериментировать не только с обычными функциями, но и со всем фреймворком. Этот REPL называется Tinker. Начиная с текущего момента и на протяжении всего курса, мы постоянно будем использовать Tinker для проверки работы любых аспектов фреймворка.

	Запускается Tinker как команда Artisan:
	
	$ php artisan tinker
	
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> array_reverse([1, 2, 3, 4])
	=> [
		  4,
		  3,
		  2,
		  1,
	]
	
	Из приветствия видно что мы имеем дело с PsySH. Здесь можно работать как с самим PHP, так и с Laravel. В последний включено множество функций, не имеющих прямого отношения к вебу, но упрощающих работу:

	>>> Str::ascii('трансляция в аски')
	=> "translyatsiya v aski"
	
	>>> last([3, 2, 8])
	=> 8
	
	Tinker и Psysh добавляют несколько полезных функций от себя. Эти функции позволяют посмотреть историю команд, документацию по функциям, увидеть их содержимое и многое другое. Ниже несколько примеров:
	
	>>> show last # посмотреть определение функции
	> 726|     function last($array)
     727|     {
     728|         return end($array);
     729|     }
	
	>>> history # история
	75: Str::ascii('трансляция в аски')
	76: last([3, 2, 8])
	77: show last
	
	>>> dd([1, 2, [3, 2, ['show', ['one' => 'two']]]]) # вывести красиво данные
	 array:3 [
		0 => 1
		1 => 2
		2 => array:3 [
		  0 => 3
		  1 => 2
		  2 => array:2 [
			 0 => "show"
			 1 => array:1 [
				"one" => "two"
			 ]
		  ]
		]
		]
	
	>>> doc head # посмотреть документацию по функции
	function head($array)
	
	Description:
  		Get the first element of an array. Useful for method chaining.
	
	Param:
  		array  $array

	Return:
  		mixed
	
	Самое интересное при работе с Tinker начнется позже, когда мы познакомимся с ORM и тестами.
*/




	# >>>>>>>>>>>> Конфигурация <<<<<<<<<<< #
	
	#@ Переменные окружения

/**
	Любое нетривиальное приложение, взаимодействует с внешним миром: ходит в базу данных, обращается к внешним сервисам (например платежным), отправляет письма и загружает друзей из, например, фейсбука. Для подавляющего большинства этих операций необходимы специальные параметры: ключи, пароли, адреса серверов и порты. Все эти параметры называются конфигурацией приложения.

	 Возникает вопрос, где хранить конфигурацию? Самый простой и самый неправильный ответ – прямо в приложении. Проблем у такого подхода две:

	> Часть этих данных секретная. Хранить их в репозитории просто нельзя из-за возможных проблем с безопасностью. Любой кто имеет доступ к репозиторию сможет получить любой доступ. Правда еще есть вариант с шифрованием, но он выходит за рамки обсуждаемой темы (для интересующихся Ansible Vault https://docs.ansible.com/ansible/latest/user_guide/vault.html).

	> При изменении этих параметров придется заново "деплоить" (то есть выкладывать) сайт, хотя, по сути, ничего не изменилось, нет новых фич, нет исправления старых багов. Просто изменилась конфигурация.


	В 2011 году, разработчики компании heroku, выложили в интернете сайт, который называется 12factors https://12factor.net/ru/. Он описывает методологию для создания веб-приложений, которая уменьшает затраты на установку и настройку приложения, повышает переносимость между средами исполнения, позволяет масштабироваться без существенных изменений в инструментах, архитектуре и практике разработки. С тех пор, эта методолгия, фактически, стала стандартом в индустрии.

	 Я крайне рекомендую прочитать этот документ целиком, но прямо сейчас нас интересует один его аспект – конфигурация. 12факторов требуют строгого разделения конфигурации и кода. Конфигурация может меняться между развертываниями (локальное окружение разработчика, продакшен, среда для тестирования), код – нет. Конфигурация должна передавать в приложение снаружи и единственный универсальный способ сделать это, использовать переменные окружения.

	Laravel имеет большое число настроек для разных подсистем, которые задаются через переменные окружения. Например вот как можно запустить фреймворк в режиме отладки:


	# при запуске устанавливается переменная окружения APP_DEBUG со значением true
	$ APP_DEBUG=true php artisan serve

	 Таких переменных довольно много, они отвечают за настройку кеширования, за отправку почты и многое другое. Для простоты конфигурации, Laravel использует библиотеку phpdotenv https://github.com/vlucas/phpdotenv, которая позволяет загружать переменные не только из окружения, но и из специального файла .env находящегося в корне проекта. Этот файл не хранится в репозитории, так как он специфичен для окружения, в котором идет запуск. Вот его небольшой кусок:

	 APP_NAME=Laravel
	 APP_ENV=local
	 APP_KEY=base64:MUD1rJ2GkEp7P5PdlsGe5MGfdwxu0v08IVDLodGW3zE=
	 APP_DEBUG=true
	 APP_URL=http://localhost
	 
	 LOG_CHANNEL=stack
	 
	 BROADCAST_DRIVER=log
	 CACHE_DRIVER=file
	 QUEUE_CONNECTION=sync
	 SESSION_DRIVER=file
	 SESSION_LIFETIME=120

	Это обычный текстовый файл, в каждой строке которого находится имя переменной и ее значение. Laravel автоматически подгружает его и затем, эти переменные используются в коде (если они там используются конечно).

	Возможно у вас возникает вопрос, каким образом формируется этот файл? После генерации проекта, Laravel создает файл .env.example, который хранится в репозитории, а в момент выполнения команды composer install он копируется в файл .env. Благодаря этому проект на Laravel старутет из коробки без необходимости дополнительной конфигурации. По крайней мере в режиме разработки. А вот для конфигурации продакшен окружения одним фреймворком не обойтись. Здесь нужно применять либо системы управления конфигурацией, такие как ansible https://www.ansible.com/, либо использовать системы оркестрации, например, kubernetes https://kubernetes.io/, либо системы подобные vault https://www.vaultproject.io/
*/

	#@ База данных

/**
	По умолчанию, ларавел, хочет взаимодействовать с MySQL, одной из самых популярных баз данных используемых в веб-разработке (наряду с PostgreSQL). Мы же поменяем базу данных и запустим наше приложение с SQLite. SQLite крайне проста в первоначальной настройке и запуске, это позволит нам прямо сейчас не отвлекаться на борьбу с операционной системой.

	 Учтите что SQLite нельзя использовать в конкуретной среде, то есть там где много пользователей. Она на это не рассчитана. Основное применение SQLite это мобильные приложения, настольные приложения, например браузеры. Еще SQLite используют как базу данных для прогона тестов или запуска веб-сайта в режиме разработки. Последнее это наш случай.
	 
	SQLite хранит данные в обычном файле. Создадим его:

	$ touch database/database.sqlite

	 Этот файл не может лежать в репозитории так как он меняется при любых изменениях данных. Laravel уже побеспокоился об этом и добавил все файлы с расширением sqlite в .gitignore.
	 
	 Теперь необходимо настроить приложение так, чтобы оно начало использовать SQLite. Для этого откройте .env и установите там тип соединения:

	DB_CONNECTION=sqlite


	 Кроме того, нужно закомментировать или удалить переменную окружения DB_DATABASE. В таком случае Laravel попробует искать файл с базой данных по пути database/database.sqlite.
	 
	 Проверить что подключение работает можно в репле:

	 $ php artisan tinker
	 Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman

	 >>> DB::select('select 1')
	 # Если нет ошибок, значит все хорошо



	 # Самостоятельная работа
	 1. Изучите файл .env.example.
	 2. Найдите в composer.json код, который отвечает за копирование .env.example в .env.
	 3. Настройте подключение к SQLite и проверьте что оно работает. Возможно вам понадобится доставить в систему пакет, который подключает sqlite3 к PHP. Точнее имя пакета зависит от системы и версии PHP.

	 # Дополнительные материалы
	 Конфигурация Laravel https://laravel.com/docs/6.x/configuration


	? Если в приложении поменялся пароль к базе данных. Что нужно сделать чтобы приложение начало работать с новым паролем, учитывая что пароль передается в код как переменная окружения.
	> Поменять переменную окружения => Перезапустить приложение

	? Если в приложении поменялся пароль к базе данных. Что нужно сделать чтобы приложение начало работать с новым паролем, учитывая что пароль "зашит" в код приложения, а не передается как переменная окружения.
	> Подготовить новую версию приложения => Выполнить деплой с новым паролем
*/




/*
	В отличии от самостоятельной работы. В упражнениях на Хекслете мы будем работать с базой данных PostgreSQL.

	.env

	Добавьте переменные окружения:
		DB_CONNECTION=pgsql
		DB_DATABASE=app_development
		DB_USERNAME=nobody
		DB_PASSWORD=secret

# РЕШЕНИЕ:
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:z0mNjzYC9xSgWQ1pYWyJxTaOT6J5J+kFDgSF6Ciqsc0=
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack

# BEGIN (write your solution here)
DB_CONNECTION=pgsql
DB_DATABASE=app_development
DB_USERNAME=nobody
DB_PASSWORD=secret
# END

BROADCAST_DRIVER=log
CACHE_DRIVER=file
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_DRIVER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_APP_CLUSTER=mt1

MIX_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
MIX_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
*/




	# >>>>>>>>>>>> ORM <<<<<<<<<<< #

/**
	 Любое веб-приложение оперирует внутри себя понятиями предметной области: пользователь, статья, курс, урок и другими. Эти понятия связаны между собой и включены в различные процессы, например, регистрацию пользователя или публикацию статьи.
	 
	 За эту часть приложения (основную!) в Laravel отвечает ORM (название группы фреймворков или библиотек, которые помогают моделировать предметную область и связывать ее с базой данных). ORM в ларавел называется Eloquent. Это фреймворк внутри фреймворка, который определяет то, как создаются сущности, как они связываются друг с другом и каким образом все это отображается на базу данных.
	 
	 Подробнее работа с ORM рассматривается в отдельном курсе, здесь же дается необходимый минимум.
	 
	 Любая сущность, создаваемая внутри приложения, называется моделью. Модели в ларавел лежат в директории app. Конкретный набор моделей зависит от приложения и может измениться со временем. На Хекслете таких моделей сотни, вот лишь некоторые, с которыми наши пользователи сталкиваются каждый день:
	 
	 > Пользователь
	 > Курс
	 > Урок
	 > Профессия
	 > Упражнение
	 > Подписка
	 > Участник курса (Мембер)
	 > Статья в блоге
	 > Топик
	 > Комментарий к топику
	 > Проект
	 
	 Важно не путать понятие модель во фреймворке, с понятием модель в MVC. Последнее это не класс не файл не функция не структра данных, это слой приложения отвечающий за модель предметной области. И это не про базу данных.
	 
	 Модели, как и большинство других частей приложения, создаются через утилиту artisan. Этот вызов создаст два файла:
	 
	 
	 $ php artisan make:model Article --migration
	 Model created successfully.
	 Created Migration: 2019_07_28_220908_create_articles_table
*/

	#@ Миграция
	
	// Первый файл – миграция в директории database/migrations.
	 
	 use Illuminate\Support\Facades\Schema;
	 use Illuminate\Database\Schema\Blueprint;
	 use Illuminate\Database\Migrations\Migration;
	 
	 class CreateArticlesTable extends Migration
	 {
		  /**
			* Run the migrations.
			*
			* @return void
			*/
		  public function up()
		  {
				Schema::create('articles', function (Blueprint $table) {
					 $table->bigIncrements('id');
					 $table->timestamps();
				});
		  }
		  
		  /**
			* Reverse the migrations.
			*
			* @return void
			*/
		  public function down()
		  {
				Schema::dropIfExists('articles');
		  }
	 }


/**
	Миграция – sql-запрос, который выполняется в базе при любом ее изменении. В данном случае запрос создает таблицу articles. Это соглашение пришло в Laravel из Rails: для каждой модели создается таблица, где имя модели берется в нижнем регистре и множественном числе. Например Article – articles или Person – people.

	Сама миграция не выглядит как SQL. Внутри нее используется библиотека, которая позволяет описывать изменения в базе в виде кода, который затем превращается в SQL. Структура этого кода достаточна проста, если знать PHP. В нем описывается таблица, все ее колонки и их типы.

	По умолчанию, Laravel добавляют в миграцию два вызова:
	> $table->bigIncrements('id') – колонка, которая будет первичным ключем
	> $table->timestamps() – два поля: updated_at (время последнего обновления) и created_at (время добавления). Это стандартная практика для многих фреймворков, эти колонки добавляются во все таблицы для удобства отслеживания дат.

	Остальные колонки нужно добавлять самостоятельно. Для статей полная миграция выглядит так:
*/
	 
	 Schema::create('articles', function (Blueprint $table) {
		  $table->bigIncrements('id');
		  $table->string('name'); // название статьи
		  $table->text('body'); // тело статьи
		  $table->timestamps();
	 });


/**
	 Миграции не выполняются автоматически. Их нужно "применять" или, как говорят "накатывать" на базу данных. Команда php artisan migrate находит все миграции, которые еще не были применены и выполняет их все в том порядке, в котором они расположены в файловой системе.

	$ php artisan migrate
	Migrating: 2014_10_12_000000_create_articles_table
	Migrated:  2014_10_12_000000_create_articles_table

	Если все прошло успешно, то в базе данных появилась таблица articles.

	 Миграции можно не только накатывать, но и откатывать. Для этого нужно набрать:

	 $ php artisan migrate:rollback.

	Эта команда попробует отменить последнюю миграцию. Повторный вызов откатит еще одну миграцию, которая была перед последней. И так далее до самого конца.
*/




	#@ Модель
	
	// Второй файл – класс (модель) с именем Article в директории app
	 
	 namespace App;
	 
	 use Illuminate\Database\Eloquent\Model;
	 
	 class Article extends Model
	 {
		  //
	 }
	 
/**
	Модель в Laravel – это класс который наследуется от Model. В самом простом случае, этот класс не содержит ни строчки кода. Большую часть работы по его функционированию берет на себя Eloquent. Эта ORM связывает класс с таблицей в базе данных и предоставляет множество необходимых методов, которых достаточно для большинства задач.
	 
	 # Самостоятельная работа
	 1. Создайте модель Article
	 2. Выполните миграции
	 
	 # Дополнительные материалы
	 Eloquent https://laravel.com/docs/6.x/eloquent
	 
	 ? Выберите верные утверждения про понятие "модель" в ORM
	 > Модель начинает работать тогда, когда создана и выполнена миграция описывающая таблицу для этой модели
	 > M в MVC это не тоже самое что и модель как сущность ORM.
	 > Модель связана с таблицей в базе данных один-к-одному
*/

	#@ database/migrations
	// Сгенерируйте файл миграции, в котором добавьте поле views_count (количество просмотров) в таблицу статей
	
	 /**
	 	Сгенерируйте файл миграции, в котором добавьте поле views_count (количество просмотров) в таблицу статей
	  */
	
	 use Illuminate\Database\Migrations\Migration;
	 use Illuminate\Database\Schema\Blueprint;
	 use Illuminate\Support\Facades\Schema;
	
	 class AddViewsCountToArticles extends Migration
	 {
		  /**
			* Run the migrations.
			*
			* @return void
			*/
		  public function up()
		  {
				Schema::table('articles', function (Blueprint $table) {
					 $table->integer('views_count');
				});
		  }
		 
		  /**
			* Reverse the migrations.
			*
			* @return void
			*/
		  public function down()
		  {
				Schema::table('articles', function (Blueprint $table) {
					 $table->dropColumn('views_count');
				});
		  }
	 }



	 
	# >>>>>>>>>>>> Модель <<<<<<<<<<< #
	
/**
	Модель в MVC v2 – это слой приложения, отвечающий за связь с предметной областью. В нем находится вся бизнес-логика приложения. Для простоты реализации, сюда часто включают механизмы для работы с базой данных.
	
	Очень важно понимать, что модель, как слой, существует независимо от фреймворка, HTTP и веба в целом. Вся остальная система может обращаться к моделям, но модели не могут знать и не знают ничего про среду в которой они выполняются.
	
	В том числе это значит, что мы можем работать с моделями вне фреймворка. В этом нам поможет Tinker. Одна из самых полезных возможностей Tinker – загрузить приложение и "поиграться" с моделями, поисследовать базу данных.
	
	Текущая версия Tinker не умеет подтягивать изменения файлов в репл. Поэтому если вы что-то меняете в коде с которым работаете в репле, придется его перезапускать
	
	Выполним полный пример, создадим новую статью, наполним ее данными и сохраним в базе:
	
	$ php artisan tinker
	Psy Shell v0.9.9 (PHP 7.3.7 — cli) by Justin Hileman
	
	>>> $a = new App\Article()
	=> App\Article {#2970}
	
	# После того как объект модели создан, его можно наполнять данными через обычные свойства (на самом деле внутри используется `__set` и `__get`). Имена этих свойств, соответствуют именам в таблице.
	
	>>> $a->name = 'my super article'
	=> "my super article"
	
	>>> $a->body = 'my content'
	=> "my content"
	
	>>> $a
	=> App\Article {#2970
     name: "my super article",
     body: "my content",
   }
	
	
	Когда объект готов, его можно сохранить в базу данных. Для этого надо вызвать метод save():
	
	>>> $a->save()
	=> true
	
	>>> $a
	=> App\Article {#2970
     name: "my super article",
     body: "my content",
     updated_at: "2019-07-29 19:17:08",
     created_at: "2019-07-29 19:17:08",
     id: 1,
   }
	
	Этот метод делает INSERT запрос в базу данных. Затем он обновляет сам объект:
	> Внутрь записывается идентификатор статьи взятый из базы данных.
	> Заполняются поля created_at и updated_at. Если это новая запись, то значения этих полей совпадают.
	
	Созданный объект можно тут же поменять:
	
	>>> $a->name = 'another title'
	=> "another title"
	
	>>> $a
	=> App\Article {#2972
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:17:08",
   }
	
	Изменение свойств никак не затрагивает базу данных. Все это происходит только на уровне самого объекта. Если в этот момент закрыть консоль, то все изменения потеряются. Для сохранения нужно опять вызвать save(). Этот метод универсальный, он подходит как для создания новой сущности, так и для ее обновления.
	
	>>> $a->save()
	=> true
	
	>>> $a
	=> App\Article {#2972
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:31:56",
   }
	
	
	Метод save() выполняет запрос в базу только тогда, когда что-то поменялось. В этом случае обязательно меняется значение поля updated_at. Оно ставновится равным текущему времени.
	
	Теперь предположим, что у нас нет переменной с текущей статьей. Например мы перезапустили консоль. Каким образом получить нужный объект? Делается это с помощью статических методов, которые появляются у каждой модели. Самый простой способ достать запись, сделать поиск по ее идентификатору:
	
	>>> $a = App\Article::find(1)
	=> App\Article {#2980
     id: "1",
     name: "another title",
     body: "my content",
     created_at: "2019-07-29 19:17:08",
     updated_at: "2019-07-29 19:31:56",
   }
	
	find всегда ищет по первичному ключу и возвращает ровно одну запись или null. Если нужен поиск по полям, который вернет коллекцию, то для этого подходит метод where:
	
	 # Такой запрос извлечет все статьи, у которых имя равно _another title_.
	 >>> $articles = App\Article::where('name', 'another title')->get()
	 => Illuminate\Database\Eloquent\Collection {#2973
     all: [
       App\Article {#2967
         id: "1",
         name: "another title",
         body: "my content",
         created_at: "2019-07-29 19:17:08",
         updated_at: "2019-07-29 19:31:56",
       },
     ],
   }
	
	Кроме where, нам понадобятся два похожих метода:
	> Model::all() извлекает все записи из таблицы. Такой метод подходит только в некоторых ситуациях, в основном при работе со справочниками где немного данных. В остальных случаях он может выбрать в память слишком много записей, что породит ненужную нагрузку на сервер.
	
	> Model::paginate($page) – извлекает записи постранично. Основной метод, который используется в списках.
	
	И последнее что можно сделать с сущностью, это удалить ее:
	
	 >>> $a->delete()
	 => true
	
	 >>> Article::find(1)
	 => null
*/



	#@ Состав модели

/*
	 В реальных проектах от десятков до тысяч (или десятков тысяч!) сущностей. При таких количествах, помнить из чего состоят модели – невозможно. Более того, в проект могут и будут приходить новые люди, которые не знают структуры моделей.
	 
	 Узнать какие поля есть у модели можно несколькими способами. Ими придется пользоваться регулярно:
 	> База данных. Всегда можно подключиться напрямую и посмотреть структуру таблицы. В разных базах данных это делается по разному.

	> Laravel имеет встроенный механизм извлечения структуры таблицы. Он сам им пользуется для работы модели.
*/
	
	 DB::getSchemaBuilder()->getColumnListing('имя таблицы');

/*
	> Пожалуй самый простой и распространенный способ. Достаточно зайти в REPL, извлечь первую сущность нужной модели и распечатать ее.

	 >>> $u = \App\User::first()
	 >>> $u->toArray()

	 string(29) "select * from "users" limit 1"
	 => [
     "id" => 1,
     "email" => "streich.viva@example.net",
     "first_name" => "Tatum",
     "last_name" => "Hudson",
     "password" => "$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi",
     "created_at" => "2019-08-29 19:31:38",
     "updated_at" => "2019-08-29 19:31:38",
   ]
*/



/**@@@
	 Добавьте несколько статей через REPL. Консоль вызывается так:
	 # Внутри выполняется команда `php artisan tinker` плюс кое-какие настройки
	 make console
	 
	 routes/web.php
	 Реализуйте обработчик маршрута /articles, который извлекает из базы данных все статьи и выводит их в шаблон.
	 
	 Получите из базы все статьи и передайте их в шаблон
	 Выведите их в шаблоне
 */


	// FILE: resources/views/articles.blade.php:
?>
	 <!-- BEGIN -->
	 @extends('layouts.app')

	 @section('content')
		  @foreach ($articles as $article)
		  		<h2>{{ $article->name }}</h2>
		  		<div>{{ $article->body }}</div>
		  @endforeach
	 @endsection

<?
	// FILE: /routes/web.php:
	
	 Route::get('/', function () {
		  return view('welcome');
	 });
	
	 Route::get('/articles', function () {
		  $articles = App\Article::all();
		  return view('articles', ['articles' => $articles]);
	 });




	# >>>>>>>>>>>> Модель <<<<<<<<<<< #
	

/**
	 Реализация CRUD – самый быстрый способ познакомиться с любым веб-фреймворком. Он затрагивает все основные его части и позволяет понять насколько в этом фреймворке удобно работать.
	 
	 Создать CRUD в Laravel можно несколькими способами. Самый простой – добавить в файл роутинга нужные маршруты вместе с обработчиками. Внутри обработчиков реализовать логику вывода списка, создания, обновления и удаления статьи. Этот способ очень муторный, он требует много движений от программиста. И он быстро захламляет файл с маршрутами. Когда таких "крудов" станет хотя бы несколько штук, то ориентироваться в нем станет проблематично. А если добавить сотню другую как в реальных проектах, так вообще станет невозможно.
	 
	 Проблема одного файла решается с помощью "контроллера". В Laravel, контроллером называют класс, который расположен в директории app/HTTP/Controllers. Методы этого класса связываются с конкретными маршрутами и отвечают за его обработку:
*/

	 // routes/web.php
	 
	 // Вторым параметром передается строчка: 'controllerName@methodName'
	 Route::get('/about', 'PageController@about');
	 Route::get('/team', 'PageController@team');
	 
	 
	 // app/HTTP/Controllers/PageController.php
	 
	 namespace App\Http\Controllers;
	 
	 // Должен наследоваться от Controller
	 class PageController extends Controller
	 {
		  public function about()
		  {
				// Точка используется вместо /.
				// То есть шаблон находится по пути resources/views/page/about.blade.php
				return view('page.about');
		  }
		  
		  public function team()
		  {
				return view('page.team');
		  }
	 }
	 
/**
	 Методы в контроллерах принято группировать по смысловой связи. Например все что относится к обычным страницам на сайте можно поместить в контроллер PageController, а CRUD статьи в контроллер ArticleController. Ниже пример структуры контроллеров из нашего открытого проекта hexlet-sicp:

	 app/Http/Controllers/
	 ├── Auth
	 │   ├── ForgotPasswordController.php
	 │   ├── LoginController.php
	 │   ├── RegisterController.php
	 │   ├── ResetPasswordController.php
	 │   ├── Social
	 │   │   └── GithubController.php
	 │   └── VerificationController.php
	 ├── Controller.php
	 ├── HomeController.php
	 ├── MyController.php
	 ├── RatingController.php
	 ├── UserChapterController.php
	 └── UserController.php
		
	 Еще одно соглашение, расположение шаблонов. Шаблоны одного контроллера лучше группировать вместе, в одной директории. В примере выше, все шаблоны страниц расположены по пути resources/views/page. Это позволяет удобнее ориентироваться в шаблонах и избегать коллизий имен.

	Контроллеры, также, как и модели не нужно создавать руками. Их можно генерировать через artisan:
	 
	 $ php artisan make:controller PageController
	 Controller created successfully.
	 
	 А вот шаблоны и методы контроллера придется добавлять самостоятельно.
	 
	 
	 # Самостоятельная работа
	Перенесите обработчик about в контроллер PageController. Убедитесь что страница открывается.
	
	 # Дополнительные материалы
	 Controller https://laravel.com/docs/6.x/controllers
*/



/**@@@
	Реализуйте рейтинг статей. Он должен быть доступен по ссылке /rating. На этой странице нужно вывести опубликованные статьи отсортированные по количеству лайков.

	routes/web.php
Реализуйте маршрут /rating и свяжите его с index экшеном контроллера RatingController.

	app/Http/Controller/RatingController.php
Создайте контроллер и экшен index. Извлеките из базы все статьи и выполните нужные преобразования (взять только опубликованные, отсортировать их) над коллекцией перед ее передачей в шаблон.
	> Метод isPublished() у статьи позволяет узнать опубликована она или нет
	> Количество лайков можно узнать обратившись к свойству likes_count

	resources/views/rating/index.blade.php
	Выведите статьи в табличном виде. Для каждой статьи нужно вывести количество лайков и название.

	 
	 Подсказки
	 Коллекции возвращаемые Laravel из базы данных поддерживают интерфейс Collection
*/


// FILE: /app/Http/Controllers/RatingController.php
	 namespace App\Http\Controllers;
	 
	 use App\Article;
	 
	 class RatingController extends Controller
	 {
		  public function index()
		  {
				$articles = Article::all();
				// in real life sorting should be done by sql
				$articlesForRating = $articles->filter(function ($a) {
					 return $a->isPublished();
				})->sortByDesc('likes_count');
				
				return view('rating.index', ['articles' => $articlesForRating]);
		  }
	 }

	// FILE: resources/views/rating/index.blade.php
?>

	 @extends('layouts.app')

	 @section('content')
		  <h1>Рейтинг</h1>
		  <div>
				<table>
					 <thead>
					 <tr>
						  <td>Название</td>
						  <td>Число лайков</td>
					 </tr>
					 </thead>
					 <tbody>
						  @foreach($articles as $article)
								<tr>
									 <td>{{$article->name}}</td>
									 <td>{{$article->likes_count}}</td>
								</tr>
						  @endforeach
					 </tbody>
				</table>
		  <div>
	 @endsection
		
<?
	 
	 
	 // FILE: /routes/web.php
	 Route::get('/', function () {
		  return view('welcome');
	 });
		
	 Route::get('/rating', 'RatingController@index');

	 
	 
	 

	# >>>>>>>>>>>> Список (CRUD) <<<<<<<<<<< #
	
/**
	 Любой CRUD начинается со списка сущностей представленных, как правило, в табличном виде. Для его реализации нам понадобится добавить маршрут, создать контроллер, реализовать обработчик и вывести данные в шаблоне. Еще обязательно нужны тесты и мы их обязательно добавим, но потом, когда разберемся с фреймворком.
	 
	 Начнем с маршрута:
*/

	 // Название сущности в URL во множественном числе, контроллер в единственном
		  Route::get('/articles', 'ArticleController@index')
			  ->name('articles.index'); // имя маршрута, нужно для того чтобы не создавать ссылки руками


/**
	Следующий шаг, сгенерировать контроллер. Контроллер создается пустым. Методы и шаблоны для них нужно добавлять самостоятельно.

	$ php artisan make:controller ArticleController

	Теперь добавим содержимое:
*/
	 
	 namespace App\Http\Controllers;
	 
	 use App\Article;
	 
	 class ArticleController extends Controller
	 {
		  public function index()
		  {
				$articles = Article::paginate();
				
				// Статьи передаются в шаблон
				return view('article.index', compact('articles'));
		  }
	 }

/*
	 Первой строкой из базы извлекаются статьи с учетом запрошенной страницы. Laravel автоматически определяет наличие параметра page в запросе и выполняет правильное смещение в SQL. Количество элементов, которые выводятся на странице равно пятнадцати. Это число можно изменить передав нужное значение в метод paginate($perPage).

	Следующей строкой, вызывается шаблон, в который передается коллекция статей. Функция view($path, $params) вторым параметром принимает ассоциативный массив, который затем попадает в шаблон.

	Осталось добавить шаблон resources/views/article/index.blade.php:
*/
?>
@extends('layouts.app')

@section('content')
    <h1>Список статей</h1>
    @foreach($articles as $article)
        <h2>{{$article->name}}</h2>
        {{-- Str::limit – функция-хелпер, которая обрезает текст до указанной длины --}}
        {{-- Используется для очень длинных текстов, которые нужно сократить --}}
        <div>{{Str::limit($article->body, 200)}}</div>
    @endforeach
@endsection

<?

/*
	Массив параметров, которые были переданы в шаблон из контроллера, превращается в набор переменных. Именами становятся ключи, а содержимым значения этих ключей в массиве. В нашем примере это $articles. Обращаться к этим переменным можно двумя способами: либо в директивах напрямую, либо через интерполяцию {{}}. Последний вариант автоматически подставит вместо переменной ее значение.
	
	 Обход коллекции выполняется с помощью директивы @foreach, которая выглядит идентично foreach самого PHP.

	Последний элемент в шаблоне – вывод пейджинга. Эту часть тоже берет на себя Laravel. Для вывода достаточно вызвать метод links() у коллекции, которую вернул метод paginate.


	# Самостоятельная работа
	1. Выполните все шаги из теории.
	2. Убедитесь что при запросе страницы /articles у вас выводятся статьи, которые вы создали в Tinker ранее.
	3. Добавьте в общий макет меню, в котором есть ссылка на articles. Воспользуйтесь хелпером route https://laravel.com/docs/6.x/helpers#urls для генерации ссылки.

	# Дополнительные материалы
	Pagination https://laravel.com/docs/6.x/pagination
*/


/**@@@
	 routes/web.php
	 Реализуйте маршрут /article_categories и свяжите его с index экшеном контроллера ArticleCategoryController. Сделайте маршрут именованным.

	app/Http/Controller/ArticleCategoryController.php
	Создайте контроллер (используя artisan) и экшен index. Извлеките из базы все категории и передайте их в шаблон.

	resources/views/article_category/index.blade.php
	 Подключите макет
	 Выведите категории любым удобным способом. Для каждой категории нужно вывести ее название и описание.

	resources/views/layouts/app.blade.php
	Добавьте ссылку (через хелпер route) ведущую на страницу категорий.
*/


	// FILE: /app/Http/Controllers/ArticleCategoryController.php
	 
	 namespace App\Http\Controllers;
	 
	 use App\ArticleCategory;
	 
	 class ArticleCategoryController extends Controller
	 {
		  public function index()
		  {
				$articleCategories = ArticleCategory::all();
				
				return view('article_category.index', compact('articleCategories'));
		  }
	 }

	
	 // FILE: /resources/views/article_category/index.blade.php
?>

	 @extends('layouts.app')

	 @section('content')
		  <h1>Список категорий статей</h1>
		  @foreach($articleCategories as $category)
				<h2>{{$category->name}}</h2>
				<div>{{$category->description}}</div>
		  @endforeach
	 @endsection
		
<?
	 // FILE: /resources/views/layouts/app.blade.php
?>
<!doctype html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <div>
            <a href="{{ route('articles.index') }}">Статьи</a>
            <a href="{{ route('article_categories.index') }}">Категории статей</a>
        </div>
        <div>
            @yield('content')
        </div>
    </body>
</html>
<?

	// FILE: routes/web.php

	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
	 Route::get('/articles', 'ArticleController@index')
		  ->name('articles.index');

	 Route::get('/article_categories', 'ArticleCategoryController@index')
		  ->name('article_categories.index');


	 
	 
	# >>>>>>>>>>>> Просмотр (CRUD) <<<<<<<<<<< #
	
/**
	После того как список готов, можно переходить к просмотру каждого элемента. Как обычно начинаем с роутинга:
*/

	# id – параметр, который зависит от конкретной статьи
	# Фигурные скобки нужны для описания параметров маршрута
	 Route::get('/articles/{id}', 'ArticleController@show')
		->name('articles.show');

	 
/**
	В этом месте у маршрута появляется динамическая часть, идентификатор статьи. Подобный маршрут обрабатывает все страницы, имеющие вид /articles/<идентификатор статьи>, пара примеров:
	 /articles/1
	 /articles/100
	 /articles/what-is-js

	 Этот идентификатор используется в обработчике, для выборки из базы нужной статьи.
*/

	 namespace App\Http\Controllers;

	 use App\Article;
	 
	 class ArticleController extends Controller
	 {
		  // ... другие обработчики
	 
		  public function show($id)
		  {
				$article = Article::findOrFail($id);
				
				return view('article.show', compact('article'));
		  }
	 }

/**
	Параметр id определенный в маршруте, приходит в обработчик как аргумент. Имя этого аргумента может быть любым, для Laravel имеет значение только порядок. Если параметров в маршруте больше одного, то они передадутся в обработчик в том же порядке, в котором они определены в маршруте:
*/

	Route::get('/articles/{commentId}/comments/{id}', function ($commentId, $id) {
    // ...
});

/**
	 Затем, происходит выборка статьи из базы данных. Для нее используется метод findOrFail, а не find. Почему? Дело в том, что, в большинстве случаев, просмотр конкретной сущности должен вернуть ошибку 404 если самой сущности не существует. Метод find никак не помогает обработать эту ситуацию, он возвращает null. Дальше программисту придется делать проверку на существование и самому формировать правильный HTTP ответ. Но, так как, задача очень частая, то разработчики Laravel решили ее внутри фреймворка. С одной стороны они добавили метод findOrFail, который выбрасывает исключение в случае отсутствия записи. С другой, добавили специальную обработку данных исключений на уровне обработки запросов.
	 
	 И последний шаг, передача статьи в шаблон. Здесь ничего нового.

	Шаблон:
*/
?>
	 @extends('layouts.app')

	 @section('content')
		  <h1>{{$article->name}}</h1>
		  <div>{{$article->body}}</div>
	 @endsection
<?

/**
	Самостоятельная работа
	 1. Выполните все шаги из теории.
	 2. Убедитесь что при запросе страницы /articles/<идентификатор> у вас выводится конкретная статья.
	 3. Сделайте имя статьи в списке статей ссылкой на конкретную статью.
*/


/**@@@
	В этом упражнении нужное реализовать страницу категории, на которой выводится список статей этой категории.

	routes/web.php
	Реализуйте маршрут /article_categories/{id} и свяжите его с show экшеном контроллера ArticleCategoryController. Сделайте маршрут именованным.

	app/Http/Controller/ArticleCategoryController.php
	Создайте экшен show.
	Извлеките из базы текущую запрошенную категорию и выведите информацию о ней на странице.
	Выведите список статей этой категории. Имя каждой статьи должно быть ссылкой на саму статью (маршрут подсмотрите в файле роутов).
	
	Список статей категории можно получить так: $category->articles

	resources/views/article_category/show.blade.php
	Подключите макет
	Выведите имя и описание категории
	Выведите список названий статей в виде <ol> списка. Если статей в категории нет, то тег <ol> не должен отображаться. Каждое название – ссылка на саму статью.

	Проверка коллекции на пустоту: $category->articles->isEmpty()

	resources/views/article/show.blade.php
	Добавьте ссылку на категорию статьи рядом с именем статьи
*/

	 // FILE: app/Http/Controllers/ArticleCategoryController.php
	 namespace App\Http\Controllers;
	 
	 use App\ArticleCategory;
	 
	 class ArticleCategoryController extends Controller
	 {
		  public function index()
		  {
				$articleCategories = ArticleCategory::all();
				
				return view('article_category.index', compact('articleCategories'));
		  }
		  
		  public function show($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				
				return view('article_category.show', compact('category'));
		  }
	 }

    
    // FILE: /resources/views/article/show.blade.php
?>
	<h1>{{$article->name}}</h1>
    
    <small>
        <a href="{{route('article_categories.show', $article->category)}}">
            {{ $article->category }}
        </a>
    </small>
    
    <div>{{$article->body}}</div>
<?
	 
	 // FILE: /resources/views/article_category/show.blade.php
?>
		
	 @extends('layouts.app')
	 
	 @section('content')
		  <h1>{{$category->name}}</h1>
		  <div>{{$category->description}}</div>
	 
		  @if(!$category->articles->isEmpty())
				<h2>Статьи</h2>
				<ol>
					 @foreach($category->articles as $article)
						  <li>
								<a href="{{ route('articles.show', $article) }}">{{$article->name}}</a>
						  </li>
					 @endforeach
				</ol>
		  @endif
	 @endsection
		
<?
	 
	 // FILE: /routes/web.php
	 Route::get('/', function () {
	 	 return view('welcome');
	});

	 Route::get('/articles', 'ArticleController@index')
		  ->name('articles.index');
	 
	 Route::get('/articles/{id}', 'ArticleController@show')
		  ->name('articles.show');
	 
	 Route::get('/article_categories', 'ArticleCategoryController@index')
		  ->name('article_categories.index');
	 
	 Route::get('/article_categories/{id}', 'ArticleCategoryController@show')
	 	 ->name('article_categories.show');




	# >>>>>>>>>>>> Просмотр (CRUD) <<<<<<<<<<< #
	
/**
	Для реализации создания и обновления сущности в CRUD, нужно научиться правильно работать с формами. Создавать формы самостоятельно, очень утомительное занятие. Сотни строк одинакового кода, обработка ошибок, защита от атак, все это придется делать снова и снова.
	
	Обычно фреймворки имеют встроенную поддержку генерации форм, которая состоит из набора функций, автоматизирующих рутину. В Laravel так было изначально, но затем формы выделели в отдельный компонент laravelcollective/html. В самом Laravel осталось буквально несколько элементов: защита от CSRF и поддержка дополнительных методов HTTP в HTML формах.
*/

	#@ LaravelCollective/HTML
	
/**
	Для установки этого компонента выполните эту команду:
	
	$ composer require "laravelcollective/html"
	
	Затем внесите два исправления в файл config/app.php
	
	1. Добавьте новый провайдер в список провайдеров
	
	'providers' => [
		  // ...
		  Collective\Html\HtmlServiceProvider::class,
		  // ...
  	],
	
	2. Добавьте два алиаса в список алиасов:
	
	'aliases' => [
		// ...
		'Form' => Collective\Html\FormFacade::class,
		'Html' => Collective\Html\HtmlFacade::class,
		// ...
	],
*/


	#@ Библиотечные функции

/**
	Эта библиотека включает в себя несколько десятков статических методов, формирующих различные элементы. Вот несколько примеров:
*/
	 
	 
	 // Не забудьте открыть Tinker и попробовать поэкспериментировать с этими функциями
	 
	 echo Form::submit('Click Me!');
	 // <input type="submit" value="Click Me!">
	 
	 echo Form::radio('category_id', 1);
	 // <input name="category_id" type="radio" value="1">
	 
	 echo Form::select('size', ['L' => 'Large', 'S' => 'Small']);
	 // <select name="size">
	 //     <option value="L">Large</option>
	 //     <option value="S">Small</option>
	 // </select>
	 
	 // Остальные элементы можно подсмотреть в официальной документации

/*
	Особняком стоит генерация самого тега формы. Из-за того что этот тег оборачивает все остальные элементы формы, он состоит из двух методов: один открывает форму, другой – закрывает:
*/

	 // По умолчанию, форме проставляется метод _POST_, но его можно изменить на любой другой:
	 // В поисковых формах нужен GET
	 {{Form::open(['url' => route('articles.index'), 'method' => 'GET'])}}
		  {{Form::text('username')}}
		  {{Form::submit('Click Me!')}}
	 {{Form::close()}}

	 # <form method="POST" action="http://localhost/foo/bar" accept-charset="UTF-8"><input name="_token" type="hidden">
	 # </form>

/**
	 Наиболее интересная возможность в этом пакете – интеграция с ORM. В таком случае, форма берет на себя часть задач по обработке формы. Для этого вместо метода open используется метод model. Первым параметром в него передается тот объект, форма которого строится.
*/

	{{ Form::model($user, ['url' => route('users.store')]) }}
    {{ Form::label('name', 'Имя') }}
    {{ Form::text('name') }}
    {{ Form::label('email', 'Email') }}
    {{ Form::email('email') }}
    {{ Form::submit('Создать') }}
	{{ Form::close() }}


/**
	 Разница в том, что эта форма самостоятельно извлекает из объекта значения свойств и подставляет их в форму. Это полезно при редактировании или при выводе ошибок, когда не удалось выполнить нужное действие. В следующем уроке мы воспользуемся именно таким подходом, он значительно экономит время.
*/

	#@ Данные формы
	
/**
	Любую информацию о HTTP-запросе, включая данные формы, можно получить из объекта $request. Laravel передает его в те экшены, которые явно указывают его в параметрах:
*/
	 
	 namespace App\Http\Controllers;
	 
	 // Нужно импортировать класс и указывать его в экшене
	 use Illuminate\Http\Request;
	 
	 class ArticleController extends Controller
	 {
		  public function index(Request $request)
		  {
				// Возвращает весь пользовательский ввод как из тела запроса (отправка форм)
				// так и из параметров запроса (query string)
				$input = $request->input();
				$value = $request->input('key'); // возврат значения по указанному ключу
				$value2 = $request->input('key2', 'default value'); // принимает значение по умолчанию
		  }
	 }

/**
	При реализации поисковых форм, данные формы должны оставаться внутри формы после запроса. Мы это наблюдаем повсеместно, особенно в поисковых системах. Для реализации такого поведения нужно выполнить два условия. Первое, передать данные в шаблон. Второе, подставить их в нужные места. Для этого, элементы библиотеки генерации формы принимают дополнительный параметр:
*/
?>
		  {{Form::open(['url' => route('articles.index'), 'method' => 'GET'])}}
		  {{-- Имя пользователя передано из экшена --}}
		  {{Form::text('username', $username)}}
		  {{Form::submit('Click Me!')}}
		  {{Form::close()}}
				
<?
/*
	# Самостоятельная работа
	1. Установите и настройте пакет
	2. Убедитесь через Tinker что пакет работает

	# Дополнительные материалы
	Документация https://laravelcollective.com/docs/6.0/html
*/


/**@@@

	 В этом упражнении нужное реализовать поисковую форму, которая позволяет отфильтровать статьи по слову, встречающемуся в названии статьи. Форма состоит из двух элементов: текстового поля (имя поля q, это важно для тестов) и кнопки "найти". Она ведет на тот же маршрут, который выводит список всех статей.

	app/Http/Controller/ArticleController.php
	 Реализуйте экшен index. Если клиент прислал запрос из формы, выполните необходимую фильтрацию данных через правильный запрос в базу данных.

	resources/views/article/show.blade.php
	Выведите форму. Убедитесь что она работает.
	Реализуйте подстановку данных в форму после запроса.

	Подсказки
	Поисковые формы отправляются методом GET.
	Для простой фильтрации (когда данных немного), подойдет Like-запрос.
	Выполняется он так: Article::where('name', 'ilike' "%{$q}%"). Где $q – это запрос из формы.
*/


	// FILE: /app/Http/Controllers/ArticleController.php
	 namespace App\Http\Controllers;
	 
	 use Illuminate\Http\Request;
	 use App\Article;
	 
	 class ArticleController extends Controller
	 {
		  public function index(Request $request)
		  {
				$q = $request->input('q');
				// Like has huge impact on the performance. Use them carefully. Learn indexes and full text search.
				$articles = $q ? Article::where('name', 'ilike', "%{$q}%")->paginate() : Article::paginate();
				
				return view('article.index', compact('articles', 'q'));
		  }
		  
		  public function show($id)
		  {
				$article = Article::findOrFail($id);
				
				return view('article.show', compact('article'));
		  }
	 }
	 
	 
	 
	 // FILE: /resources/views/article/index.blade.php
?>
	 @extends('layouts.app')

	 @section('content')
		  {{Form::open(['url' => route('articles.index'), 'method' => 'get'])}}
		  {{Form::text('q', $q)}}
		  {{Form::submit('Search')}}
		  {{Form::close()}}
		  <h1>Список статей</h1>
		  @foreach($articles as $article)
				<h2>{{$article->name}}</h2>
				<div>{{Str::limit($article->body, 200)}}</div>
		  @endforeach
	 @endsection

<?


	# >>>>>>>>>>>> Создание (CRUD) <<<<<<<<<<< #
	
/**
	Создание сущности в CRUD требует наличия двух маршрутов: один для отображения формы, другой для обработки формы. Кроме того, важно понимать как взаимодействуют между собой эти маршруты, как обрабатываются ошибки и так далее. Начнем с того что у нас есть три состояния:
	
	> Отображение новой формы
	> Отображение формы с подсвеченными ошибками валидации после ее отправки
	> Редирект на какую-то страницу (обычно это редактирование сущности или список сущностей) после успешной обработки формы
	
	
	Самое интересное здесь – вторая часть. Когда данные формы приходят в обработчик формы (пользователь нажал кнопку отправки), этот обработчик выполняет "валидацию", то есть проверку введенных данных. Например проверяет что данные в принципе есть, то есть они не пустые. Если данные корректные, то обработка завершается и пользователя отправляют в другое место, но если нет, то Laravel должен отработать эту ситуацию по особенному.
	
	С точки зрения пользователя, это выглядит просто. Сайт снова отображает форму с подставленными значениями, которые он ввел раньше. Кроме этого, на странице выводятся возникшие ошибки. Дальше пользователь их исправляет и отправляет форму заново. Этот процесс может повторяться много раз перед тем как пользователь сделает все правильно.
	
	
	Технически, Laravel ведет себя так. Если пользователь ввел что-то некорректно, то происходит редирект на страницу с формой. Laravel автоматически записывает данные формы в сессию и, затем, использует эти данные для подстановки в форму (тут участвует Form::model).
*/

	#@ Форма


	// Как обычно нам придется добавить три вещи: маршрут, обработчик маршрута, шаблон.
	Route::get('/articles/create', 'ArticleController@create')
		  ->name('articles.create');
	
	// Важно добавить этот маршрут до маршрута /articles/{id}. Иначе последний перехватит обращение к /articles/create, так как он соответствует шаблону.
	
	
	#@ Обработчик
	
	namespace App\Http\Controllers;

	 use App\Article;
	 
	 class ArticleController extends Controller
	 {
		  // Вывод формы
		  public function create()
		  {
				// Передаем в шаблон вновь созданный объект. Он нужен для вывода формы через Form::model
				$article = new Article();
				return view('article.create', compact('article'));
		  }
	 }
		
	
	 #@ Шаблон
?>

	 {{ Form::model($article, ['url' => route('articles.store')]) }}
		  {{ Form::label('name', 'Название') }}
		  {{ Form::text('name') }}<br>
		  {{ Form::label('body', 'Содержание') }}
		  {{ Form::textarea('body') }}<br>
		  {{ Form::submit('Создать') }}
	 {{ Form::close() }}
<?

	#@ Обработчик данных формы
	#@ Маршрут
	
	// POST запрос
	 Route::post('/articles', 'ArticleController@store')
			->name('articles.store');
	
	 

	 #@ Обработчик
	 
	 namespace App\Http\Controllers;
	 
	 use App\Article;
	 // Нам понадобится объект запроса
	 use Illuminate\Http\Request;
	 
	 class ArticleController extends Controller
	 {
		  // Здесь нам понадобится объект запроса, для извлечения данных
		  public function store(Request $request)
		  {
				// Проверка введенных данных
				// Если будут ошибки, то возникнет исключение
				$this->validate($request, [
					 'name' => 'required|unique:articles',
					 'body' => 'required|min:1000',
				]);
	 
				$article = new Article();
				// Заполнение статьи данными из формы
				$article->fill($request->all());
				// При ошибках сохранения возникнет исключение
				$article->save();
	 
				// Редирект на указанный маршрут с добавлением флеш сообщения
				return redirect()
					 ->route('articles.index');
		  }
	 }
	 
/**
	Это первый обработчик, в котором нам понадобился доступ к объекту запроса. Любая информация о HTTP-запросе, любые данные отправленные по HTTP можно получить только через $request.
	 
	 Как и ранее тут может возникнуть вопрос, каким образом Laravel понимает что в этот метод надо передать объект запроса, а в другие ничего передавать не надо. Ответ кроется в метапрограммировании, которое в PHP делается через Reflection API. Это большая тема, которая разбирается в отдельном курсе
	 
	 Первым делом объект $request используется в валидации. Валидация в Laravel привязана к запросу. Она выполняется с помощью метода validate($request, $params), доступного в каждом контроллере. Второй аргумент в этом методе – массив, в котором ключ это название поля из формы, а значение, это набор "валидаторов", правил, которые применяются к значению для проверки его корректности. Валидаторы отделяются друг от друга вертикальной чертой. Вот что они означают:
	 
	> required – не может быть пустым
	> min:1000 – минимум 1000 символов
	> unique:articles – поле (name) должно быть уникально в таблице articles
	 
	 Метод validate ничего не делает если с данными все в порядке и выбрасывает исключение в случае ошибок. Затем Laravel перехватывает это исключение и выполняет всю остальную работу за нас. Он сохраняет данные формы, делает редирект на страницу отображения формы и формирует переменную $errors доступную в шаблоне. Самый простой способ вывести ошибки, добавить над формой такой код:
*/
?>
	@if ($errors->any())
		  <div>
				<ul>
					 @foreach ($errors->all() as $error)
						  <li>{{ $error }}</li>
					 @endforeach
				</ul>
		  </div>
	@endif
	
<?
	
	 // Вернемся к нашему обработчику. Сразу после валидации выполняется создание сущности, наполнение ее данными формы и сохранение.
	 
	 $article = new Article();
	 $article->fill($request->all());
	 $article->save();

/**
	Метод all() возвращает все данные формы, а метод fill($params) выполняет, так называемый mass-assignment, то есть установку сразу всех значений через передачу ассоциативного массива. Такой способ удобнее чем копировать каждое значение индивидуально:
*/

	$article->name = $request->input('name');
	$article->body = $request->input('body');

/**
	* Но mass-assignment обладает одним недостатком, который приходится обрабатывать отдельно. Такой способ установки значений опасен, так как пользователь может послать любые данные, включая те, которых нет в форме (это HTTP, пользователь может отправить все что угодно). Это значит что пользователь может переписать любые данные, включая пароли, идентификаторы и все что угодно, до чего он, по идее, не должен иметь доступ.

	Разные фреймворки обрабатывают эту ситуацию по разному. Laravel предлагает создавать внутри модели массив, в котором перечисляются поля, доступные для mass-assignment. Все что там не перечислено будет игнорироваться:
*/

	 namespace App;
	 
	 use Illuminate\Database\Eloquent\Model;
	 
	 class Article extends Model
	 {
		  protected $fillable = ['name', 'body'];
	 }
	 
	 
	 
	 // Это легко проверить в Tinker:
		
		
		
/**
	 >>> $article = new Article();
	 => App\Article {#3033}
		
	 >>> $article->fill(['name' => 'supername', 'wrongfield' => 'boom!']);
	 => App\Article {#3033
	  name: "supername",
	 }
		
		
	После того как объект сохранился в базе данных, осталось перенаправить пользователя в то место, куда мы хотим его отправить после успешного создания. Обычно отправка идет на список сущностей или страницу редактирования.
 
 	Обратите внимание, что у обработчика данных формы нет своего шаблона. Он в любом случае выполняет редирект: либо на исходную форму, либо на результирующую.
*/

	// Не забудьте сделать return
	 return redirect()
		  ->route('articles.index');

/**
	 # Дополнительные материалы
	 Валидаторы https://laravel.com/docs/6.x/validation
	 Flash-сообщения https://laravel.com/docs/6.x/session#flash-data
*/



/**@@@
	 routes/web.php
	 Добавьте маршруты для создания категории
	 
	 exercise/resources/views/article_category/index.blade.php
	 Добавьте ссылку на создание категории
	 
	 app/Http/Controller/ArticleCategoryController.php
	 Реализуйте экшены для создания категории. Добавьте следующие валидации:
	 	Имя (name) – обязательно
	 	Описание (description) – обязательно и должно быть минимум 200 знаков
	 	Состояние (state) – может быть либо draft либо published
  
	resources/views/article_category/create.blade.php
	Реализуйте форму создания категории. Добавьте три поля:
	 	Имя
	 	Описание
	 	Состояние
	 	Добавьте вывод ошибок
*/


	// FILE: app/Http/Controllers/ArticleCategoryController.php
    namespace App\Http\Controllers;
	 
	 use Illuminate\Validation\Rule;
	 use Illuminate\Http\Request;
	 use App\ArticleCategory;
	 
	 class ArticleCategoryController extends Controller
	 {
		  public function index()
		  {
				$articleCategories = ArticleCategory::orderBy('id', 'desc')->get();
				
				return view('article_category.index', compact('articleCategories'));
		  }
	 
		  public function show($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				return view('article_category.show', compact('category'));
		  }
		  
		  public function create()
		  {
				$category = new ArticleCategory();
				
				return view('article_category.create', compact('category'));
		  }
	 
		  public function store(Request $request)
		  {
				$this->validate($request, [
					 'name' => 'required|unique:article_categories',
					 'description' => 'required|min:200',
					 'state' => [
						  'required',
						  Rule::in(['draft', 'published']),
					 ]
				]);
	 
				$category = new ArticleCategory();
				$category->fill($request->all());
				$category->save();
	 
				return redirect()
					 ->route('article_categories.index');
		  }
	 }
    
    
    // FILE: /resources/views/article_category/create.blade.php
?>
	 @extends('layouts.app')
	 
	 @section('content')
		  
		  @if ($errors->any())
				<div>
					 <ul>
						  @foreach ($errors->all() as $error)
								<li>{{ $error }}</li>
						  @endforeach
					 </ul>
				</div>
		  @endif
		  
		  {{ Form::model($category, ['url' => route('article_categories.store')]) }}
				{{ Form::label('name', 'Название') }}
				{{ Form::text('name') }}<br>
				{{ Form::label('description', 'Описание') }}
				{{ Form::textarea('description') }}<br>
				{{ Form::select('state', ['draft' => 'Черновик', 'published' => 'Опубликован']) }}<br>
				{{ Form::submit('Создать') }}
		  {{ Form::close() }}
		  
	 @endsection
    
<?
	 
	 // FILE: /resources/views/article_category/index.blade.php
?>
	 <small><a href="{{ route('article_categories.create') }}">Создать категорию</a></small>
	 
<?
	 // FILE: /routes/web.php
	 
	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
	 Route::get('/articles', 'ArticleController@index')
		  ->name('articles.index');
	 
	 Route::get('/articles/{id}', 'ArticleController@show')
		  ->name('articles.show');
	 
	 Route::get('/article_categories/create', 'ArticleCategoryController@create')
		->name('article_categories.create');
	 
	 Route::post('/article_categories', 'ArticleCategoryController@store')
		->name('article_categories.store');
	 
	 Route::get('/article_categories', 'ArticleCategoryController@index')
		  ->name('article_categories.index');
	 
	 Route::get('/article_categories/{id}', 'ArticleCategoryController@show')
		  ->name('article_categories.show');

	 
// FILE: /tests/CreatesApplication.php

	 namespace Tests;

	 use Illuminate\Contracts\Console\Kernel;
	 
	 trait CreatesApplication
	 {
		  /**
			* Creates the application.
			*
			* @return \Illuminate\Foundation\Application
			*/
		  public function createApplication()
		  {
				$app = require __DIR__.'/../bootstrap/app.php';
	 
				$app->make(Kernel::class)->bootstrap();
	 
				return $app;
		  }
	 }


	// FILE: /tests/TestCase.php
		
	 namespace Tests;
	 
	 use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
	 
	 abstract class TestCase extends BaseTestCase
	 {
		  use CreatesApplication;
	 
		  protected function setUp() : void
		  {
				parent::setUp();
				$this->withoutExceptionHandling();
		  }
	 }



	// FILE: /tests/Feature/ArticleCategoryControllerTest.php
	 
	 namespace Tests\Feature;
	 
	 use Illuminate\Foundation\Testing\RefreshDatabase;
	 use Tests\TestCase;
	 
	 class ArticleCategoryControllerTest extends TestCase
	 {
		  use RefreshDatabase;
	 
		  public function testIndex()
		  {
				factory(\App\Article::class, 10)->create();
				$response = $this->get(route('article_categories.index'));
				$response->assertStatus(200);
		  }
	 
		  public function testCreate()
		  {
				$response = $this->get(route('article_categories.create'));
				$response->assertStatus(200);
		  }
	 
		  public function testStoreWithValidationErrors()
		  {
				$this->expectException(\Illuminate\Validation\ValidationException::class);
				$params = [
					 'description' => 'b',
					 'state' => 'draft'
				];
				$this->post(route('article_categories.store'), $params);
		  }
	 
		  public function testStore()
		  {
				$params = [
					 'name' => 'jopa',
					 'description' => str_repeat('lala', 50),
					 'state' => 'draft'
				];
				$response = $this->post(route('article_categories.store'), $params);
				$response->assertStatus(302);
	 
				$this->assertDatabaseHas('article_categories', [
					 'name' => 'jopa'
				]);
		  }
	 }



	# >>>>>>>>>>>> Обновление (CRUD) <<<<<<<<<<< #
	
/**
	Обновление очень похоже на создание, с той лишь разницей, что мы не создаем сущность с нуля, а извлекаем ее из базы. Остальное практически без изменений.

	 За скобками остается важный вопрос: права на изменение. Изменять что-то на сайте, обычно, может только автор, тот кто создал сущность. Механизм который отвечает за выдачу и проверку прав, называется авторизацией (не путать с аутентификацией). В Laravel авторизация встроена. Она не рассматривается в курсе, но про нее можно прочитать самостоятельно в документации.
*/

	#@ Форма
	#@ Маршрут
	
	Route::get('/articles/{id}/edit', 'ArticleController@edit')
  			->name('articles.edit');
	
	
	#@ Обработчик
	
	use App\Article;
	
	public function edit($id)
	{
		$article = Article::findOrFail($id);
		return view('article.edit', compact('article'));
	}
	
	
	#@ Шаблон
		
/**
	 Шаблон редактирования практически один в один повторяет шаблон создания. Разными у них бывают только отдельные элементы, например текст кнопки отправки формы. Для таких случаев используют директиву @include($pathToTemplate), которая позволяет извлекать общие куски шаблонов в отдельные шаблоны и включать их там где нужно.
	 
	 Создайте в директории resources/views/article шаблон form.blade.php.
*/
?>

	 @if ($errors->any())
		  <div>
				<ul>
					 @foreach ($errors->all() as $error)
						  <li>{{ $error }}</li>
					 @endforeach
				</ul>
		  </div>
	 @endif
	 
	 {{ Form::label('name', 'Название') }}
	 {{ Form::text('name') }}<br>
	 {{ Form::label('body', 'Содержание') }}
	 {{ Form::textarea('body') }}<br>

<?
	// Теперь включите его в create.blade.php:
?>

	 {{ Form::model($article, ['url' => route('articles.store')]) }}
	 @include('article.form')
	 {{ Form::submit('Сохранить') }}
	 {{ Form::close() }}
	
<?
	// И практически тоже самое надо добавить в edit.blade.php. Создайте этот файл и вставьте в него код:
?>
		
	 {{ Form::model($article, ['url' => route('articles.update', $article), 'method' => 'PATCH']) }}
	 @include('article.form')
	 {{ Form::submit('Обновить') }}
	 {{ Form::close() }}
	
<?
/**
	 Основных изменений здесь три:
	 > Другое имя кнопки
	 > Метод отправки PATCH, так как происходит обновление
	 > Адрес формы указывает на конкретную статью
*/
	#@ Обработчик формы
	#@ Маршрут
	
	// Метод PATCH
	 Route::patch('/articles/{id}', 'ArticleController@update')
		->name('articles.update');
	
	 
	 #@ Обработчик
	 use Illuminate\Http\Request;
	 use App\Article
	 
	 public function update(Request $request, $id)
	 {
		  $article = Article::findOrFail($id);
		  $this->validate($request, [
				// У обновления немного измененная валидация. В проверку уникальности добавляется название поля и id текущего объекта
				// Если этого не сделать, Laravel будет ругаться на то что имя уже существует
				'name' => 'required|unique:articles,name,' . $article->id,
				'body' => 'required|min:100',
		  ]);
	 
		  $article->fill($request->all());
		  $article->save();
		  
		  return redirect()
				->route('articles.index');
	 }
	 
/**
	Обработчик обновляющий сущность практически идентичен созданию сущности. Разница кроется в нескольких деталях. Во-первых мы работаем с существующей статьей, поэтому ее нужно извлечь из базы данных. Во-вторых, валидация на уникальность должна учитывать текущую статью при проверке. Иначе валидатор будет ругаться, что такое имя уже есть в базе данных.
	 
	 Можно заметить, что валидации повторяются практически один в один. Так происходит в подавляющем большинстве случаев. Те правила которые применяются к сущности при создании, должны применяться к ней и во время редактирования. При текущем подходе возникает дублирование, которого хотелось бы избежать. Это можно сделать с помощью Form Request.
	 
	 В остальном все тоже самое: объект заполняется значениями из формы, далее сохранение и редирект на список статей.
*/



/**@@@
	 routes/web.php
	 Добавьте маршруты для редактирования категории
	 
	 app/Http/Controller/ArticleCategoryController.php
	 Реализуйте экшены для редактирования категории. Добавьте валидации аналогичные тем что были при создании.
	 
	 resources/views/article_category/edit.blade.php
	 Реализуйте форму редактирования категории.
	 
	 resources/views/article_category/form.blade.php
	 Вынесите сюда общие части для create и edit форм
*/


	// FILE: /app/Http/Controllers/ArticleCategoryController.php
	 
	 namespace App\Http\Controllers;
	 
	 use Illuminate\Validation\Rule;
	 use Illuminate\Http\Request;
	 use App\ArticleCategory;
	 
	 class ArticleCategoryController extends Controller
	 {
		  public function index()
		  {
				$articleCategories = ArticleCategory::orderBy('id', 'desc')->get();
				return view('article_category.index', compact('articleCategories'));
		  }
	 
		  public function show($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				return view('article_category.show', compact('category'));
		  }
		  
		  public function edit($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				return view('article_category.edit', compact('category'));
		  }
	 
		  public function update(Request $request, $id)
		  {
				$category = ArticleCategory::findOrFail($id);
				$this->validate($request, [
					 'name' => 'required|unique:article_categories,name,' . $category->id,
					 'description' => 'required|min:200',
					 'state' => [
						  'required',
						  Rule::in(['draft', 'published']),
					 ]
				]);
	 
				$category->fill($request->all());
				$category->save();
				return redirect()
					 ->route('article_categories.index');
		  }
		  // END
	 
		  public function create()
		  {
				$category = new ArticleCategory();
				return view('article_category.create', compact('category'));
		  }
	 
		  public function store(Request $request)
		  {
				$this->validate($request, [
					 'name' => 'required|unique:article_categories',
					 'description' => 'required|min:200',
					 'state' => [
						  'required',
						  Rule::in(['draft', 'published']),
					 ]
				]);
	 
				$category = new ArticleCategory();
				$category->fill($request->all());
				$category->save();
	 
				return redirect()
					 ->route('article_categories.index');
		  }
	 }
    
    
	// FILE: /resources/views/article_category/edit.blade.php
?>
	 @extends('layouts.app')

	 @section('content')
		  @if ($errors->any())
				<div>
					 <ul>
						  @foreach ($errors->all() as $error)
								<li>{{ $error }}</li>
						  @endforeach
					 </ul>
				</div>
		  @endif
		  
		  {{ Form::model($category, ['method' => 'PATCH', 'url' => route('article_categories.update', $category)]) }}
				@include('article_category.form')
				{{ Form::submit('Обновить') }}
		  {{ Form::close() }}
	 @endsection
    
    
<?
	// FILE: /resources/views/article_category/form.blade.php
?>
	 {{ Form::label('name', 'Название') }}
	 {{ Form::text('name') }}<br>
	 {{ Form::label('description', 'Описание') }}
	 {{ Form::textarea('description') }}<br>
	 {{ Form::select('state', ['draft' => 'Черновик', 'published' => 'Опубликован']) }}<br>
<?


	 // FILE: /routes/web.php
	 
	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
	 Route::get('/articles', 'ArticleController@index')
		  ->name('articles.index');
	 
	 Route::get('/articles/{id}', 'ArticleController@show')
		  ->name('articles.show');
	 
	 Route::get('/article_categories/create', 'ArticleCategoryController@create')
		  ->name('article_categories.create');
	 
	 Route::post('/article_categories', 'ArticleCategoryController@store')
		  ->name('article_categories.store');
	 
	 Route::get('/article_categories/{id}/edit', 'ArticleCategoryController@edit')
		  ->name('article_categories.edit');
		  
	 Route::patch('/article_categories/{id}', 'ArticleCategoryController@update')
		  ->name('article_categories.update');
	 
	 
	 Route::get('/article_categories', 'ArticleCategoryController@index')
		  ->name('article_categories.index');
	 
	 Route::get('/article_categories/{id}', 'ArticleCategoryController@show')
		  ->name('article_categories.show');



	 
	# >>>>>>>>>>>> Удаление (CRUD) <<<<<<<<<<< #

/**
	Удаление – самое простое действие в обычном CRUD. Ему не нужен шаблон, все удаление состоит из простого обработчика, в котором даже нет условных конструкций.
	 
	 Маршрут:
*/

	Route::delete('/articles/{id}', 'ArticleController@destroy')
  		->name('articles.destroy');
	
	
	#@ Обработчик:
	 
	 // Не забывайте про авторизацию (здесь не рассматривается)
	 // Удаление должно быть доступно только тем, кто может его выполнять
		
	 public function destroy($id)
	 {
		  // DELETE идемпотентный метод, поэтому результат операции всегда один и тот же
		  $article = Article::find($id);
		  if ($article) {
			 $article->delete();
		  }
		  return redirect()->route('articles.index');
	 }
		
		
/**
	Самое интересное в удаление – это ссылка или кнопка удаления. Она не может быть обычной ссылкой. Почему? Потому что, с точки зрения HTTP, удаление это DELETE запрос. Эту семантику важно соблюдать, так как на нее ориентируются разные инструменты и поисковики при анализе страниц. Если сделать удаление обычной ссылкой, то любой автоматический инструмент может попробовать перейти по ней (например предзагрузка страниц в chrome). Это будет крайне неприятный сюрприз.
	
	Как минимум для разрешения подобных ситуаций нужно использовать аттрибут rel:
	<a href="..." rel="nofollow">Удалить</a>
	
	Но этого недостаточно для отправки DELETE запроса. Правильно реализовать эту ссылку формой, которая не отправляет никаких данных, но шлет верный запрос. В принципе так и можно поступить, но возникает странная ситуация. Само удаление содержит меньше кода чем кнопка по удалению. Да и шаблоны становятся очень грязными.
		
		Избежать ручного создания такой формы можно с помощью библиотеки jquery-ujs, которая изначально была написана для Rails, но не ограничина этим фреймворком. Эта библиотека написана на js и подключается во фронтенд части. Она опирается на дата-атрибуты и сама превращает в форму все что ее попросят. Для ее установки, наберите в директории проекта:
		
	 # Убедитесь в том что у вас установлена Node.js
	 $ npm install jquery-ujs
	 # Для установки остальных пакетов
	 $ npm install

	Затем добавьте в файл resources/js/app.js строчку:
	
	// После строчки require('./bootstrap');
	require('jquery-ujs');
	
	
	И запустите сборку фронтенда:
	$ npm run watch
	
	Теперь попробуем использовать эту библиотеку:
	<a href="..." data-method="delete" rel="nofollow">Удалить</a>
	
	Библиотека подключенная к странице, проанализирует все ссылки с нужными дата-атрибутами и превратит их в формы отправляющие указанные запросы. Эти запросы могут быть любыми, хоть DELETE, хоть PATCH.
	
	Кроме того, с ее помощью можно блокировать кнопки и вызывать подтверждение:

	<a href="..." data-confirm="Вы уверены?" data-method="delete" rel="nofollow">Удалить</a>
	
	<input type="submit" value="Сохранить" data-disable-with="Сохраняем">
*/


	#@ Зависимости

/**
	В реальной жизни удаление не такая простая операция. Обычно сущности не существут сами по себе, у них есть зависимости. Например у статьи есть комментарии, а у курса есть уроки. Как должна вести себя система при удалении родительской сущности? Что делать с зависимостями?
	 
	 Ответ будет разный для разных проектов и разных сущностей. Иногда нужно все удалить, иногда разорвать связи. В более сложных ситуациях удалять нельзя вообще и тогда используется "мягкое удаление". При таком подходе сущность просто помечается как удаленная и не выводится на сайте, но всегда есть возможность ее восстановить.
	 
	 # Дополнительные материалы
	 Работа с фронтендом в Laravel https://laravel.com/docs/6.x/mix
	 Мягкое удаление https://laravel.com/docs/6.x/eloquent#soft-deleting
*/



/**@@@
	 routes/web.php
	 Добавьте маршрут для удаления категории
	 
	 app/Http/Controller/ArticleCategoryController.php
	 Реализуйте экшен для удаления категории
	 
	 resources/views/article_category/index.blade.php
	 Выведите ссылку на удаление статьи. Добавьте подтверждение удаления и отправку данных методом DELETE.
*/


// FILE: /app/Http/Controllers/ArticleCategoryController.php
    namespace App\Http\Controllers;
	 
	 use Illuminate\Validation\Rule;
	 use Illuminate\Http\Request;
	 use App\ArticleCategory;
	 
	 class ArticleCategoryController extends Controller
	 {
		  public function index()
		  {
				$articleCategories = ArticleCategory::orderBy('id', 'desc')->get();
				return view('article_category.index', compact('articleCategories'));
		  }
	 
		  public function show($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				return view('article_category.show', compact('category'));
		  }
	 
		  public function edit($id)
		  {
				$category = ArticleCategory::findOrFail($id);
				return view('article_category.edit', compact('category'));
		  }
	 
		  public function update(Request $request, $id)
		  {
				$category = ArticleCategory::findOrFail($id);
				$this->validate($request, [
					 'name' => 'required|unique:article_categories,name,' . $category->id,
					 'description' => 'required|min:200',
					 'state' => [
						  'required',
						  Rule::in(['draft', 'published']),
					 ]
				]);
	 
				$category->fill($request->all());
				$category->save();
				return redirect()
					 ->route('article_categories.index');
		  }
	 
		  public function create()
		  {
				$category = new ArticleCategory();
				return view('article_categories.create', compact('category'));
		  }
	 
		  public function store(Request $request)
		  {
				$this->validate($request, [
					 'name' => 'required|unique:article_categories',
					 'description' => 'required|min:200',
					 'state' => [
						  'required',
						  Rule::in(['draft', 'published']),
					 ]
				]);
	 
				$category = new ArticleCategory();
				$category->fill($request->all());
				$category->save();
	 
				return redirect()
					 ->route('article_categories.index');
		  }
		  
		  public function destroy($id)
		  {
				$category = ArticleCategory::find($id);
				if ($category) {
					 $category->delete();
				}
				return redirect()->route('article_categories.index');
		  }
	 }

// FILE: /resources/views/article_category/index.blade.php
?>
	 @extends('layouts.app')
	 
	 @section('content')
		  <small><a href="{{ route('article_categories.create') }}">Создать категорию</a></small>
		  <h1>Список категорий статей</h1>
		  @foreach($articleCategories as $category)
				<h2>
					 <a href="{{ route('article_categories.show', $category) }}">{{$category->name}}</a>
					 (
						  <a href="{{ route('article_categories.edit', $category) }}">Edit</a>
						  
						  <a href="{{ route('article_categories.destroy', $category) }}"
								data-method="delete"
								rel="nofollow"
								data-confirm="Are you sure?">Delete</a>
					 )
				</h2>
				<div>{{$category->description}}</div>
		  @endforeach
	 @endsection

<?

// FILE: /routes/web.php
	 Route::get('/', function () {
		  return view('welcome');
	 });
	 
	 Route::get('/articles', 'ArticleController@index')
		  ->name('articles.index');
	 
	 Route::get('/articles/{id}', 'ArticleController@show')
		  ->name('articles.show');
	 
	 Route::get('/article_categories/create', 'ArticleCategoryController@create')
		->name('article_categories.create');
	 
	 Route::post('/article_categories', 'ArticleCategoryController@store')
		->name('article_categories.store');
	 
	 Route::get('/article_categories/{id}/edit', 'ArticleCategoryController@edit')
		->name('article_categories.edit');
	 
	 Route::patch('/article_categories/{id}', 'ArticleCategoryController@update')
		->name('article_categories.update');
	 
	 Route::delete('/article_categories/{id}', 'ArticleCategoryController@destroy')
		->name('article_categories.destroy');
	 
	 Route::get('/article_categories', 'ArticleCategoryController@index')
		  ->name('article_categories.index');
	 
	 Route::get('/article_categories/{id}', 'ArticleCategoryController@show')
		  ->name('article_categories.show');

	 
	 

	# >>>>>>>>>>>> Удаление (CRUD) <<<<<<<<<<< #
	
/**
	 Фактически, любой круд состоит из 7 маршрутов, контроллера и шаблонов. Причем большая часть этого кода идентична, особенно маршруты. Они не содержат логики и всегда строятся по одному и тому же принципу.
	 
	 Laravel частично заимствовал из Rails еще один механизм, который называется "ресурсный роутинг". Он упрощает создание типичных крудов, за счет полной унификации всех маршрутов и способах их обработки. Вместо описания 7 разных маршрутов, ресурсный роутинг позволяет указать один метамаршрут:
*/

	Route::resource('/articles', 'ArticleController');
	
/**
	Внутри себя он превращается в те самые семь маршрутов, которые мы реализовывали в предыдущих уроках. Их можно увидеть с помощью команды artisan:
	 
	 $ php artisan route:list
	 +-----------+-------------------------+------------------+------------------------------------------------+
	 | Method    | URI                     | Name             | Action                                         |
	 +-----------+-------------------------+------------------+------------------------------------------------+
	 | GET|HEAD  | /                       |                  | Closure                                        |
	 | GET|HEAD  | articles                | articles.index   | App\Http\Controllers\ArticleController@index   |
	 | POST      | articles                | articles.store   | App\Http\Controllers\ArticleController@store   |
	 | GET|HEAD  | articles/create         | articles.create  | App\Http\Controllers\ArticleController@create  |
	 | GET|HEAD  | articles/{article}      | articles.show    | App\Http\Controllers\ArticleController@show    |
	 | PUT|PATCH | articles/{article}      | articles.update  | App\Http\Controllers\ArticleController@update  |
	 | DELETE    | articles/{article}      | articles.destroy | App\Http\Controllers\ArticleController@destroy |
	 | GET|HEAD  | articles/{article}/edit | articles.edit    | App\Http\Controllers\ArticleController@edit    |
	 +-----------+-------------------------+------------------+------------------------------------------------+
	 # Обратите внимание на имя плейсхолдера. Ниже станет понятно почему здесь article, а не id
	
		
	 Довольно неплохо. В проектах где подобных крудов много (любой типичный веб-проект), ресурсный роутинг очень помогает. Он не просто сокращает количество кода, но и дает хорошую унификацию. Нужно меньше думать и меньше спорить. Все уже спроектировано.
	
	Следующий шаг – упрощение контроллера. Во-первых можно сразу сгенерировать контроллер, со всеми нужными обработчиками. Во-вторых, этот контроллер можно интегрировать с нужной моделью:
	
	$ php artisan make:controller ArticleController --resource --model=Article
	
	На выходе получим такой контроллер:
*/

	 namespace App\Http\Controllers;
	 
	 use App\Article;
	 use Illuminate\Http\Request;
	 
	 class ArticleController extends Controller
	 {
		  /**
			* Display a listing of the resource.
			*
			* @return \Illuminate\Http\Response
			*/
		  public function index()
		  {
				//
		  }
	 
		  /**
			* Show the form for creating a new resource.
			*
			* @return \Illuminate\Http\Response
			*/
		  public function create()
		  {
				//
		  }
	 
		  /**
			* Store a newly created resource in storage.
			*
			* @param  \Illuminate\Http\Request  $request
			* @return \Illuminate\Http\Response
			*/
		  public function store(Request $request)
		  {
				//
		  }
	 
		  /**
			* Display the specified resource.
			*
			* @param  \App\Article  $article
			* @return \Illuminate\Http\Response
			*/
		  public function show(Article $article)
		  {
				//
		  }
	 
		  /**
			* Show the form for editing the specified resource.
			*
			* @param  \App\Article  $article
			* @return \Illuminate\Http\Response
			*/
		  public function edit(Article $article)
		  {
				//
		  }
	 
		  /**
			* Update the specified resource in storage.
			*
			* @param  \Illuminate\Http\Request  $request
			* @param  \App\Article  $article
			* @return \Illuminate\Http\Response
			*/
		  public function update(Request $request, Article $article)
		  {
				//
		  }
	 
		  /**
			* Remove the specified resource from storage.
			*
			* @param  \App\Article  $article
			* @return \Illuminate\Http\Response
			*/
		  public function destroy(Article $article)
		  {
				//
		  }
	 }

/**
	 Обратите внимание на параметры обработчиков. Laravel самостоятельно находит нужную сущность и достает ее из базы данных. Это позволяет хоть немного, но сократить код.
	 
	 Ресурсы могут быть вложенными. Это дает возможность строить пути, отражающие зависимости между сущностями на сайте:

	 
	 # Примеры с хекслета
	 
	 # Урок /courses/{course}/lessons/{lesson}
	 /courses/js-testing/lessons/asserts

	 # Список пройденных курсов /u/{user}/courses
	 /u/mokevnin/courses

	Принцип построения адресов точно такой же как и для обычного ресурса, но с включением указания на родительский ресурс:
	 
	 # Список
	 /entities/{entity}/subentities
	 
	 # Сущность
	 /entities/{entity}/subentity/{subentity}
	 
	 # Все остальные маршруты строятся по такому же принципу.
	 # Впереди добавляется /entities/{entity}.

	Вложенный ресурс можно генерировать автоматически:

	$ php artisan make:controller ArticleCommentController --resource --model=ArticleComment --parent Article

	Например вот так выглядит ресурс комментарии к статьям:
*/

	Route::resource('/articles.comments', 'ArticleCommentController');
	
	// Для вложенного ресурса, в экшены, кроме самой сущности передается и родительская сущность:
	
	 # /articles/{article}/comments/{comment}
	 # Обе сущности можно получить через параметры
	 public function edit(Article $article, ArticleComment $comment)
	 {
		  return view('article_comment.edit', compact('article', 'comment'));
	 }
		
	 
	 // Немного по другому начинает работать хелпер route. Для построения ссылок, там где участвуют оба ресурса, нужно использовать массив для их передачи:
		
	route('article.comments.edit', [$article, $comment]);
	
/**
	# Заключение
		
	 Ресурсный роутинг – удобный механизм позволяющий немного упростить создание крудов (CRUD). Он берет на себя много работы и дает программисту возможность сосредоточиться на логике.
	 
	 Существует негласное правило, о том насколько вложенным может быть вложенный роутинг. Считается, что не стоит делать более одного вложения. Иначе ссылки получаются очень длинными, а код начинает усложняться, так как приходится оперировать сразу тремя сущностями и более.
	 
	 # Самостоятельная работа
	 Удалите все маршруты связанные со статьями
	 Удалите контроллер статей (шаблоны оставьте)
	 Добавьте ресурсный роутинг articles
	 Сгенерируйте для него контроллер ArticleController
	 Реализуйте CRUD
	
	# Дополнительные материалы
	Ресурсный роутинг https://laravel.com/docs/6.x/controllers#resource-controllers
*/

/**@@@
	 В этом уроке вам предстоит добавить вложенный ресурс – комментарий к статье. Его особенность в том, что список комментариев и создание комментария выводятся на странице самой статьи. Все остальное уже во вложенном ресурсе.
	 
	 В целях простоты в этом проекте не учитываются пользователи. В реалной жизни комментарии принадлежат пользователям и только они могут управлять ими. Поэтому придется делать авторизацию.
	 
	 app/Http/Controller/ArticleCommentController.php
	 Сгенерируйте ресурсный контроллер. Добавьте все нужные экшены (кроме списка и формы создания)
	 
	 resources/views/article_comment/edit.blade.php
	 Реализуйте редактирование комментария
*/

	// FILE: /app/Http/Controllers/ArticleCommentController.php
	 
	 namespace App\Http\Controllers;
	 
	 use App\Article;
	 use App\ArticleComment;
	 use Illuminate\Http\Request;
	 
	 class ArticleCommentController extends Controller
	 {
		  public function store(Article $article, Request $request)
		  {
				$this->validate($request, [
					 'content' => 'required|min:10'
				]);
	 
				$comment = $article->comments()->make();
				$comment->fill($request->except('_token'));
				$comment->save();
	 
				return redirect()
					 ->route('articles.show', $article);
		  }
	 
		  public function edit(Article $article, ArticleComment $comment)
		  {
				return view('article_comment.edit', compact('article', 'comment'));
		  }
	 
		  public function update(Request $request, Article $article, ArticleComment $comment)
		  {
				$this->validate($request, [
					 'content' => 'required|min:10'
				]);
	 
				$comment->fill($request->except('_token'));
				$comment->save();
				
				return redirect()
					 ->route('articles.show', $article);
		  }
	 
		  public function destroy(Article $article, ArticleComment $comment)
		  {
				$comment->delete();
				
				return redirect()->route('articles.show', $article);
		  }
	 }

	 
	 // FILE: /resources/views/article_comment/edit.blade.php
?>
	 @extends('layouts.app')

	 @section('content')
		  <h1>{{$article->name}}</h1>
		  @if ($errors->any())
				<div>
					 <ul>
						  @foreach ($errors->all() as $error)
								<li>{{ $error }}</li>
						  @endforeach
					 </ul>
				</div>
		  @endif
		  
		  {{ Form::model($comment, ['method' => 'PATCH', 'url' => route('articles.comments.update', [$article, $comment])]) }}
		  {{ Form::textarea('content') }}
		  {{ Form::submit('Update') }}
		  {{ Form::close() }}
	 @endsection

