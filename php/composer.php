<?
	 
	 ############## PHP Basics ##############
	 
	 # >>>>>>>>>>>> Установка PHP <<<<<<<<<<< #

/**
	php-package https://github.com/hexlet-boilerplates/php-package — так называемую заготовку, содержащую базовую структуру нового проекта на PHP.


	Начнём с установки PHP и знакомства с REPL. PHP можно скачать и установить с официального сайта PHP http://php.net/downloads.php, но лучше выполнить эту процедуру через пакетные менеджеры. Откройте терминал и выполните команду, подходящую к вашей операционной системе:

	Ubuntu
	$ sudo apt update
	$ sudo apt install php

	macOS
	# https://brew.sh/index_ru.html
	$ brew install php


	 Если все прошло удачно, то теперь самое время повыполнять код на PHP. PHP поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введённый код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для его запуска достаточно набрать php -a.

	REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из репла достаточно нажать Ctrl + C. Если вы ошиблись при вводе команды, например забыли ;, то всегда можно выйти и зайти снова.

	Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях, когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением php, например, index.php, а затем запустить:

	$ php index.php

	Обратите внимание, что запускать код нужно из той же директории, в которой лежит файл index.php, либо указывать путь до файла.
 */

	#@ phpbrew
	
/**
	Совсем другой способ установки PHP — утилита phpbrew https://phpbrew.github.io/phpbrew/. Кроме установки любых версий PHP, эта утилита позволяет удобно переключаться между версиями. Такое может быть нужно когда вы одновременно работаете над двумя проектами, требующими разные версии PHP.
	
	? В какой момент жизненного цикла программы, возникают ошибки парсинга (ошибки, связанные с тем что программа синтаксически некорректна, например, забыта точка с запятой)?
	> На этапе загрузки соответствующего файла в интерпретатор
 */
	 
	 


	 # >>>>>>>>>>>> Composer <<<<<<<<<<< #


/**
	Ключевая задача, которую решает Composer — управление зависимостями, и именно о ней мы поговорим. Процесс установки самого Composer для каждой операционной системы описан в официальном руководстве:

	https://getcomposer.org/download/
	https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos

	Кроме самого Composer установите следующие программы, используя пакетный менеджер вашей операционной системы:

	 git https://ru.wikipedia.org/wiki/Git
	 curl https://ru.wikipedia.org/wiki/CURL

	Запуск Composer без аргументов, выведет весь список доступных команд с их описанием. Пробегитесь по ним, чтобы сформировать первое впечатление.
*/

	#@ Терминология

/**
	В PHP используются следующие понятия.
	Пакет — собственно, та самая библиотека, которую мы либо пишем, либо используем в проекте как зависимость.

	Репозиторий (Registry) — хранилище пакетов PHP, которое называется Packagist. Каждый желающий может опубликовать пакет в Packagist, потратив буквально минуту времени, а остальные смогут его использовать. В хранилище, на текущий момент, сотни тысяч пакетов и их количество растёт. Исходный код пакетов, как правило, хранится на гитхабе, но это не обязательно. Пакеты в PHP никак не связаны с Git и GitHub.
 */


	#@ Глобальная установка пакетов
	
/**
	Многие пакеты в PHP представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту phploc, которая умеет считать количество строк и сущностей в PHP-проекте. Инструкция по установке подобных пакетов обычно присутствует на странице репозитория https://github.com/sebastianbergmann/phploc на GitHub.
	
	$ composer global require phploc/phploc
	
	global означает, что установка глобальная, то есть пакет ставится в операционную систему как обычная программа
	
	Чтобы shell увидел программу, установленную глобально, нужно правильно настроить переменную окружения $PATH
	
	Если что-то пошло не так, убедитесь что вы всё правильно настроили:
	Изучите вывод echo $PATH. Есть ли там путь до исполняемых файлов Composer.
	
	Проверьте, все ли установилось командой which phploc.
 */

	#@ Проект

/*
	Composer работает таким образом, что объединяет понятия "проект" (приложение или application) и "пакет" в одно целое. В общем случае считается, что проект, в отличие от пакета, это конечный продукт, который никуда не публикуется, что довольно очевидно. Если компания делает сайт на PHP, то этот сайт, хотя и использует публичные зависимости, сам по себе хранится в приватном репозитории и никуда не утекает. Но с точки зрения Composer все происходит одинаково. Причём под проектом понимается не обязательно что-то большое. Даже если ваш проект (файл) состоит из 3 строчек кода и использует зависимости, вам понадобится работать с ним как с полноценным проектом. Начинается всё просто. Необходимо выполнить команду composer init в той папке, где вы собираетесь писать код.

	$ composer init

	После этого вам предложат ответить на десяток вопросов. Если вы не понимаете значение некоторых вопросов, то смело жмите Enter, потом все можно будет поправить.

	Когда вопросы закончатся, Composer покажет конечный результат в виде JSON. JSON — это текстовый формат для представления структурированных данных. Если вы не знакомы с ним, то не стоит переживать, формат это не язык программирования. Достаточно выучить несколько правил по формированию данных в виде JSON для того, чтобы чувствовать себя комфортно.
 */
{
	 "name": "hex/example",
    "description": "example package",
    "authors": [
        {
				"name": "hex",
            "email": "hex@hexlet.io"
        }
    ],
    "require": {}
}
	 
/**
	Имя пакета, записанное в composer.json, состоит из двух частей. Первая — vendor name, имя, под которым вы зарегистрированы в Packagist, вторая — project name. Причём vendor name уникален глобально (то есть все пользователи имеют своё собственное неповторимое имя), а вот project name должен быть уникален только в пределах vendor name.
	 
	 Composer рекомендует именовать пакет словами в нижнем регистре и в качестве разделителя использовать дефис, например: dependency-injection.
 */
	 
	 
	 
	 # >>>>>>>>>>>> Управление зависимостями <<<<<<<<<<< #

/**
	В файле composer.json по умолчанию создаётся две секции: require и require-dev. Они предназначены для описания зависимостей проекта. Две секции понадобилось для разделения тех зависимостей, которые нужны при использовании библиотеки, и тех, которые нужны только для тестирования и локальной разработки. Например, тесты при использовании пакета совершенно ни к чему, они запускаются только во время разработки самого пакета, поэтому всё связанное с тестированием можно смело описывать в require-dev.

	Предположим, что наш пакет зависит от библиотеки tightenco/collect. Эту библиотеку мы будем активно использовать в наших курсах позже. Разберём процесс установки:

	1. Для начала нужно понять, а под каким именем существует наша библиотека в Packagist. Тут вариантов два: либо мы уже знаем, как в случае tightenco/collect, либо мы загуглили библиотеку на GitHub и хотим выяснить её имя. Часто имя можно извлечь из строки установки, которая есть в файле README.md, но если её нет, вы всегда можете узнать имя, открыв файл composer.json и прочитав значение свойства name.

	 {
		  "name": "tightenco/collect",
		  "description": "Collect - Illuminate Collections as a separate package.",
		  "keywords": ["laravel", "collection"]
	 }

	2. Теперь введём команду установки:

	$ composer require tightenco/collect

	Эта команда не только устанавливает зависимость в текущий проект, но и автоматически добавляет его в секцию require файла composer.json. Такая установка является локальной (в команде нет слова global), то есть пакет ставится именно в текущий проект. При таком подходе, зависимости ставятся в папку vendor, находящуюся в корне проекта. Не забудьте добавить эту папку в .gitignore, так как библиотеки не являются частью вашего репозитория и ставятся по необходимости после клонирования. Секция require теперь выглядит примерно так:

	 "require": {
		  "tightenco/collect": "^5.7"
	 }


	Кроме того, Composer создаст файл composer.lock в корне проекта. Этот файл должен храниться в репозитории, а его значение я объясню в следующем уроке.
	 
	 Точно таким же способом ставятся последующие зависимости. Если зависимость должна оказаться в require-dev, то команда установки меняется так:

	$ composer require --dev phpunit/phpunit

	Создайте в корне вашего проекта папку src, а внутри неё файл Runner.php. Добавьте следующий код:
 */
	 
	 namespace My\Project\Runner;
	 
	 use Illuminate\Support\Collection;
	 
	 function run()
	 {
		  $collection = collect(['taylor', 'abigail', null])->map(function ($name) {
				return strtoupper($name);
		  });
		  
		  return $collection;
	 }

/**
	Если попытаться вызвать эту функцию, то выполнение кода завершится с ошибкой.

	Если вы склонировали репозиторий с GitHub, папка vendor будет отсутствовать, как и пакеты в ней. Первое, что нужно будет сделать — выполнить команду composer install в директории проекта. Установка пакетов — это идемпотентная операция, её можно запускать сколько угодно раз без риска что-либо поломать.
 */
	

	#@ Пакет

/**
	 Всё, что описывалось выше для проекта, также применимо и для пакета. Единственное ключевое отличие — пакет нужно опубликовать, если вы хотите, чтобы другие люди могли им пользоваться. Для этого обязательно нужно изменить версию, указанную в composer.json, так как нельзя публиковать уже опубликованную версию. Ушедший код не может изменяться, ведь на него завязываются другие.
	 
	 Для успешной публикации должны выполниться два условия:
	 
	 Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет.
	 Вы зарегистрированы на сайте https://packagist.org/
	 Далее следуйте указаниям на странице https://packagist.org/packages/submit. После того, как пакет будет опубликован, его можно устанавливать стандартным способом через вызов composer require.
	 
	 Интересный вопрос заключается в том, как правильно версионировать пакет. На этот счёт был придуман стандарт, названный SEMVER https://semver.org/lang/ru. Его описание занимает буквально пару страниц на русском языке. Обязательно ознакомьтесь.
*/


	#@ Пространства имён
	
/*
	Любой код на PHP, написанный в современном стиле, вызывается с указанием пространства имён. Не важно, о каком коде идёт речь, будь то вызов кода из файла, лежащего в соседнем файле, или вызов кода из установленной зависимости. Давайте ещё раз посмотрим на код из предыдущего примера:
 */
	 
	 namespace My\Project\Runner;
	 
	 use Illuminate\Support\Collection;
	 
	 function run()
	 {
		  $collection = collect(['taylor', 'abigail', null])->map(function ($name) {
				return strtoupper($name);
		  });
		  
		  return $collection;
	 }

/**
	Как видите, для использования collect мы указываем использовать пространство имён Illuminate\Support\Collection. То же самое касается любой другой библиотеки, включая те, которые пишем мы сами. По этой причине нужно как-то выбрать имя пространства имён. Имя пакета отображается в имени пространства имён таким образом — Dependency\Injection, где дефис заменяется на \ (обратный слеш), а каждое слово начинается с заглавной буквы.

	К сожалению, из-за того, что пространства имён в языке появились не сразу, PHP позволяет создавать файловую структуру и структуру пространств имён независимо. Кроме того, в разных пакетах разные способы именования файлов, разные способы формирования самих имён пакетов, разные способы организации файлов внутри пакета. По этой причине я постарался использовать в php-package те практики, которые наиболее распространены и похожи на то, как всё организовано в других языках.

	> Пакет именуется в "шашлычной нотации" (kebab-case).
	> Каждый пакет может выставлять наружу только одно пространство имён, что снижает риск пересечения с другими пакетами, а также позволяет легко определить принадлежность пространства имён к пакету. В терминологии стандарта PSR-4, такое пространство имён называется "vendor namespace".
	> Пространства имён именуются в стиле StudlyCaps https://en.wikipedia.org/wiki/Studly_caps и напрямую отображаются на файловую систему. Исключением является корневое пространства имён, которое получается путём трансформации имени пакета.
	> Исходный код проекта находится в папке src, а тесты в директории tests.

	Что касается именования файлов, то, что бы ни хранилось внутри, придерживайтесь именования в стиле StudlyCaps (например, MySuperFile.php).
*/


	#@ Автозагрузка

/**
	В предыдущем уроке мы создали файл src/Runner.php, но я сказал, что попытка запустить его завершится с ошибкой. Дело в том, что попытка использовать любой сторонний код, включая другие файлы, принадлежащие текущему пакету, требует загрузки этих файлов. Указание пространства имён, само по себе, никак не влияет на их загрузку. По умолчанию считается, что если вы пытаетесь использовать какой-то код, то он уже загружен, используя require или require_once. Чисто технически можно так и делать. Каждый раз, когда нам нужно использовать сторонний код, мы можем сначала делать его подгрузку через require. К счастью, этого делать не нужно. Более того, линтер ругается на попытку использовать require самостоятельно.

	 Дело в том, что Composer умеет автоматически загружать все необходимые файлы. Эта функциональность частично опирается на возможности автозагрузки самого PHP. Мы ещё не проходили классы, но стандарт PSR-4 описывает автозагрузку именно классов. Грубо говоря, если правильно сконфигурировать автозагрузчик, то при добавлении нового файла с классом, тот будет загружен автоматически. В случае с файлами, в которых есть только пространство имён и функции, всё чуть сложнее. Каждый новый файл должен быть прописан внутри composer.json, только тогда он будет загружен. Вот как это выглядит:
	 
	 {
		  "name": "hexlet/pairs",
		  "autoload": {
				"files": [
					 "src/Pairs.php",
					 "src/Lists.php"
				]
		  }
	 }
	 
	 В файл composer.json добавляется секция autoload, внутрь которой добавляется ещё одна секция files, которая в свою очередь содержит список файлов, которые надо загрузить. После обновления секции autoload нужно обязательно запускать команду composer dump-autoload. Она генерирует необходимый код в папке vendor, реализующий указанную загрузку. Затем остаётся только один шаг. Чтобы ваш код начал использовать всё, что сделал Composer, необходимо в начале вашего кода прописать следующую строку: require __DIR__ . '/../vendor/autoload.php';.
*/
	
	
	
	
	 #@ Lock-файл

/*
	Поговорим про обновление зависимостей. Для обновления всех зависимостей нужно выполнить команду composer update. Чтобы выполнить обновление конкретной зависимости — composer update vendor-name/project-name. А вот то, как будет происходить обновление, зависит от содержимого composer.json.

	Рассмотрим возможные варианты:
	 
	 require {
		'package1': "*",
		'package2': "1.3.5",
		'package3': ">2.3.4",
		'package4': "~3.9",
		'package5': "^1.2"
	 }
	 
	 * означает, что можно ставить любую версию библиотеки. После выполнения команды обновления, в папке vendor окажется последняя доступная версия package1.
	 
	 1.3.5 — конкретный номер. Если версия библиотеки жёстко зафиксирована, никакая команда не сможет обновить её.
	 
	 Кроме этих вариантов существует масса других способов указать зависимость, часть из них вы видите в списке выше. Все они подробно описаны в официальном руководстве, поэтому не будем повторяться. На текущем этапе для вас и так слишком много новой информации, которую нужно усвоить, а тонкости указания зависимостей не такая важная тема сейчас.


	На предыдущем шаге каждая новая установка зависимостей приводила сначала к созданию, а потом и обновлению lock-файла composer.lock.

Попытаемся разобраться в смысле этого файла. Как мы помним, в файле composer.json указываются зависимости, и мы рассмотрели то, как их устанавливать и обновлять. Но также мы помним, что у каждой зависимости могут быть свои собственные зависимости, которые также обновляются и так до бесконечности. Зависимости зависимостей называются транзитивными, и с ними не всё так просто. Настолько не просто, что существует понятие "ад зависимостей" (dependency hell).

	Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей. Предположим, что в нашем пакете есть зависимость A с зафиксированной версией 1.3.2, у которой в зависимостях стоит пакет B, причём с версией *. В такой ситуации (и без lock-файла), composer install поставил бы версию зависимости A указанной версии, но того же самого нельзя сказать про пакет B. Composer поставит последнюю доступную версию из репозитория. Такое поведение не детерминировано. Если создатель обновит B так, что нарушится обратная совместимость, наш проект просто сломается, так как перестанет работать A. Фактически, если бы мы полгода не заходили в проект, а затем зашли и поставили зависимости заново (удалив папку vendor или выполнив новое клонирование), то с почти вероятностью 100% ничего не заработает. Как правило, пакеты обновляются часто, и какой-нибудь из них обязательно изменит мажорную версию за столь большой срок.

	Очевидный, но не рабочий выход из данной ситуации — вручную отслеживать зависимости всех зависимостей и явно прописывать их версии в composer.json. Такой способ сработает, но даже в проекте, который содержит пять зависимостей, транзитивных зависимостей будет сотни! Вдумайтесь в эту цифру. Я уже не говорю про то, что пакеты обновляются и меняются. Такую ситуацию невозможно контролировать, она выльется в то, что зависимости просто перестанут обновляться.

	Другой выход — требовать того, чтобы создатели всех библиотек всегда жёстко указывали версии. По понятным (человеческим) причинам так не сработает, а автоматизация этого процесса привела бы к полному параличу.

И тут на сцену выходит lock-файл. По сути он представляет собой автоматизированное решение первого способа. Его содержимое выглядит примерно так:
	 
	 {
		  "_readme": [
				"This file locks the dependencies of your project to a known state",
				"Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
				"This file is @generated automatically"
		  ],
		  "content-hash": "ab2dac1e4b8d91d81b2295ca726e9499",
		  "packages": [
				{
					 "name": "tightenco/collect",
					 "version": "v5.5.27",
					 "source": {
						  "type": "git",
						  "url": "https://github.com/tightenco/collect.git",
						  "reference": "07d58f7f663d5033a08541f9c481d33ad3f514a5"
					 },
					 "dist": {
						  "type": "zip",
						  "url": "https://api.github.com/repos/tightenco/collect/zipball/07d58f7f663d5033a08541f9c481d33ad3f514a5",
						  "reference": "07d58f7f663d5033a08541f9c481d33ad3f514a5",
						  "shasum": ""
					 }
				}
		  ]
	 }

	Первый запуск установки зависимостей сформирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные с их версиями. При дальнейших запусках composer install всегда ставится то, что указано в lock-файле, даже если удалить папку vendor или в Packagist добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведёт к тому же результату. Теперь всегда можно быть уверенным — если заработало сейчас, то заработает и потом (и не только у нас).
	 
	 Наличие lock-файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в composer.json, обновился и может быть обновлён в соответствии с тем, как указана его версия, то загрузится новая версия, а lock-файл обновится автоматически. После этого нужно только не забыть зафиксировать его изменение в репозитории.

	На самом деле поведение чуть сложнее и количество различных ситуаций тоже больше. Но в целом, для понимания схемы работы, достаточно описанного выше.

	? Что дает наличие lock-файла?
	> Гарантию того, что у разработчиков установлены одни и те же версии всех зависимостей, включая транзитивные
*/
	
	
	
	
	 # >>>>>>>>>>>> Скрипты <<<<<<<<<<< #

/**
	Как правило, даже исполняемые пакеты ставятся не глобально, а локально в текущий проект. Composer помещает их в директорию vendor, а если пакет содержит бинарник (то есть может выполняться как программа), то на него создаётся ссылка в ./vendor/bin. Попробуйте ответить на вопрос: "Заработает ли запуск phpcs после локальной установки PHP_CodeSniffer, содержащего соответствующий исполняемый файл?". Правильный ответ — нет. Путь ./vendor/bin не добавлен в $PATH и более того, не должен быть туда добавлен. Локальная установка на то и локальная, что доступна только внутри проекта. Мы можем запустить бинарник, обратившись к нему непосредственно ./vendor/bin/phpcs. Но есть способ лучше.
*/

	#@ Скрипты

/**
	Секция scripts внутри файла composer.json, позволяет описывать произвольные команды, которые затем можно выполнять. Её особенностью является то, что Composer в контекст выполнения команды добавляет путь /vendor/bin в $PATH (только для текущего вызова!). А папка vendor/bin это место куда Composer складывает бинарники всех локально установленных пакетов.

	Рассмотрим пример. Предположим, что мы установили программу phpcs как зависимость.

	$ composer require "squizlabs/php_codesniffer" --dev

	 Примечание: флаг "--dev" добавлен для того, чтобы Composer автоматически сделал запись об устанавливаемой зависимости в секцию require-dev конфигурационного файла composer.json, так как эта программа нужна только для локальной разработки.
	 
	 Следующим шагом нужно открыть файл composer.json в любом редакторе и создать в секции scripts такую запись: "phpcs": "phpcs". Имя свойства используется как команда в командной строке, значение — то что реально исполнится. Они не обязательно должны совпадать, но в нашей ситуации это удобно. Теперь, если вы попробуете сделать так:

	$ composer run-script phpcs -- --standard=PSR12

	То выполнится проверка кода. -- используется для передачи аргументов команде phpcs.

	Таким же способом можно добавить на выполнение любую команду. Общий шаблон вызова выглядит так:

	$ composer run-script <имя скрипта>
	
*/

	#@ Хуки

/**
	Есть целый набор предопределённых свойств в секции scripts, которые Composer запускает автоматически в разные моменты жизненного цикла. Например, может понадобиться выполнить некоторые действия до или после установки пакета. Composer определяет для этого следующий список скриптов:

	 pre-package-install
	 post-package-install
	 pre-package-update
	 post-package-update
	 pre-package-uninstall
	 post-package-uninstall

Подробнее об этом можно прочитать в официальной документации https://getcomposer.org/doc/articles/scripts.md
*/
	
	
	

	 # >>>>>>>>>>>> Исполняемые файлы в пакетах <<<<<<<<<<< #
	 
/**
	 Многие пакеты представляют из себя приложения командной строки, так называемые cli-утилиты, взаимодействие (запуск команд, передача аргументов и опций, вывод результатов) которых с пользователем происходит интерактивным образом через терминал. Для обеспечения такой возможности (запуск файлов из командной строки) в Composer существует секция bin конфигурационного файла composer.json, например:
	 
	 "bin": ["bin/php-package"]
	 
	 Эта запись означает, что при установке пакета в операционной системе будет физически создан файл (а точнее, его особая разновидность — символическая ссылка) с именем php-package, запуск которого приведёт к запуску файла вашего проекта по адресу bin/php-package. Как можно заметить, имя ссылки задаётся именем файла (совпадает с ним). Также обратите внимание, что ссылок может быть множество (столько, сколько сами укажите в секции bin).
	 
	 Месторасположение символической ссылки и способ её запуска из командной строки различаются в зависимости от способа установки пакета: глобального (с командой global: например, composer global vendor/package) или локального. Рассмотрим каждый случай отдельно.
*/


	#@ Глобальная установка: генерация ссылок и запуск исполняемых файлов
	
/**
	При глобальной установке пакета, composer создаёт символические ссылки в каталоге $HOME/.composer/vendor/bin. То есть, при создании ссылок, в домашнюю директорию пользователя (от имени которого запускалась установка пакета) будет добавлен (если ещё не существует) каталог .composer/vendor/bin, куда и будут размещены ссылки. Это каталог по умолчанию, но путь к нему нам надо самостоятельно прописать в переменной окружения PATH. После этого мы можем запускать приложение по имени символической ссылки из командной строки, находясь в любой точке файловой системы (ведь при поиске исполняемых файлов командная оболочка ищет их последовательно по всем путям, прописанным в переменной окружения PATH).
	
	В зависимости от версии composer директория по умолчанию может различаться. Кроме того, это значение можно конфигурировать. Посмотреть, в какую конкретно директорию composer складывает ссылки на исполняемые файлы можно с помощью команды composer global config bin-dir.
*/


	#@ Пример
/**
	Давайте создадим и опубликуем пакет, который для краткости и наглядности будет очень простым, состоящим всего из двух исполняемых файлов, запуск которых выводит соответственно приветствие и прощание с Хекслетом.

	 Структура проекта:

	~/projects/smallTalkWithHexlet$ ls -al

	 drwxrwxr-x 2 hex hex 4096 Jul  1 04:32 .
	 drwxrwxr-x 3 hex hex 4096 Jul  1 04:21 ..
	 -rw-rw-r-- 1 hex hex  225 Jul  1 04:31 composer.json
	 -rw-rw-r-- 1 hex hex    0 Jul  1 04:32 sayBye
	 -rw-rw-r-- 1 hex hex    0 Jul  1 04:32 sayHi

	// Содержимое исполняемого файла sayHi:
	#!/usr/bin/env php
	<?php
	
	print_r("Hello, Hexlet!\n");

	Содержимое исполняемого файла sayBye:
	 
	 #!/usr/bin/env php
	 <?php
	 
	 print_r("Bye-bye! See you later, Hexlet!\n");


	Содержимое конфигурационного файла composer.json:
	 
	 ~/projects/smallTalkWithHexlet$ cat composer.json
	 {
		  "name": "hex/small-talk-with-hexlet",
		  "description": "Small talk with Hexlet",
		  "keywords": ["hexlet", "php", "composer"],
		  "license": "MIT",
		  "bin": [
				"./sayHi",
				"./sayBye"
		  ]
	 }

	Небольшое отступление про исполняемые файлы:
	1. Для возможности запуска файла из командной строки у пользователя должно быть право на выполнение (атрибут x) этого файла.

	2. Если исполняемый файл содержит код, то надо указать командной оболочке интерпретатор, который будет исполнять этот код при запуске исполняемого файла. Это делается с помощью так называемого шебанга. В примере выше мы указали в качестве интерпретатора php, а путь к нему задали не абсолютный (в разных системах php может быть находится по совершенно разным путям), а с помощью специальной утилиты env.

	Итак, мы подготовили пакет, и после публикации, он становится доступен для установки под именем hex/small-talk-with-hexlet.

	Теперь установим этот пакет в систему глобально.

	Но сначала убедимся, что никаких символических ссылок в директории не существует.

	Здесь с помощью фильтра grep мы попытались найти файлы, содержащие в своём имени (как наши ссылки в секции bin) строчку "say". Но поиск не дал результатов, потому что таких файлов (до установки пакета) нет.

	Далее глобально устанавливаем пакет в систему:

	$ composer global require hex/small-talk-with-hexlet

	Теперь снова проверим с помощью grep директорию установки исполняемых файлов

	$ ls -al /home/hex/.composer/vendor/bin/ | grep 'say'
	 lrwxrwxrwx  1 hex hex   36 Jul  4 02:05 sayBye -> ../hex/small-talk-with-hexlet
	 sayBye
	 lrwxrwxrwx  1 hex hex   35 Jul  4 02:05 sayHi -> ../hex/small-talk-with-hexlet/s
	 SayHi

	Как и ожидалось, в этом каталоге находятся символические ссылки (об этом свидетельствует первый символ l, определяющий тип файла в строке атрибутов файла lrwxrwxrwx), которые мы можем запускать из любой точки файловой системы:

	$ sayHi
	> Hello, Hexlet

	$ sayBye
	> Bye-bye! See you later, Hexlet!

	Из примера видно, что мы можем успешно запускать одни и те же команды из разных директорий. Почему так происходит подробно обсуждалось выше.
*/

	#@ Что происходит при локальной установке

/*
	В подавляющем большинстве случаев для целей разработки пакеты устанавливаются не глобально, а локально. При такой установке они "привязываются" к конкретному проекту и размещаются внутри его каталога по пути ./vendor/. При этом ссылки на исполняемые файлы устанавливаемых пакетов composer размещает в каталоге ./vendor/bin.

	Ссылки на исполняемые файлы локально установленных пакетов "заточены" на использование их в скриптах (секция scripts конфигурационного файла composer.json), для чего существует особенный синтаксис. Эту тему мы проходили в уроке, посвящённом скриптам.

	Естественно, к символическим ссылкам можно также обратиться напрямую, указав нужный путь. Давайте рассмотрим это на примере, подключив к нашему разрабатываемому проекту small-talk-with-hexlet пакет PHP_CodeSniffer:

	$ ~/projects/smallTalkWithHexlet$ composer require --dev "squizlabs/php_codesniffer=*"

	Если в корневом каталоге проекта установить какой-либо пакет с флагом --dev (composer require --dev some_package) — то он автоматически добавится в зависимости проекта: в секцию require-dev файла composer.json. Этой возможностью мы и воспользовались.

	$ composer require --dev "squizlabs/php_codesniffer=*"

	Как и ожидалось, появился каталог ./vendor, в котором лежит код подключённого пакета, а также других пакетов, от которых он, в свою очередь, зависит.

Узнать место, где composer хранит ссылки на исполняемые файлы локально подключаемых пакетов, позволяет команда composer config bin-dir (обратите внимание, что здесь нет команды global). В нашем случае это каталог ./vendor/bin, заглянем в него:
	
	 $ composer config bin-dir --absolute

	Как видно, при установке PHP_CodeSniffer добавилось два исполняемых файла для запуска разных программ. Давайте запустим phpcs (т.н. линтер — утилита, отвечающая за проверку кода на соответствие стандартам):
	$ phpcs
	> bash: phpcs: command not found

	Программа отработала корректно и "молча" (без дополнительного вывода отчёта об ошибках), потому что в наших скромных файлах не было никаких нарушений оформления кода.

Затем была попытка запустить исполняемый файл из командной строки только по имени, но она привела к неудаче — bash: phpcs: command not found — командная оболочка просто не нашла его (в отличие от того, как это было бы при глобальной установке).
*/
