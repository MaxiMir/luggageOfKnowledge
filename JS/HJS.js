/*####### JS #######*/

// repl.it

############################### JS: Функции ###############################

<<<<< Guard Expression >>>>>

/*
Одни функции устроены сложнее других. Иногда так происходит в силу объективных причин (необходимая сложность). Иногда — в силу особенностей писавшего её программиста (случайная сложность). И хотя нельзя однозначно описать эту сложность, существуют способы, позволяющие хотя бы частично её оценить.

# Цикломатическая сложность
Цикломатическая сложность — это структурная, или топологическая, мера сложности компьютерной программы, разработанная Томасом Дж. Маккейбом в 1976 году.

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только один маршрут через код.

Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один, если условие оператора if имеет значение true, и один — если false.

Такую оценку можно применять как в целом к программе, так и к отдельным функциям.
*/

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);
abs(10); // => 10
abs(-3); // => 3

/*
В примере выше у функции sum цикломатическая сложность равна единице, а у функции abs — двойке, так как она содержит ветвление, а значит два независимых пути выполнения.

Чем больше возможных путей выполнения, тем сложнее функцию понять, отладить и модифицировать. Очевидно, что, с одной стороны, функции нужно дробить, а с другой — описывать логику программы так, чтобы не появлялись лишние пути. Даже опытные разработчики часто сталкиваются с этой проблемой.

Линтеры многих языков измеряют показатель сложности и сигнализируют, если он, скажем, больше 5 для одной функции.

# Guard Expression
Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:
*/

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

/*
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.
*/

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

/*
Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.




/**@@@
Реализуйте и экспортируйте по умолчанию функцию isPalindrome с использованием рекурсии.

Примеры использования:
*/
import isPalindrome from './isPalindrome';

isPalindrome('radar'); // => true
isPalindrome('a');     // => true
isPalindrome('abs');   // => false


// file: App/isPalindrome.js:
const isPalindrome = (string) => {
  if (string.length <= 1) {
    return true;
  }

  const firstSymbol = string[0];
  const lastSymbol = string[string.length - 1];

  if (firstSymbol !== lastSymbol) {
    return false;
  }

  const stringWithoutFirstAndLastSymbols = string.substr(1, string.length - 2);

  return isPalindrome(stringWithoutFirstAndLastSymbols);
}

export default isPalindrome;

// ## TESTS:
// file: __tests__/isPalindrome.test.js:
import isPalindrome from '../isPalindrome';

test('isPalindrome', () => {
  expect(isPalindrome('a')).toBe(true);
  expect(isPalindrome('aa')).toBe(true);
  expect(isPalindrome('404')).toBe(true);
  expect(isPalindrome('abba')).toBe(true);
  expect(isPalindrome('radar')).toBe(true);
  expect(isPalindrome('absba')).toBe(true);
  expect(isPalindrome('aibohphobia')).toBe(true);

  expect(isPalindrome('abaoba')).toBe(false);
  expect(isPalindrome('aashgkhdj')).toBe(false);
  expect(isPalindrome('palindrome')).toBe(false);
  expect(isPalindrome('aibohapohobia')).toBe(false);
});


<<<<< Параметры по умолчанию >>>>>

// Опишем функцию greeting, которая печатает на экран приветствие:
const greeting = name => console.log(`Hi, ${name}!`);

greeting('John'); // => Hi, John!


// Но что произойдёт, если при вызове функции передать ей меньшее число аргументов, чем у неё установлено параметров? Давайте посмотрим:
greeting(); // => Hi, undefined!

// Правило здесь простое: параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined. Проиллюстрируем это подробнее на примере функции, которая принимает на вход три параметра и распечатывает их значения:

const foo = (a, b, c) => {
  const output = `a - ${a}; b - ${b}, c - ${c}`;
  console.log(output);
}

foo('I', 'am', 'here'); // => a - I; b - am, c - here

foo('I', 'am'); // => a - I; b - am, c - undefined

foo('I'); // => a - I; b - undefined, c - undefined

foo(); // => a - undefined; b - undefined, c - undefined

/* 
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.

Допустим, мы хотим, чтобы при вызове функции greeting без параметров, она выводила сообщение Hi, anonymous!.

Тогда мы можем реализовать её следующим образом:
*/

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

// Однако, JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:
const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);
greeting(); // => Hi, anonymous!


const pow = (base, exp = 2) => base ** exp;

pow(5); // => 25
pow(5, 2); // => 25
pow(5, 1); // => 5

// Кроме того, в значениях по умолчанию можно использовать идентификаторы:
const f = (x = Math.PI) => {}

// И даже вызовы функций:
const f = (x, y = Math.sqrt(x)) => {}


const getSum = (a = 10, b = 2 * a, c = 3 * b) => a + b + c;
const result = getSum(); // <-> 10 + 20 + 60 => 90
const result = getSum(2); // <-> 2 + 4 + 12 => 18
const result = getSum(2, 3); // <-> 2 + 3 + 9 => 14
const result = getSum(2, 3, 4); // <-> 2 + 3 + 4 => 9


const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`); // интерполяция - работает только со строками в бэктиках.

/*
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования.

Примечание
В этом уроке мы рассмотрели случай, когда в функцию передаётся меньше параметров, чем она ожидает. У вас может возникнуть вопрос, что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?

Ответ: ничего не произойдёт они будут просто проигнорированы.

Дополнительные материалы
Default function parameters https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters

/**@@@
Реализуйте и экспортируйте по умолчанию функцию substr, которая возвращает подстроку из переданной строки. Подстрокой называется любая выбранная часть строки. Например для строки hello можно выделить следующие подстроки: ello, llo, o, el и множество других.

Функция принимает на вход три параметра:
> Строка.
> Начальный индекс. Значение по умолчанию: 0.
> Длина подстроки. Значение по умолчанию: длина всей строки.
*/
substr('abba', 0, 1);    // => a
substr('abba', 1, 2);    // => bb
substr('abba', -10, 2);  // => ab
substr('abba', -1, 100); // => abba
substr('abba', -1, -1);  // => a
substr('abba', 1, -10);  // => b
substr('abba', 1, 10);   // => bba
substr('abba', 1, 0);    // => ''
substr('abba', 100, 3);  // => ''

// По умолчанию, то есть если не переданы дополнительные параметры, возвращается сама строка:
substr('');     // => ''
substr('abba'); // => abba

/*
У этой функции множество вариантов поведения:
Если переданная длина отрицательная, то внутри она становится единицей
Если переданная длина равна нулю, то возвращается пустая строка
Если конечный индекс (переданная длина + начальный индекс - 1) выходит за границу строки, то берется подстрока от начального индекса до конца строки.
*/
substr('abba', 1, 10);   // => bba

/*
Конечный индекс 1 + 10. Он выходит за границу строки, так как длина строки 4 символа. Поэтому возвращается подстрока, от начального индекса 1 и до конца строки.

Если начальный индекс отрицательный, то внутри он становится нулем
Если начальный индекс выходит за границу слова справа, то всегда возвращается пустая строка

Для реализации этой функции, используйте подход, который называется "нормализация". Он заключается в том, что перед тем как делать вычисления, данные приводятся к виду, с которым удобно работать. Например, длина строки для substr может иметь следующие неудобные значения:

Отрицательное число
Число, выходящее за границу строки
Индекс + Длина выходят за границу строки
В каждой из этих ситуаций длину строки можно изменить на такое значение, которое будет удобно для обработки сразу всех возможных случаев. Если число отрицательное, то длина становится равной единице (из условия), если оно выходит за границу строки, то его нужно сделать равным длине строки. В последнем случае длина должна стать числом Длина Строки - Индекс. После этих манипуляций процесс взятия подстроки становится универсальным и не содержащим условия.
*/

// file: app/substr.js
export default (str, index = 0, substrLength = str.length) => {
  if (index >= str.length) {
    return '';
  }

  const currentIndex = index < 0 ? 0 : index;

  let lastIndex = currentIndex + (substrLength - 1);

  if (lastIndex + 1 < currentIndex) {
    lastIndex = currentIndex;
  } else if (lastIndex > str.length - 1) {
    lastIndex = str.length - 1;
  }

  let result = '';
  
  for (let i = currentIndex; i <= lastIndex; i += 1) {
    result = `${result}${str[i]}`;
  }

  return result;
};


// ## TESTS:
// file: app/__tests__/substr.test.js:
import substr from '../substr';

test('substr', () => {
  expect(substr('')).toEqual('');
  expect(substr('abba', 4, -10)).toEqual('');
  expect(substr('abba')).toEqual('abba');
  expect(substr('abba', 1, 0)).toEqual('');
  expect(substr('abba', 0, 1)).toEqual('a');
  expect(substr('abba', 1, 2)).toEqual('bb');
  expect(substr('abba', -10, 2)).toEqual('ab');
  expect(substr('abba', -1, 100)).toEqual('abba');
  expect(substr('abba', -1, -1)).toEqual('a');
  expect(substr('abba', 1, -10)).toEqual('b');
  expect(substr('abba', 1, 10)).toEqual('bba');
});



>>>>> Выполнение функций <<<<<

/*
Вспомним несколько важных понятий из прошлого курса:

Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

Выражения — вычисляются.
Инструкции — исполняются.

К выражениям относятся:
 * Вызов функции
 * Арифметические и логические операции
 * Тернарный оператор
 * и другие

К инструкциям относятся:
 * for
 * while
 * break
 * return
 * if
 * и другие

Необходимо знать разницу между ними — это позволит лучше понимать, как могут взаимодействовать друг с другом различные конструкции языка.

Возьмем условный оператор if. В некоторых языках он представлен инструкцией, в некоторых — выражением. Посмотрите на код ниже и подумайте, возможно ли такое в JavaScript и почему:
*/
const value = if (something) {
    one
  } else {
    two
  }

/*
Такой код в JavaScript невозможен только по одной простой причине: if — это инструкция, а не выражение.

Но такой код возможен и часто используется в языках вроде Ruby или Python. Зачем же нужен if, если есть тернарный оператор, который как раз и является выражением?

Дело вот в чем. Если бы if был выражением, то тернарный оператор стал бы попросту не нужен, несмотря на то, что он является более лаконичной заменой if. Но и тернарный оператор бывает неудобен в тех ситуациях, когда вычисление слишком большое и не помещается в одну строку, а его результат должен быть записан в одну и ту же константу или переменную в каждой из веток. В такой ситуации как раз пригодился бы if как выражение.

Этот пример ярко иллюстрирует тот факт, что конструкции языка, представленные выражением, делают язык гибче, а решения с их использованием делают код лаконичнее. Другими словами, язык становится выразительнее. Кроме описанного выше, у выражений есть еще одно огромное преимущество: они могут комбинироваться друг с другом и вкладываться друг в друга.

Ниже я продемонстрирую варианты комбинирования выражений, но с акцентом на функции:

# Арифметические операции
*/
const r1 = 5;
const r2 = 5 + 8;
const r3 = 5 + 8 - Math.PI;
const r4 = 5 + 8 - Math.PI * Math.sqrt(16);
const r5 = f1() + f2() * f3();

/*
Вопросы могут возникнуть только в последней строчке. Насколько это допустимо? Вызов функции — это выражение, возвращающее результат, так что этот код допустим на 100%. Если функция вернет значение, неподходящее для сложения, то может возникнуть ошибка, но это будет логическая ошибка, а не синтаксическая.

Примечание: предополагается, что используемые в примерах этого урока функции и константы (например, f2 или isEditing) ранее где-то были определены. Их определение мы убрали из примеров, чтобы не отвлекать от главного.

# Логические операции

Все то же самое можно делать и с логическими выражениями:
*/

const r1 = true;
const r2 = true || false;
const r3 = true || false && isEditing;
const r4 = true || false && isEditing || isEmpty(data);
const r5 = f1() || f2() && f3();

/*
Из-за слабой типизации подобный код работать будет вообще всегда, даже если функции возвращают не true или false, но пользоваться этим не стоит. 

# Аргументы

А теперь чуть более сложный пример. Когда мы вызываем функцию, то в аргументах ожидается выражение: func(<expression>, <expression>, ...). А из этого следует, что мы можем сделать так:
*/

const r1 = f();
const r2 = f(5);
const r3 = f(5 + Math.PI);
const r4 = f(5 + Math.PI - cube(number));
const r5 = f(f1(f2(n3, f3(n1, n2))), f4());

/*
Пройдемся по примеру выше. f(f1(f2(n3, f3(n1, n2))), f4()) содержит в аргументах два выражения:

1. f4()
2. f1(f2(n3, f3(n1, n2)))
  этот вызов содержит один аргумент — вызов функции: f2(n3, f3(n1, n2)),
    который в свою очередь содержит два аргумента: n3 и вызов функции f3(n1, n2).


#  Порядок выполнения

Осталось понять, в какой последовательности происходят эти вызовы. JavaScript считается энергичным языком, то есть языком с аппликативным порядком вычисления, а это значит, что аргументы вычисляются до того, как попадают внутрь функций.    
*/

const f1 = () => console.log('called f1');
const f2 = () => console.log('called f2');
const f3 = () => console.log('called f3');
const f4 = () => console.log('called f4');
const f5 = () => console.log('called f5');
const f6 = () => console.log('called f6');

f1( f2(f4(), f5()), f3(f6()) ); // =>

// called f4
// called f5
// called f2
// called f6
// called f3
// called f1

// Как видно, вычисление идет с самого глубокого уровня слева направо.



/**@@@
Модуль tags содержит набор функций, позволяющих генерировать HTML с помощью функций.
*/

table(
  tr(td('one'), td('two')),
  tr(td('three'), td('four'))
);

/*
В результате вызовов возвращается вот такой HTML:
<table>
  <tr>
    <td>one</td>
    <td>two</td>
  </tr>
  <tr>
    <td>three</td>
    <td>four</td>
  </tr>
</table>
buildHtml.js
Реализуйте и экспортируйте по умолчанию функцию buildHtml, простой вызов которой:
*/

buildHtml();

/*
создаёт и возвращает следующий HTML:

<table>
  <tr>
    <td>lang</td>
    <td>comment</td>
  </tr>
  <tr>
    <td>php</td>
    <td>statements</td>
  </tr>
  <tr>
    <td>clojure</td>
    <td>expressions</td>
  </tr>
</table>

// file: buildHtml.js
**/
import { table, tr, td } from './tags';

export default () => table(
  tr(td('lang'), td('comment')),
  tr(td('php'), td('statements')),
  tr(td('clojure'), td('expressions')),
);

// ## TESTS:
// app/__tests__/buildHtml.test.js 

import { html } from 'js-beautify';
import buildHtml from '../buildHtml';

test('htmlBuilder', () => {
  expect(html(buildHtml())).toMatchSnapshot();
});


// app/__tests__/__snapshots__/buildHtml.test.js.snap 

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`htmlBuilder 1`] = `
"<table>
    <tr>
        <td>lang</td>
        <td>comment</td>
    </tr>
    <tr>
        <td>php</td>
        <td>statements</td>
    </tr>
    <tr>
        <td>clojure</td>
        <td>expressions</td>
    </tr>
</table>"
`;



>>>>>  Объекты первого класса <<<<<

/*
Продолжая тему предыдущего урока, познакомимся с понятием "first-class citizen" или "объекты первого класса".

Объектами первого класса в контексте конкретного языка программирования называются элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идет обо всем, что может быть данными. Самые простые типы данных — это числа и строки. Как вы потом увидите, все остальные типы данных также являются объектами первого класса.

А теперь посмотрите внимательно на этот код: const x = () => console.log('hey'). Ничего необычного, вы видели и писали подобное множество раз. Если вы считаете, что в этом коде создается функция x, на самом деле это не так. Здесь происходят следующие две операции:

1. Создание функции: () => console.log('hey')
2. Создание константы со значением в виде функции: const x =

Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: () => {}. Это пустая функция с пустым телом, которая не делает ничего. Присваивать ее константе или нет — вопрос отдельный. Вполне допустимо написать и выполнить подобную программу: (a, b) => a + b;.

Из примеров выше можно сделать вывод, что функция — тоже данные, ведь ее можно присвоить константе. Рассмотрим это утверждение на практике:
*/

const identity = v => v; // функция: v => v, константа: identity
console.log(identity(10)); // => 10

const z = identity;
console.log(z === identity); // => true

const x = 5;
console.log(z(x) === identity(x)); // => true

/*
Главный вывод, который можно сделать из кода выше, заключается в том, что определение функции (не вызов!) — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать ее без создания промежуточной константы:
*/

// Определяем функцию v = v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

/*
Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нем создается функция, принимающая на вход другую функцию v и вызывающая ее внутри с аргументом 'run'.

Попробуем усложнить:
*/
identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

/*
Первым идет пример вызова функции по идентификатору, а во втором примере я заменил идентификатор на определение функции, сделав подстановку. Результат получился тот же самый. Еще раз посмотрите на этот шаблон (<тут определение функции>)(). Попробуйте самостоятельно разобрать пример ниже:
*/

((a, b) => a + b)(3, 2); // => 5
// const sum = (a, b) => a + b;
// sum(3, 2); // => 5


// Теперь попробуем использовать функции как данные:
const sqrt = identity(Math.sqrt);
console.log(sqrt === Math.sqrt); // true
sqrt(4); // => 2

/*
В первой строчке вызывается функция identity, в которую передается Math.sqrt. Результатом этого вызова будет все та же функция Math.sqrt.

Здесь мы видим сразу два новых аспекта: передача функции как аргумента и возврат функции как значения. Функции, которые принимают на вход другие функции или возвращают другие функции, называются функциями высшего порядка. В функциональных языках большинство задач, связанных с обработкой данных, работают именно через них. JavaScript в этом смысле ведет себя точно также.

В следующем примере внутрь функции передается другая функция, определяемая в аргументах. В комментариях показан альтернативный способ через создание константы с функцией.
*/

const sum = identity((a, b) => a + b);
sum(3, 5); // => 8

// const f = (a, b) => a + b;
// const sum = identity(f);
// sum(3, 5); // => 8

/*
Подобная передача функций в функции с определением прямо в аргументах встречается повсеместно в реальном коде. Как правило, те функции, которые передаются в аргументах, нужны только здесь и сейчас.

Возникает вопрос: есть ли имя у функций, определенных подобным образом? Имени нет даже у такой функции const f = () => {}. Мы просто связали константу с функцией, но сама функция ничего про константу не знает. Звучит слегка безумно, но это так. Ведь мы можем взять и связать эту функцию уже с другой константой. По этой причине такие функции часто называют анонимными. Другое распространенное название — лямбда-функция. Своим названием лямбда-функция обязана лямбда-исчислению (математическая формальная система, легшая в основу языков семейства lisp). Только в отличие от языков программирования, "лямбды" в лямбда-исчислении — всегда функции от одного аргумента, поэтому общее с функциями из js у них, в первую очередь, анонимность, и то, что они являются объектами первого класса.

Попробуем сделать что-нибудь полезное. Иногда встречается задача, в рамках которой нужно применить одну и ту же функцию несколько раз, например, так: Math.sqrt(Math.sqrt(16)). Создав функцию высшего порядка, можно упростить эту задачу. Рассмотрим пример с двойным применением одноаргументной функции:
*/

const callTwice = (f, arg) => f(f(arg));

callTwice(Math.sqrt, 16); // => 2
callTwice(x => x ** 2, 3); // => 81
// const f = x => x ** 2;
// f(f(3));

// callTwice применяет переданную функцию к своему аргументу два раза. Если расписать подробнее, то происходит следующее:

const res1 = f(arg);
const res2 = f(res1);
return res2;

const result = ((a, b) => a ** b)(5, 2); // функции можно вызывать сразу после определения.

// Все функции в языке JavaScript являются объектами первого класса.



/**@@
Реализуйте и экспортируйте по умолчанию функцию apply, которая принимает на вход три параметра:

1. Количество раз, которое нужно применить функцию к аргументу (ряд последовательных вызовов, где каждому следующему вызову передается аргумент, являющийся результатом предыдущего вызова функции)
2. Функцию для применения
3. Аргумент для применения
*/

apply(0, Math.sqrt, 4); // => 4
apply(1, Math.sqrt, 4); // => 2

// Math.sqrt(Math.sqrt(16));
apply(2, Math.sqrt, 16); // => 2
// Math.sqrt(Math.sqrt(Math.sqrt(256)));
apply(3, Math.sqrt, 256); // => 2

apply(1, v => v ** 2, 3); // => 9
apply(5, v => v + 10, 3); // => 53

// file: app/apply.js 
const apply = (count, fn, value) => count === 0 ? value : apply(count - 1, fn, fn(value));

export default apply;


// ## TEST
// file: app/__tests__/apply.js 

import apply from '../apply';

test('apply', () => {
  expect(apply(0, Math.sqrt, 4)).toBe(4);
  expect(apply(1, Math.sqrt, 4)).toBe(2);
  expect(apply(2, Math.sqrt, 16)).toBe(2);

  expect(apply(1, v => v ** 2, 3)).toBe(9);
  expect(apply(5, v => v + 10, 3)).toBe(53);
});



>>>>> Лексическое окружение (LexicalEnvironment) <<<<<

/*
Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь LexicalEnvironment (лексическое окружение), привязанный к этому вызову. Все определения констант, переменных и прочего внутри функции автоматически записываются в словарь. Имя определения (идентификатор, то есть имя константы, переменной и так далее) становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и т.д. Лексическое окружение — это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.

В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.
*/

const showWarning = (field) => {
  // LexicalEnvironment = { field: 'email' }
  const warning = `verify your ${field}, please`;
  // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
  console.log(warning);
}

showWarning('email'); // => verify your email, please

/*
Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.

В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.

Из этого поведения есть исключение — возврат функции. В следующем уроке мы рассмотрим связанный с ним механизм так называемых «замыканий». 

Окружение есть не только у функций. Любой идентификатор, определенный на уровне модуля, попадает в лексическое окружение модуля. Кроме того, существует и глобальное окружение. Благодаря ему мы с легкостью используем в JS такие функции, как console.log или Math.sqrt, даже особо не задумываясь, откуда они берутся.
*/

const number = 5;
const square = () => number ** 2;
square(); // => 25

/*
Такой код работает — и это для нас не секрет, но как он вяжется с механизмом окружений? А вот как: интерпретатор производит поиск значения идентификатора не только в локальном лексическом окружении (в том, где используется идентификатор), но и во внешнем окружении. Поиск начинается с локального окружения, и если в нём не найден нужный идентификатор, то просмотр идет дальше, вплоть до уровня модуля, а затем и до глобального уровня.

Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена (а не вызвана!). Если разбить пример выше на два файла, то разница станет очевидной.

Так сработает:
*/

// module1.js
const number = 5;
export const square = () => number ** 2;

// module2.js
import { square } from './module1';
square(); // => 25

// А так нет:

// module1.js
export const square = () => number ** 2;

// module2.js
import { square } from './module1';

const number = 5;
square(); // => ReferenceError: number is not defined

/*
Если подумать логически, так и должно быть. Представьте: если бы сработал второй вариант, то автоматически это бы означало, что вы можете случайно создать имя переменной, совпадающее с именем переменной внутри функции, написанной другим человеком. Как при этом будет работать код — предположить невозможно.

Попробуйте самостоятельно ответить на вопрос: сработает ли такой код, в котором константа определена позже её использования внутри функции?
*/

const square = () => number ** 2;
const number = 5;

square(); // => 25

/*
Ответ: сработает.

Окружение — это не «всё, что было объявлено до функции, в которой я использую эти объявления». Не важно, что number появился позже использования внутри функции. Главное, что вызов функции square происходит позже определения number, а значит к этому времени идентификатор уже был добавлен в окружение, внутри которого была создана функция square.

# Переменные
Когда мы работаем с константами, всё просто. Нет изменений — нет проблем. В случае с переменными ситуация становится сложнее.
*/

const square = () => number ** 2;

let number = 5;
square(); // => 25

number = 3;
square(); // => 9

/*
Изменение переменной следует читать как «изменение значения ключа в окружении». Соответственно, обращение к number всегда вернет последнее присвоенное значение. Завязка на переменные, описанная в коде выше, должна восприниматься как абсолютное зло. Она порождает неявные зависимости, сложный код и отладку. Функция автоматически перестает быть чистой, так как начинает зависеть от внешнего контекста.

# Вложенные функции
*/

const factorial = (n) => {
  const iter = (counter, acc) => {
    if (counter > n) {
      return acc;
    }
    return iter(counter + 1, counter * acc);
  }

  return iter(1, 1);
}

factorial(5); // => 120

/*
В этом коде реализовано вычисление факториала с применением итеративного процесса. Внутри функции factorial определяется внутренняя функция iter, которая накапливает аккумулятор, вызываясь рекурсивно. Условие выхода из рекурсии — попытка посчитать число большее, чем нужно.

В этой проверке используется переменная n, которая явно в iter не передавалась. Но благодаря тому, как работают окружения, любые функции (в том числе и вложенные), определенные внутри factorial, имеют к ней доступ. Как видно из кода, n используется как константа, а значит такое использование абсолютно безопасно.



# Перекрытие (Shadowing)

Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем. Причем не важно, что это: аргумент функции, константа или переменная.
*/

const f = (coll) => {
  const iter(item, coll) => {
    // using coll
  }
  // ...
}

/*
Несмотря на то, что сам код остается рабочим, перекрытие больше не позволяет обратиться к идентификатору из внешнего окружения, ведь поиск всегда происходит сначала в локальном окружении, а уже затем во внешних. Но еще большей проблемой является то, что такой код сложнее в анализе. Глядя на него недостаточно видеть имена, нужно также учитывать их контекст, так как одно и то же имя на разных строках может означать разные вещи. Если запустить линтер для подобного кода, то он укажет на перекрытие как на плохую практику программирования. Подробнее об этом можно прочитать в правилах Eslint https://eslint.org/docs/rules/no-shadow.


Когда внутри функции создается локальное окружение?
> Во время вызова

Когда функция запоминает внешнее окружение?
> Во время определения



/**@@
Реализуйте функцию reverse, переворачивающую строку. В этот раз, используя итеративный процесс. Работа функции основана на двух принципах.
**/

// file: app/reverse.js
export default (str) => {
  const lastIndex = str.length - 1;
  
  const iter = (index, acc) => {
    if (index > lastIndex) {
      return acc;
    }
    return iter(index + 1, `${str[index]}${acc}`);
  }
  
  return iter(0, '');
}


// ## TESTS:
// file: app/__tests__/reverse.test.js:
import reverse from '../reverse';

test('reverse', () => {
  expect(reverse('')).toBe('');
  expect(reverse('z')).toBe('z');
  expect(reverse('zz')).toBe('zz');
  expect(reverse('zza')).toBe('azz');
  expect(reverse('qwerty')).toBe('ytrewq');
});



>>>>> Возврат функций из функций <<<<< 

const identity = v => v;
identity('wow'); // => wow

const sum = identity((a, b) => a + b);
sum(1, 8); // => 9

/*
Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций. Мы даже можем определить функцию внутри другой функции и вернуть её наружу. И в этом нет ничего удивительного. Константы можно создавать где угодно.
*/

const generateSumFinder = () => {
  const sum = (a, b) => a + b;     // создали функцию
  return sum;                      // и вернули её
}

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа


/*
Можно даже обойтись без промежуточного создания константы:
вызвали функцию, которая возвращает функцию, и тут же вызвали возвращенную функцию
*/

generateSumFinder()(1, 5); // => 6
// ((a, b) => a + b)(1, 5)

/*
Всегда, когда видите подобные вызовы f()()(), знайте: функции возвращаются!
Теперь посмотрим, как еще можно описать функцию generateSumFinder:
*/

// предыдущий вариант для сравнения
// const generateSumFinder = () => {
//   const sum = (a, b) => a + b;
//   return sum;
// }

// новый вариант
const generateSumFinder = () => (a, b) => a + b;

// Для понятности можно расставить скобки:
const generateSumFinder = () => ((a, b) => a + b);

/*
Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:
*/

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

sum(1)(3)(5); // => 9

/*
Ту же функцию можно представить другим способом, вынеся каждую функцию в свою собственную константу. Этот способ полезен как мысленный эксперимент, чтобы понять где заканчивается одна и начинается другая функция, но сам по себе он не заработает, потому что теряется замыкание.
*/

const inner1 = z => x + y + z;
const inner2 = y => inner1;
const sum = x => inner2;

/*
Попробуем последовательно пройтись по вызовам функции выше, чтобы понять, как получается результат. После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.
*/

sum(1)(3)(5); // => 9

const sum1 = x => y => z => x + y + z;

// sum(1);
const sum2 = y => z => 1 + y + z; // inner2

// sum(1)(3)
const sum3 = z => 1 + 3 + z; // inner1

// sum(1)(3)(5)
const sum4 = 1 + 3 + 5; // => 9

/*
Как видно выше, sum1, sum2 и sum3 — это функции, а sum4 уже число, так как были вызваны все внутренние функции.
Давайте распишем все функции:
*/

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));

/*
Функция sum принимает x и возвращает функцию, которая
  принимает y и возвращает функцию, которая
    принимает z и возвращает функцию, которая
      возвращает сумму x + y + z

Попробуем развить идею функции callTwice из предыдущего урока. Напишем функцию generate, которая не применяет функцию сразу, а генерирует новую.      
*/

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));

/*
Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:

Создадим функцию f1. Она будет той функцией, которую вернет generate если передать ей функцию Math.sqrt (она вычисляет квадратный корень числа).

Получается, f1 — это функция, которая принимает число и возвращает корень корня — Math.sqrt(Math.sqrt(x)):
*/

const f1 = generate(Math.sqrt);
f1(16); // => 2
// generate(Math.sqrt)(16);

/*
Ещё пример: передадим в функцию generate новую функцию на ходу, без предварительного создания. Переданная функция возводит число в квадрат.
*/

const f2 = generate(x => x ** 2);
f2(4); // => 256
// generate(x => x ** 2)(4);

/*
Теперь функция f2 возводит число в квадрат два раза: (42)2.

Функция generate имеет такое имя не просто так. Дело в том, что возврат функции порождает каждый раз новую функцию при каждом вызове, даже если тела этих функций совпадают:
*/

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false

/*
Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию. 
Запомнить довольно просто, если вы где-то слышите или читаете что происходит генерация функций, значит кто-то их возвращает.

# Замыкание
Работа практически всех описанных примеров базировалась на одном интересном свойстве, которое называется «замыкание». 
*/

const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);

/*
Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.


Функция, которая была возвращена из generateDouble, называется замыканием. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

В СИКП дается прекрасный пример на понимание замыканий. Представьте себе, что мы проектируем систему, в которой нужно запомнить пароль пользователя, а потом проверять его, когда пользователь будет заново заходить. Можно смоделировать функцию savePassword, которая принимает на вход пароль и возвращает предикат, то есть функцию, возвращающую true или false, для его проверки. Посмотрите, как это выглядит:
*/

const secret = 'qwerty';
// Возвращается предикат.
const isCorrectPassword = savePassword(secret);

// Теперь можно проверять
console.log(isCorrectPassword('wrong password')); // => false
console.log(isCorrectPassword('qwerty')); // => true

// А вот как выглядит код функции savePassword:

const savePassword = password => passwordForCheck => password === passwordForCheck;

/*
# Возврат функций в реальном мире (Debug)
Логгирование — неотъемлемая часть разработки. Для понимания того, что происходит внутри кода, используют специальные библиотеки, с помощью которых можно логгировать (выводить) информацию о проходящих внутри процессах, например в файл. Типичный лог веб-сервера, обрабатывающего HTTP запросы выглядит так:


[  DEBUG] [2015-11-19 19:02:30.836222] accept: HTTP/1.1 GET - / - 200, 4238
[   INFO] [2015-11-19 19:02:32.106331] config: server has reload its config in 200 ms
[WARNING] [2015-11-19 19:03:12.176262] accept: HTTP/1.1 GET - /info - 404, 829
[  ERROR] [2015-11-19 19:03:12.002127] accept: HTTP/1.1 GET - /info - 503, 829


В js самой популярной библиотекой для логгирования считается Debug. 

Обратите внимание на левую часть каждой строки. Debug для каждой выводимой строчки использует так называемый неймспейс, некоторую строчку, которая указывает принадлежность выводимой строчки к определенной подсистеме или части кода. Он используется для фильтрации, когда логов становится много. Другими словами, можно указать "выводи сообщения только для http". А вот как это работает:
*/

import debug from 'debug';

const logHttp = debug('http');
const logHandler = debug('handler');

logHttp('hello!');
logHttp('i am from http');

logHandler('hello from handler!');
logHandler('i am from handler');

/* Что приведет к такому выводу:

http hello! +0ms
http i am from http +2ms
handler hello from handler! +0ms
handler i am from handler +1ms

Получается, что импортированный debug — это функция, которая принимает на вход неймспейс в виде строки и возвращает другую функцию, которая уже используется для логгирования.
*/



/**@@
Во многих языках программирования существует интересная функция flip. Её необычность заключается в том, что единственная цель этой функции — это преобразовать другую функцию так, чтобы порядок её аргументов был обратным.

Например, у нас может быть функция pow, которая возводит первый аргумент в степень второго. flip вернет нам новую функцию, у которой первый аргумент — это степень, а второй — это число, которое нужно возводить в эту степень.

Эта функция бывает очень полезна при активной работе с функциями высшего порядка, она часто упрощает возможность комбинировать функции между собой.

Реализуйте и экспортируйте по умолчанию функцию flip. Данная версия flip работает только с функциями от двух аргументов.
**/

// subtraction:
const sub = (a, b) => a - b;
const reverseSub = flip(sub);

sub(5, 3); // 2
reverseSub(5, 3); // -2

// exponentiation:
const wop = flip(Math.pow);

Math.pow(1, 2); // 1
wop(1, 2); // 2

Math.pow(3, 2); // 9
wop(3, 2); // 8


// file: app/flip.js
// #1:
const flip = f => (...args) => { // 
  const revArgs = args.reverse();

  return f(...revArgs);  
}


// #2:
const flip = f => (a, b) => f(b,a);

export default: flip;

// ## TESTS:
// file: app/__tests__/flip.test.js
import flip from '../flip';

test('reverseSub', () => {
  const sub = (a, b) => a - b;
  const reverseSub = flip(sub);
  expect(reverseSub(1, 2)).toBe(1);
  expect(reverseSub(5, 3)).toBe(-2);
});

test('wop', () => {
  const wop = flip((a, b) => a ** b);
  expect(wop(1, 2)).toBe(2);
  expect(wop(3, 2)).toBe(8);
});



>>>>> Частичное применение <<<<<

/*
Частичное применение функций, техника основанная на возможности возвращать функции из других функций. Допустим у нас есть функция sum суммирующая три числа.
*/

const sum = (a, b, c) => a + b + c;
sum(4, 3, 1); // 8
sum(1, 1, 1); // 3

/*
Частичное применение позволяет на основе старой функции, создать новую, которая "частично применена". Для начала вспомним что такое применение функции. Математики никогда не говорят что функция вызывается с некоторыми аргументами, вместо этого они говорят что функция была применена к этим аргументам. В примере выше функция sum была применена к трем аргументам 4, 3 и 1. Такое применение можно назвать полным, то есть в функцию было передано столько аргументов сколько и ожидалось. Здесь возникает вопрос, а можно было по другому? Да можно.

Частичное применение, техника которую проще всего объяснить в отрыве от языков программирования, на языке близком к математике (для простоты назову его Ha). Представьте что наша функция выше, имеет вот такое определение:

-- Слева имя функции, затем идет список параметров
-- разделенных пробелами и после знака => тело функции
*/
sum a b c => a + b + c

/*
А ее вызов выглядит так:
-- Скобок и запятых нет, но это равносильно sum(4, 3, 1) в js
*/

sum 4 3 1 -- 8
sum 1 1 1 -- 3

/*
Ha необычный язык, если внутри него вызвать функцию с неполным набором параметров, то в отличии от js он не вызовет саму функцию (или не упадет с ошибкой как во многих других языках). Он вернет новую функцию, которая "частично применена".

-- sum2 новая функция, полученная частичным применением функции sum к числу четыре
-- Применение "частичное" потому что в функцию sum передается только один параметр, а не три
*/

sum2 = sum 4
sum2 1 1 -- 6
sum2 3 2 -- 9

/*
Другими словами, такой вызов создает новую функцию, которая работает точно так же как и исходная, но, при этом, часть ее аргументов как будто уже подставлены. То есть наш вызов sum2 1 1 в действительности приведет к вызову sum 4 1 1. Этот трюк работает с любым количеством аргументов. Посмотрите на частичное применение двух аргументов:
*/

sum3 = sum 1 1
-- sum3 принимает только один аргумент
sum3 2 -- 4
sum3 1 -- 3

/*
Арифметика аргументов очень простая. Если исходная функция принимала 3 параметра, то после частичного применения одного параметра, новая функция будет принимать на вход два параметра (2 + 1 = 3), если частично применились два параметра, то новая функция принимает на вход 1 параметр. А можно ли частично применить три параметра для функции которая принимает на вход 3 параметра? Конечно нет, ведь это будет обычный вызов функции со всеми параметрами. Довольно несложно догадаться как выглядело бы определение функций sum2 и sum3 если бы мы их описали явно:
*/

sum a b c => a + b + c
sum2 b c => 4 + b + c
sum3 c => 1 + 1 + c

// Ha настолько необычный язык, что позволяет частично применять то что уже было частично применено:
// -- Создаем первую функцию с 3 - 1 аргументами
sum4 = sum 2
// -- Создаем вторую функцию с 2 - 1 аргументами
sum5 = sum4 3
// -- Вызываем то что получилось. В реальности вычисляется 2 + 3 + 1
sum5 1 -- 6
sum5 4 -- 9

// В js эта возможность не встроена прямо в сам язык, но ее можно реализовать с помощью дополнительной функции:
const sum = (a, b, c) => a + b + c;

// Берем исходную функцию sum и отдаем ее в функцию partialApply
const sumWithFour = partialApply(sum, 4);
sumWithFour(3, 1); // 8
sumWithFour(10, 3); // 17

const sumWithFourAndTwo = partialApply(sumWithFour, 2);
sumWithFourAndTwo(3); // 9

/*
Функция partialApply принимает на вход исходную функцию и параметры которые нужно применить, а возвращает новую, частично примененную функцию.
Вот как может выглядеть реализация partialApply для функций от трёх аргументов (таких как sum):
*/

const partialApply = (fn, arg1) => (arg2, arg3) => fn(arg1, arg2, arg3);

/*
Немного примеров из реальности. Предположим, что мы пишем программу, вычисляющую зарплату людей разных специальностей по всему миру. Для этого используется функция getAverageSalary.
*/

const salary1 = getAverageSalary('programmer', 'spain');
const salary2 = getAverageSalary('programmer', 'russia');
const salary3 = getAverageSalary('programmer', 'usa');

/*
Первым параметром функция принимает на вход название профессии, вторым — страну, на выходе — годовая зарплата. Все довольно примитивно, но часть данных дублируется. Вычисляется зарплата программистов в разных странах, что приводит к постоянному вызову функции с первым параметром programmer. В этом нет ничего криминального, но существует способ устранить подобное повторение. Убрать с помощью введения дополнительной константы.
*/

const job = 'programmer'
const salary1 = getAverageSalary(job, 'spain');
const salary2 = getAverageSalary(job, 'russia');
const salary3 = getAverageSalary(job, 'usa');

/*
Название профессии больше не повторяется, но нам по-прежнему приходится подставлять его в каждый вывод. Здесь на помощь приходит так называемое частичное применение функции.
*/

const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Принцип действия частичного применения функции основан на генерации (в нашем случае с помощью функции partialApply) новой функции оборачивающей старую, причем так, что она принимает на вход меньшее количество аргументов. Для нашей задачи мы применили один аргумент, но это не обязательно. Применять можно любое число аргументов исходной функции (но, естественно, не все, ведь в таком случае мы получим обычный вызов функции). И хотя пример выше выглядит слегка искусственным, в реальной жизни этот прием применяется часто. Причем нередко частично применяется больше одного аргумента за раз.

Тело функции getProgrammersSalaryByCountry выглядит предсказуемо. Внутри вызывается исходная функция с подставленным в аргумент значением.
*/

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

// А partialApply для функций от двух аргументов, реализуется способом очень похожим на реализацию flip.
const partialApply = (fn, arg1) => arg2 => fn(arg1, arg2);

/*
То есть функция partialApply возвращает (генерирует) функцию, которая внутри себя замыкает два параметра: fn и arg1.

Частичное применение для JS — практически как воздух для живых организмов. Из-за асинхронной природы JS часто бывают ситуации, когда одни параметры функции задаются в одном месте, а другие в другом, так как они становятся доступны только после выполнения асинхронной операции. Поскольку вы еще не обладаете достаточными знаниями для понимания соответствующего кода, я не буду приводить более сложных примеров, чтобы не сбивать вас с толку, но уверяю, что в дальнейших курсах все, что изучалось здесь, будет использоваться на полную катушку.

Возможно ли частичное применение без замыкания?
> Нет. Частичное применение подразумевает запоминание аргументов функции/


/**
Реализуйте и экспортируйте по умолчанию функцию partialApply. Эта функция умеет частично применять один (второй) аргумент у переданной функции:
**/

const pow = (a, b) => a ** b;
const f1 = partialApply(pow, 2);
f1(1); // => 1
f1(10); // => 100

const f2 = partialApply((a, b) => a * b, 5);
f2(2); // => 10
f2(5); // => 25


// file: app/partialApply.js:

export default (f, second) => first => f(first, second);

export default partialApply;


// ## TESTS:
// file: app/__tests__/partialApply.test.js:

import partialApply from '../partialApply';

test('partialApply', () => {
  const f1 = partialApply((a, b) => a ** b, 2);
  expect(f1(1)).toBe(1);
  expect(f1(10)).toBe(100);

  const f2 = partialApply((a, b) => a * b, 5);
  expect(f2(2)).toBe(10);
  expect(f2(5)).toBe(25);
});



>>>>> Каррирование <<<<<

/*
Каррирование — очень интересная техника, позволяющая сильно упростить использование частичного применения на практике. Многие путают эти понятия, но, как вы увидите далее, они обозначают совершенно разные вещи.

В предыдущем уроке нам приходилось писать функцию-обертку для применения.
*/

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Eсли бы наша функция getAverageSalary была каррирована, то все было бы значительно проще. Каррирование — это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.

Предположим, что у нас есть функция const sum = (a, b, c) => a + b + c, которая складывает три числа. Тогда ее каррированная версия будет выглядеть так: const sum2 = a => b => c => a + b + c, а использование таким: sum2(5)(10)(-2). То же самое, разложенное по функциям:
*/

const sum2 = (a) => {
  return (b) => {
    return (c) => {
      return a + b + c;
    };
  };
}

/*
Посмотрите внимательно на определение a => b => c => a + b + c. Эта запись очень краткая и одновременно очень емкая. Суммарное количество функций считается очень легко, оно равно сумме всех стрелок =>. Для лучшего понимания можно добавить скобки a => (b => (c => a + b + c)). Для каждого определения функции все, что находится справа от стрелки, является ее телом, каким бы сложным оно не было. Поначалу такая запись может помочь понять, как друг в друга вложены функции, но со временем, когда вы привыкните к обычной записи, она будет больше мешать.

С другой стороны, если нам нужно каррировать существующую функцию без ее реализации, то делается это так: const sum2 = a => b => c => originalSum(a, b, c). То есть создается цепочка вложенных функций, в которой количество вложений равно количеству аргументов исходной функции и в конце которой происходит вызов оригинальной функции.

Разберем происходящее по шагам.
*/

const sum = a => b => c => a + b + c;
const sum1 = sum(10); // sum1 = b => c => 10 + b + c
const sum2 = sum1(3); // sum2 = c => 10 + 3 + c
const result = sum2(0); // result = 10 + 3 + 0
console.log(result); // 13

/*
То же самое происходит и при таком вызове: sum(10)(3)(0), разница только в том, что вызовы происходят без создания промежуточных констант.

И задача для самоконтроля. Сколько раз нужно вызвать цепочку функций const greeting = () => () => () => () => console.log('Hey!'), чтобы дойти до конца? Обязательно попробуйте прямо сейчас выполнить это задание на repl.it.

Теперь вернемся к нашей функции расчета зарплаты в ее каррированном виде. Представим, что теперь у нас в распоряжении две вложенных функции от одного аргумента: const getAverageSalary = job => country => /* body */:

const salary1 = getAverageSalary('programmer')('spain');
const salary2 = getAverageSalary('programmer')('russia');
const salary3 = getAverageSalary('programmer')('usa');

// Попробуем частично применить:

const getProgrammersSalaryByCountry = getAverageSalary('programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Применение в реальной жизни

В функциональных языках, подобных haskell, вопросов об использовании каррированных функций просто не встает. Они там используются постоянно, начиная с самых азов. Это одна из причин, почему стоит учить подобные языки, даже если вы не будете писать на них программы. В императивных языках такое происходит значительно реже, но не в JS. JS по своей сути очень близок к функциональным языкам. Изначально он должен был быть написан на Scheme, языке из семейства Lisp, и функции в нем занимают центральное место. Каррирование используется в различных библиотеках и иногда является их ключевой "фичей", как, например, здесь: https://github.com/substantial/updeep.




/**@@
Удивительно, но факт — условные конструкции можно реализовать самостоятельно с использованием одних лишь каррированных функций.

В этой практике мы реализуем упрощённую версию, имитирующую работу условной конструкции if.

Экспортируйте тройку True, False, If, используя только функции, внутри которых только функции ;) То есть нельзя пользоваться встроенными в язык if, а также true и false. Сами функции должны быть каррированы.

Пример использования:
**/

import { If, True, False } from './logic';

If(True)('one')('two');  // one
If(False)('one')('two'); // two

/*
Подсказки
Общая схема работы функций такова:
*/

If(func)('one')('two'); // ?

/*
То есть, в итоге должно вернуться то или иное значение, в зависимости от того, какая функция передана на вход If.
Если функции If была передана True, то выражение ниже вернёт значение аргумента первого вызова (one):
*/
const ConditionTFunction = If(True);
ConditionTFunction('one')('two'); // => one

// Если функции If была передана False, то выражение ниже вернёт значение аргумента второго вызова (two):
const ConditionRFunction = If(False);
ConditionRFunction('one')('two'); // => two


// file: app/logic.js 
export const True = x => () => x;
export const False = () => y => y;

export const If = f => f;


// # TESTS:
import { If, True, False } from '../logic';

test('Boolean', () => {
  expect(If(True)('fo')('bar')).toBe('fo');
  expect(If(False)('foo')('ba')).toBe('ba');
  expect(True()()).toBeUndefined();
  expect(False()()).toBeUndefined();
});



/**@@
Реализуйте и экспортируйте по умолчанию каррированую версию функции, которая принимает на вход три строки и возвращает новую строчку составленную из трех входных.
**/
// исходная версия
concat('a', 'bc', 'f'); // => abcf

// каррированая версия
concat('a')('bc')('f'); // => abcf


// file: app/concat.js
export default str1 => str2 => str3 => `${str1}${str2}${str3}`;


// file: app/__tests__/compose.test.js

import concat from '../concat';

test('compose', () => {
  expect(concat('')('')('')).toBe('');
  expect(concat('a')('bc')('f')).toBe('abcf');
});



/**@@
Реализуйте и экспортируйте по умолчанию функцию compose, которая принимает на вход две других одноаргументных функции и возвращает новую функцию. Эта новая функция также принимает на вход один параметр и при вызове применяет его последовательно к переданным функциям в обратном порядке.

Примеры ниже помогут понять, как должна работать функция:
**/

const f = compose(Math.sqrt, Math.abs);
f(-4); // => 2

compose(v => v, v => v)(10); // => 10
compose(v => v + 2, v => v)(10); // => 12
compose(v => v, v => v - 2)(10); // => 8
compose(v => v ** 2, v => v - 2)(2); // => 0
compose(v => v - 2, v => v ** 2)(2); // => 2


// file: app/compose.js:
export default (f, g) => x => f(g(x));


// # TESTS:
// file: app/__tests__/compose.test.js:

import compose from '../compose';

test('compose', () => {
  expect(compose(v => v, v => v)(10)).toBe(10);
  expect(compose(v => v + 2, v => v)(10)).toBe(12);
  expect(compose(v => v, v => v - 2)(10)).toBe(8);
  expect(compose(v => v ** 2, v => v - 2)(2)).toBe(0);
  expect(compose(v => v - 2, v => v ** 2)(2)).toBe(2);
});


/** 
Числа Черча
В 30-х годах прошлого века перед математиками встала так называемая проблема разрешения (Entscheidungsproblem), сформулированная Давидом Гильбертом. Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение. Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? Ответ был найден двумя великими учёными того времени Алонзо Чёрчем и Аланом Тьюрингом. Они показали (первый — с помощью изобретённого им λ-исчисления, а второй — теории машины Тьюринга), что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима.

Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики. Пока в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…

В основе лямбда-исчисления лежит понятие, известное ныне каждому программисту, — анонимная функция. В нём нет встроенных констант, элементарных операторов, чисел, арифметических операций, условных выражений, циклов и т. п. — только функции, только хардкор. Потому что лямбда-исчисление — это не язык программирования, а формальный аппарат, способный определить в своих терминах любую языковую конструкцию или алгоритм. В этом смысле оно созвучно машине Тьюринга, только соответствует функциональной парадигме, а не императивной.

Как уже говорилось ранее, в чистом бестиповом лямбда-исчислении отсутствует всё, кроме функций. Так что даже такие элементарные вещи, как числа или булевы значения необходимо реализовывать самим. Точнее, надо создать некие активные сущности, которые будут вести себя подобно необходимым нам объектам. И, естественно, процесс кодирования будет заключаться в написании соответствующих функций.

Натуральные числа реализованные посредством лямбда-исчисления, называются числами Черча, и являются отличной разминкой для мозга. В основе реализации по-прежнему будут лежать функции, ведущие себя в заданном контексте подобно единице, двойке и т.д. Собственно, это одна из особенностей лямбда-исчисления: сущности, записанные в его терминах, не обладают самодостаточностью, поскольку воплощают поведение того или иного объекта.

Реализуйте число Zero и операцию Succ (увеличение на единицу). Не забудьте про экспорт.
Пример:
*/

const two = Succ(Succ(Zero));

// Немного хитрый способ трансформировать число черча в обычное представление.
// Откровенно говоря, устройство самих чисел еще хитрее ;)

two(x => x + 1)(0); // 2

const four = Succ(Succ(two));
four(x => x + 1)(0); // 4


// file: app/numerals.js:
export const Zero = () => x => x;

export const Succ = n => f => x => f(n(f)(x));


// ## TESTS:
// file: app/__tests__/numerals.test.js

import { Zero, Succ } from '../numerals';

it('numerals', () => {
  const two = Succ(Succ(Zero));
  expect(two(x => x + 1)(0)).toBe(2);

  const four = Succ(Succ(two));
  expect(four(x => x + 1)(0)).toBe(4);

  expect(four(two(x => x + 1))(0)).toBe(8);
});




############################### JS: Настройка окружения ###############################

// Ubuntu
$ curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash -
$ sudo apt install -y nodejs

/*
Теперь убедимся в том, что Node.js поставлена и работает. Вероятно, в некоторых операционных системах понадобится перезапустить терминал или даже перезагрузиться.
Проверяем:
*/

$ node -v
v10.0.0

/*
Версия, которую вы увидите, должна быть не ниже 8.

Если все прошло удачно, самое время повыполнять код на js. Node.js поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для ее запуска достаточно набрать node:
*/

$ node
>

/*
Если все прошло успешно, то REPL выведет приглашение для ввода инструкций: >. Попробуйте поиграться с ним. Наберите любое арифметическое выражение, например, 1 + 3 и нажмите Enter. Обратите внимание на то, что нет необходимости использовать console.log. REPL автоматически распечатывает последний вычисленный результат.

Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
*/

$ node
> a = 5
5
> b = 10
10
> a + b
15

/*
Чтобы выйти из REPL, нужно либо набрать .exit и нажать Enter, либо два раза нажать CTRL + C

Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением js, например, index.js, а затем запустить:
*/
// file: index.js
console.log('hello!');

$ node index.js
hello!

/*
# NVM
Совсем другой способ установки Node.js — утилита nvm. Кроме установки любых версий Node.js, она позволяет удобно переключаться между версиями. Это может понадобится, когда вы одновременно работаете над двумя проектами, требующими разные версии Node.js.


# ECMAScript
Основа js — язык ECMAScript. ECMAScript — это встраиваемый, расширяемый, не имеющий средств ввода-вывода (то есть он не может писать и читать файлы) язык программирования, используемый в качестве основы для построения других скриптовых языков. По сути, он существует только на бумаге. Стандартизирован международной организацией ECMA в спецификации ECMA-262. JS основан на ECMAScript, но расширяет его. Кстати, js не единственный язык, расширяющий ECMAScript. Кроме него также используются JScript и ActionScript.

Интересно, что сам по себе ECMAScript никакого отношения ни к браузерам, ни к вебу не имеет. Несмотря на это, сам ECMAScript развивается и имеет не одну версию, которая также называется стандартом:

es3
es5.1
strict mode
ECMAScript 2015 (es6)
es7 ?


# JavaScript
JavaScript — динамический, слабо типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.

# Интерпретируемый
У js отсутствует стадия компиляции, как у языков, подобных Java или C. Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на js состоит из текстовых файлов.
*/
$ node
> eval('10 * 3 + Math.random()')

/*
# Динамический
В отличие от статических языков, проверка типов в js происходит в момент выполнения кода. А значит, если мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статическими анализаторами кода. Слово статический как раз означает, что программа не выполняется. Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок. 

# Слабо типизированный
Слабая типизация означает, что js автоматически приводит типы там, где считает нужным. Подробнее этот механизм описан в спецификации. С одной стороны, слабая типизация позволяет писать более короткий код. С другой стороны, количество ошибок резко возрастает, так как вместо остановки выполнения, код продолжает работать там, где он не должен работать. Например, мы можем сложить число со строкой по ошибке, и js молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Никогда не полагайтесь на эту особенность языка, во избежание проблем.
*/

$ node
> 3 + '8ha'
'38ha'
> '8ha' * 3
NaN
> true + 1
2



>>>>> NPM <<<<<

/*
Node.js поставляется вместе с программой NPM. Она выполняет множество функций, которые не представляется возможным рассмотреть в рамках текущего курса. Рекомендуем периодически посматривать на ее команды и изучать информацию по ним. Ключевая задача, которую решает NPM — управление зависимостями, и именно о ней мы поговорим.

Практически с самого зарождения программирования: с тех пор, когда код стал храниться в памяти компьютера, появилась идея повторного использования кода не только в рамках одного проекта, но и во многих других. В разных проектах используются одни и те же функции для работы с датами, математическими формулами, всевозможными расчетами. Подобное переиспользование кода приводит к резкому росту производительности. Программисты современности могут сосредоточиться на решении уникальных задач бизнеса, вместо создания своих велосипедов для решения инфраструктурных задач. Все стало еще проще с появлением git и github.

Первоначально общий код выносился в файлы, которые программисты часто держали на своих собственных компьютерах и копировали из проекта в проект. Такой способ обладает рядом существенных недостатков:

Код сложно передать другим.
У каждого разработчика своя собственная копия одинаковых или почти одинаковых решений одних задач.
Доработкой занимается только автор.
Существует много разных копий без возможности быстрого обновления.
Из-за того, что код копируется прямо в другой проект, он, как правило, модифицируется и становится специфичным.
Если использовать git, то часть проблем решается автоматически. Cоздается набор общих файлов, который называется "библиотека". Конечные проекты, в свою очередь, начинают использовать библиотеки, написанные нами или сторонними разработчиками. Но тут возникает следующая сложность: когда таких библиотек становится много, у них также появляется общий код более низкого уровня. Например, финансовые библиотеки могут использовать функции для преобразования валют. Чтобы подобный код не дублировался, хочется вынести его в общедоступное место. Этот процесс может продолжаться бесконечно. Одни библиотеки зависят от других, те в свою очередь от третьих и так далее. С точки зрения переиспользования кода все хорошо: большое число маленьких библиотек, решающих всевозможные задачи, позволяет быстро двигаться вперед в разработке. Но с точки зрения управления этим зоопарком появляются проблемы:

Появляются новые версии библиотек. Из-за этого они начинают зависеть не только друг от друга, но и от разных версий друг друга. Зачем это нужно? Предположим, что создатель сторонней библиотеки, от которой зависит наша библиотека, обновил ее так, что изменил сигнатуры функций или, как говорят, сломал обратную совместимость. Теперь в них другое число параметров, другие параметры, другой возврат. Если мы обновим стороннюю библиотеку, наша первоначальная библиотека перестанет работать. Она рассчитывала на одно поведение библиотеки, от которой зависела, а получила другое.
Необходимо стандартизировать способ создания библиотек. Только в таком случае станет возможным автоматизировать процесс их соединения. Стандартный веб-проект может зависеть от сотни библиотек, которые в свою очередь зависят от сотен других библиотек. Общее число зависимостей может легко перевалить за тысячу. Управлять таким количеством зависимостей вручную невозможно.
Из проблемы, описанной выше, вытекает необходимость в автоматизированном средстве управления зависимостями: их обновлению, установке и удалению.
Всеми этими вопросами и занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.


# Терминология

В NPM используются следующие понятия:

Пакет (Package) — базовая единица, которой управляет NPM как единым целым. Может содержать любое количество файлов и кода. NPM позволяет устанавливать пакеты, обновлять или удалять.

Реестр (Registry) — хранилище пакетов NPM. Каждый желающий может опубликовать пакет в npm registry, потратив буквально минуту, а остальные смогут его использовать. В хранилище на текущий момент сотни тысяч пакетов и их количество стремительно растет. Исходный код пакетов, как правило, хранится на гитхабе. Несмотря на это, пакеты в npm никак не связаны с git и github.

# Глобальная установка пакетов

Многие пакеты в npm представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту sloc, которая умеет считать количество строк кода в указанной папке. Инструкция по установке обычно находится на странице репозитория в гитхабе.
*/
$ sudo npm install -g sloc

/*
Отмечу несколько моментов:
  -g — этот флаг говорит о том, что нужно установить пакет глобально, то есть в такое место, которое доступно для всех пользователей системы.
  sudo — нужно потому, что это место чаще всего недоступно для записи обычным пользователям (в Ubuntu это, скорее всего, /usr/local/lib).
после команды install можно перечислять любое количество пакетов через пробел.
Глобальная установка пакета sloc:

Процесс установки занимает некоторое время, в течение которого видно, как скачивается не только сам пакет, но и его зависимости. Дальше ничего делать не нужно, так как sloc создан утилитой командной строки и сразу готов к использованию.

# Создайте файл index.js в любом месте вашей файловой системы и добавьте туда любой код (например, печать на экран)
# Затем вызовите программу sloc, используя терминал. Для этого перейдите в директорию, содержащую этот файл, и выполните команду:
*/
$ sloc index.js // =>

/*
---------- Result ------------

            Physical :  2
              Source :  2
             Comment :  0
 Single-line comment :  0
       Block comment :  0
               Mixed :  0
               Empty :  0
               To Do :  0

Number of files read :  1

------------------------------

# Пакет

NPM работает таким образом, что объединяет понятия "проект" и "библиотека" в одно целое. И то и другое оформляется, как пакет NPM. Причем проект может быть любых размеров. Даже если ваше приложение состоит из 3 строчек кода, вам понадобится работать с ним, как с полноценным проектом.

Для создания пакета необходимо выполнить команду npm init в той директории, где вы собираетесь писать код. С этого момента эта папка будет корневой для вашего пакета.
*/
$ npm init

/*
После ввода данной команды вам предложат ответить на десяток вопросов, например, ввести имя вашего проекта, его описание, имя автора (вас как создателя) и тому подобное. Некоторые вопросы имеют ответы по умолчанию, например имя проекта или его версия. NPM предлагает для названия проекта использовать имя директории, внутри которой запускается npm init. Это полезное соглашение, которого стоит придерживаться (по необходимости переименуйте саму директорию).

# Если нажать Enter, то ответом на вопрос станет значение по умолчанию
*/
package name: (js_setup_environment_course) // ответ по умолчанию указан в скобках

// Когда вопросы закончатся, npm покажет конечный результат в виде JSON. JSON — это формат для представления структурированных данных.

{
  "name": "My Super Project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

/*
В этом JSON содержатся ответы которые вы дали ранее. NPM спросит все ли хорошо с ним? Если вы ответите утвердительно, то NPM создаст файл package.json, куда поместит данный вывод (JSON). В дальнейшем вы всегда сможете открыть его в обычном текстовом редакторе и поправить, если понадобится. Файл package.json крайне важен для правильной работы NPM. Кроме информационных полей типа имени автора, есть и функциональные поля, которые влияют на то как будет работать пакет. Они изучаются далее на протяжении всего курса.

# Проблемы

Если в файле package.json содержатся синтаксические ошибки, иными словами, там нарушены правила форматирования JSON, то при попытке сделать что-то с проектом будут появляться подобные ошибки:
*/
npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected string in JSON at position 225 while parsing '{
npm ERR!   "name": "gendiff_freetonik",
npm ERR!   "vers'
npm ERR! File: /Users/a/cpackage.json
npm ERR! Failed to parse package.json data.

// или такие:

npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected token n in JSON at position 207 while parsing near '...
npm ERR!   "engines": {
npm ERR!     node: 8
npm ERR!   },
npm ERR!   "scri...'
npm ERR! File: /Users/a/c/package.json
npm ERR! Failed to parse package.json data.

/*
Обычно любое сообщение с «неожиданными» (unexpected) символами или строками означает наличие синтаксической ошибки.

Воспользуйтесь валидаторами JSON для проверки верности своего файла: jsonlint.com или другими подобными инструментами, которые можно загуглить по запросу "json validator".

Другая проблема связана с тем, что NPM во время установки пакетов нередко выводит подобные сообщения:
*/

npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0.

/*
Бояться их не надо, это не сообщения об ошибках. Deprecated warning — сообщение, сигнализирующее о том, что нечто устарело. Под этим «нечто» может скрываться все, что угодно и часто не по вашей вине. Например, в package.json могут использоваться свойства, которые в новых версиях NPM называются по-другому. К этим предупреждениям стоит прислушиваться, но на работу они не влияют.


# Код пакета

После завершения процесса инициализации, можно приступать к самому главному — написанию кода. По умолчанию код пакета создается внутри файла index.js, лежащего в корне проекта (там, где создан файл package.json). Это не значит, что весь пакет состоит из одного файла. Файлов с кодом можно создавать сколько угодно, главное, при этом, что основная работа происходит внутри index.js, куда импортируется код из остальных файлов.


# Самостоятельная работа

Клонируйте nodejs-package к себе на компьютер (документация по клонированию https://help.github.com/articles/cloning-a-repository/).
Установите (глобально) пакет sloc.
Выполните команду sloc path/to/nodejs-package и изучите вывод. Где path/to/nodejs-package путь до директории nodejs-package клонированного на ваш компьютер.

Дополнительные материалы
NPM https://www.npmjs.com/
Документация NPM https://docs.npmjs.com/


В чём разница между секциями dependencies и devDependencies в структуре конфигурационного файла package.json?
> Секцию dependencies необходимо использовать для описания зависимостей, которые будут нужны при использовании программы, а devDependencies только для тестирования и локальной разработки.

Как правильно использовать установленную библиотеку (например hexlet-pairs) в файле с кодом?
*/
import { cons, car, cdr } from 'hexlet-pairs';




>>>>>> Публикация пакета <<<<<<

/*
Утилита sloc, которую мы использовали в прошлом уроке, создана обычным программистом как пакет NPM. Каким образом она стала доступна для установки? Дело в том, что недостаточно просто создать пакет и залить (git push) его код на гитхаб. Так NPM ничего о нем не узнает. При установке неизвестного пакета NPM выдаст соответствующее предупреждение:
*/

$ npm install unkownpackagename // =>
/*
npm ERR! code E404
npm ERR! 404 Not Found: unkownpackagename@latest


Утилита npm не смогла найти пакет в своем хранилище пакетов, о чем радостно нам и сообщила. Разберемся с добавлением нашего пакета в хранилище NPM.

Если мы хотим дать разработчикам возможность использовать наш пакет, то необходимо выполнить его публикацию. Публикация пакета сводится к запуску команды npm publish в корне нашего проекта:

Ниже показан процесс публикации пакета из репозитория https://github.com/hexlet-boilerplates/nodejs-package
*/
$ cd nodejs-package
$ npm publish

/* =>
> nodejs-package@0.0.2 prepublishOnly .
> npm run build

> nodejs-package@0.0.2 build /Users/hex/projects/nodejs-package
> NODE_ENV=production babel src --out-dir dist --source-maps inline

src/bin/hexlet.js -> dist/bin/hexlet.js
src/half.js -> dist/half.js
src/index.js -> dist/index.js
+ nodejs-package@0.0.2


Вывод может быть довольно большим. Главное, что здесь не видно явных ошибок и в конце такая строчка: + nodejs-package@0.0.2. Она сигнализирует о том, что пакет с именем nodejs-package был добавлен в NPM хранилище под версией 0.0.2. Как только публикация пройдет, ваш пакет автоматически станет доступным для установки. Убедиться в этом можно следующим образом:
*/

$ sudo npm install -g nodejs-package

/* =>
npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0. Please update to graceful-fs@^4.0.0 as soon as possible. Use 'npm ls graceful-fs' to find it in the tree.
/usr/local/bin/hexlet -> /usr/local/lib/node_modules/nodejs-package/dist/bin/hexlet.js
+ nodejs-package@0.0.2
added 187 packages in 16.11s

Как видите, в конце снова появляется строчка + nodejs-package@0.0.2, но теперь она означает, что пакет nodejs-package версии 0.0.2 был установлен.


И для полноты картины еще два способа найти нужный пакет и убедиться, что он есть в NPM хранилище:

1. Поискать на сайте https://www.npmjs.com/
2. Выполнить команду npm info nodejs-package. Если вы увидите информацию о пакете, то все хорошо. В противном случае возникнет ошибка.

Для успешной публикации должны выполниться два условия:

Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет, что и понятно, ведь тогда станет невозможным разобраться чей ставить пакет при указании этого имени.
Вы зарегистрированы на сайте https://www.npmjs.com/ и выполнили локально аутентификацию, запустив в командной строке npm login (синоним команды npm adduser). Такое требование важно с точки зрения безопасности. Пакет может публиковать только зарегистрированный пользователь, а обновлять — автор пакета.
В случае обновления, версия нового пакета должна быть выше версии текущего опубликованного пакета. Подробнее об этом пункте в разделе Версионирование.


Иногда требуется простая провека, что все настройки публикации выполнены правильно. Для этого не обязательно публиковать cам пакет в хранилище. Можно воспользоваться опцией --dry-run. Она сохраняет весь процесс публикации кроме фактического добавления пакета в NPM. При этом будут выведены подробности публикации:
*/

$ npm publish --dry-run


/* =>
> nodejs-package@0.0.3 prepublishOnly .
> npm run build

> nodejs-package@0.0.3 build /Users/hex/projects/nodejs-package
> NODE_ENV=production babel src --out-dir dist --source-maps inline

Successfully compiled 3 files with Babel.
npm notice
npm notice 📦  nodejs-package@0.0.3
npm notice === Tarball Contents ===
npm notice 1.6kB package.json
npm notice 1.1kB README.md
npm notice 852B  dist/bin/hexlet.js
npm notice 622B  dist/half.js
npm notice 711B  dist/index.js
npm notice === Tarball Details ===
npm notice name:          nodejs-package
npm notice version:       0.0.3
npm notice package size:  2.3 kB
npm notice unpacked size: 4.8 kB
npm notice shasum:        e9d86f87706327cb5afd3d2d594a3c8922dd2f4d
npm notice integrity:     sha512-xnK7Kuq2e7IGI[...]ZIMd7JXP9YPjA==
npm notice total files:   5
npm notice
+ nodejs-package@0.0.3



# Версионирование

В разработке принято версионировать программное обеспечение. Версия — это номер либо группа номеров (иногда с буквами или словами), которая обозначает какой-то конкретный этап разработки данного кода. Вот некоторые примеры: 0.0.2, 1.0.32, 1.33. С конкретной версией кода всегда связаны какие-то изменения относительно предыдущей версии, например, новые фичи, исправления багов или улучшения, такие как повышение производительности.

Зачем нужны версии в библиотеках? В первую очередь из-за обратной совместимости. Жизнь течёт, всё меняется и со временем библиотеки начинают работать по-другому, используют более удобные и современные подходы. В свою очередь код который их использует, не меняется одновременно с ними, а значит мы не можем гарантировать того, что наш код заработает с другой, более новой версией библиотеки. Поэтому нужна возможность фиксировать версию до тех пор, пока наш код не будет готов к использованию новой. Подробнее поговорим об этом в уроке про зависимости.

Современное версионирование кода основано на универсальном стандарте, который называется SEMVER http://semver.org/lang/ru (семантическое версионирование). По стандарту, версия представляет из себя три числа разделенных точками: 1.23.5. Каждое из этих чисел имеет собственно имя и предназначение:

Первое число (1 в примере выше) — мажорная версия. Меняется только в случае серьезных изменений, как правило, ломающих обратную совместимость
Второе число (23 в примере выше) — минорная версия. Не должна ломать обратную совместимость (в идеале). Меняется при добавлении новых возможностей.
Третье число (5) — патч. Гарантировано не должна менять обратную совместимость (к сожалению такое бывает). Меняется только при исправлении багов.
К сожалению, соответствие требованиям, целиком и полностью ответственность разработчиков. Автоматическая проверка (верификация) невозможна. Поэтому бывают сбои, когда версионирование происходит неверно, но в целом такой подход работает и упрощает работу.

Обратите внимание на то, что версия 1.12.3 выше, чем версия 1.3.3, потому что 12 больше чем 3.

# Самостоятельная работа
Зарегистрируйтесь на сайте https://www.npmjs.com/ (это пригодится для участия в проектах).
*/

>>>>>> Зависимости <<<<<<
/*
Основное предназначение пакетов - удобный способ делиться общим кодом. Возьмем для примера библиотеку lodash, которая очень широко используется в JavaScript и добавляет много маленьких функций, решающих различные повседневные задачи. Посмотрите на список функций слева https://lodash.com/docs/4.17.11. Их там больше сотни! Ниже типичный пример использования:
*/

// По общепринятому соглашению, lodash импортируется под именем _
import _ from 'lodash';

// capitalize делает первую букву заглавной
_.capitalize('hello'); // Hello

/*
Как только мы добавили подобный код (с импортом кода из другой библиотеки, а не локального файла) в наш проект (или библиотеку), мы получили так называемую зависимость. Теперь наш проект зависит от пакета lodash. Обратите внимание на то, как написано слово lodash. Перед ним нет указания текущей директории ./, именно так NPM понимает, что это внешняя зависимость, а не файл, лежащий рядом.

Возникает закономерный вопрос, как начать использовать эту библиотеку в своем коде? Если мы попытаемся импортировать ее как в примере выше, то получим закономерную ошибку о том, что пакет не найден. Во время запуска кода, все что импортируется, должно быть установлено локально в директорию node_modules лежащую в корне проекта. Делается это уже знакомой нам командой npm install, но в этот раз без флага глобальной установки. Для добавления пакета lodash, перейдите в корневую директорию того пакета, который вы разрабатываете и выполните следующую команду:

Имя пакета всегда совпадает с именем, которое указывается в части импорта, идущей после from
from 'lodash';
*/
$ npm install lodash

// После завершения установки, вы увидите что файл package.json изменился. В него добавилась секция dependencies с таким содержимым:
"dependencies": {
  "lodash": "^4.2.1"
}

/*
Отличие от глобальной установки состоит в том, что здесь нет флага -g и не нужно использовать sudo. При таком подходе зависимости ставятся в директорию node_modules, находящуюся в корне проекта. Кроме того, NPM создаст файл package-lock.json рядом с файлом package.json. Этот файл должен храниться в репозитории, а его значение я объясню в следующем уроке.

Теперь NPM знает о том что ваш проект (он же пакет) зависит от lodash.

Кроме обычных зависимостей, NPM отдельно обрабатывает зависимости необходимые только во время разработки. К таким пакетам относятся тестовые фреймворки и тому подобные вещи. Их установка немного отличается:
*/
$ npm install --save-dev jest

/*
Флаг --save-dev приводит к тому что зависимость добавляется в секцию devDependencies файла package.json. Эти зависимости никак не используются при публикации пакета, что позволяет экономить память. В остальном механизм работы тот же: они скачиваются и сохраняются в директорию node_modules и импортируются внутри кода как и любой другой код.
*/

"devDependencies": {
  "jest": "^23.6.0",
  "jest-cli": "^23.6.0"
}

/*
К сожалению, на текущем этапе код, указанный выше, не будет работать в любом случае. Связано это с тем, что Node.js напрямую не поддерживает синтаксис импортов и для их использования нужно подключить пакет Babel. 

Сами зависимости не хранятся в git-репозитории и должны быть добавлены в .gitignore:
*/

// FILE: .gitignore
node_modules

/*
Если вы клонировали репозиторий с гитхаба, директория node_modules будет отсутствовать, как и пакеты в ней. Первое, что нужно сделать в этом случае — выполнить команду npm install. Эта команда, запущенная без аргументов, выполняет установку тех пакетов, которые указаны в файле package.json. Она запускается в разных случаях: если вы удалили папку node_modules и хотите снова ее восстановить или если вы только что клонировали репозиторий. Установка пакетов — идемпотентная операция, поэтому ее можно запускать сколько угодно раз, не боясь что-либо сломать.

# Самостоятельная работа:
Изучите зависимости в репозитории nodejs-package https://github.com/hexlet-boilerplates/nodejs-package. Попробуйте найти репозитории зависимых пакетов.
*/



>>>>>> Lock файл <<<<<<

/*
Поговорим об обновлении зависимостей. Для обновления всех зависимостей нужно выполнить команду npm update. Чтобы выполнить обновление конкретной зависимости — npm update name, где name — имя библиотеки. А вот то, как будет происходить обновление, зависит от того, что написано в package.json.

Рассмотрим все доступные варианты:
*/

dependencies {
  'package1': "*",
  'package2': "1.3.5",
  'package3': "~2.3.4",
  'package4': "^2.3.4",
}


/*
* означает, что можно ставить любую версию библиотеки. После выполнения команды обновления в папке node_modules окажется последняя доступная версия package1.
1.3.5 - конкретный номер. Если версия библиотеки жестко зафиксирована, никакая команда не сможет обновить ее.


Самый интересный сценарий происходит в случае использования тильды (~). Напомню, что в семантическом версионировании считается, что patch (последняя цифра в версии) изменяется только в случае исправления ошибок, а значит обратная совместимость не должна теряться. На практике это не всегда так, код может работать с учетом ошибок в зависимостях. Как правило, в проектах десятки, а то и сотни зависимостей, причем обновляются они очень часто. С одной стороны, можно всегда писать *, но тогда мажорные обновления библиотек могут сломать систему. С другой стороны, можно зафиксировать все версии, но тогда обновлять все придется вручную, а значит, по закону Мерфи, никто не будет этого делать. Поэтому появился третий вариант. Добавление тильды приводит к тому, что в автоматическом режиме обновляются только патчи. Предположим, что после добавления зависимости в проект, версия была установлена в ~2.10.3. Если после нее в npm репозитории появилась 2.10.5, то она будет установлена командой обновления. То же самое произойдет, если потом будет выпущена версия 2.10.15. Но если создатель библиотеки опубликует изменения в мажорной или минорной версии, например 2.11.5 или 3.0.0, то npm их проигнорирует.

Примерно то же самое происходит и при использовании ^ ("крышки"), только в отличие от тильды, она фиксирует мажорную версию, а минорная обновляется наравне с патчем.

# Lock

На предыдущем шаге каждая новая установка зависимостей сначала создавала, а потом обновляла файл package-lock.json.

Попытаемся разобраться, зачем он нужен. Как мы помним, в package.json указываются зависимости, и мы научились устанавливать и обновлять их. У каждой зависимости могут быть свои собственные зависимости, которые тоже обновляются — и так до бесконечности. Зависимости зависимостей называются транзитивными и с ними не все так просто. Настолько не просто, что существует понятие "dependency hell" (ад зависимостей).


Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей. Предположим, что в нашем пакете есть зависимость A с зафиксированной версией 1.3.2, у которой в зависимостях стоит пакет B с версией *. В такой ситуации в отсутствие лок файла npm install установит указанную версию зависимости A и последнюю доступную версию пакета B. Такое поведение не детерминировано. Если создатель пакета B обновит его так, что нарушится обратная совместимость, наш проект просто сломается, так как перестанет работать A. Если мы полгода не заходим в проект, а затем зайдем и поставим зависимости заново, удалив папку node_modules или выполнив новое клонирование, то почти наверняка ничего не заработает. Пакеты обновляются часто, и какой-нибудь из них обязательно изменит мажорную версию за столь длинный срок.

Очевидный, но не рабочий выход из данной ситуации — вручную отслеживать зависимости всех зависимостей и явно прописывать их версии в package.json. Такой способ сработает, но даже в проекте на js, который содержит всего 5 зависимостей, транзитивных зависимостей будут сотни! Вдумайтесь в эту цифру. Я уже не говорю про то, что пакеты обновляются и меняются. Такую ситуацию невозможно контролировать, и зависимости просто перестанут обновляться.

Другой выход — требовать, чтобы создатели всех библиотек всегда жестко указывали версии. Из-за человеческого фактора этот вариант обречен на провал. Автоматизация такого процесса привела бы к полному параличу системы пакетов и библиотек, а значит и разработки программ.

И тут на сцену выходит lock-файл. Он представляет собой автоматизированное решение первого способа. Его содержимое выглядит примерно так:
*/

{
  "name": "hexlet-co",
  "version": "0.1.4",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "JSONStream": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.1.tgz",
      "integrity": "sha1-cH92HgHa6eFvG8+TcDt4xwlmV5o=",
      "requires": {
        "jsonparse": "1.3.1",
        "through": "2.3.8"
      }
    },
    "abab": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/abab/-/abab-1.0.4.tgz",
      "integrity": "sha1-X6rZwsB/YN12dw9xzwJbYqY8/U4=",
      "dev": true
    },
    "acorn": {
      "version": "4.0.13",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-4.0.13.tgz",
      "integrity": "sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c="
    },
    ...
  }
}

/*
Первый запуск установки зависимостей формирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные, и их версии. При дальнейших запусках npm install всегда ставится то, что указано в lock файле, даже если стереть папку node_modules, а в npm-хранилище добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь всегда можно быть уверенным, что если заработало сейчас, то заработает потом и не только у нас.

Наличие lock файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в package.json, обновился и может быть обновлен до указанной версии, то загрузится новая версия, а файл lock обновится автоматически. После этого нужно не забыть залить его в git-репозиторий.

На самом деле, lock-файл ведет себя сложнее, но для понимания схемы его работы достаточно описанного выше. Если хотите разобраться в теме от и до — изучите официальную документацию.

Как и любой автоматически генерируемый файл, lock-файл не может правиться вручную, потому что ваши изменения сразу будут сброшены при следующей генерации.

# Самостоятельная работа
Клонируйте репозиторий nodejs-package, а затем выполните внутри него команду npm update. Изучите вывод команды git diff.
Попробуйте изменить версию любого пакета в package.json, указав точную версию без использования ^, и выполните npm install. Доступные версии пакета можно посмотреть командой: npm view <packagename> versions, например: npm view eslint versions.

В каких случаях происходит создание и обновление файла package-lock.json?
> При установке новых зависимостей
> При установке доступных обновлений существующих зависимостей
*/

>>>>>> NPX <<<<<<

/*
Не все устанавливаемые зависимости, используются внутри кода как библиотеки. Некоторые нужны для различных утилитарных задач. К подобным пакетам относится eslint. Eslint - это программа для проверки кода на соответствие стандартам кодирования, она используется на Хекслете для проверки ваших решений как в практике к урокам так и в проектах, где вы будете устанавливать ее самостоятельно. Существует два способа ее установки, глобальный и локальный.

Глобальная установка позволяет установить eslint один раз и затем использовать его во всех необходимых пакетах, которые мы разрабатываем:
*/
$ sudo npm install -g eslint
$ cd my-package

// eslint требует указать директорию, в которой нужно искать файлы для проверки. Точка означает текущую директорию:
$ eslint .

/*
Хотя такой способ установки кажется заманчивым, все же, его стоит избегать. Глобальные зависимости не ставятся при первоначальной настройке пакета. То есть если мы выполним команду npm install в свежесклонированном репозитории, eslint не поставится, а значит придется устанавливать его отдельно. И это придется делать не только нам, но и всем кто участвует в разработке данного пакета. К тому же возможны проблемы с версиями. Если у кого-то стоит eslint старой версии, это может помешать нормальной проверке, и в такой ситуации не будет никакой возможности обновить версию пакета автоматически, это произойдет только если разработчик сам вспомнит о том, что пакет стоит обновить.

Поэтому наш выбор - локальная установка. Подобные пакеты всегда используются только при разработке, поэтому не забываем указывать флаг --save-dev во время локальной установки:
# В корне проекта
*/
$ npm install --save-dev eslint

/*
Но здесь нас ожидает сюрприз. Если попробовать его запустить как обычно, то bash скажет что команда не найдена (если, конечно, вы не установили его глобально ранее).
# В корне проекта
*/

$ eslint .
bash: eslint: command not found

/*
Такое поведение вполне ожидаемо. Вспомните, курс по основам командной строки и урок посвященный запуску программ из консоли. Исполняемый файл программы ищется по путям перечисленным в переменной окружения $PATH. В случае локальной установки, пакет устанавливается в директорию node_modules и только туда, никакие файлы больше никуда не добавляются. Другими словами bash не может узнать о том, что вы установили какую-то программу.

Из этой ситуации есть два выхода: правильный и неправильный. Неправильный - запустить исполняемый файл указав прямой путь. Для eslint он будет таким:
*/
$ ./node_modules/.bin/eslint --init // инициализация линтера, во время которой создается конфигурационный файл
$ ./node_modules/.bin/eslint . // запуск проверки в текущей и всех вложенных директориях

/*
Проблема такого подхода в том, что идет завязка на конкретный путь внутри самого пакета. Если разработчики поменяют его или банально переименуют файл eslint.js, то все запуски сломаются. Поэтому нужно использовать правильный способ:
*/
$ npx eslint --init
$ npx eslint .

//  npx - специальная программа, которая автоматически устанавливается вместе с утилитой npm (убедитесь что вы ставите одну из последних версий Node.js). Она имеет такой формат работы:

$ npx <тут любая программа, установленная как локальный пакет NPM> <тут опции этой программы>

/*
То есть npx добавляется слева к любому вызову, при этом сама команда никак не меняется.

Как работает npx? Эта утилита меняет $PATH для конкретного вызова, добавляя туда путь ./node_modules/.bin. Именно поэтому начинают работать локально установленные программы.

Например для написания тестов в js, мы используем тестовый фреймворк Jest. Он ставится как обычная зависимость в проект и дальше запускается через команду jest:
*/

$ npm install --save-dev jest

// Пример вызова без npx
$ jest
// => bash: jest: command not found

// А теперь правильно
$ npx jest
// =>  тут побежали тесты



>>>>>> Scripts <<<<<<

// Секция Scripts позволяет описывать произвольные команды, которые затем можно выполнять.
"scripts": {
  "test": "jest",
  "build": "NODE_ENV=production babel src --out-dir dist --source-maps inline",
  "prepublishOnly": "npm run build"
}

// Рассмотрим пример. Предположим, что мы установили программу sloc как зависимость и хотим ее запускать с определенными параметрами.
"scripts": {
    ...
    "sloc": "sloc",
    ...
}

/*
Имя свойства используется как команда в командной строке, значение — исполняемая программа. Теперь, если вы попробуете сделать так: npm run sloc, то все отработает как и ожидается.

Некоторые свойства в Scripts имеют особое значение. Например, на Хекслете код проверяется автоматическими тестами с использованием библиотеки jest. Она содержит бинарник с тем же именем и все, что нужно сделать для запуска тестов - выполнить команду jest. Мы могли бы сделать в скриптах такую запись: "jest": "jest", но именно для тестов NPM предлагает делать так: "test": "jest". Главное отличие подобных встроенных команд — в их способе запуска. Достаточно набрать npm test вместо npm run test, хотя второй вариант также сработает.
*/

nodejs-package$ npm test

/* =>
> nodejs-package@0.0.1 test /Users/mokevnin/hexlet/nodejs-package
> jest

 PASS  __tests__/half.test.js
  ✓ half (3ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.242s, estimated 1s
Ran all test suites.

# Hooks

Есть целый набор предопределенных свойств в Scripts, которые NPM запускает автоматически в разные моменты жизни. Подробнее об этом можно прочитать в официальной документации https://docs.npmjs.com/misc/scripts. Одним из таких свойств является свойство prepublishOnly, которое используется тогда, когда перед публикацией пакета в репозиторий NPM необходимо выполнить некоторые действия, например, сгенерировать документацию. Команда, указанная в нем, запустится во время выполнения npm publish.

Самостоятельная работа
Попробуйте выполнить скрипт test в пакете nodejs-package https://github.com/hexlet-boilerplates/nodejs-package


Допустим, в файле package.json прописан следующий скрипт:

"scripts": {
  "eslint": "eslint --colors"
}


Как выполнить проверку файла index.js линтером используя npm?
> npm run eslint index.js


Допустим, в файле package.json прописан следующий скрипт:
"scripts": {, так как в секции scripts есть скрипт с ключом start
  "start": "bin/index.js"
}
Какими способами нужно запускать скрипт start используя npm? Выберите все правильные ответы.
> npm run start, так как в секции scripts есть скрипт с ключом start
> npm start, так как start является дефолтной для npm командой, а значит ключ run можно опустить
*/




>>>>>> Babel <<<<<<

/*
Итак, мы знаем, что есть спецификация, а есть ее реализация. Знаем, что реализация зачастую отстает от спецификации. Более того, разные реализации по-разному отстают от спецификации. Написав код, мы не можем гарантировать, где он будет запускаться, а где — нет.

Исходя из этого можно сделать вывод, что нужно писать код, придерживаясь старых стандартов. К счастью, есть другой путь: мы можем писать код с использованием всех возможных фич, но перед публикацией автоматически транслировать его (то есть переводить из одного вида в другой) в старую версию. Звучит сложно, но на практике все просто.

Сама природа JS и его способы использования готовят нас к тому, что никогда не настанет светлых времен с современными рантаймами. Люди использовали и продолжат использовать разные браузеры и разные версии браузеров, разные версии Node.js и так далее. Использование новых синтаксических конструкций в такой ситуации практически невозможно. Запуск кода на платформе, не поддерживающей новый синтаксис приведет к синтаксической ошибке. Закономерным решением этой проблемы стало появление Babel — программы, которая берет указанный код и возвращает тот же код, но транслированный в старую версию JS. Фактически, в современном мире Babel стал неотъемлемой частью JS. Его не используют только в старых проектах, также называемых легаси-проектами. Все новые проекты так или иначе делают с его использованием.

У Babel есть собственный онлайн REPL https://babeljs.io/repl/. Попробуйте вставить туда любой код, который вы писали на Хекслете, и посмотрите, во что он превратится. Такая трансляция называется транспайлингом, а сам Babel называют транспайлером, от transpiler https://en.wikipedia.org/wiki/Source-to-source_compiler.
*/

// before:
const factorial = (n) => {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

// after:
"use strict";

var factorial = function factorial(n) {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
};

/*
Babel состоит из многих частей:

Пакет @babel/core содержит код, который выполняет всю работу по трансляции, но не содержит внутри себя правил преобразования. Правила описаны в отдельных пакетах, называемых плагинами (например, babel-plugin-transform-constant-string).

@babel/preset-env. Пресет - это группа плагинов, которую можно подключить к Babel целиком. preset-env - основной пресет поддерживаемый командой Babel, который содержит внутри себя плагины, реализующие стандартизированные возможности js.

Пакет @babel/cli обеспечивает возможность работы с бабелем через терминал. Предоставляет командную утилиту babel. Ниже рассматривается ее использование.

Пакет @babel/node - еще одна утилита командной строки: babel-node. 


# Установка
*/
$ npm install --save-dev @babel/core @babel/cli @babel/node @babel/preset-env


/*
# Настройка

Babel полагается на наличие файла babel.config.js в корне проекта. Именно через него он узнает, как нужно транслировать код.

Этот файл нужно создать самостоятельно. Если вы забудете добавить туда плагин или пресет, то на выходе Babel отдаст тот же код, что был и на входе.
*/

module.exports = {
  presets: [
    ['@babel/env', {
      targets: {
        node: 'current',
        firefox: '60',
        chrome: '67',
        safari: '11.1',
      },
    }],
  ],
};

/*
Разные среды исполнения поддерживают (или не поддерживают) разные возможности и синтаксические конструкции языка. В свойстве targets перечисляются конкретные окружения (и их версии), для которых пишете код. Если код предназначен для выполнения на nodejs, то достаточно указать только его. В таком случае babel будет транслировать конструкции, поддерживаемые на nodejs, и ничего лишнего:
*/

module.exports = {
  presets: [
    ['@babel/env', {
      targets: {
        node: 'current',
      },
    }],
  ],
};

/*
Минимально достаточно подключить пресет @babel/preset-env. Он добавляет возможности JS, которые входят в стандарт.

# Использование

При появлении в проекте Babel, изменяется файловая структура проекта. Так как код существует в двух состояниях: исходном и транслированном, то удобно создать две директории, под каждый набор исходников. 
Исходный код, принято хранить в директории src в корне проекта, а код полученный в результате трансляции - в директории dist.

# Команда babel предоставляется пакетом @babel/cli:
*/
$ npx babel src --out-dir dist

/*
Эта команда берет весь код из файлов в директории src и создает его транслированную версию в директории dist. Запускается он точно так же, как и любой другой код, и фактически именно этот код нужно доставить в NPM-репозиторий. Другими словами, пользователи вашего пакета запускают код из директории dist, а не src, хотя сами об этом не знают. Сама директория dist добавляется в .gitignore, так как сгенерированный код нужен только в момент публикации пакета для упаковки в архив, который уходит в NPM-репозиторий. В процессе разработки пакета, запуск сборки не требуется.

Есть только один маленький нюанс. Изначально я сказал, что NPM никак не интегрирован с Git, но это не совсем правда. По умолчанию NPM смотрит в файл .gitignore. Все, что там перечислено, не попадет в NPM-репозиторий при публикации пакета. В нашем случае такой директорией является dist, но именно ее мы и хотим опубликовать. Выходов из этой ситуации несколько. Один связан с файлом .npmignore и описан в документации, про другой я скажу подробнее. NPM позволяет указать список файлов и папок, которые нужно опубликовать. Достаточно добавить секцию files в package.json. Содержимое files — массив директорий и файлов:
*/

"files": [
  "dist"
]

/*
Существует два способа подготовки пакета к публикации. Первый подход заключается в том, чтобы перед выполнением npm publish вручную сгенерировать каталог dist, используя скрипты: npx babel src --out-dir dist. Подход рабочий, но сопряжён с постоянными ошибками в стиле "ой, забыл собрать новый код". К тому же, это действие может быть автоматизировано — именно эту идею и реализует второй подход. NPM содержит множество предопределённых скриптов, которые выполняются автоматически в определённые этапы работы. Например, prepublishOnly запускается перед непосредственным выполнением публикации. То, что нам и требуется.
*/

"scripts": {
  "build": "NODE_ENV=production babel src --out-dir dist",
  "prepublishOnly": "npm run build"
}


/*
В примере выше используется небольшой трюк. В prepublishOnly вызывается другой скрипт — build. Этот приём используется широко, и он действительно удобен. Бывают ситуации, когда все же нужно запускать сборку руками. Поэтому удобно иметь отдельную команду только для генерации. Скрипт build как раз и призван решить эту задачу.

Подчеркну еще раз: каталог dist не должен храниться в git-репозитории, и вы не найдете его на Гитхабе. Посмотрите lodash. Она генерируется только в момент публикации пакета и заливается в npm-репозиторий. Каждая новая публикация должна генерировать этот каталог заново. Только в этом случае обновится код в пакете.

Подведём итог. В git-репозитории хранится исходный код, ещё не обработанный babel. Это значит, что вы всегда можете найти библиотеку и изучить её содержимое на github. А вот пакет, установленный к вам в систему содержит обработанный код, предназначенный для запуска, а не для чтения. Этот код не хранится в git-репозитории. Он попадает в NPM-репозиторий в момент публикации новой версии пакета за счет выполнения команды prepublishOnly (в которую вы сами должны прописать вызов трансляции).

# Babel-node

При использовании новых возможностей js, запуск кода на выполнение node file.js, упадет с ошибкой, потому что внутри файла используется синтаксис, который нода не понимает. Для запуска кода после каждого изменения, необходимо выполнять трансляцию. Этот процесс выглядит так:

1 Делаем изменение.
2 Транслируем код с помощью Babel.
3 Запускаем на выполнение.

Разработчики Babel предусмотрели эту ситуацию. В этом случае можно установить пакет @babel/node. Теперь код можно вызывать так: npx babel-node src/index.js. Команда babel-node делает одновременно две вещи. Транслирует код и сразу же запускает его на выполнение. В отличие от команды babel, babel-node не сохраняет результат трансляции. Все происходит во время работы в памяти. Обратите внимание на то, что вам все равно понадобится правильно настроенный файл babel.config.js в корне проекта иначе babel-node не сможет произвести трансляцию и так же завершится с ошибкой синтаксиса на момент запуска.

# Самостоятельная работа
Попробуйте выполнить скрипт build в пакете nodejs-package. Изучите результаты его работы в папке dist. Вы должны увидеть, что содержимое файлов внутри dist отличается от содержимого тех же файлов внутри src. Вместо const использован var, вместо import - require. В целом код остается читаем, хотя и выглядит странновато.



Как устанавливать Babel?
> Добавить необходимые пакеты в devDependencies и создать конфигурационный файл babel.config.js

С помощью какой утилиты можно сразу увидеть результат выполнения Babel кода?
> babel-cli

Как автоматизировать процесс доставки кода прошедшего через Babel в NPM репозиторий?
> Использовать скрипт prepublishOnly, который выполняется автоматически перед командой npm publish

Какой код в итоге должен попасть в NPM репозиторий?
> Исходный код прошедший обработку через Babel. Только так будет обеспечена максимальная совместимость со всеми интерпретаторами.

Рассмотрим ситуацию, когда в файле .gitignore имеется следующее содержимое:
.*.swp
dist
npm-debug.log
Как опубликовать пакет так, чтоб в него попал каталог dist не меняя при этом содержимое файла .gitignore?
> Создать файл .npmignore (можно даже пустой), так как для NPM он представляет наибольший приоритет
> Добавить в package.json секцию files и записать в неё dist
*/



>>>>>> Source Map <<<<<<

/*
В самых простых случаях транслированный код выглядит почти так же, как и исходный. Но стоит начать использовать чуть более продвинутые возможности JS, как код изменяется до неузнаваемости:
*/

// Было:
const defaultState = { channels: {}, messages: {} };
let state = { ...defaultState };

export default router => router.put('refresh', '/refresh', async (ctx) => {
  state = { ...defaultState };
});

// Стало:

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultState = { channels: {}, messages: {} };
var state = _extends({}, defaultState);

exports.default = function (router) {
  return router.put('refresh', '/refresh', function (ctx) {
    state = _extends({}, defaultState);
    ctx.status(200);
  });
};

/*
Трансляция не дается бесплатно. Получившийся код нечитаем и его невозможно нормально отладить. Ведь теперь запускается не наш первоначальный код, а транслированный. Это значит, что любая логическая ошибка нашего кода будет указывать на транслированный код, который в свою очередь очень сильно отличается от исходного, поскольку:

 - Babel может заменять имена переменных.
 - Строчки, на которые указывает stacktrace — отчет о вызванных функциях после возникновения ошибки в программе, в исходном и транслированном файле не совпадают. Более того, stacktrace указывает только на транслированный код.
 - В одних и тех же ситуациях возникают разные ошибки. Например, если вы забыли экспортировать функцию по умолчанию, то после трансляции вы увидите такое сообщение: TypeError: (0 , _path2.default) is not a function вместо Module 'path' has no default export.


Для решения этой проблемы используется специальный механизм под названием "source map" или "маппинг". Его принцип действия следующий. При транспайлинге кода создается структура определенного формата, в которой описана связь сгенерированного кода с исходным кодом. Затем эта структура записывается либо в отдельный, либо прямо в сгенерированный файл в виде комментария (inline mode). Затем, во время выполнения программы, она используется интерпретатором для построения правильных стектрейсов и ссылок.

Пример содержимого файла index.js.map с маппингом: 
*/
{"version":3,"sources":["../src/index.js"],"names":["co","generator","args","iterator","enerator","next","result","value","Promise","resolve","done","then","res","throw","err","reject"],"mappings":";;;;;;AAEA;;;;AAEA;;;;;;;;;;;;;AAaA,IAAMA,KAAK,SAALA,EAAK,CAACC,SAAD,EAAyC;AAAA,oCAAdC,IAAc;AAAdA,QAAc;AAAA;;AAClD,MAAMC,WAAWC,6CAAYF,IAAZ,EAAjB;;AAEA,MAAMG,OAAO,SAAPA,IAAO,CAACC,MAAD,EAAY;AACvB,QAAMC,QAAQC,QAAQC,OAAR,CAAgBH,OAAOC,KAAvB,CAAd;AACA,QAAID,OAAOI,IAAX,EAAiB;AACf,aAAOH,KAAP;AACD;;AAED,WAAOA,MAAMI,IAAN,CACL;AAAA,aAAON,KAAKF,SAASE,IAAT,CAAcO,GAAd,CAAL,CAAP;AAAA,KADK,EAEL;AAAA,aAAOP,KAAKF,SAASU,KAAT,CAAeC,GAAf,CAAL,CAAP;AAAA,KAFK,CAAP;AAID,GAVD;;AAYA,MAAI;AACF,WAAOT,KAAKF,SAASE,IAAT,EAAL,CAAP;AACD,GAFD,CAEE,OAAOS,GAAP,EAAY;AACZ,WAAON,QAAQO,MAAR,CAAeD,GAAf,CAAP;AACD;AACF,CApBD;;kBAsBed,E","file":"index.js","sourcesContent":["// @flow\n\nimport 'source-map-support/register';\n\n/**\n * Generator based control flow\n * @name co\n * @example\n * co(function* () {\n *   const result = yield Promise.resolve(true);\n *   return result;\n * }).then(value => {\n *   console.log(value);\n * }, err => {\n *   console.error(err.stack);\n * });\n */\nconst co = (generator: () => void, ...args: any) => {\n  const iterator = enerator(...args);\n\n  const next = (result) => {\n    const value = Promise.resolve(result.value);\n    if (result.done) {\n      return value;\n    }\n\n    return value.then(\n      res => next(iterator.next(res)),\n      err => next(iterator.throw(err)),\n    );\n  };\n\n  try {\n    return next(iterator.next());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n};\n\nexport default co;\n"]}

// А в конце сгенерированного файла index.js будет такая строчка:
//# sourceMappingURL=index.js.map

/*
Эта техника не является специфичной для JS. Она используется повсеместно там, где применяется транспайлинг.

Babel

Babel поддерживает source map из коробки. Для его генерации достаточно добавить флаг --source-maps в процесс компиляции:
*/
$ npx babel script.js --out-file script-compiled.js --source-maps inline


/*
После выполнения этой команды в конце транслированных файлов появится source map в виде комментария. Однако, если речь идет про Node.js (а не браузер), то этого недостаточно. На текущий момент Node.js не имеет встроенной поддержки source map, поэтому даже если вы их сгенерировали, нода никак не отреагирует на их наличие. Их поддержку можно добавить с помощью npm пакета https://github.com/evanw/node-source-map-support https://github.com/evanw/node-source-map-support.

# Самостоятельная работа
Пропустите код nodejs-package https://github.com/hexlet-boilerplates/nodejs-package через Babel, включив генерацию Source Map в отдельных файлах.


Для чего нужен Source Map?
> Для отладки кода прошедшего транспайлинг путём добавления карты, указывающей на реальную структуру исходных файлов

Как сгенерировать source map для файла hexlet.js используя Babel?
> npx babel hexlet.js --out-file hexlet-compiled.js --source-maps

Как автоматически сгенерировать source map для всех файлов в папке dist при сборке пакета?
> Добавить babel src --out-dir dist --source-maps в значение ключа build секции scripts
*/




>>>>>> Точка Входа <<<<<<

/*
В курсе "Введение в программирование" использовался только один вид импортов — импорт из локальных файлов. Подобные импорты отличает указание относительного пути (./) в секции from.
*/

import { length } from './strings';
import factorial from './factorial';

/*
Все подобные импорты объединяет то, что в них мы обращаемся к конкретному файлу, лежащему где-то рядом. Его всегда можно открыть и посмотреть содержимое. Но в реальных проектах и дальше в курсах, вам будут встречаться нелокальные импорты:
*/

import path from 'path';
import fs from 'fs';
import lodash from 'lodash';

/*
Как видите, в импортах выше, нет начального ./. Некоторые из них, по сути, тоже локальные — это импорты из стандартной библиотеки. В указанном примере к ним относятся первые два импорта из модулей path и fs. Эти модули лежат где-то в системных директориях — там, куда они были помещены во время установки Node.js. Посмотреть список всех модулей стандартной библиотеки можно в официальной документации https://nodejs.org/api/modules.html

Самое интересное происходит при импорте сторонних npm-пакетов: import lodash from 'lodash';. Дело в том, что пакет — не то же самое что и модуль. Модуль — один файл, а пакет — набор файлов, в которые входят модули и package.json. Посмотрите содержимое репозитория lodash. В корне проекта находится, наверное, сотня файлов.


Возникает закономерный вопрос. Если внутри одного пакета множество модулей, то что же импортируется если мы пишем import lodash from 'lodash'?

В npm принято соглашение, что по умолчанию всегда импортируется файл index.js, находящийся в корне проекта. Этот файл является точкой входа в пакет. Все остальные модули, как правило, собираются внутри index.js. Но это поведение можно изменить. За это отвечает свойство main (главный) в файле package.json. Посмотрите его значение в пакете lodash. В нашем эталонном пакете nodejs-package эта строчка выглядит так:
*/
"main": "dist/index.js"

/*
Сам файл dist/index.js в репозитории отсутствует, как впрочем и папка dist. Как вы помните из урока про babel, эта директория формируется только в момент публикации пакета и заливается в npm, но в репозиторий ее не добавляют.


В какой секции файла package.json задаётся точка входа?
> "main": "path/to/file"

Какой файл вашего проекта является точкой входа по умолчанию?
> index.js
*/



>>>>>> Исполняемые файлы <<<<<<

/*
Многие пакеты представляют из себя приложения командной строки, так называемые cli-утилиты, взаимодействие (запуск команд, передача аргументов и опций, вывод результатов) которых с пользователем происходит интерактивным образом через терминал. Для обеспечения такой возможности (запуск файлов из командной строки) в npm существует секция bin конфигурационного файла package.json, например:
*/

"bin": {
    "hexlet": "dist/bin/hexlet.js"
}

/*
Эта запись означает, что при установке пакета в операционной системе будет физически создан файл (а точнее, его особая разновидность — символическая ссылка, symlink) с именем hexlet, запуск которого приведёт к запуску файла вашего проекта по адресу dist/bin/hexlet.js. Также обратите внимание, что количество ссылок может быть множество (столько, сколько сами укажете в секции bin).

Месторасположение символической ссылки и способ её запуска из командной строки различаются в зависимости от способа установки пакета: глобального (с флагом -g: npm -g install packageName) или локального. Рассмотрим каждый случай отдельно.


# Глобальная установка: генерация ссылок и запуск исполняемых файлов
При глобальной установке пакета npm создаёт символические ссылки в каталоге по умолчанию /usr/bin (или /usr/local/bin, в разных системах значение может отличаться, кроме того оно может конфигурироваться https://docs.npmjs.com/misc/config с помощью npm). Это каталог для прикладных программ общего назначения, распространённый в операционных системах семейства UNIX, и путь к нему прописан в переменной окружения PATH. Именно поэтому мы можем запускать приложение по имени символической ссылки из командной строки, находясь в любой точке файловой системы (ведь при поиске исполняемых файлов командная оболочка ищет их последовательно по всем путям, прописанных в переменной окружения PATH).

Посмотреть, в какую директорию npm складывает ссылки на исполняемые файлы можно с помощью команды:
*/
$npm bin -g // npm bin --global.

// Посмотреть содержание переменной окружения PATH в вашей системе можно так:
echo $PATH
echo $PATH | grep /usr/bin


// Если вы пользуетесь системой управления версиями nvm (Node Version Manager, позволяет удобно использовать разные версии nodejs в рамках одной операционной системы), то каталог для символических ссылок может быть другой, например:
npm -g bin

/*
Как видно, для каждой версии nodejs менеджер nvm создаёт отдельный каталог bin для ссылок на исполняемые файлы устанавливаемых на нём пакетов. Но суть от этого не меняется — самое главное, чтобы путь к каталогу был в переменной окружения PATH (в данном случае nvm автоматически добавляет путь к каталогу в PATH).

Пример
Давайте создадим и опубликуем пакет, который для краткости и наглядности будет очень простым, состоящим всего из двух исполняемых файлов, запуск которых выводит соответственно приветствие и прощание с Хекслетом.

Структура проекта:
*/
~/projects/smallTalkWithHexlet$ ls -al
drwxrwxr-x  2 hex hex 4096 июн 12 16:35 ./
drwxrwxr-x 18 hex hex 4096 июн 12 16:22 ../
-rw-rw-r--  1 hex hex  340 июн 12 16:49 package.json
-rwxrwxr-x  1 hex hex   69 июн 12 16:29 sayBye.js*
-rwxrwxr-x  1 hex hex   52 июн 12 16:31 sayHi.js*


// Содержимое исполняемого файла sayHi.js:
~/projects/smallTalkWithHexlet$ cat sayHi.js
#!/usr/bin/env node

console.log('Hello, Hexlet!');

// Содержимое исполняемого файла sayBye.js:
~/projects/smallTalkWithHexlet$ cat sayBye.js
#!/usr/bin/env node

console.log('Bye-bye! See you later, Hexlet!');


// Содержимое конфигурационнного файла package.json:
~/projects/smallTalkWithHexlet$ cat package.json
{
  "name": "small_talk_with_hexlet",
  "version": "1.0.0",
  "description": "Small talk with Hexlet",
  "main": "",
  "bin": {
    "sayHi": "./sayHi.js",
    "sayBye": "./sayBye.js"
  },
  "keywords": [
    "hexlet"
  ],
  "author": "hex",
  "license": "MIT"
}


/*
Небольшое отступление про исполняемые файлы:

1 Для возможности запуска файла из командной строки у пользователя должно быть право на выполнение (атрибут x) этого файла.
2 Если исполняемый файл содержит код, то надо указать командной оболочке интерпретатор, который будет исполнять этот код при запуске исполняемого файла. Это делается с помощью так называемого шебанга. В примерах выше (#!/usr/bin/env node) мы указали в качестве интерпретатора node, а путь к нему задали не абсолютный (в разных системах node может лежать по совершенно разным путям), а с помощью специальной утилиты env.

Итак, пакет опубликован и теперь доступен для установки под именем small_talk_with_hexlet (если решите опубликовать аналогичный пакет, то вам надо будет придумать своё уникальное имя для него).

Теперь установим этот пакет в систему глобально.

Но сначала убедимся, что никаких символических ссылок в директории не существует.
*/
$ npm bin --global
$ ls -al /usr/bin | grep 'say'

/*
Здесь с помощью фильтра grep мы попытались найти файлы, содержащие в своём имени (как наши ссылки в секции bin) строчку "say". Но поиск не дал результатов, потому что таких файлов (до установки пакета) нет.

Далее глобально устанавливаем пакет в систему:
*/
$ npm -g install small_talk_with_hexlet

/*
Как видно из лога установки выше, создалось две символические ссылки с указанием на какие файлы приложения они ведут.

Теперь снова проверим с помощью grep директорию установки исполняемых файлов.
*/
$ ls -al /usr/bin/ | grep 'say'
$ ls -al /usr/bin/say*

/*
Как и ожидалось, в этом каталоге лежат символические ссылки (об этом свидетельствует первый символ l, определяющий тип файла в строке атрибутов файла lrwxrwxrwx), которые мы можем запускать из любой точки файловой системы:
*/
$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!
$ cd /media/
$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!


/*
Из примера видно, что мы можем успешно запускать одни и те же команды из разных директорий. Почему так происходит подробно обсуждалось выше.

# Что происходит при локальной установке
В подавляющем большинстве случаев для целей разработки пакеты устанавливаются не глобально, а локально. При такой установке они "привязываются" к конкретному проекту и размещаются внутри его каталога по пути ./node_modules/. При этом ссылки на исполняемые файлы устанавливаемых пакетов npm размещает в каталоге ./node_modules/.bin.

Ссылки на исполняемые файлы локально установленных пакетов "заточены" на использование их в скриптах (секция scripts конфигурационного файла package.json), для чего существует особенный синтаксис. Эту тему мы проходили в одном из предыдущих уроков, посвящённых скриптам.

Естественно, к символическим ссылкам можно также обратиться напрямую, указав нужный путь. Давайте рассмотрим это на примере, подключив к нашему разрабатываемому проекту small_talk_with_hexlet пакет babel-node https://babeljs.io/docs/en/babel-node:

~/projects/smallTalkWithHexlet$ npm install --save-dev @babel/node


Если в корневом каталоге проекта установить какой-либо пакет с флагом --save-dev (npm i some_package --save-dev) — то он автоматически добавится в зависимости проекта: в раздел devDependencies файла package.json. Этой возможностью мы и воспользовались.

Как и ожидалось, появился каталог ./node_modules/, в котором лежит код подключенного пакета, а также других пакетов, от которых он, в свою очередь, зависит.

Узнать место, где npm складывает ссылки на исполняемые файлы локально подключаемых пакетов, позволяет команда npm bin (обратите внимание, что здесь нет параметра --global или -g). В нашем случае это каталог ./node_modules/.bin, заглянем в него:
*/
$ npm bin
$ ls -al node_modules/.bin/


// Давайте запустим babel-node (REPL-утилита, позволяющая "на лету" комплировать и исполнять новый ES6 код):
$ ./node_modules/.bin/babel-node
> ['hi', undefined, 'bye'].fill('Hexlet', 1, 2)
['hi', undefined, 'bye']
> .exit

$ babel-node
bash: babel-node: command not found

/*
Программа отработала корректно — мы успешно сделали вычисление в REPL-режиме babel-node.

Затем была попытка запустить исполняемый файл из командной строки только по имени, но она привела к неудаче — bash: babel-node: command not found — командная оболочка просто не нашла его (в отличие от того, как это было бы при глобальной установке).

# Установка пакета без публикации
В npm существует удобная команда для работы — npm link. Она позволяет поставить свой пакет в систему без публикации в NPM. Так вы можете убедиться в том что всё работает без полного цикла выкладки. Для удаления такого пакета воспользуйтесь командой npm unlink.


# Заключение
В этом уроке мы рассмотрели как общие принципы, так и отдельные нюансы работы Npm с исполняемыми файлами проекта. Важно отметить, что эти принципы характерны для большинства других пакетных менеджеров из разных языков (например, composer в php). Поэтому, если в будущем вам придётся столкнуться с чем-то из них, то это не должно вызвать затруднений.
*/



############################### JS: Составные данные ############################### 


>>>>>> Точки <<<<<<

// # Интерфейс:
const x = 5;
const y = -7;

// Конструктор
const point = makePoint(x, y);

// Селекторы
getX(point);
getY(point);

toString(point); // (5, -7)

// # Манипуляции:
const symmetricalXPoint = point => makePoint(getX(point), -getY(point));

const point = makePoint(10, 10);
symmetricalXPoint(point); // (10, -10)

// # Манипуляции:
const point = makePoint(3, 4);
const point2 = makePoint(0, 0);

quadrant(point); // 1
distance(point, point2); // 5

/*
# Итог: 
Абстрактные данные: Точка. Характеризуется двуся значениями (координатами): x и y.

Конкретные данные: На текущий момент неизвестно как реализованы точки.

Интерфейс:
*/

// Конструктор:
makePoint(<x>, <y>);

// Селекторы:
getX(<point>);
getY(<point>);



/**@@
Реализуйте и экспортируйте следующие функции для работы с точками:

getQuadrant - функция, которая вычисляет квадрант, в котором находится точка. Ниже приведена схема, показывающая номера квадрантов на плоскости.

      +
      2 | 1
        |
+----------------+
        |
      3 | 4
        +
*/
const point = makePoint(1, 5);
getQuadrant(point); // 1
getQuadrant(makePoint(3, -3)); // 4

// Если точка не принадлежит ни одному квадранту (т.е., если она лежит хотя бы на одной из осей координат), то функция должна возвращать null:

const point = makePoint(0, 7);
getQuadrant(point); // null
getQuadrant(makePoint(2, 0)); // null


// getSymmetricalPoint - функция, возвращающая новую точку, симметричную относительно начала координат. Такая симметричность означает, что меняются знаки у x и y.

getSymmetricalPoint(makePoint(1, 5)); // makePoint(-1, -5)


// calculateDistance - функция, вычисляющая расстояние между точками по формуле: d = sqrt((x2−x1)^2+(y2−y1)^2)

calculateDistance(makePoint(-2, -3), makePoint(-4, 4)); // ≈ 7.28

// FILE: points.js
import { makePoint, getX, getY } from 'hexlet-points';

export const getQuadrant = point => {
  const x = getX(point);
  const y = getY(point);

  if (x > 0 && y > 0) {
    return 1;
  } else if (x < 0 && y > 0) {
    return 2;
  } else if (x < 0 && y < 0) {
    return 3;
  } else if (x > 0 && y < 0) {
    return 4;
  }

  return null;
}

export const getSymmetricalPoint = point => {
  return makePoint(-getX(point), -getY(point));
}

export const calculateDistance = (point1, point2) => {
  const dX = getX(point2) - getX(point1);
  const dY = getY(point2) - getY(point1);

  return Math.sqrt((dX ** 2) + (dY ** 2));
}



>>>>>> Пары <<<<<<

import { cons, car, cdr } from 'hexlet-pairs';

// Конструктор
const pairs = cons(8, 7);

car(pair); // 8
cdr(pair); // 7

const pair2 = cons(3, pair);

// # Представление точек:

import { cons, car, cdr } from 'hexlet-pairs';

const makePoint = (x, y) => cons(x, y);

const getX = point => car(point);
const getY = point => cdr(point);

const toString = point => toString(point);

// # Представление отрезков:

const point1 = makePoint(1, 2);
const point2 = makePoint(10, -2);

const segment = makeSegment(point1, point2);

startSegment(segment); // (1, 2)
endSegment(segment);   // (10, -2)


/*@@
В этом задании мы немного потренируемся работать с парами. Без фанатизма и по шагам.

Шаг 1 - reversePair.js
Реализуйте функцию reversePair, которая принимает на вход пару и возвращает другую, в которой значения переставлены местами:
*/
import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons('one', 'two');
console.log(toString(reversePair(pair))); // ('two', 'one')

/*
Шаг 2 - sumOfPairs.js
Реализуйте функцию sumOfPairs, которая принимает на вход две пары и возвращает новую пару, в элементах которой находятся суммы элементов из исходных пар:
*/

import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair1 = cons(4, 10);
const pair2 = cons(100, 0);
console.log(toString(sumOfPairs(pair1, pair2))); // (104, 10)

/*
Шаг 3 - findPrimitiveBox.js
Однажды вы сидели дома, когда курьер Василий принес вам коробку. С коробкой шла записка следующего содержания:

Коробка состоит из двух отсеков, в одном из которых письмо, а в другом лежит еще одна коробка, в которой также два отсека и точно также один отсек с письмом, а в другом - коробка. Коробки могут быть вложены друг в друга сколько угодно раз. Вам нужно добраться до коробки, внутри которой нет вложенной коробки ни в одном из двух отсеков, и отдать ее курьеру.

Подчеркну, что во всех коробках, кроме той последней, в одном отсеке письмо (любые данные, которые не являются парой), а в другом - всегда коробка, но никогда не две коробки одновременно. Сами отсеки при этом могут меняться, то есть в одной коробке отсеком с письмом может быть первый, а в другой - последний.

Реализуйте рекурсивную функцию findPrimitiveBox, которая принимает на вход "коробку" (пару), находит внутри нее пару без вложенных пар (как описано выше) и возвращает наружу.
*/

import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons(
  null,
  cons('one', 'two'),
);
toString(findPrimitiveBox(pair)); // ('one', 'two')

const pair2 = cons(
  cons(null, cons(1, 5)),
  null,
);
toString(findPrimitiveBox(pair2)); // (1, 5)

/*
Подсказки
Выполняйте практику строго по порядку (по шагам): от простых упражнений к более сложным.
Функция isPair из библиотеки hexlet-pairs проверяет, является ли переданный ей параметр парой. Более подробное описание функции смотрите в документации библиотеки (файл hexlet-pairs.md в каталоге docs).
Функцию toString из библиотеки hexlet-pairs можно использовать (при необходимости) для отладки решений.
*/

// FILE: sumOfPairs.js:
import { cons, car, cdr, toString } from 'hexlet-pairs'; 

const sumOfPairs = (pair1, pair2) => cons(car(pair1) + car(pair2), cdr(pair1) + cdr(pair2));

export default sumOfPairs;


// FILE: reversePair.js:
import { cons, car, cdr, toString } from 'hexlet-pairs'; 

const reversePair = pair => cons(cdr(pair), car(pair));

export default reversePair;


// FILE: findPrimitiveBox.js:
import { car, cdr, isPair, toString } from 'hexlet-pairs';

const findPrimitiveBox = (pair) => {
  const first = car(pair);
  const last = cdr(pair);

  if (!isPair(first) && !isPair(last)) {
    return pair;
  }

  const next = isPair(first) ? first : last;
  
  return findPrimitiveBox(next);
};

export default findPrimitiveBox;




>>>>>> Моделирование <<<<<<

/*
Абстракции позволяют нам моделировать необходимую предметную область. Попробуем понять это утверждение на конкретном примере. Допустим, мы хотим сделать программу-каталог для управления коллекцией книг. Вы можете сразу кинуться писать код, но так делать не стоит :)

В первую очередь необходимо проанализировать предметную область (книги + каталоги) и сформировать базовую модель. Нужно начать с определения сущностей и операций над ними. В случае нашего каталога у нас есть по крайней мере две сущности: книга и коллекция. Базовыми операциями сделаем добавление книги в коллекцию и удаление ее из коллекции.

Напишем код операции для добавления сущности в коллекцию:
*/

const book1 = makeBook('Дети капитана Гранта');
const book2 = makeBook('Приключения Тома Сойера');
const coll = makeColl('приключения');
const updatedColl1 = addBookToColl(coll, book1);
const updatedColl2 = addBookToColl(updatedColl1, book2);


/*
Мы создаем две книги, одну коллекцию и добавляем эти книги в коллекцию. Что значит "создали книгу"? Что такое "книга"? Книга — это сущность, которая ведет себя как книга. Что это значит?

Так как мы работаем с языком программирования, то конструктор makeBook, создающий книгу, возвращает какие-то данные: примитивные (число, строку) или составные, используя пары. Главное — нам не важно, как они устроены.

Организовать эти данные можно тысячью разных способов, и конкретный способ зависит от разработчика, его предпочтений и данных, которые необходимо хранить. То, что книга является книгой, определяется не её внутренним устройством, а тем, что к ней применим набор операций, созданный для книг. Например, операция «получить имя книги». Сами операции знают, как устроены данные, иначе они не смогли бы ими манипулировать. Запомните: это детали реализации. Не заглянув внутрь операций, мы не узнаем, как они устроены, но нам это и не нужно.

В этом и заключается вся суть абстракции. Мы знаем, как создать сущность и какие операции к ней применимы. Обычно это и называется дизайном кода, а сами операции + конструктор — это API или интерфейс модуля/пакета/библиотеки.


Получаем следующий алгоритм:

1 Анализируем предметную область. Выделяем сущности.
2 Реализуем конструктор. Внутреннее представление сущностей выбираем на основе того, что мы планируем в них хранить.
3 Реализуем необходимые операции.

В примере с книгами видно, что мы храним только название, а это значит, что нам достаточно хранить одну строчку.

Тогда реализация конструктора будет такой:
*/
const makeBook = name => name;

const book = makeBook('Дети капитана Гранта');
console.log(toString(book)); // Дети капитана Гранта

// А что, если мы захотим дополнительно хранить версию издания книги? Тогда мы можем использовать пары для хранения составных данных, и у нас уже появляются составные данные, так как нужно хранить два параметра.

const makeBook = (name, rev) => cons(name, rev);
const book = makeBook('Дети капитана Гранта', 3);
console.log(toString(book)); // ('Дети капитана Гранта', 3);

/*
Поменяется ли клиентский код, использующий нашу библиотеку, при изменении внутреннeй структуры? Как видно из примеров выше, ничего не поменяется, кроме вызова конструкторов. Это и есть хорошая абстракция, при которой наш код не рассыпается в случае любых изменений внутренней реализации.

# Примеры других абстракций

Пример с книгами — это всего лишь один из многих вариантов. Программисты в своей работе постоянно перекладывают сущности реального мира на код, создавая всевозможные абстракции данных. Давайте попробуем пофантазировать и накидать еще вариантов. Я добавлю только три, а еще три додумайте сами. В реальной жизни абстракции будут сложнее, так как должны включать больше данных, но суть от этого не поменяется.

1 Товар. Все, что продается и покупается. Предположим, что нам интересны только два параметра: цена и название. Саму сущность можно назвать product. Тогда наша абстракция будет содержать как минимум три следующих функции:
*/

// интерфейсные функции (абстракция)
const makeProduct = (name, cost) => cons(name, cost);
const getName = product => car(product);
const getCost = product => cdr(product);

// использование
const product = makeProduct('Сыр Пармезан', 100);
getName(product); // Сыр Пармезан
getCost(product); // 100

/*
2 Текстовый документ. Например, как в Google Docs. В нашем примере он будет состоять из названия и содержимого.
*/

// интерфейсные функции (абстракция)
const makeDocument = (name, body) => cons(name, body);
const getName = document => car(document);
const getBody = document => cdr(document);

// использование
const document = makeDocument('Как я провел лето', 'Много текста');
getName(document); // Как я провел лето
getBody(document); // Много текста

// 3 А вот пример, в котором нужно хранить не два значения, а три. Это точка в пространстве.

// интерфейсные функции (абстракция)
const make3dPoint = (x, y, z) => cons(cons(x, y), z); // альтернатива cons(x, cons(y, z));
const getX = point => car(car(point));
const getY = point => cdr(car(point));
const getZ = point => cdr(point);

// использование
const point = make3dPoint(1, 10, -3);

/*
И теперь самое интересное. Любая абстракция, построенная таким образом, может выступать в роли строительных блоков в другой абстракции.

Предположим, что мы продаем документы как продукты:
*/

const document = makeDocument('Как я провел лето', 'Много текста');
const product = makeProduct(document, 100);

// А дальше все по аналогии.

/**@@
Рассмотрим задачу представления отрезков на прямой плоскости. Каждый отрезок представляется как пара точек: начало и конец. Он может быть описан, например, так: [(1, 3), (5, 4)]. Это означает, что наш отрезок начинается в точке (1, 3) и заканчивается в точке (5, 4) координатной плоскости.

В этом задании необходимо разработать абстракцию для работы с отрезками (англ. segment), которая позволяет строить их из точек, извлекать из отрезков составные части (начало или конец сегмента), а также получать текстовое представление сегмента.

Абстракция заключается в том, что конкретное представление сегмента определяется внутри функций, описывающих работу с отрезками и зависит от создателя библиотеки. С точки зрения клиента библиотеки (кода который ее вызывает), не важно как конкретно устроен сегмент, важно только то, что есть некоторый набор функций (абстракция), позволяющий работать с ним.

segments.js

Определите и экспортируйте следующие функции:
 - Конструктор makeSegment, который принимает на вход две точки и возвращает сегмент. Первая точка это начало сегмента, вторая это конец.
 - Селекторы startSegment и endSegment, которые извлекают из сегмента его начальную и конечную точку соответственно.
 - Вспомогательную функцию segmentToString, которая возвращает текстовое представление сегмента: [(1, 2), (-4, -2)].
 - Функцию midpointSegment, которая находит точку на середине отрезка по формулaм: x = (x1 + x2) / 2 и y = (y1 + y2) / 2.

Пример использования абстракции:
*/

import { makePoint, getX, getY, toString as pointToString } from 'hexlet-points';

// не важно, чем является segment с точки зрения реализации, главное, что с ним можно
// работать используя функции для работы с сегментами
const segment = makeSegment(makePoint(1, 2), makePoint(-4, -2));
console.log(segmentToString(segment)); // [(1, 2), (-4, -2)]

const point1 = startSegment(segment);
console.log(pointToString(point1)); // (1, 2)

const point2 = endSegment(segment);
console.log(pointToString(point2)); // (-4, -2)

pointToString(startSegment(segment)) === pointToString(makePoint(1, 2)); // true

pointToString(midpointSegment(segment)); // (-1.5, 0)

/*
Поскольку на текущий момент мы знакомы только с парами для работы с составными данными, то и реализация сегментов должна быть основана на них.

Описание функции toString (в коде она импортирована под псевдонимом pointToString) из библиотеки hexlet-points можно посмотреть в файле документации docs/hexlet-points.md
*/


// FILE: segments.js:
import {
  makePoint, getX, getY, toString as pointToString,
} from 'hexlet-points';
import { cons, car, cdr } from 'hexlet-pairs';

export const makeSegment = (point1, point2) => cons(point1, point2);

export const startSegment = segment => car(segment);

export const endSegment = segment => cdr(segment);

export const segmentToString = segment => `[${pointToString(startSegment(segment))}, ${pointToString(endSegment(segment))}]`;

export const midpointSegment = (segment) => {
  const startPoint = startSegment(segment);
  const endPoint = endSegment(segment);
  const x = (getX(startPoint) + getX(endPoint)) / 2;
  const y = (getY(startPoint) + getY(endPoint)) / 2;

  return makePoint(x, y);
};


>>>>> Барьеры абстракции <<<<<

/*
Идея абстракции данных состоит в том, чтобы определить для каждого типа объектов данных набор базовых операций, через которые будут выражаться все действия с объектами этого типа. Если представить эту идею графически, то мы можем увидеть следующую картину:

На самом верхнем уровне находятся программы, которые используют наши графические примитивы и делают это на максимально высоком уровне. Далее мы определяем графические примитивы уже в терминах функций для доступа к более низкому уровню. Например, у нас есть функции distance и makeSegment, которые работают с отрезками и обращаются к точкам. А точки, в свою очередь, построены на парах. При этом любой части программы на любом уровне всё равно, как устроены пары, от этого ничего не должно поменяться. При этом, конечно, абстракция может "протекать". Это означает, что более высоким уровням приходится напрямую обращаться к более низким, минуя расположенные между ними уровни. Например, программа пытается пользоваться точками как парами. В таких случаях принято считать, что абстракция не очень хороша, и это приводит к проблемам в дальнейшем при модификации программы.

Барьеры абстракции в современной литературе часто именуют другим термином — принцип одного уровня абстракции. Это означает, что работая в одной предметной области на определенном срезе, оперируют объектами только этого среза, избегая объектов, к нему не относящихся.

Итак, какие же преимущества нам даёт такой подход, когда мы строим всё независимыми слоями или ярусами? Во-первых, нам проще рассуждать о программе, потому что на том уровне абстракции, на котором мы работаем, мы оперируем небольшим ограниченным набором сущностей, которые к тому же соответствуют одному уровню мышления о них. Во-вторых, нам проще комбинировать разные части программы, склеивая их через определенные нами интерфейсы для получения нового более сложного поведения. И, наконец, нам гораздо проще поддерживать и изменять наши программы, потому что код, отделенный барьером абстракции на определенном уровне, не зависит от реализации более низких уровней. Это позволяет в любой момент переписывать отдельные уровни, например, для большей производительности.

Когда мы говорили о данных, мы говорили о том, что они реализуются некоторым интерфейсом, набором конструкторов и селекторов. Но, строго говоря, этого определения недостаточно, потому что структура данных реализуется не любым набором конструкторов и селекторов, они должны быть связаны между собой определенным образом. Формально можно сказать так: для любых x и y, если p есть точка makePoint(x, y), (getX(p), getY(p)) является точкой (x, y). Такое определение оказывается крайне простым, если просто подумать о нем логически: положенное в конструктор должно быть получено селекторами. Если это правило выполняется, то можно сказать, что мы имеем некоторые данные, с которыми мы можем работать, и они будут вести себя предсказуемым образом. По сути, у нас есть правило (может быть даже не одно), которое описывает связи между данными.

Увеличение уровня абстракции и разделения уровней абстракции позволяет
> упростить мыслительный процесс при рассмотрении данных
> упростить комбинирование различных данных или частей программы

При движении от пар к точкам, отрезкам и далее, к более сложным объектам, в какую сторону мы двигаемся по воображаемой «лестнице» абстракции?
> вверх, повышая уровень абстракции
*/

/*@@
rectangles.js
Реализуйте абстракцию (набор функций) для работы с прямоугольником, стороны которого всегда параллельны осям. Прямоугольник может располагаться в любом месте координатной плоскости.

При такой постановке задачи достаточно знать только три параметра для однозначного задания прямоугольника на плоскости: координаты левой-верхней точки, ширину и высоту. Зная их, мы всегда можем построить прямоугольник одним единственным способом.
      |
    4 |    точка   ширина
      |       *-------------
    3 |       |            |
      |       |            | высота
    2 |       |            |
      |       --------------
    1 |
      |
------|---------------------------
    0 |  1   2   3   4   5   6   7
      |
      |
      |

Основной интерфейс:      
makeRectangle (конструктор) - создаёт прямоугольник. Принимает параметры: левую-верхнюю точку, ширину и высоту.
Селекторы getStartPoint, getWidth и getHeight

Вспомогательные функции для выполнения расчетов:

square - возвращает площадь прямоугольника (a * b).
perimeter - возвращает периметр прямоугольника (2 * (a + b)).
containsTheOrigin - проверяет, принадлежит ли центр координат прямоугольнику (не лежит на границе прямоугольника, а находится внутри). Чтобы в этом убедиться, достаточно проверить, что все вершины прямоугольника лежат в разных квадрантах (их можно вычислить в момент проверки).
Так как это интерфейсные функции, то они должны быть экспортированы. Если этого не сделать, система модулей js не даст ими воспользоваться.
*/

// Создание прямоугольника:
// p - левая верхняя точка
// 5 - ширина
// 4 - высота
//
// p    5
// -----------
// |         |
// |         | 4
// |         |
// -----------

const p = makePoint(0, 1);
const rectangle = makeRectangle(p, 5, 4);

// Вычисление площади прямоугольника
square(rectangle); // 20;

perimeter(rectangle); // 18
containsTheOrigin(rectangle); // false

const rectangle02 = makeRectangle(makePoint(-4, 3), 5, 4);
containsTheOrigin(rectangle02); // true

containsTheOrigin(makeRectangle(makePoint(-4, 4), 5, 2)); // false
containsTheOrigin(makeRectangle(makePoint(-4, 3), 2, 8)); // false



>>>>>> Реализация пар <<<<<<

/*
Вот мы и подобрались к тому, чтобы рассмотреть пары поподробнее и понять, как они устроены внутри. Давайте ещё раз вспомним, что такое пара и какие условия должны быть соблюдены для того, чтобы выполнялись наши требования к данным:
*/
const pair = cons(a, b);

a === car(pair); // true
b === cdr(pair); // true

/*
Итак, пара — это соединение a и b, при этом a мы получаем через car, b — через cdr; a и b — это какие-то другие данные и они тоже могут быть парами. По сути, пара — это конструктор, селекторы и правила, которые определяют соотношения между конструктором, селекторами и данными.
*/

const cons = (a, b) => (message) => {
  switch (message) {
    case 'car':
      return a;
    case 'cdr':
      return b;
  }
};

const car = (pair) => pair('car');
const cdr = (pair) => pair('cdr');

/*
Начнем с определения cons: это функция, которая принимает a и b, а внутри (и тут самое удивительное) содержит другую функцию, которая будет возвращена наружу. Внутри этой другой функции мы делаем switch, и если message равен 'car', возвращаем a, если 'cdr' — возвращаем b. Итак, в результате создания пары снаружи оказывается функция. Как же она работает? Очень просто: селекторы принимают пару и вызывают её как функцию, передавая в неё соответствующие сообщения. Если это селектор car, то передается сообщение 'car', если селектор cdr — то 'cdr'. А поскольку пара — это функция, которая принимает сообщение, то мы получаем то или иное значение в зависимости от переданного сообщения. Значения же сохраняются во внутренней функции за счёт замыкания.

Для примера давайте представим, что мы определяем внутреннюю функцию руками для конкретных a и b:
*/

const pair = cons(4, 5);
// const pair = (message) => {
//   switch (message) {
//     case 'car':
//       return a;
//     case 'cdr':
//       return b;
//   }
// };

car(pair); // 4
// pair('car');



/*
В этом примере мы можем представить, что пара — это функция, которая принимает сообщение, и если сообщение равно 'car', то возвращает 4, если 'cdr' — возвращает 5. Вызывая селектор car c аргументом pair, мы внутри вызываем эту функцию с сообщением 'car'.

Возможно, такое определение пар вас шокирует, ведь мы в нём не используем ничего, кроме функций и свойства замыкания. Тем не менее, это вполне рабочий и адекватный способ определять структуры данных. Есть несколько причин, по которым мы именно так реализовали пары.

Во-первых, языки программирования вполне могли бы реализовывать (а некоторые, возможно, реализуют) свои структуры данных таким образом. Вы об этом наверняка не знаете, но гарантировано, если бы это был эффективный способ, то им бы и пользовались. Скорее всего, он не очень эффективный, но показывает, что нет никаких ограничений.

Во-вторых, это отличная иллюстрация того, каким мощным инструментом являются функции, когда они используются как объекты первого класса. Это позволяет строить очень компактные, лаконичные, но при этом насыщенные смыслом программы из простых компонентов, постепенно усложняя поведение. Дополнительно мы увидели такой механизм, как передача сообщений, когда мы не просто вызываем какую-то функцию, а передаем туда сообщение. На данный момент мы не будем подробно разбирать эту технику, но в будущем она будет иметь огромное значение как один из элементов так называемого объектно-ориентированного программирования, о котором мы будем говорить позже.

И, наконец, такой подход, выбранный нами для обучения, очень сильно влияет на развитие функционального мышления, что позволяет легче понимать то, как соединять между собой части и учиться мыслить гораздо более абстрактно. Обычно при классическом обучении происходит смещение в императивную область, из-за чего люди лишены возможности глубокого понимания того, как писать модульные программы без необходимости дублировать код. И функциональное мышление вам в этом крайне сильно поможет.
*/

/*@@
Рассмотренный в уроке способ создания пар не является единственным возможным, даже если мы говорим только о реализации на функциях.

pairs.js
Напишите и экспортируйте функции car и cdr, основываясь на реализации функции cons:
*/
const cons = (x, y) => f => f(x, y);

// При таком определении как выше, пара будет представлять из себя функцию f => f(x, y). Например:
const pair = cons(5, 3);
// const pair = f => f(5, 3);

/*
Теперь догадаться до решения не так уж и сложно. По сути car и cdr должны вызвать внутри себя pair (ведь это функция, не забыли?), и передать туда функцию, которая в зависимости от ситуации вернет либо первый, либо второй аргумент.
*/
export const cons = (x, y) => f => f(x, y);

export const car = z => z(x => x); 
export const cdr = z => z((x, y) => y);

/*@@
Рациональное число — число, представляемое обыкновенной дробью m/n, числитель m — целое число, а знаменатель n — натуральное число. Пример рационального числа: 2/3.

Формулы
Сложение
a/b + c/d = (a * d + b * c) / (b * d)
Вычитание
a/b - c/d = (a * d - b * c) / (b * d)
Умножение
a/b * c/d = (a * c) / (b * d)
Деление
a/b / c/d = (a * d) / (b * c)
Равенство
a/b = c/d, если a * d = c * b
rational.js
Реализуйте абстракцию для работы с рациональными числами, используя пары:

Конструктор make(numer, denom).
Селекторы numer (числитель) и denom (знаменатель).

Функцию toString, возвращающую строковое представление рационального числа. Например для дроби 3/4 созданной так make(3, 4), строковым представлением будет 3 / 4.

Предикат isEqual, проверяющую равенство двух рациональных чисел. Например isEqual(make(1, 2), make(2, 4)).

Функцию add, выполняющую сложение дробей.
Функцию sub, выполняющую вычитание дробей.
Функцию mul, выполняющую умножение дробей.
Функцию div, выполняющую деление дробей.

Экспортируйте созданные функции.

Обратите внимание, что результатом любой арифметической операции над рациональным числом будет рациональное число.

Примеры
*/
const rat1 = make(2, 3);
const rat12 = make(4, 6);
const rat2 = make(7, 2);

toString(rat12); // '4 / 6'
isEqual(rat1, rat12); // true

add(rat1, rat2); // 25/6
sub(rat2, rat1); // 17/6
mul(rat1, rat2); // 14/6
div(rat1, rat2); // 4/21

import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs';

// BEGIN (write your solution here)

// END


/**@@
Пары неотрицательных целых чисел можно представить числами и арифметическими операциями. Можно считать, что пара чисел a и b – это 2^a * 3^b.

Функции car и cdr при этом будут просто вычислять значения a и b (кратности двойки и тройки, соответственно), раскладывая аргумент на множители.

Например, имея пару 5, 8 в виде числа 209952 (2^5 * 3^8), можно получить первый элемент пары, разложив число на множители и вычислив факторизацию для числа 2, а второй элемент пары – разложив число на множители и вычислив факторизацию для числа 3.

pairs.js
Реализуйте и экспортируйте следующие функции в соответствии с алгоритмом выше:

cons
car
cdr
Пример:
*/
const pair = cons(5, 8); // => 2^5 * 3^8 = 209952
car(pair); // 5
cdr(pair); // 8

/*
Подсказки
Пара – это число, поэтому, чтобы получить из него исходные значения a и b, нужно раскладывать число на множители.
*/

const factor = (base, value) => {
  if (value % base !== 0) {
    return 0;
  }

  return 1 + factor(base, value / base);
};

export const cons = (a, b) => (2 ** a) * (3 ** b);
export const car = pair => factor(2, pair);
export const cdr = pair => factor(3, pair);



/**@@
Кроме пар можно создавать абстрактные типы данных, которые содержат внутри себя три и более элемента.

В данном испытании необходимо реализовать структуру данных тройка, позволяющую хранить три значения. Как и в случае с парами создаётся конструктор make и селекторы get1, get2, get3, которые будут извлекать соответствующие значения.

triple.js
Реализуйте и экспортируйте следующие функции:

make
get1
get2
get3
Пример
*/

const triple = make(3, 5, 'I am element from triple');
get1(triple); // 3
get2(triple); // 5
get3(triple); // I am element from triple


// FILE: /app/triple.js:
/* eslint default-case: 0, consistent-return: 0 */

// BEGIN (write your solution here)
export const make = (a, b, c) => (
  (message) => {
    switch (message) {
      case 'get1':
        return a;
      case 'get2':
        return b;
      case 'get3':
        return c;
    }
  }
);

export const get1 = triple => triple('get1');

export const get2 = triple => triple('get2');

export const get3 = triple => triple('get3');
// END



// #TESTS FILE: /app/__tests__/triple.test.js:
import {
  make,
  get1,
  get2,
  get3,
} from '../triple';

test('triple', () => {
  const triple = make(1, 2, 3);
  expect(get1(triple)).toBe(1);
  expect(get2(triple)).toBe(2);
  expect(get3(triple)).toBe(3);
});

test('triple in triple', () => {
  const triple1 = make(14, 22, 32);
  const triple2 = make(11, 12, triple1);
  expect(get1(triple2)).toBe(11);
  expect(get2(triple2)).toBe(12);
  expect(get3(triple2)).toBe(triple1);
});

test('triple string', () => {
  const triple = make('str', 44);
  expect(get1(triple)).toBe('str');
  expect(get2(triple)).toBe(44);
  expect(get3(triple)).toBe(undefined);
});


/**@@
Пару можно создать на основе строки. Для хранения двух значений применим разделитель. Им может выступить любой символ, однако во избежание совпадений с исходными данными лучше взять редко используемое значение.

Для этого подойдёт так называемая управляющая или escape-последовательность, которая начинается с обратной косой черты. Мы будем использовать специальный символ \0, обозначающий нулевой символ (NUL).

Функции car и cdr должны получить содержимое строки до и после разделителя соответственно.

Управляющая последовательность воспринимается интерпретатором как одиночный символ, т.е. имеет длину, равную 1.

Обязательным условием является отсутсвие данного символа в строках, которые объединяются в пару.

pairs.js
Реализуйте и экспортируйте следующие функции в соответствии с алгоритмом выше:

cons
car
cdr
Пример
*/

const pair = cons('computer', 'science');   // => computer\0science
car(pair); // computer
cdr(pair); // science

/*
Подсказки
Для подсчёта длины строки используйте функцию length() из модуля strings.
*/

// FILE: /app/pairs.js:
import length from './strings';

const separator = '\0';

const getSeparatorPosition = (str) => {
  const iter = i => (str[i] === separator ? i : iter(i + 1));

  return iter(0);
};

const getValue = (pair, begin, end) => {
  const iter = (acc, i) => {
    if (i >= end) {
      return acc;
    }

    const newAcc = `${acc}${pair[i]}`;

    return iter(newAcc, i + 1);
  };

  return iter('', begin);
};

export const cons = (a, b) => `${a}${separator}${b}`;
export const car = pair => getValue(pair, 0, getSeparatorPosition(pair));
export const cdr = pair => getValue(pair, getSeparatorPosition(pair) + 1, length(pair));


// #TESTS FILE: /app/__tests__/pairs.test.js:
import { cons, car, cdr } from '../pairs';

describe('Pairs', () => {
  it('1 set', () => {
    const pair = cons(0, 0);
    expect(pair).toBe(1);
    expect(car(pair)).toBe(0);
    expect(cdr(pair)).toBe(0);
  });

  it('2 set', () => {
    const pair = cons(1, 2);
    expect(pair).toBe(18);
    expect(car(pair)).toBe(1);
    expect(cdr(pair)).toBe(2);
  });

  it('3 set', () => {
    const pair = cons(2, 1);
    expect(pair).toBe(12);
    expect(car(pair)).toBe(2);
    expect(cdr(pair)).toBe(1);
  });

  it('4 set', () => {
    const pair = cons(5, 8);
    expect(pair).toBe(209952);
    expect(car(pair)).toBe(5);
    expect(cdr(pair)).toBe(8);
  });

  it('5 set', () => {
    const pair = cons(0, 0);
    const transit = cons(1, 1);
    expect(pair).toBe(1);
    expect(car(pair)).toBe(0);
    expect(cdr(pair)).toBe(0);
    expect(car(transit)).toBe(1);
    expect(cdr(transit)).toBe(1);
  });
});






// #TESTS FILE: /app/__tests__/pairs.test.js:
import { cons, car, cdr } from '../pairs';

describe('Pairs on strings', () => {
  it('1 set', () => {
    const pair = cons('hi', 'hexlet');
    expect(car(pair)).toBe('hi');
    expect(cdr(pair)).toBe('hexlet');
  });

  it('2 set', () => {
    const pair = cons('Hello!', '');
    expect(car(pair)).toBe('Hello!');
    expect(cdr(pair)).toBe('');
  });

  it('3 set', () => {
    const pair = cons('', 'XXI');
    expect(car(pair)).toBe('');
    expect(cdr(pair)).toBe('XXI');
  });
});



############################### JS: Последовательности ###############################   

>>>>>> Введение <<<<<<

/* 
Документация функций по работе с парами https://github.com/hexlet-components/js-pairs/tree/master/docs

Последовательность — упорядоченная совокупность объектов данных. Совокупность — некая единая сущность. Данные — любая информация: числа, строки, составные объекты вроде пар и так далее.

Некоторые разделы математики сфокусированы на последовательностях чисел.
*/



>>>>>> Представление последовательностей <<<<<<

/*
Пары и списки
В этом уроке мы реализовали абстрактный тип данных Список на основе ранее пройденных пар. Ключевой особенностью списка является его интерфейс, а именно функции, реализующие такие операции, как "получить голову" (возвращает первый элемент списка), "получить хвост" (возвращает новый список, полученный из исходного списка отсечением у него первого элемента), "добавить новую голову" (добавление элемента в начало списка). И здесь следует обратить внимание на несколько вещей.

Во-первых, не стоит отождествлять между собой пары и списки. Пары в данном случае были использованы как подходящий инструмент для создания списка. Абстрактный список (см. первый абзац) может быть реализован в конкретных структурах данных. В нашем случае это односвязный список. Важной характеристикой этой структуры данных является то, что каждый элемент списка, помимо определённого хранимого значения (числа, строки, даты, адреса, имени и любой другой информации), содержит ссылку на другой такой же по структуре элемент. Таким образом, между элементами списка существует связь, и мы можем последовательно "путешествовать" (перемещаться) от текущего элемента к следующему, от начала списка к его концу.

И, как видим, пары вполне позволяют реализовать особенности списка как структуры данных. Ведь пара, помимо основного значения, может содержать ещё другую пару аналогичной структуры (значение + ссылка на другую пару) — и такая последовательность может длиться бесконечно.
*/

import { cons, toString } from 'hexlet-pairs';

const(5, 8);

const pair = cons(5, cons(2, 9));
toString(pair); // (5, (2, 9))

cons(1, cons(2, cons(3, cons(4, cons(5, ...
cons('one', cons('two', cons('three', cons('four', cons('five', ...


/*
Однако, надо понимать, что сделать это можно не только с помощью пар. Представимы списки на основе массивов, а также некоторых других типов данных. Поэтому, если мы пользуемся списком, то к нему нельзя напрямую применять функции по работе с парами даже если мы знаем, что данный конкретный список состоит из пар. Для этого вводятся специальные функции для работы со списками, учитывающие его внутреннюю реализацию, которая может изменяться.

Во-вторых, коль скоро мы реализовали список именно на основе пар, то следует понимать, что не каждая пара, с которой мы имеем дело, какой бы «сложной» она ни была, является списком. У списка есть начало и конец, и мы должны иметь возможность последовательно перемещаться от одного элемента к другому. Для того, чтобы понять, что мы достигли последнего элемента списка и перемещаться дальше уже нет смысла, мы вводим специальный маркер конца списка — пустую пару l(). По предварительному соглашению в роли маркера могут также выступать другие подходящие значения, например, null. Как только мы встречаем очередную пару, в cdr которой находится пустая пара, это означает, что очередное значение списка, лежащее в car пары, является последним элементом списка. Отметим также, что у пустого списка (списка, в котором нет ни одного элемента) не может быть ни головы, ни хвоста. Поэтому соответствующие операции, примененные к пустому списку (взятие head или tail), приводят к возникновению ошибки. Чтобы её избежать, вводят функцию для проверки списка на «пустоту» (например, isEmpty), а далее берут голову или хвост у списка, предварительно убедившись, что он не является пустым.

Ниже приведены примеры пар, которые нельзя назвать списками. Они не реализуют требования, предъявляемые к односвязным спискам: в них отсутствует последовательная связь между элементами и/или нет маркера конца списка:
*/

cons(1, cons(cons(3, null), 2));
cons(1, cons(2, cons(3, 4)));
cons(cons(1, 2), cons(3, cons(4, null)));

// Теперь покажем пары, которыми мы можем смело пользоваться как списками:

cons(1, cons(2, cons(3, null)));
cons('This', cons('is', cons('a', cons('list', null))));

/*
# l() - отвлекаемся от деталей и повышаем уровень абстракции

В уроке мы отметили, что следующие две записи, конструирующие список, являются эквивалентными:
*/

import {l, cons, head, tail, isEmpty, toString} from 'hexlet-pairs-data';

const list = l(1, 2, 3 , 4); // -> cons(1, cons(2, cons(3, cons(4, null)))) -> (1, 2, 3, 4, 5)
cons(10, list); // (10, 1, 2, 3, 4)
toString(list) // => (1, 2, 3 , 4)

head(list); // => 1
tail(list); .. l(2, 3, 4)

isEmpty(l(4)); // => false
isEmpty(l()); // => true

/*
Для генерации списка мы создали функцию l, несмотря на то, что у нас уже есть конструктор cons. Это необходимо по нескольким причинам. Отметим наиболее важные из них:

Выделив код создания списка в отдельную функцию и дав ей имя l (сокращ. от list), мы ввели отдельную и понятную абстракцию, отвечающую за создание списков (и ничего другого!). Выше говорилось, что списки могут быть реализованы не только на парах, но и на массивах, а также других типах данных. Так вот, наша абстракция l позволяет отвлечься от внутреннего устройства списка. Тот, кто будет пользоваться этой функцией, не обязан знать, какими способами она конструирует список, а в случае необходимости может изменить его внутреннее устройство "незаметно и безболезненно" для пользователей l.
Хорошая абстракция делает код более понятным и повышает его читабельность. Теперь, видя в коде l, мы однозначно понимаем, что здесь происходит. Тогда как в ином случае, цепляясь глазом за множественные, разбросанные среди строк cons, мы каждый раз должны будем определять, что же делает данная конкретная пара: то ли создаёт список, то ли хранит временные данные, то ли печёт пирожки ?! ;)

Посмотрите на «безликие» нагромождения пар, создающие разные сущности, которые мы проходили в прошлых курсах. Только комментарии помогают понять, что здесь происходит.
*/
cons(5, cons(2, cons(7, cons(11, cons(6, cons(14, null)))))); // создание списка
cons(3, 17); // создание точки
cons(8, 17); // создание рационального числа
cons(cons(3, 33), cons(-2, -22)); // создание сегмента (отрезка)
const rectangle = cons(cons(-2, 23), cons(5, 11)); // создание прямоугольника
2 * (car(cdr(rectangle)) + cdr(cdr(rectangle))); // вычисление периметра прямоугольника

// А вот как выглядит код с введёнными абстракциями. Комментарии здесь уже не нужны:

list(5, 2, 7, 11, 6, 14);
makePoint(3, 17);
makeRational(8, 17);
makeSegment(makePoint(3, 33), makePoint(-2, -22));
const point = makePoint(-2, 23);
const rectangle = makeRectangle(point, 5, 11);
perimeter(rectangle);


// Естественно, введение функции устраняет дублирование кода. Каждый раз писать при создании списка такое нагромождение кода в виде вложенных cons, демонстрируя при этом все внутренности создаваемой конструкции, — не лучший стиль написания кода.

const { l, head, tail } = require('hexlet-pairs-data');

const list = l(5, 3, 9);
console.log(head(tail(list)));


/*@@
Все создаваемые функции, в рамках этого задания, должны быть реализованы независимо друг от друга, то есть их нельзя использовать для реализации друг друга.

list.js
Реализуйте и экспортируйте функцию has, которая проверяет, является ли переданное значение элементом списка.
*/
const numbers = l(3, 4, 5, 8);
has(numbers, 8); // true
has(numbers, 0); // false
// Реализуйте и экспортируйте функцию reverse, которая переворачивает список, используя итеративный процесс.

const numbers = l(3, 4, 5);
reverse(numbers); // (5, 4, 3)

// Реализуйте и экспортируйте функцию concat, которая соединяет два списка, используя рекурсивный процесс (попробуйте сначала представить, как работала бы функция copy, которая принимает на вход список и возвращает его копию).

const numbers = l(3, 4, 5, 8);
const numbers2 = l(3, 2, 9);
concat(numbers, numbers2); // (3, 4, 5, 8, 3, 2, 9)

import { l, cons, head, tail, isEmpty, toString as listToString } from 'hexlet-pairs-data'; 

export const has = (list, element) => {
  if (isEmpty(list)) {
    return false;
  }

  if (head(list) === element) {
    return true;
  }

  return has(tail(list), element);
};

export const reverse = (list) => {
  const iter = (items, acc) => (
    isEmpty(items) ? acc : iter(tail(items), cons(head(items), acc))
  );

  return iter(list, l());
};

export const concat = (list1, list2) => {
  if (isEmpty(list1)) {
    return list2;
  }

  return cons(head(list1), concat(tail(list1), list2));
};



>>>>>> Разметка <<<<<<

import {
  make, append, toString, node
} from 'hexlet-html-tags';

const html1 = make();
const html2 = append(html1, node('h1', 'hexlet'));
const p1 = node('p', 'hello, world');
const html3 = append(html2, p1);

toString(html3);
// <h1>hexlet</h1>
// <p>hello, world</p>


/**@@
html-tags.js
Реализуйте абстракцию для создания html. Она включает в себя следующие функции:

make — конструктор. Уже реализован. Не принимает параметров, и создает html-список.
node — создает новый тег. Содержит два элемента, имя тега и его содержимое. Дополнительно реализуйте селекторы тега: name и value.
  const tag = node('div', 'what is love?');
  getName(tag); // => div
  getValue(tag); // => what is love?
append — добавляет элемент (тег), созданный с помощью node, в html-список. Возвращает новый html-список. Новый элемент должен добавляться в начало ("голову") списка.
toString — возвращает текстовое представление html на основании html-списка.
Пример использования этого интерфейса:
*/
import { make, append, toString, node } from './html-tags';

// Создаем новый html-список
const dom1 = make();

// Создаем тег и сразу добавляем его в html
const dom2 = append(dom1, node('h1', 'hello, world'));
// Еще раз
const dom3 = append(dom2, node('h2', 'header2'));

// Создаем новый тег
const tag = node('h3', 'header3');
// Добавляем созданный тег в html-список
const dom = append(dom3, tag);

// Преобразуем html-список в строчку
toString(dom);
// => <h1>hello, world</h1><h2>header2</h2><h3>header3</h3>

// Пример без создания промежуточных переменных
toString(append(make(), node('p', 'this is Sparta!')));
// <p>this is Sparta!</p>

// Экспортируйте все созданные функции.

// FILE: /src/html-tags.js:
// eslint-disable-next-line
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs';
// eslint-disable-next-line
import { l, isEmpty, head, tail, cons as consList, toString as listToString } from 'hexlet-pairs-data';

export const make = () => l();
// BEGIN (write your solution here)

// END






############################### JS: Программирование, управляемое данными ###############################   

>>>>>> Введение <<<<<<
/*
# Адитивность
расширение функциональности системы без переписывания исходного кода.

# Test Driven Development
Дизайн кода, чтобы сосредотачиваться на внутреннем представлении, сначала прорабатываются варианты использования этого кода.
*/

>>>>>> Игровой дизайн: карточный бой <<<<<<

// Тест:
import { cons } from 'hexlet-pairs';
import { l, length } from 'hexlet-pairs-data';
import { make } from 'hexlet-card-game';

const cards = l(
  cons('Костяная кочерга гробницы', () => 6)
);

const game = make(cards); // создание игры (принимает колоду карт)
const log = game('John', 'Ada'); // после автоматической игры -> возвращает лог игры

assert.equal(length(log), 5);

// Шаги:

// step((health1, health2), message)

const step1 = get(0, log);
assert.equal(toString(car(step1)), '(10, 10)');
const step2 = get(1, log);
assert.equal(toString(car(step1)), '(10, 4)');
const step3 = get(2, log);
assert.equal(toString(car(step1)), '(4, 4)');
const step4 = get(3, log);
assert.equal(toString(car(step1)), '(4, -2)');
const step5 = get(4 log);
assert.equal(toString(car(step1)), '(4, -2)');









############################### JS: DOM API ###############################   

/*
Большое количество языков либо созданы поверх js либо позволяют транслировать свой код в js. 
К таким языкам относятся: clojurescript, typescript, kotlin, java, elm.

#  JavaScript в браузере
<html>
  <body>
    <script>
      const greeting = 'hello, world!';
      alert(greeting);
    </script>
  </body>
</html>

alert, confirm и prompt - эти функции присутствуют только в браузерах и недоступны в серверных версиях js. Это первый пример, когда мы видим как браузер "расширяет" js, добавляя туда новые возможности. Но не возможности самого языка, язык-то как раз остается тем же, а возможности по взаимодействию со средой.
*/


>>>>> JavaScript в браузере <<<<<

/*
# Внешние скрипты

Инлайн скриптинг, как правило, используется для небольших кусков кода, или для вызова кода, загруженного из внешних скриптов. Загружаются внешние скрипты следующим образом:

<body>
<html>
  <head>
    <script src="/assets/application.js"></script>
  </head>
  <body>
  </body>
</html>

Довольно часто можно увидеть подобный вариант загрузки:

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/core.js"></script>

В примере выше, файл грузится с CDN (https://ru.wikipedia.org/wiki/Content_Delivery_Network), что может давать определенные преимущества в скорости загрузки.


# Скорость
В зависимости от того, в каком месте документа появляются теги script, вы можете наблюдать серьезные изменения как в скорости отрисовки сайта, так и в скорости загрузки.


# Server (Nodejs) vs Client (Browser)
В браузере отсутствует множество тех вещей, с которыми мы привыкли иметь дело работая в серверном окружении. Среди них:


# Стандартная библиотека
Про библиотеку (https://nodejs.org/api/modules.html) можно забыть. Из коробки никаких assert, events, net, http, url и всего остального. Для любой простейшей задачи придется подключать библиотеку из npm.


# Модули
До недавнего времени, модульной системы в браузерах не существовало. Сейчас она появляется, но пока только в экспериментальном варианте.

На текущий момент, любой загруженный код, работает в глобальной области видимости. Такое поведение привело к большому количеству обходных маневров используемых повсеместно для ручной изоляции кусков js друг от друга.

<html>
  <body>
    <script>
      const greeting = 'hello, world!';
    </script>
    <script>
      alert(greeting);
    </script>
  </body>
</html>

Самый распространенный способ изоляции называется Immediately-Invoked Function Expression. Его принцип действия крайне прост: весь код, который должен быть выполнен в браузере, заворачивается в анонимную функцию, которая сразу же вызывается:
*/

(function() {
 // some code…
})();


/*
Как вы позже увидите, современные системы сборки избавляют нас от необходимости делать такие манипуляции руками. Мы можем продолжать использовать привычный и полноценный javascript.

# Версии и движки
Еще один существенный недостаток js в браузере в том, что реализация js в разных браузерах отличается и иногда весьма существенно. Более того, даже разные версии одного и того же браузера могут отличаться катастрофически. Причем, эту проблему решить невозможно, она является следствием самой природы фронтенда. У каждого пользователя будет стоять тот браузер, который ему нравится, той версии, до которой он не забыл обновиться.

# Сборка
К счастью, современный мир фронтенда смог выкрутиться из этой ситуации. Мы по прежнему можем пользоваться всеми (почти) современными фишками js, включая систему модулей. Возможно это благодаря babel с одной стороны и сборщиками, подобными webpack, с другой. Ну и нельзя не упомянуть про полифиллы, которым будет посвящен отдельный урок.

Принцип работы этой связки заключается в том, что сборщик по определенным правилам собирает все наши ресурсы (css, fonts, images) и файлы с кодом, пропускает их через обработчики, например, babel и на выходе мы получаем файлы, готовые к использованию в браузере.


# Безопасность
Во всех браузерах поддерживается механизм под названием cookies, который мы изучали в курсе по протоколу http. Этот механизм играет центральную роль в реализации такой вещи, как аутентификация. После того, как сайт вас опознал, он выставляет специальную сессионную куку и на основе нее определяет залогинены вы на сайте или нет.

Как вы, возможно, помните, js позволяет обращаться к вашим кукам. Это автоматически означает, что если злоумышленнику удастся разместить произвольный код на странице сайта, то он сможет прочитать вашу сессионную куку и передать ее в нужное место. Так легко и беззаботно уводятся сессии и пользователи внезапно оказываются без своего аккаунта. Ни антивирус, ни фаервол в такой ситуации ничем помочь не смогут.

Внедрение произвольного кода на сайт называется XSS (Cross-Site Scripting) и является популярным способом атаки, кроме него так же распространен CSRF (Cross-Site Request Forgery).
*/



>>>>> Глобальный объект Window <<<<<

/*
Если в консоли браузера выполнить команду console.log(this), то на экран будет выведен некий Window.

Window — это глобальный объект, то есть доступный из любого места всегда. Он не является частью js и предоставляется браузерами. Как правило, к нему обращаются по имени window, так как this из-за позднего связывания указывает на него не всегда.

Обратите внимание на то, что функция alert находится в объекте window. Другими словами, когда мы вызываем функцию alert, то в действительности происходит вызов window.alert. Более того, все глобальные объекты js тоже принадлежат window.
*/

window.console.log('hey');
window.Math.abs(5);

/*
# Объектная модель браузера
Это набор глобальных объектов, управляющих поведением браузера. Все они так же находятся внутри window. Разберем некоторые из них.

# Navigator
Предоставляет информацию о браузере, такую как версию, название, используемую локаль, доступные права, подключенные плагины.

# Location
Позволяет управлять адресной строкой. Например, вот так можно инициировать загрузку другой страницы:
*/

location.href = "https://hexlet.io";

/*
# History
С помощью этого объекта можно перемещаться по истории переходов, а так же формировать ее в тех ситуациях, когда не происходит реального переход по страницам. Это особенно актуально для SPA.

# Fetch
Современный метод для выполнения AJAX запросов. Именно с помощью fetch происходит общение с сервером и другими сайтами.
*/


>>>>> Что такое DOM? <<<<<

/*
С высоты птичьего полета процесс отображения страницы можно представить следующим образом:

1. Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью DNS)
  GET /courses HTTP/1.1
  HOST: ru.hexlet.io

2. Пришедший в ответ html парсится, и на его основе строится DOM дерево

3. Браузер рисует страницу, используя DOM дерево (упрощенно).

Чтобы понять, что такое DOM и, в частности, DOM дерево, рассмотрим следующий пример.
*/

const json = '{ "key": "value" }';
const obj = JSON.parse(json);

console.log(obj.key); // value

/*
Как мы помним, json — это текстовый формат, используемый для взаимодействия между разными программами, которые, возможно, написаны на совершенно разных языках. Одна программа сериализует данные в json, а другая десереализует их во внутренние структуры своего языка.

Думаю, достаточно очевидно, что программа, получившая какие-то данные в виде json, не сможет работать с ним, если он останется в текстовом представлении, ведь по сути это строчка текста.

Теперь, попробуем понять смысл DOM дерева:
*/

// Гипотетический пример, так как модуля HTML не существует в природе

const html = `
  <body>
    <p>hello, <b>world</b>!</p>
  </body>
`;

const document = HTML.parse(html);
console.log(document.firstChild.name); // html

/*
Грубо говоря, html можно сравнить с json. Другими словами, html — это текстовое представление DOM дерева, не зависящее от языка программирования. То, что оно является деревом, видно невооруженным взглядом, так как теги вкладываются в теги.

Каждый html-тег становится узлом этого дерева, а теги, вложенные в него, становятся дочерними узлами. Для представления текста создаются специальные текстовые узлы.

Важно то, что в DOM дерево попадают все элементы, представленные в html, включая пробелы и переводы строк.

С DOM tree разобрались, теперь попробуем разобраться с тем, что же, собственно, такое DOM.

Объектная модель документа (Document Object Model) - это не зависящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

На практике, во фронтенд разработке это сводится к тому, что браузер предоставляет специальный объект document, который содержит внутри себя DOM tree и который наполнен большим количеством методов (согласно спецификации DOM) для манипулирования этим деревом. Любые изменения, которые производятся с ним, сразу же отображаются браузером на странице.

Подавляющее число возможностей, связанных с DOM, описаны в спецификациях раз https://dom.spec.whatwg.org/ и два https://html.spec.whatwg.org/ и, по идее, должны работать одинаково во всех браузерах. К сожалению, это не так. DOM развивается, но браузеры двигаются медленнее. Кроме того, существует множество исторических решений, которые приводят к проблемам.


# Восстановление
Те, кто сталкивались с html в реальной жизни, прекрасно знают, что если подать на вход браузеру невалидный html с незакрытыми тегами, нарушенной вложенностью и другими проблемами, то мы не получим сообщений об ошибках. Браузер переварит этот html и что-то отобразит на экране. Возможно, вам не понравится то, что вы увидите, но, по крайней мере, оно будет работать.

Браузер действительно восстанавливает структуру и делает это по очень хитрым правилам. И это логично, иначе было бы невозможно произвести парсинг в принципе. Но есть и другая причина: даже если сам html будет валидным, браузер при создании DOM tree добавляет в него узлы (представленные тегами в html), которые вы, возможно, пропустили, но стандарт требует их наличия. Например, в таблицы добавляется tbody.

Именно DOM открывает практически безграничные возможности по изменению страниц. Все библиотеки (jquery и другие) и фреймворки (angular, react) внутри себя манипулируют DOM. Это та база, вокруг которой построено всё во фронтенд разработке.
*/



>>>>> DOM Дерево <<<<<

/*
Корневым элементом в DOM дереве считается элемент html. Доступ к нему можно получить так: document.documentElement.
Навигация по дереву достаточно интуитивная, поэтому можно смело экспериментировать в браузере:
*/

const html = document.documentElement;
// Read-only
html.childNodes; // [head, text, body]
html.firstChild; // <head>...</head>
html.lastChild; // <body>...</body>
html.childNodes[1]; // #text

// Из-за того, что body и head всегда присутствуют внутри документа, их вынесли на уровень объекта document для более простого доступа:
document.head;
document.body;

// Кроме того, что можно идти вглубь дерева, так же можно идти и наружу:
document.documentElement === document.body.parentNode;
document.body === document.body.childNodes[2].parentNode;


/*
# childNodes

В работе с childNodes есть несколько интересных моментов.
1. Это свойство доступно только для чтения. Попытка что то записать в конкретный элемент не приведет к успеху:
*/
document.body.childNodes[0] = 'hey';


/*
Изменение DOM дерева осуществляется специальным набором методов.

Хотя childNodes и является коллекцией, это все же не массив. В нем отсутствует привычные методы, такие как map, filter и другие. Для перебора элементов можно воспользоваться итератором или сделать так:
*/

const elements = document.documentElement.childNodes;

elements.toString()
// "[object NodeList]"

[...elements]; // теперь это массив

// либо так
elements.forEach(el => console.log(el));


/*
# Иерархия
Хотя каждый узел дерева и представлен типом Node, но в реальности это базовый тип. А каждый конкретный элемент имеет свой. Другими словами, у нас есть определенная иерархия типов.

Ноды с типами Text и Comment являются листовыми, то есть они не могут иметь детей. А вот элементы — это то, с чем приходится иметь дело чаще всего. 
Как видите, в DOM HTMLElement — это отдельное направление, потому что DOM также может представлять и xml документы.

На практике чаще всего нас интересуют не ноды, а элементы. Именно ими мы манипулируем, перемещаемся сквозь них. Это настолько важно, что в DOM есть альтернативный способ обхода дерева, который построен только на элементах


# Специальная навигация

Некоторые элементы обладают специальными свойствами для навигации по ним, к таким элементам относятся, например, формы и таблицы.

<table>
  <tr>
    <td>1.1</td>
    <td>1.2</td>
    <td>1.3</td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>2.2</td>
    <td>2.3</td>
  </tr>
</table>

*/

const table = document.body.firstElementChild
table.rows[0].cells[2];

// Этот способ навигации не заменяет основные. Он сделан исключительно для удобства в тех местах где это имеет смысл.


/*
Каким тегом в html представляется document.documentElement?
> html


<div>
  Text
  <p><span>Text</span></p>
  Text
</div>
Сколько детей (нод Node) содержит представленный div?
> 3


<div>
  Text
  <p><span>Text</span></p>
  Text
</div>
Сколько потомков (элементов HTMLElement) содержит представленный div?
> 2
*/

/**@@
src/search.js
Реализуйте и экспортируйте по умолчанию функцию search, которая принимает на вход document и имя тега, а возвращает массив из всех элементов соответствующих этому тегу.
*/

// <body>
//   <p>1</p>
//   text
//   <div><p>2</p></div>
// </body>
const elements = search(document, 'p');
// ['<p>1</p>' '<p>2</p>'] где каждый элемент это объект соответствующего типа
console.log(elements.length); // 2

/*
Это задание подразумевает тренировку работы с домом как с деревом, по этой причине большая просьба не использовать реализацию на основе getElementsByTagName.

Подсказки
Имя тега соответствующего dom элементу, можно получить так: element.tagName
*/

const search = (doc, tag) => {
  const coll = [...doc.children];
  const initAcc = coll.filter(e => e.tagName.toLowerCase() === tag);

  return coll.reduce((acc, child) => [...acc, ...search(child, tag)], initAcc);
};

export default search;



>>>>>> Поиск по дереву <<<<<<

/*
Как правило, в реальных фронтенд-задачах нужно манипулировать наборами элементов (или одним), находящимися где-то глубоко в ДОМе. Причём зачастую эти элементы разбросаны по его разным частям. Например, мы можем отметить список файлов на удаление и выполнить это действие. С точки зрения изменения DOM Tree эта задача сводится к выборке всех элементов, которые представляют файлы (с точки зрения визуализации), и их последующему удалению.

# Специализированные поисковые методы

В такой ситуации ручной проход по дереву окажется крайне утомительным занятием. DOM предлагает сразу несколько способов решения этой задачи. Самый простой вариант поиска — это поиск по идентификатору:

<p id="content">Это параграф</p>
*/
const el = document.getElementById('content');

/*
Так как id в соответствии со спецификацией обязан быть уникальным на странице, то и метод getElementById всегда возвращает один элемент. С другой стороны, по случайности, в html может оказаться несколько тегов с одним id. В такой ситуации браузер может вернуть всё, что угодно.

Если нужна обработка сразу нескольких элементов, то тут лучше подойдёт поиск по классу:
*/

// Будет возвращена коллекция!
const collection = document.getElementsByClassName('row');

// поиск среди потомков el
el.getElementsByClassName('row');

/*
Как видите, этот метод позволяет искать не только в целом документе, но и среди потомков любого элемента.
При необходимости можно искать по тегу:
*/

document.getElementsByTagName('span');

// поиск всех элементов
document.getElementsByTagName('*');

// поиск среди потомков el
el.getElementsByTagName('span');

/*
# Поиск по селектору

Наиболее универсальным способом поиска является поиск по селектору. Напомню, что селектор — это правило, позволяющее описать набор элементов в DOM Tree.

<ul id="menu">
  <li class="even"><span>Первый</span> пункт</li>
  <li>Второй</li>
  <li class="even"><span>Третий</span> пункт</li>
</ul>
*/

// Возвращает первый элемент
const ul = document.querySelector('#menu');

const spans = ul.querySelectorAll('.even > span');

/*
Оба метода querySelector и querySelectorAll могут применяться как ко всему документу, так и к конкретному элементу. Поиск, как обычно, будет вестись среди всех потомков.

# Полезные методы

# matches
Предикат el.matches(css) проверяет, удовлетворяет ли el селектору css.

# closest
Метод el.closest(css) ищет ближайший элемент выше по иерархии, удовлетворяющий селектору. Сам элемент тоже анализируется. Если такой элемент найден, то он возвращается.

# XPath

Язык запросов, изначально разработанный для навигации по DOM в XML. Поддерживается браузерами.

<html>
 <body>
    <div>Первый слой
      <span>блок текста в первом слое</span>
    </div>
    <div>Второй слой</div>
    <div>Третий слой
      <span class="text">первый блок в третьем слое</span>
      <span class="text">второй блок в третьем слое</span>
      <span>третий блок в третьем слое</span>
    </div>
    <span>четвёртый слой</span>
    <img />
 </body>
</html>
*/


// XPath-путь /html/body/*/span/@class (полный синтаксис имеет вид /child::html/child::body/child::*/child::span/attribute::class) будет соответствовать в нём двум элементам исходного документа — <span class="text">первый блок в третьем слое</span> и <span class="text">второй блок в третьем слое</span>.

// В повседневной практике он практически не встречается при работе с DOM, поэтому здесь я его описал только для общего понимания.

// Функция console.dir выводит узлы DOM в формате, удобном для интроспекции.



>>>>>> Тесты <<<<<<

/*
Тесты, с которыми мы имели дело до этого курса, сильно отличаются от тех тестов, которые используются при проверке фронтенда.

Типичный тест выглядел так: импортируется необходимая функция, а затем вызывается с разными аргументами.
*/

import sum from '../sum';

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});


/*
Все просто и понятно. Конечно, если функция не чистая, то тест будет сложнее. Но в любом случае с этим можно разобраться.

Такие тесты называются юнит и интеграционными, в зависимости от того сколько подсистем вовлечено в проверку. Причём невозможно провести чёткую границу между этими видами тестирования. Лучше воспринимать их названия как шкалу, где слева — юниты, справа — интеграционные, а ваши тесты где-то между ними.

А как тестировать поведение кода в браузере? Ведь, по сути, основные действия, выполняемые таким кодом, это манипуляция с DOM.

# Системные тесты

Тестировать такой код действительно можно. Для этого используется специальный софт, webdriver, который посылает команды из теста в браузер и возвращает результат обратно. То есть код теста имитирует настоящие действия пользователей и смотрит то, как изменился DOM. Такой вид тестов называется системным.
*/

import Nightmare from 'nightmare';

const nightmare = new Nightmare({ show: true });

test('duckduckgo', async () => {
  const link = await nightmare
    .goto('https://duckduckgo.com')
    .type('#search_form_input_homepage', 'github nightmare')
    .click('#search_button_homepage')
    .wait('#zero_click_wrapper .c-info__title a')
    .evaluate(() => document.querySelector('.c-info__title a').href);
  expect(link).toBe('www.nightmarejs.org');
});


/*
Nightmare — это библиотека для системного тестирования. Внутри себя она использует конкретный драйвер, но для нас сейчас это не принципиально. Таких библиотек достаточно много, особенно в мире js. Конкретно nightmare, с одной стороны, популярная библиотека, с другой — позволяет запускаться в среде без графической оболочки, что важно при разработке.

В тесте, первым делом, мы указываем адрес страницы, которую необходимо открыть. Затем начинаем манипулировать этой страницей. Функция type вводит текст по указанному селектору, a click, очевидно, выполняет клик по элементу.

А вот что такое wait? Как вы знаете, браузер работает асинхронно. После клика на элемент не происходит блокирования, мы можем продолжать работать дальше. Как только код выполнится, то возможно произойдут изменения на странице. А вот то, когда это произойдёт, никто сказать не сможет. Всё, что мы можем делать, это постоянно опрашивать дом на наличие требуемого изменения. wait упрощает эту задачу. Эта функция принимает на вход селектор, за которым надо следить, и ждёт его появления. Если он появился, то управление передаётся дальше, если нет, то происходит ошибка.

Дальше мы видим функцию evaluate. Эта функция позволяет выполнить произвольный код внутри браузера. Подчеркну, тот код, который будет описан внутри функции, передающейся в evaluate, выполняется не в том месте, где запустились тесты, а внутри браузера, с которым работает драйвер. Как правило, в этом месте извлекают данные, которые нужно проверить в тесте. evaluate возвращает промис, из которого можно извлечь результат, используя async/await.

# Плюсы и минусы
Системные тесты, как правило, дают гораздо бОльшие гарантии того, что ваша система работает. Поэтому их писать полезно на особо критические участки. Но покрывать ими всё "от и до" — занятие не для слабонервных. Минусов у этого вида тестирования вагон и маленькая тележка:

# Тесты очень хрупкие
Это значит, что незначительные изменения в вёрстке приводят к тому, что они ломаются. Так как они завязаны на селекторы. Эту проблему частично можно нивелировать, используя так называемый паттерн Page Object. Его идея крайне проста. Давайте сделаем абстракцию над каждой страницей и будем работать через неё:
*/

test('LoginPage', () => {
  LoginPage.open();
  LoginPage.username.setValue('foo');
  LoginPage.password.setValue('bar');
  LoginPage.submit();
  expect(LoginPage.flash.getText()).toBe('Your username is invalid!');
});

/*
Такой подход важен и позволяет снизить хрупкость. Но всё равно эти тесты ломаются часто тогда, когда всё работает, и дело не только в вёрстке. Например, увеличение времени ответа может приводить к таймаутам, а иногда вообще происходят странные флуктуации и один запуск приводит к прохождению теста, а другой падает. В общем занятие не для слабонервных.


# Сложно писать
В системных тестах нужно полностью имитировать действия пользователей, а значит активно взаимодействовать с домом. Во время их написания, приходится постоянно шариться по исходному коду страницы, чтобы понять, как выбирать те или иные элементы. Особенно этот процесс осложняется при использовании внешних компонентов, которые генерируют с помощью js сложную вёрстку.

Так же сложности добавляет невозможность легко писать в стиле TDD. По сути, тесты всегда пишутся после отладки кода через браузер.

Ну и одна из самых больших проблем — это подготовка необходимых данных в проекте для конкретного теста, а так же очистка после. В таких тестах обычно нет прямого доступа к базе, а значит придётся искать другие пути.

# Сложно отлаживать.
Типичный вывод провалившегося теста выглядит так:
  Селектор ".title" на странице не найден

За этим выражением может скрываться всё, что угодно: начиная от ошибки 500 и заканчивая тем, что у элемента стоит стиль display: none. 


# Долгое время выполнения
Просто как факт. Эти тесты выполняются крайне долго и большой тестовый набор может лопатить сайт часами и даже днями.


# Разновидности системных тестов
Существуют и альтернативные подходы к системному тестированию. В основе тот же DOM, но проверки строятся по-другому.


# Screenshot Testing

Такой тест при первом запуске создаёт скриншот страницы, а при последующих сравнивает результаты новых запусков с исходным скриншотом. На рисунке выше слева это исходный скриншот (получаемый автоматически), по середине — результат очередного прогона, а справа — дифф.


# Snapshot Testing

Еще один способ тестирования, популяризированный компанией facebook в их фреймворке jest. Он похож на предыдущий способ, с той разницей, что сравниваются не скриншоты, а результирующий dom.
*/
test('application', () => {
  const element = document.querySelector('a[href="#profile"]');
  element.click();
  expect(getTree()).toMatchSnapshot();

  const element2 = document.querySelector('a[href="#settings"]');
  element2.click();
  expect(getTree()).toMatchSnapshot();

  const element3 = document.querySelector('a[href="#profile"]');
  element3.click();
  expect(getTree()).toMatchSnapshot();
});

/*
Как видите, в тесте выше, нет точечных проверок. Есть только функция toMatchSnapshot. Вызов этой функции в первый раз (когда снепшота нет) создаёт эталонный снепшот в директории tests/snapshots, а повторные вызовы используют его для сравнения с текущим результатом. Из этого следует, что первый запуск снепшот тестов можно выполнять только тогда, когда мы уверены в работоспособности нашего кода.

Самое прекрасное в этой технике то, что она сильно упрощает анализ результата проверки. Ниже реальный пример из заданий на Хекслете:

Received value does not match stored snapshot 3.

    - Snapshot
    + Received

    @@ -18,11 +18,11 @@
         <!-- Tab panes -->
         <div class="tab-content m-3">
             <div class="tab-pane" id="home" role="tabpanel">
                 Home
             </div>
    -        <div class="tab-pane active" id="profile" role="tabpanel">
    +        <div class="tab-pane" id="profile" role="tabpanel">
                 Profile
             </div>

      at Object.<anonymous> (__tests__/application.test.js:43:21)


Вывод почти такой же, как и у git diff. Видно, что было не так и как должно было быть. Такой подход практически идеален для задач на Хекслете, так как сильно облегчает анализ для неподготовленных людей. Но за него приходится платить определённую цену. Так как снепшот содержит в себе всю страницу, то любое малейшее изменение dom приводит к тому, что всё ломается. По этой причине крайне важно, чтобы вёрстка была практически неизменяема. Банально, классы, добавленные в элемент не в той последовательности, приведут к тому, что тесты упадут.

Другими словами, snapshot testing — не панацея. Он отлично подходит для ситуаций, где дом меняется редко и предсказуемо. Например, при разработке виджетов или в обучающих курсах.

# Дополнительные материалы
Начинаем писать тесты правильно https://www.youtube.com/watch?v=zsz8kdi62mE
*/



>>>>>> Манипулирование DOM деревом <<<<<<<

/*
То, что DOM может меняться уже будучи отрисованным в браузере, и есть ключевая возможность для создания интерактивных приложений.


# innerHTML

Самый простой способ обновить часть DOM — это функция innerHTML

<ul>
  <li>item 1</li>
  <li>item 2</li>
</ul>
*/

const body = document.body;
console.log(body);
// <ul><li>item 1</li><li>item 2</li></ul>

body.innerHTML = '<b>make</b> love';
console.log(body.innerHTML);
// <b>make</b> love

console.log(body.childNodes);
// [b, text]

/*
Эта функция целиком заменяет потомков элемента, на котором она была вызвана. Весь встречающийся внутри html парсится и становится частью дерева. Если вы пытаетесь вставить обычный текст, который потенциально может содержать html, то лучше воспользоваться другой, безопасной функцией textContent.
*/

document.body.textContent = '<b>make</b> love';
console.log(document.body.innerHTML); // "&lt;b&gt;make&lt;/b&gt; love"

/*
innerHTML работает со строками, такой подход удобен только в том случае, если мы работаем со статическим представлением DOM. Для динамического формирования хорошо подходят специальные функции.

# Создание узлов
*/

// Создаем текстовый узел
const textNode = document.createTextNode('life is life');

// Создаем элемент p
const pEl = document.createElement('p');

// Добавляем textNode в конец списка childNodes элемента pEl
pEl.append(textNode);
// pEl.textContent = 'life is life';

const el = document.createElement('div');
el.append(pEl);

console.log(el);
// <div><p>life is life</p></div>


/*
Код, создающий DOM динамически, похож на матрешку. После создания одни элементы все время вкладываются в другие. Так выглядит код, который конструирует деревья в любом языке. Утомительное занятие, скажу я вам.

# Вставка
*/

const el = document.createElement('p');
document.body.prepend(el);

// автоматически удаляется из старого места
const elFromDom = document.querySelector('.col');
document.body.append(elFromDom);

// append/prepend — не единственный способ добавить элементы в DOM:

node.after(...nodes) // вставляет nodes после узла node,
node.before(...nodes) // вставляет nodes перед узлом node,
node.replaceWith(...nodes) // вставляет nodes вместо node.
node.remove() // удаляет node

/*
# Старый API

Описанные выше функции появились не так давно. Большая часть кода написана с использованием других функций, список которых ниже:
*/

parent.appendChild(el) // добавляет el в конец списка детей
parent.insertBefore(el, nextElSibling) // добавляет el в список детей parent перед nextElSibling
parent.removeChild(el) // удаляет el из детей parent
parent.replaceChild(newEl, el) // заменяет el на newEl

/*
# Клонирование

Иногда требуется создать элемент, подобный уже существующему. Можно, конечно, это сделать полностью руками, копируя свойства одного в свойства другого, но есть способ проще:
*/
const newEl = el.cloneNode(true);

// true говорит о том, что нужно сделать "глубокую" копию, другими словами, вы получите копию не только этого элемента, но и всех его потомков.


/**@@
prettify
Реализуйте функцию prettify, которая находит текст (дочерние текстовые ноды) внутри элемента div и оборачивает текст в параграф. Экспортируйте функцию по умолчанию.

// <body>
//   <p>Boom</p>
//   text
//   <div>Bam</div>
// </body>
*/
const elements = prettify(document);
console.log(document.body.innerHTML);
/*
// <body>
//   <p>Boom</p>
//   text
//   <div><p>Bam</p></div>
// </body>

#Подсказки
Очистка строки от пробельных символов: trim
*/

export default (document) => {
  const divs = [...document.getElementsByTagName('div')];

  divs.forEach((div) => {
    const textNodes = [...div.childNodes]
      .filter(child => child instanceof Text)
      .filter(child => child.textContent.trim() !== '');

    textNodes.forEach((node) => {
      const p = document.createElement('p');
      
      p.textContent = node.textContent;
      node.replaceWith(p);
    });
  });
};



>>>>>> Управление элементами DOM <<<<<<
/*
Самая серьезная часть DOM API сосредоточена в свойствах конкретных элементов. В этом уроке мы рассмотрим только самые базовые свойства, исключительно с целью показать то, как это делается в принципе. В повседневной практике программисты постоянно обращаются к документации, чтобы узнать, как можно поменять то или иное поведение.

# Атрибуты

У каждого тега в HTML есть атрибуты. Некоторые из них общие для всех, другие специфичные для конкретных тегов.
*/

<a id="aboutPage" href="/pages/about" class="simple">About</a>

/*
В примере выше, атрибуты id и class могут использоваться с любым тегом. Специфичный атрибут href только с некоторыми, например, с <a>.

Когда браузер загрузил HTML, он строит из него DOM. Во время обработки, каждый тег становится узлом, а атрибуты - свойствами этого узла. Обычно имена атрибутов и свойств узлов совпадают между собой:
*/

// <a id="aboutPage" href="/pages/about" class="simple">About</a>
const el = document.querySelector('#aboutPage');
el.className; // simple
el.id; // aboutPage
el.href; // /pages/about

/*
Существуют и исключения, например, атрибуту class соответствует свойство className. Более того, для удобной работы с классами предусмотрены дополнительные API. Это нужно по той причине, что классов может быть много, и задаются они обычной текстовой строкой. Соответственно, если возникает задача изменения этого списка, то придется оперировать строчками, что совсем неудобно. А вот как можно это делать, используя DOM API:
*/

const el = document.querySelector('#aboutPage');
el.classList.add('page');
el.classList.remove('simple');
el.className; // page

// Дополнительные методы:
el.classList.contains("class") – возвращает true/false
el.classList.toggle("class") – если класс есть, удаляет его, и наоборот

/*
С одной стороны атрибуты отображаются на свойства, но с другой есть множество нюансов.

1. Атрибут всегда строка, а свойство — не всегда. Например:

<textarea rows="5"></textarea>
А значение свойства rows соответствующего элемента в DOM дереве будет числом.

2. Атрибуты не чувствительны к регистру
<a Id="aboutPage" hrEf="/pages/about" CLASS="simple">About</a>
Так писать, конечно же, не стоит, но по крайней мере знать о том, что оно работает - полезно.

3. Атрибут всегда присутствует в html (а значит innerHTML)
Это довольно логично. А вот огромное количество свойств не присутствует в html. Причём, для некоторых вообще нет аналогов, а другие получают значение по умолчанию, если атрибут не проставлен.

Как мы увидели выше, атрибут и свойство, в общем случае — не одно и то же. Поэтому существует набор методов для управления атрибутами:
*/

el.hasAttribute(name) – проверяет наличие атрибута
el.getAttribute(name) – получает значение атрибута
el.setAttribute(name, value) – устанавливает атрибут
el.removeAttribute(name) – удаляет атрибут
el.attributes - список html атрибутов

// Методы работают с атрибутами html
el.getAttribute('class');

/*
Обратите внимание на то, что они работают именно с атрибутами (их именами), а не свойствами. И позволяют не только их извлекать, но и менять. Возникает закономерный вопрос: поменяется ли атрибут, если поменять свойство и наоборот?

В основном синхронизация осуществляется только в сторону свойств. То есть, меняется атрибут и автоматически обновляется свойство. Но существуют и исключения. Из этих тезисов не следует делать вывод, что нужно стараться работать через атрибуты. Наоборот, по возможности, всегда работайте со свойствами дом дерева, а атрибуты используйте только для чтения, чтобы получить то состояние, которое было в доме на момент инициализации (парсинга html).

<a id="aboutPage" href="/pages/about" class="simple">About</a>
*/

const el = document.querySelector('#aboutPage');
el.setAttribute('class', 'page');
el.className; // page
el.getAttribute('class'); // page

/*
В отличие от свойств значение атрибута всегда совпадает с тем, что мы видим в html, а вот для свойства иногда приводятся в нормализованный вид:
В этот момент браузер открыт на https://ru.hexlet.io
<a id="link-to-courses" href="/courses">Курсы</a>
*/

const el = document.querySelector('#link-to-courses');
el.href; // https://ru.hexlet.io/courses
el.getAttribute('href'); // /courses

/*
Нестандартные атрибуты никогда не превращаются в свойства соответствующих элементов DOM дерева. То есть, если мы добавим в тег p атрибут href то оно будет проигнорировано. Хотя это не отменяет возможность его извлечения через getAttribute.

Для работы с произвольными свойствами в html зарезервирован специальный атрибут data-*, где на месте звездочки может стоять любое слово.

<a href="#" data-toggle="tab">Мои проекты</a>
Такие атрибуты активно используются в js плагинах и позволяют не завязываться на классы. В элементах DOM они доступны через специальное свойство dataset:
*/

console.log(el.dataset.toggle); // tab

/*
Внутри объекта dataset имя каждого свойства — это строка после data- в атрибуте. Если имя содержит дефис, то он удаляется, а следующее за ним буква становится заглавной:
<a href="#" data-nav-toggle="tab">Мои проекты</a>
*/

console.log(el.dataset.navToggle); // tab

/*
# Свойства

В зависимости от типа элемента меняется и набор свойств. Кроме, конечно, тех что достались в наследство от Node и Element.
Чтобы узнать список этих свойств, можно обращаться к спецификации. Они описаны в специальном формате, который интуитивно понятен:

interface HTMLLinkElement : HTMLElement {
  attribute USVString href;
  attribute DOMString? crossOrigin;
  attribute DOMString rel;
  attribute RequestDestination as; // (default "")
  readonly attribute DOMTokenList relList;
  attribute DOMString media;
  attribute DOMString nonce;
  attribute DOMString integrity;
  attribute DOMString hreflang;
  attribute DOMString type;
}

Кроме всего прочего, так как элементы являются обычными js объектами, мы можем добавлять в них любые свойства. Лучше такой подход не практиковать, но в теории вы можете на него наткнуться в реальных приложениях.

Правильный подход при работе с DOM состоит в том, что данные хранятся отдельно от DOM дерева.
*/

/**@@
Реализуйте и экспортируйте по умолчанию функцию normalize, которая нормализует имена классов для всех элементов на странице. В данном случае это означает, что происходит преобразование всех классов, написанных с использованием kebab нотации, в camelCase нотацию: text-center => textCenter

Попробуйте решить эту задачу без использования регулярных выражений.
*/

// <body>
//   <div class="text-center row-b">Bam</div>
// </body>
normalize(document);
console.log(document.body.innerHTML);
// <body>
//   <div class="textCenter rowB">Bam</div>
// </body>

/*
Подсказки
- Самый простой способ найти все элементы в документе это document.body.getElementsByTagName('*')
- Приведение к camelCase https://lodash.com/docs/4.17.11#camelCase
- Замена классов replace у объекта classList
*/

// FILE: /app/src/normalize.js:
import { camelCase } from 'lodash';

export default (doc) => {
  for (const element of doc.body.getElementsByTagName('*')) { 
    const process = item => element.classList.replace(item, camelCase(item));
    
    element.classList.forEach(process);
  }
};



>>>>>> Полифиллы <<<<<<

/*
Как я уже неоднократно упоминал, DOM не везде одинаковый, к тому же он непрерывно развивается. Какие-то браузеры его адаптируют быстрее, какие-то медленнее. Все это не позволяет легко и непринужденно пользоваться последними новинками.

Впрочем, как мы уже знаем, то же самое относится и к самому js в браузере. С js нам помогает babeljs, а вот кто поможет с DOM?

Библиотеки, которые добавляют в DOM (вы ведь помните, что это просто объект?) необходимые свойства и методы, называются полифиллами.

Общий принцип работы этих библиотек следующий:

1. Проверяем наличие возможности
2. Если ее нет, то добавляем

# Добавление метода
*/

(function(constructor) {
  const p = constructor.prototype;
  if (!p.matches) {
    p.matches = p.matchesSelector ||
    p.mozMatchesSelector ||
    p.msMatchesSelector ||
    p.oMatchesSelector ||
    p.webkitMatchesSelector;
  };
})(window.Element);


// Добавление свойства
if (!('lastElementChild' in document.documentElement)) {
  Object.defineProperty(Element.prototype, 'lastElementChild', {
    get: function() {
      for (let nodes = this.children, n, i = nodes.length - 1; i >= 0; --i) {
        if (n = nodes[i], 1 === n.nodeType) {
          return n;
        }
      }
      return null;
    }
  });
}

/*
Примеры выше не являются полными. Если посмотреть исходники соответствующих библиотек, то хочется их быстрее закрыть. Количество кода иногда зашкаливает до неприличия. Обратите внимание на то, что добавление свойства производится особым образом, таким, который позволяет сделать свойство динамическим и ленивым. То есть его значение будет вычисляться только в момент обращения.

Чтобы узнать поддержку определенных фич в разных браузерах, можно воспользоваться прекрасным ресурсом https://caniuse.com/

Иногда бывает нужно просто проверить наличие определенной фичи, и в зависимости от результата выполнять разный код. В такой ситуации поможет библиотека modernizr.
*/

Modernizr.on('flash', function( result ) {
  if (result) {
   // the browser has flash
  } else {
    // the browser does not have flash
  }
});

/*
А самый простой способ добавить полифиллы на свой сайт — это воспользоваться проектом https://polyfill.io/v2/docs/. Все что вам нужно будет сделать, это вставить следующий тег:

<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>

Этот файл формируется динамически под конкретный браузер и на страницу закачивается только то, что нужно полифиллить.
*/



>>>>>> Введение в события <<<<<<

/*
Интерактивные системы, такие как сайты в браузере или, даже, терминал, устроены по одному и тому же принципу. После загрузки, они находятся в режиме "ожидания" действий от пользователя. К таким действиям относятся клики, набор текста, перемещение мышки, горячие клавиши и многое другое.

С точки зрения кода, все действия представлены событиями. События в браузере, являются частью стандарта DOM. Вот некоторые из них:

- click
- submit
- keyup/keydown
- focus
- contextmenu
- mouseover
- mousedown/mouseup

Как видите, их гранулярность достаточно высокая, набор текста раскладывается на два события: кнопка зажата и кнопка отпущена. Кроме этого, есть специальное событие keypress, которое позволяет отличать горячие клавиши от нормального ввода.

Самый простой способ попробовать события в действии, это использование специализированных атрибутов:
<button onclick="alert('Бум!')"></button>
<div onclick="alert(this.innerHTML)">Бум!</div>

Обработчик события можно определить и снаружи:

<script>
  const getBoom = () => alert('Boom!');
</script>

<button onclick="getBoom()"></button>
*/


/*
Ну, и конечно через свойство элемента в DOM:
<button id="myButton"></button>
*/

const button = document.getElementById('myButton');
button.onclick = () => alert('Boom!');

/*
В такой ситуации мы не вызываем обработчик, а только устанавливаем его в свойство onclick.

У этого способа есть один недостаток, который актуален там, где на странице есть множество скриптов, работающих независимо на одних и тех же элементах. Он заключается в том, что невозможно повесить одновременно несколько обработчиков. Перезаписав свойство onclick старый обработчик будет потерян безвозвратно.

На уровне атрибутов эта проблема не решаема, но в DOM есть метод, позволяющий повесить множество обработчиков.
<button id="myButton"></button>
*/

const button = document.getElementById('myButton');

button.addEventListener('click', () => alert('Boom 1!'));
button.addEventListener('click', () => alert('Boom 2!'));

/*
Каждый обработчик события, представляет собой функцию, которая будет вызвана в момент наступления события. Обработчики вызываются один за другим, в том же порядке, в котором они были определены. Подчеркну что обработчик это функция, а не вызов функции. Вот так делать неверно:
*/

const button = document.getElementById('myButton');
const handler = () => alert('Boom 1!');
button.addEventListener('click', handler()); // передается не сама функция, а ее результат

// При необходимости, можно удалить обработчик:
const button = document.getElementById('myButton');

const handler = () => alert('Boom 1!');
button.addEventListener('click', handler);
button.removeEventListener('click', handler);

/*
Обратите внимание на то, что удаление сработает только в том случае, если вы передадите в функцию removeEventListener ту же самую функцию. Не "такую же по структуре", а именно ту же самую, другими словами такой код не удалит нужный обработчик:
*/
const button = document.getElementById('myButton');

button.addEventListener('click', () => alert('Boom 1!'));
button.removeEventListener('click', () => alert('Boom 1!'));

/*
В процессе выполнения обработчиков могут возникать новые события, как от действий пользователя, так и программно, в самих обработчиках, а некоторые события всегда возникают целым блоком, например mouseup и click. Но это не означает что выполнение кода сразу переключается на обработку этих событий. Вместо этого, события складываются в очередь и будут выполнены строго последовательно.

Но некоторые события, все же, берутся в обработку сразу. Это касается тех событий, которые генерируются программно, например onfocus.

Возникает закономерный вопрос, что происходит со страницей во время выполнения обработчика? И здесь возможны варианты. Если обработчик выполняет некоторый код синхронно, например занимается вычислениями, то в этот момент, блокируется все остальное (не считая webworkers) и страница замирает (говорят фризится).

Если такое поведение длится слишком долго, то некоторые браузеры зависают, а другие предлагают закрыть вкладку. Отсюда вывод, обработчики должны выполнять свою задачу максимально быстро. Если задача долгая и синхронная, то ее можно вынести либо в webworker, либо разбить на этапы, фактически реализовав кооперативную многозадачность (основы операционных систем, в любой книге). Самый простой способ сделать это, переодически прерывать выполнение и продолжать выполнять через setTimeout. Это позволит выполниться остальным событиям.

А что если задача асинхронная, например выполняется запрос к серверу? В таком случае все продолжает прекрасно работать.

Вообще говоря, из этого урока должно стать понятно, почему js именно такой, какой есть. Событийная система возможна только в асинхронном коде. По сути, при загрузке страницы происходит инициализация и установка обработчиков, а дальше, как правило, не выполняется никакой код, вся страница находится в ожидании действий от пользователя.

# Объект события

С каждым возникающим событием связана информация, зависящяя от типа события. Например событие click это не только факт сам по себе, но так же и координаты точки на экране, где был совершен клик. Эта информация доступна через специальный объект-событие.

<div id="myElement">Бум!</div>
const button = document.getElementById('myElement');
*/
button.addEventListener('click', e => alert(e.target.textContent));

/*
По умолчанию этот объект передается всегда, в любой обработчик, как единственный параметр. Если он вам не нужен, то его можно проигнорировать.

Базовые свойства объекта Event:
- event.target - элемент на котором произошло событие
- event.type - тип события

У каждого типа событий свой набор свойств, подробнее о них смотрите в документации https://developer.mozilla.org/en/docs/Web/Events/click.

# Действие по умолчанию

Некоторые элементы в DOM обладают действиями по умолчанию. Например если повесить обработчик на клик по ссылке, то выполнив этот клик, мы внезапно перейдем на другую страницу, ту которая была указана в href. Здесь мы видим пример того самого действия по умолчанию, на которое никак не влияет наличие обработчиков. Чтобы отменить это действие, а такое бывает нужно часто, необходимо вызвать метод event.preventDefault() внутри обработчика.

<a href="#" id="myElement">Бум!</a>
*/
const button = document.getElementById('myElement');

button.addEventListener('click', (e) => {
  e.preventDefault();

  alert(e.target.textContent);
});

/*
Иногда вы можете встретить такой код:
<a href="#" id="myElement" onclick="alert('hey'); return false;">Бум!</a>

Возврат false внутри значения атрибута, приводит к такому же эффекту.

Действиями по умолчанию обладают следующие элементы:

 - Клик по ссылке приводит к переходу на страницу указанную в href атрибуте.
 - Клик на кнопку с типом submit начинает отправку формы на сервер.
 - Вращение колесом мышки в textarea передвигает текст если он не помещается
 - Вызов контекстного меню с помощью правого клика мышки


# Оживление страницы 

В промышленной разработке, как правило, в первую очередь используются уже написанные кем-то компоненты, и только в крайнем случае используются свои. Большая часть этих компонентов реализована таким образом, что может работать с любым сайтом и с минимальным уровнем конфигурирования. Вплоть до того, что вам даже не придется вызвать js для его работы.

Существует несколько подходов, которые используются для подключения компонентов на странице:

# Через класс

Здесь все очень просто. Для работы компонента требуется наличие определенного класса у тега. Иногда есть класс по умолчанию, который описан в документации, но его можно и поменять.

<select class="style-select">
  <option>1</option>
  <option>2</option>
</select>
<script>
  styleSelect('select.style-select');
</script>

# Через data-* атрибуты

Этот подход более гибкий и, например, активно используется в Bootstrap. Вместо указания классов, каждый компонент определяет свой data-* атрибут (или набор таких атрибутов). Одно из преимуществ перед классами заключается в том, что, в отличие от класса, атрибут имеет значение и это можно использовать.

Библиотека jquery-ujs, изначально написанная для rails (но подходит для всего), позволяет очень легко получать разные возможности в html без прямого использования js. Например мы можем захотеть сделать отправку по ссылке используя глагол POST. С этой библиотекой достаточно написать следующее:

<a href="page/url" data-method="post">Submit</a>

Возможно мы хотим подтверждение действия перед выполнением. Делается это крайне просто:
<a href="page/url" data-confirm="Are you sure?">Submit</a>


Точно так же в Bootstrap работают почти все компоненты. Например выпадающее меню:
<div class="dropdown">
  <button class="btn btn-secondary dropdown-toggle" type="button" data-toggle="dropdown">
    Dropdown button
  </button>
  <div class="dropdown-menu">
    <a class="dropdown-item" href="#">Action</a>
    <a class="dropdown-item" href="#">Another action</a>
    <a class="dropdown-item" href="#">Something else here</a>
  </div>
</div>
*/


/**@@
В Bootstrap есть компонент nav (Обязательно перейдите по ссылке и покликайте по нему). Один из вариантов этого компонента, это табы, которые переключаются, по нажатию, без перезагрузки страницы.

      <ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
          <a class="nav-link active" data-toggle="tab" href="#home3" role="tab">Home 2</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="tab" href="#profile3" role="tab">Profile 2</a>
        </li>
      </ul>

      <!-- Tab panes -->
      <div class="tab-content m-3">
        <div class="tab-pane active" id="home3" role="tabpanel">
          Home
        </div>
        <div class="tab-pane" id="profile3" role="tabpanel">
          Profile
        </div>
      </div>

      <!-- Nav tabs -->
      <ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
          <a class="nav-link active" data-toggle="tab" href="#home" role="tab">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="tab" href="#profile" role="tab">Profile</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="tab" href="#messages" role="tab">Messages</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="tab" href="#settings" role="tab">Settings</a>
        </li>
      </ul>

      <!-- Tab panes -->
      <div class="tab-content m-3">
        <div class="tab-pane active" id="home" role="tabpanel">
          Home
        </div>
        <div class="tab-pane" id="profile" role="tabpanel">
          Profile
        </div>
        <div class="tab-pane" id="messages" role="tabpanel">
          Messages
        </div>
        <div class="tab-pane" id="settings" role="tabpanel">
          Settings
        </div>
      </div>

      <ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
          <a class="nav-link active" data-toggle="tab" href="#home2" role="tab">Home 2</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="tab" href="#profile2" role="tab">Profile 2</a>
        </li>
      </ul>

      <!-- Tab panes -->
      <div class="tab-content m-3">
        <div class="tab-pane active" id="home2" role="tabpanel">
          Home
        </div>
        <div class="tab-pane" id="profile2" role="tabpanel">
          Profile
        </div>
      </div>

    </div>

По клику на таб происходит следующее:
- Класс active снимается с текущего элемента меню
- У ссылки и дива с данными добавляется класс active

Общий принцип работы в том, что каждый таб представлен ссылкой с href в виде хеша #profile, а ниже определен div с id равным profile. По клику на таб, код должен извлечь id, найти соответствующий элемент и сделать его активным, не забыв при этом снять класс active с таба который был активным до клика.

src/application.js
Реализуйте логику переключения табов.

Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов nav.

Технически, бутстрап ориентируется на наличие аттрибута data-toggle и именно по нему решает активировать ли динамическое поведение для компонента nav. Если его нет, значит данное меню не динамическое.
*/

const handle = ({ target }) => {
  const nav = target.closest('.nav');
  const current = nav.querySelector('a.active');
  current.classList.remove('active');
  const currentTabContentId = current.hash.slice(1);
  const currentTabContent = document.getElementById(currentTabContentId);
  currentTabContent.classList.remove('active');

  target.classList.add('active');
  const nextTabContentId = target.hash.slice(1);
  const nextTabContent = document.getElementById(nextTabContentId);
  nextTabContent.classList.add('active');
};

const links = document.querySelectorAll('a[data-toggle]');

links.forEach((element) => {
  element.addEventListener('click', handle);
});



>>>>>>Перехват и всплытие <<<<<<

/*
Предположим что у нас есть два вложенных элемента, на каждом из которых висит обработчик события click. Если выполнить щелчок по области внешнего элемента, не затрагивающей внутренний, то выполнится обработчик, привязанный к этому внешнему элементу. Если выполнить щелчок по внутреннему элементу, автоматически выполнится щелчок и по внешнему, а значит, отработают оба события.

<div>
  <button>Send</button>
</div>
*/

button.addEventListener('click', () => alert('Boom 1!'));
div.addEventListener('click', () => alert('Boom 2!'));

/*
Возникает закономерный вопрос, в каком порядке выполнятся эти события после щелчка на кнопку? В общем случае, событие проходит сквозь дерево начиная от корня до самого глубокого элемента, на котором событие сработало, и затем, в обратном направлении. Путешествия события туда и обратно, называется его стадиями или фазами, ниже о них подробнее.


# Погружение (Capturing)

Когда событие только возникло, оно начинает двигаться по DOM-дереву, начиная от корневого узла, до самого глубокого, на котором произошло событие. Попутно выполняются все обработчики связанные с этим событием.

               | |
---------------| |---------------
| div          | |              |
|   -----------| |-----------   |
|   | button   \ /          |   |
|   -------------------------   |
|        Event CAPTURING        |
---------------------------------

На стадии погружения выполняются не все обработчики, а только те которые были привязаны к этой стадии. Привязка регулируется третьим параметром функции addEventListener.
*/

button.addEventListener('click', () => alert('Boom 1!'), true);
div.addEventListener('click', () => alert('Boom 2!'), true);

/*
Значение true привязывает обработчики к стадии погружения. Получится такой вывод:
Boom 2!
Boom 1!

# Всплытие (Bubbling)

После остановки погружения на target элементе, начинается всплытие.

               / \
---------------| |---------------
| div          | |              |
|   -----------| |-----------   |
|   | button   | |          |   |
|   -------------------------   |
|        Event BUBBLING         |
---------------------------------


Именно эта стадия подразумевается при вызове addEventListener без указания третьего параметра.
*/
button.addEventListener('click', () => alert('Boom 1!'));
div.addEventListener('click', () => alert('Boom 2!'));

/*
На ней выполнение обработчиков происходит изнутри наружу:
Boom 1!
Boom 2!

# W3C Модель

Согласно стандарту, большинство событий проходят обе стадии, сначала погружаясь в глубину дерева и затем поднимаясь до самого верха. Стадия погружения, при этом, используется крайне редко, большая часть обработчиков вешается на стадию всплытия.

В предыдущем уроке, мы познакомились с объектом e.target. Это самый глубокий элемент до которого идет погружение. Target не меняется в процессе всплытия. Благодаря нему всегда можно узнать где конкретно произошло событие. Кроме него, доступен объект currentTarget - это элемент, к которому прикреплен данный обработчик. В зависимости от ситуации используется тот или иной.

В обычной ситуации событие должно всплывать до конца, но иногда могут возникать ситуации, когда всплытие нежелательно.

Сделать это можно двумя способами:
*/
event.stopPropagation()
event.stopImmediatePropagation()

// Первый останавливает всплытие, но дает возможность доработать всем обработчикам, которые висят на текущем элементе, второй же, не дает выполнится больше ни одному обработчику.


/**@@
Игра в 15 или пятнашки — популярная головоломка, придуманная в 1878 году Ноем Чепмэном. Представляет собой набор одинаковых квадратных костяшек с нанесёнными числами, заключённых в квадратную коробку. Длина стороны коробки в четыре раза больше длины стороны костяшек для набора из 15 элементов, соответственно в коробке остаётся незаполненным одно квадратное поле. Цель игры — перемещая костяшки по коробке, добиться упорядочивания их по номерам, желательно сделав как можно меньше перемещений.

| 1  | 2  | 9  | 12 |
|----|----|----|----|
| 4  | 3  | 8  | 10 |
|----|----|----|----|
| 15 | 14 | 5  | 7  |
|----|----|----|----|
| 11 | 13 | 6  |    |

src/application.js

Реализуйте эту игру внутри функции экспортируемой по-умолчанию, учитывая следующие моменты:

- Перемещение происходит по клику. Если номер, на котором был клик, находится рядом с пустой областью, то он перемещается на эту область. Если пустой области рядом нет, то ничего не происходит.
- При перемещении числа, из текущей ячейки удаляется класс table-active и добавляется на ту, откуда происходит перемещение (та что становится пустой).
- В файле уже заданы values, в том порядке в котором они должны появляться в выводе. Для упрощения тестирования, этот порядок всегда один и тот же.
- В файле index.html находится div с классом gem-puzzle, именно к нему нужно привязывать игру.

html первой позиции должен получиться таким:

<div class="gem-puzzle">
  <table class="table-bordered">
    <tbody>
      <tr>
        <td class="p-3">8</td>
        <td class="p-3">11</td>
        <td class="p-3">7</td>
        <td class="p-3">12</td>
      </tr>
      <tr>
        <td class="p-3">3</td>
        <td class="p-3">15</td>
        <td class="p-3">6</td>
        <td class="p-3">10</td>
      </tr>
      <tr>
        <td class="p-3">2</td>
        <td class="p-3">5</td>
        <td class="p-3">13</td>
        <td class="p-3">14</td>
      </tr>
      <tr>
        <td class="p-3">9</td>
        <td class="p-3">1</td>
        <td class="p-3">4</td>
        <td class="p-3 table-active"></td>
      </tr>
    </tbody>
  </table>
</div>


Теги и классы должны совпадать.

Подсказки
 - Используйте дополнительную навигацию доступную в таблицах: rows, cells.
 - Достаточно повесить событие на всю таблицу и использовать возможности всплытия
 - У cell есть свойство cellIndex у row есть свойство rowIndex
*/

// FILE: /app/public/index.html:
/*
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  </head>
  <body>
    <div class="container m-3">
      <div class="gem-puzzle"></div>
    </div>
    <script src="/vendors~main.js" ></script>
    <script src="/main.js" ></script>
  </body>
</html>
*/

// FILE: /app/src/index.js:
import app from './application';

app();


// FILE: /app/src/application.js:
const values = [8, 3, 2, 9, 11, 15, 5, 1, 7, 6, 13, 4, 12, 10, 14];

const generatePlayingField = () => {
  const tableEl = document.createElement('table');

  tableEl.className = 'table-bordered';

  for (let i = 0; i < 4; i += 1) {
    const row = tableEl.insertRow(); // добавляет новую строку в таблицу и возвращает на неё ссылку.

    for (let j = 0; j < 4; j += 1) {
      const cell = row.insertCell(); // метод вставляет ячейку в текущей строке.

      cell.className = 'p-3';

      if (i === 3 && j === 3) {
        cell.classList.add('table-active');
      } else {
        cell.textContent = values[i + (j * 4)];
      }
    }
  }

  return tableEl;
};

const getDistance = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);

export default () => {
  let currentPosition = { x: 3, y: 3 };
  const tableEl = generatePlayingField();

  tableEl.addEventListener('click', (e) => {
    const cell = e.target;
    const { cellIndex, parentElement: { rowIndex } } = cell;
    const newPosition = { y: rowIndex, x: cellIndex };
    const distance = getDistance(currentPosition, newPosition);

    if (distance !== 1) {
      return;
    }

    const point = tableEl.rows[currentPosition.y].cells[currentPosition.x];
    point.textContent = cell.textContent;
    point.classList.remove('table-active');
    cell.textContent = '';
    cell.classList.add('table-active');
    currentPosition = { x: cellIndex, y: rowIndex };
  });

  const root = document.querySelector('.gem-puzzle');
  root.append(tableEl);
};

>>>>>> События документа <<<<<<

/*
Кроме событий, которые возникают в ответ на действия пользователей, существует ряд событий, которые живут своей жизнью. К таким событиям относятся события на загрузку и выгрузку страницы:

- DOMContentLoaded – DOM-дерево построено
- load – все ресурсы загружены (картинки, стили, скрипты, ...)
- beforeunload - уйти со страницы

DOMContentLoaded возникает в тот момент, когда DOM дерево полностью построено и готово к работе, но, при этом, стили, скрипты и картинки могут находиться в процессе загрузки.

Это событие происходит на document:
*/

document.addEventListener('DOMContentLoaded', () => {
    const coll = document.querySelectorAll('.help');
    [...coll].forEach(el => el.classList.add('hidden'));
  });

/*
Скорость построения DOM дерева, очень зависима от тегов <script>. По стандарту, любой <script> встреченный в HTML будет выполняться до полного построения дерева. Следовательно скорость отработки кода в этом блоке <script> будет сильно влиять на то, когда пользователь увидит сам сайт и то, когда сработает событие DOMContentLoaded.

Поскольку DOM полностью готов только тогда, когда срабатывает событие DOMContentLoaded, многие механизмы активизируются именно на нем, например, браузерная подстановка значений в поля форм. По этой же причине, большинство сайтов, инициализируют интерфейсы также на этом событии.

Тема оптимизации загрузки скриптов и быстрой инициализации достаточно сложна. Это связано не только с большим количеством факторов влияющих на порядок и скорость, но так же и с тем, что в разных браузерах этот механизм работает по разному. Здесь мы не будем его разбирать, это тема продвинутого уровня и по ней написано множество статей.

Обратите внимание на красную и синюю полоску. Красная показывает момент когда сработало событие load, а синяя - DOMContentLoaded. Внизу картинки указано время срабатывания каждого события, от начала загрузки страницы.

Из картинки видно, что браузер сначала скачивает саму страницу (ее html), а затем начинает скачивать ресурсы (картинки, стили и скрипты), причем делает это параллельно.
*/


>>>>>> AJAX <<<<<<

/*
Манипуляции с dom деревом помогают сделать наши сайты более живыми, но их все же недостаточно для создания автономных виджетов или полноценных (имеющих бекенд) Single Page Application (SPA).

Рассмотрим конкретный пример. Многие сервисы дают возможность использовать разные виджеты, например, погода или курсы валют. Работает это так: вы вставляете в свой html код предоставленный сервисом. Далее этот код подгружает сам виджет и периодически обращается за необходимыми данными на сервера сервиса. Это может происходить в тот момент, когда пользователь виджета нажимает кнопки, требующие новых данных: например, показать погоду за следующую неделю.

Кстати, подобный виджет используется на Хекслете. В уроке в правом нижнем углу есть пункт "Техподдержка", а вне уроков в углу висит синий кружочек. По нажатию появляется специальная форма обратной связи. Она предоставлена специальным сервисом, который помогает нам обрабатывать фидбек от пользователей, причем работа этой формы никак не связана с бекендом Хекслета.

Ключевая технология в этой истории, механизм для выполнения http запросов прямо из браузера. Именно его называют AJAX, что расшифровывается как "Asynchronous JavaScript and XML". Несмотря на название, эта технология работает не только с xml.

# XMLHttpRequest

До появления html5, браузеры предоставляли (и сейчас предоставляют) специальный объект XMLHttpRequest:
*/

const request = new XMLHttpRequest();

request.onreadystatechange = () => {
  if (this.readyState == 4 && this.status == 200) {
    document.getElementById('demo').innerHTML = this.responseText;
  }
};

request.open('GET', '/api/v1/articles/152.json', true);
request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
request.send();

/*
Работать с ним крайне неудобно и, по сути, все использовали обертку созданную в рамках библиотеки JQuery. Подробнее об этом будет в уроке посвященному JQuery.

# Fetch

С появлением стандарта HTML5, появился новый механизм для http запросов:
*/

// const promise = fetch(url[, options]);
fetch('/api/v1/articles/152.json')
  .then((response) => {
    console.log(response.status); // 200
    console.log(response.headers.get('Content-Type'));

    return response.json();
   })
  .then((article) => {
    console.log(article.title); // Как использовать fetch?
  })
  .catch(console.error);

/*
Как видно, fetch это функция возвращающая промис, а значит работать с ней удобно и приятно. А благодаря наличию полифиллов можно не переживать о том что какой-то браузер не поддерживает этот механизм.

Обратите внимание на то что response.json тоже возвращает промис. Кроме json данные можно получать используя функции blob, text, formData и arrayBuffer.

Отправка формы POST запросом:
*/

const form = document.querySelector('form');

fetch('/users', {
  method: 'POST',
  body: new FormData(form),
});


// Отправка формы как json:
fetch('/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Hubot',
    login: 'hubot',
  })
})

/*
При всех своих преимуществах, fetch довольно низкоуровневый механизм. Например работая с json (очень частый вариант), придется самостоятельно выставлять заголовки и делать разные манипуляции с данными, которые можно было бы автоматизировать.

На практике, это привело к созданию различных библиотек, которые работают схожим образом, но дают гораздо больше возможностей. Причем многие из этих библиотек изоморфные, то есть работают одинаково и в браузере и на сервере. Одна из самых популярных библиотек на момент создания курса - axios https://github.com/mzabriskie/axios.


# URL

Как мы знаем из предыдущих курсов, клеить строчки для работы с путями или урлами это плохая идея. Можно легко ошибиться и, в целом, приходится выполнять работу, которую может выполнять машина. В Node.js с этим никаких проблем, у нас есть соответствующие модули, а вот в браузере это всегда вызывало сложности. Распарсить url или собрать легко и просто не получалось.

С одной стороны, можно всегда воспользоваться сторонними библиотеками, которых достаточно много, но с другой, в браузерах уже есть встроенный для этого механизм (как обычно добавляется полифиллами).
*/

const url = new URL('../cats', 'http://www.example.com/dogs');
console.log(url.hostname); // www.example.com
console.log(url.pathname); // /cats

url.hash = 'tabby';
console.log(url.href); // http://www.example.com/cats#tabby

url.pathname = 'démonstration.html';
console.log(url.href); // http://www.example.com/d%C3%A9monstration.html

// Что особенно приятно, fetch умеет работать с объектом URL напрямую:
const response = await fetch(new URL('http://www.example.com/démonstration.html'));

// А вот как можно работать с query параметрами:
// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get('id')); // 123
parsedUrl.searchParams.append('key', 'value')
console.log(parsedUrl); // https://some.site/?id=123&key=value

/*
# HTTP access control (CORS)

В отличие от бекенда, http запросы на клиенте могут использоваться злоумышленниками для кражи данных. Поэтому браузеры контролируют то, куда и как делаются запросы.

Подробно об этом механизме можно прочитать тут https://habr.com/ru/company/ruvds/blog/421347/
*/



/**@@
Задача этого упражнения состоит в том чтобы реализовать автокомплит по странам. На странице присутствует элемент input, с аттрибутами data-autocomplete и data-autocomplete-name, к которому нужно привязаться. Атрибут data-autocomplete содержит ссылку, по которой нужно делать запрос на данные. Атрибут data-autocomplete-name содержит имя, по которому необходимо найти на странице список ul с точно таким же аттрибутом и значением. В этом списке выводятся данные.

src/application.js
Реализуйте автокомплит по странам.

Как только в поле ввода появляется хотя бы один символ, необходимо выполнить запрос на сервер с параметром term значением которого, будет строка введенная в input. Сервер возвращает массив из стран (на английском языке).

Если этот массив не пустой, то нужно заполнить список (посмотреть его нахождение можно либо через public/index.html либо открыв исходный код страницы в веб доступе) таким образом:

<ul data-autocomplete-name="country">
  <li>pakistan</li>
  <li>panama</li>
  <li>paraguay</li>
</ul>
Если с сервера пришел пустой список то нужно вывести:

<ul data-autocomplete-name="country">
  <li>Nothing</li>
</ul>

Подсказки
Для формирования правильного запроса на сервер, используйте URL https://nodejs.org/api/url.html#url_url_strings_and_url_objects
Значение поля input необходимо брать из события так: e.target.value
Используйте async/await
Ваш код должен работать даже в том случае если на странице множество автокомплитов
Используйте событие input https://developer.mozilla.org/en-US/docs/Web/Events/input
*/

// FILE: /app/public/index.html:
/*
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  </head>
  <body>
    <div id="container" class="container m-3">
      <div class="row">

        <div class="col-6">
          <div class="form form-inline">
            <div class="form-group">
              <label>Country</label>
              <input type="text" data-autocomplete-name="country" data-autocomplete="/countries.json" class="form-control">
            </div>
          </div>
        </div>
        <div class="col-6">
          <ul data-autocomplete-name="country">
            <li>Nothing</li>
          </ul>
        </div>
      </div>
    </div>
    <script src="/vendors~main.js" ></script>
    <script src="/main.js" ></script>
  </body>
</html>
*/

import '@babel/polyfill';
import 'whatwg-fetch';

export default () => {
  const autocompleteElements = document.querySelectorAll('input[data-autocomplete]');

  autocompleteElements.forEach((el) => {
    const route = el.dataset.autocomplete;

    el.addEventListener('input', async (e) => {
      const dataAutocompleteName = el.dataset.autocompleteName;
      const oldList = document.querySelector(`ul[data-autocomplete-name="${dataAutocompleteName}"]`);
      const url = new URL(route, window.location.origin);
      url.searchParams.append('term', e.target.value);
      const response = await fetch(url);
      const countries = await response.json();
      const list = document.createElement('ul');
      list.dataset.autocompleteName = dataAutocompleteName;
      if (countries.length === 0) {
        countries.push('Nothing');
      }
      countries.forEach((country) => {
        const li = document.createElement('li');
        li.textContent = country;
        list.append(li);
      });
      oldList.replaceWith(list);
    });
  }); 
};



>>>>>> JQuery <<<<<<

/*
В августе 2006 года Джон Резиг выпустил библиотеку JQuery. За короткое время эта библиотека завоевала огромную популярность и стала стандартом де-факто при разработке интерактивных элементов на сайтах.
*/

// Знак $ — это функция JQuery, через которую все и делается
$(() => {
  // Эта функция выполнится на событие DOMContentLoaded
});

/*
Во многом, это случилось, потому что JQuery появилась в нужное время в нужном месте. В те года шел переход к верстке без использования таблиц, и css использовался все активнее и разнообразнее. JQuery позволил переиспользовать те же самые селекторы для добавления поведения.

К тому же, в JQuery был реализован CSS3 гораздо раньше, чем он появился нативно в самих браузерах. Более того, JQuery в принципе позволила практически не думать о разных браузерах, так как ее задачей было, в том числе, обеспечить работоспособность на всех платформах.
*/

// Работает так же, как и document.querySelectorAll
const spans = $('.section span');

/*
Еще одной причиной успеха стало то, что JQuery популяризовал отделение верстки от поведения. Такую технику называют "ненавязчивый javascript". Ее идея в том, что обработчики событий описываются не в самих тегах, а отдельно:
*/

$('button').click(() => {
  alert('hey!');
});

/* 
Вместо:
<button onclick="alert('hey!')">

Сам JQuery при этом является прекрасным примером DSL (предменто-ориентированный язык). Как правило, код на JQuery выражает задачу в тех же терминах, в которых эта задача формулируется:
*/

$('container.main').hide();
$('#address').remove();

// Fluent interface
$('#p1').css('color', 'red').slideUp(2000).slideDown(2000);

/*
И это еще не все. JQuery долгое время предоставляла единственный нормальный способ делать AJAX запросы и анимацию на страницах. А благодаря расширяемости, за счет плагинов, экосистема библиотеки за десяток лет стала фантастических размеров. В какой-то период времени любая библиотека для фронтенда появлялась как плагин к JQuery. Вплоть до того, что некоторые люди вообще не догадываются о существовании javascript и DOM. Они сразу начали с JQuery и видят мир только сквозь него.


# Манипуляции

Функция $ — это единая точка входа для всего. Если ее вызвать и передать внутрь строчку, то JQuery считает, что строка — это селектор, и нужно сделать выборку элементов DOM. Этот вызов аналогичен вызову querySelectorAll, с тем лишь отличием, что возвращается специализированная коллекция.

Более того, JQuery, в принципе, работает с элементами как с коллекциями, даже если это один элемент. И любые изменения применяются сразу ко всем элементам коллекции без необходимости итерирования.
*/

// Selecting all <h1> tags.
const headings = $('h1');
const firstHeader = headings.get(0); // извлечение DOM элемента

// Ниже два эквивалентных примера
headings.addClass('header');
headings.each((i, header) => $(header).addClass('header'));

// В последнем примере, во время итерации, в функцию передается именно DOM нода. Чтобы сделать из нее JQuery коллекцию, придется делать оборачивание: $(domNode).

// Если был найден один заголовок
const link = $('#home');
link.html('link to home'); // val(), text()
link.attr('href', '/about'); // prop(), css()
console.log(link.attr('href')); // /about

/*
Выше приведено несколько примеров функций, изменяющих дом элемент и его потомков. Главная особенность JQuery здесь в том, что если вызвать эти функции без параметров, то они возвращают значение, если вызвать с параметрами, то изменяют.

# События
*/
$('button').click(() => {
  $('#w3s').attr('href', (i, origValue) => `${origValue}/jquery`);
});

// Либо так:
$('button').on('click', () => {
  $('#w3s').attr('href', (i, origValue) => `${origValue}/jquery`);
});

// # AJAX

const jqxhr = $.get('/api/v1/companies.json', (data) => {
  console.log('success');
})
.done(() => {
  console.log('success');
})
.fail(() => {
  console.log('fail');
})
.always(() => {
  console.log('finished');
});

/*
Как видно из примера выше, интерфейс промисов JQuery не совпадает с принятым стандартом.

# Анимация

<div id="clickme">
  Click here
</div>
<img id="book" src="book.png" alt="" width="100" height="123">
*/

// With the element initially hidden, we can show it slowly:
$('#clickme').click(() => {
  $('#book').show('slow', () => {
    // Animation complete.
  });
});

/*
# JQuery UI

Это группа плагинов к JQuery, которая реализует типичную функциональность, необходимую при разработке интерактивных сайтов, например, перетаскивание, автокомплит, изменение размеров, сортировка и многое другое.


# Перспективы

В свое время JQuery была прекрасным выбором, но это время уходит. С момента выхода библиотеки веб ушел вперед. Стандарт DOM развился настолько, что многие вещи делать напрямую удобнее, чем через JQuery, а поддержка самого стандарта браузерами достаточно высока. В тех местах, где поддержки не хватает, всегда есть полифиллы. К тому же появились новые стандарты, в которые JQuery не вписывается. Ярким примером служат промисы и тот же AJAX.

Все это приводит к тому, что постепенно происходит отказ от JQuery. Для любых задач на фронтенде можно найти множество популярных библиотек, которые в своей нише будут лучше, чем то, что предлагает JQuery.

Есть еще один очень важный аспект. Хотя JQuery и позволила упростить работу с DOM (когда он был плох), этого недостаточно для создания по-настоящему сложных интерактивных сайтов. В 2015 году я делал доклад на эту тему, где подробно объяснял, почему прямое манипулирование домом (пусть даже через JQuery) — концептуально неверный путь. Такой подход срабатывает в тривиальных ситуациях, а дальше всё очень быстро усложняется.

Поэтому современные проекты строят с использованием React, Vue, Angular и других фреймворков, а JQuery не используют совсем.

С другой стороны, на JQuery уже столько понаписано, что его требуют знать в любой вакансии, связанной с фронтендом. Как вы могли убедиться исходя из примеров выше, ничего сложного и фантастического в JQuery нет. Более того, в первую очередь надо знать DOM, а остальное — это просто внимательное чтение документации и примеров использования.
*/

