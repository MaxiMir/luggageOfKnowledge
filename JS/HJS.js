/*####### JS #######*/

// repl.it

############################### JS: Функции ###############################

<<<<< Guard Expression >>>>>

/*
Одни функции устроены сложнее других. Иногда так происходит в силу объективных причин (необходимая сложность). Иногда — в силу особенностей писавшего её программиста (случайная сложность). И хотя нельзя однозначно описать эту сложность, существуют способы, позволяющие хотя бы частично её оценить.

# Цикломатическая сложность
Цикломатическая сложность — это структурная, или топологическая, мера сложности компьютерной программы, разработанная Томасом Дж. Маккейбом в 1976 году.

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только один маршрут через код.

Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один, если условие оператора if имеет значение true, и один — если false.

Такую оценку можно применять как в целом к программе, так и к отдельным функциям.
*/

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);
abs(10); // => 10
abs(-3); // => 3

/*
В примере выше у функции sum цикломатическая сложность равна единице, а у функции abs — двойке, так как она содержит ветвление, а значит два независимых пути выполнения.

Чем больше возможных путей выполнения, тем сложнее функцию понять, отладить и модифицировать. Очевидно, что, с одной стороны, функции нужно дробить, а с другой — описывать логику программы так, чтобы не появлялись лишние пути. Даже опытные разработчики часто сталкиваются с этой проблемой.

Линтеры многих языков измеряют показатель сложности и сигнализируют, если он, скажем, больше 5 для одной функции.

# Guard Expression
Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:
*/

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

/*
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.
*/

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

/*
Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.




/**@@@
Реализуйте и экспортируйте по умолчанию функцию isPalindrome с использованием рекурсии.

Примеры использования:
*/
import isPalindrome from './isPalindrome';

isPalindrome('radar'); // => true
isPalindrome('a');     // => true
isPalindrome('abs');   // => false


// file: App/isPalindrome.js:
const isPalindrome = (string) => {
  if (string.length <= 1) {
    return true;
  }

  const firstSymbol = string[0];
  const lastSymbol = string[string.length - 1];

  if (firstSymbol !== lastSymbol) {
    return false;
  }

  const stringWithoutFirstAndLastSymbols = string.substr(1, string.length - 2);

  return isPalindrome(stringWithoutFirstAndLastSymbols);
}

export default isPalindrome;

// ## TESTS:
// file: __tests__/isPalindrome.test.js:
import isPalindrome from '../isPalindrome';

test('isPalindrome', () => {
  expect(isPalindrome('a')).toBe(true);
  expect(isPalindrome('aa')).toBe(true);
  expect(isPalindrome('404')).toBe(true);
  expect(isPalindrome('abba')).toBe(true);
  expect(isPalindrome('radar')).toBe(true);
  expect(isPalindrome('absba')).toBe(true);
  expect(isPalindrome('aibohphobia')).toBe(true);

  expect(isPalindrome('abaoba')).toBe(false);
  expect(isPalindrome('aashgkhdj')).toBe(false);
  expect(isPalindrome('palindrome')).toBe(false);
  expect(isPalindrome('aibohapohobia')).toBe(false);
});


<<<<< Параметры по умолчанию >>>>>

// Опишем функцию greeting, которая печатает на экран приветствие:
const greeting = name => console.log(`Hi, ${name}!`);

greeting('John'); // => Hi, John!


// Но что произойдёт, если при вызове функции передать ей меньшее число аргументов, чем у неё установлено параметров? Давайте посмотрим:
greeting(); // => Hi, undefined!

// Правило здесь простое: параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined. Проиллюстрируем это подробнее на примере функции, которая принимает на вход три параметра и распечатывает их значения:

const foo = (a, b, c) => {
  const output = `a - ${a}; b - ${b}, c - ${c}`;
  console.log(output);
}

foo('I', 'am', 'here'); // => a - I; b - am, c - here

foo('I', 'am'); // => a - I; b - am, c - undefined

foo('I'); // => a - I; b - undefined, c - undefined

foo(); // => a - undefined; b - undefined, c - undefined

/* 
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.

Допустим, мы хотим, чтобы при вызове функции greeting без параметров, она выводила сообщение Hi, anonymous!.

Тогда мы можем реализовать её следующим образом:
*/

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

// Однако, JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:
const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);
greeting(); // => Hi, anonymous!


const pow = (base, exp = 2) => base ** exp;

pow(5); // => 25
pow(5, 2); // => 25
pow(5, 1); // => 5

// Кроме того, в значениях по умолчанию можно использовать идентификаторы:
const f = (x = Math.PI) => {}

// И даже вызовы функций:
const f = (x, y = Math.sqrt(x)) => {}


const getSum = (a = 10, b = 2 * a, c = 3 * b) => a + b + c;
const result = getSum(); // <-> 10 + 20 + 60 => 90
const result = getSum(2); // <-> 2 + 4 + 12 => 18
const result = getSum(2, 3); // <-> 2 + 3 + 9 => 14
const result = getSum(2, 3, 4); // <-> 2 + 3 + 4 => 9


const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`); // интерполяция - работает только со строками в бэктиках.

/*
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования.

Примечание
В этом уроке мы рассмотрели случай, когда в функцию передаётся меньше параметров, чем она ожидает. У вас может возникнуть вопрос, что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?

Ответ: ничего не произойдёт они будут просто проигнорированы.

Дополнительные материалы
Default function parameters https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters

/**@@@
Реализуйте и экспортируйте по умолчанию функцию substr, которая возвращает подстроку из переданной строки. Подстрокой называется любая выбранная часть строки. Например для строки hello можно выделить следующие подстроки: ello, llo, o, el и множество других.

Функция принимает на вход три параметра:
> Строка.
> Начальный индекс. Значение по умолчанию: 0.
> Длина подстроки. Значение по умолчанию: длина всей строки.
*/
substr('abba', 0, 1);    // => a
substr('abba', 1, 2);    // => bb
substr('abba', -10, 2);  // => ab
substr('abba', -1, 100); // => abba
substr('abba', -1, -1);  // => a
substr('abba', 1, -10);  // => b
substr('abba', 1, 10);   // => bba
substr('abba', 1, 0);    // => ''
substr('abba', 100, 3);  // => ''

// По умолчанию, то есть если не переданы дополнительные параметры, возвращается сама строка:
substr('');     // => ''
substr('abba'); // => abba

/*
У этой функции множество вариантов поведения:
Если переданная длина отрицательная, то внутри она становится единицей
Если переданная длина равна нулю, то возвращается пустая строка
Если конечный индекс (переданная длина + начальный индекс - 1) выходит за границу строки, то берется подстрока от начального индекса до конца строки.
*/
substr('abba', 1, 10);   // => bba

/*
Конечный индекс 1 + 10. Он выходит за границу строки, так как длина строки 4 символа. Поэтому возвращается подстрока, от начального индекса 1 и до конца строки.

Если начальный индекс отрицательный, то внутри он становится нулем
Если начальный индекс выходит за границу слова справа, то всегда возвращается пустая строка

Для реализации этой функции, используйте подход, который называется "нормализация". Он заключается в том, что перед тем как делать вычисления, данные приводятся к виду, с которым удобно работать. Например, длина строки для substr может иметь следующие неудобные значения:

Отрицательное число
Число, выходящее за границу строки
Индекс + Длина выходят за границу строки
В каждой из этих ситуаций длину строки можно изменить на такое значение, которое будет удобно для обработки сразу всех возможных случаев. Если число отрицательное, то длина становится равной единице (из условия), если оно выходит за границу строки, то его нужно сделать равным длине строки. В последнем случае длина должна стать числом Длина Строки - Индекс. После этих манипуляций процесс взятия подстроки становится универсальным и не содержащим условия.
*/

// file: app/substr.js
const substr = (string, ...options) => {
  if(options.length === 0) {
    return string;
  }

  let index = options[0] || 0;
  let length = options[1] || string.length;

  if (length === 0 || index > length) {
    return '';
  }

  if (length < 0) {
    length = 1;
  }

  if (index) {

  }
}


// ## TESTS:
// file: app/__tests__/substr.test.js:
import substr from '../substr';

test('substr', () => {
  expect(substr('')).toEqual('');
  expect(substr('abba', 4, -10)).toEqual('');
  expect(substr('abba')).toEqual('abba');
  expect(substr('abba', 1, 0)).toEqual('');
  expect(substr('abba', 0, 1)).toEqual('a');
  expect(substr('abba', 1, 2)).toEqual('bb');
  expect(substr('abba', -10, 2)).toEqual('ab');
  expect(substr('abba', -1, 100)).toEqual('abba');
  expect(substr('abba', -1, -1)).toEqual('a');
  expect(substr('abba', 1, -10)).toEqual('b');
  expect(substr('abba', 1, 10)).toEqual('bba');
});



>>>>> Выполнение функций <<<<<

/*
Вспомним несколько важных понятий из прошлого курса:

Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

Выражения — вычисляются.
Инструкции — исполняются.

К выражениям относятся:
 * Вызов функции
 * Арифметические и логические операции
 * Тернарный оператор
 * и другие

К инструкциям относятся:
 * for
 * while
 * break
 * return
 * if
 * и другие

Необходимо знать разницу между ними — это позволит лучше понимать, как могут взаимодействовать друг с другом различные конструкции языка.

Возьмем условный оператор if. В некоторых языках он представлен инструкцией, в некоторых — выражением. Посмотрите на код ниже и подумайте, возможно ли такое в JavaScript и почему:
*/
const value = if (something) {
    one
  } else {
    two
  }

/*
Такой код в JavaScript невозможен только по одной простой причине: if — это инструкция, а не выражение.

Но такой код возможен и часто используется в языках вроде Ruby или Python. Зачем же нужен if, если есть тернарный оператор, который как раз и является выражением?

Дело вот в чем. Если бы if был выражением, то тернарный оператор стал бы попросту не нужен, несмотря на то, что он является более лаконичной заменой if. Но и тернарный оператор бывает неудобен в тех ситуациях, когда вычисление слишком большое и не помещается в одну строку, а его результат должен быть записан в одну и ту же константу или переменную в каждой из веток. В такой ситуации как раз пригодился бы if как выражение.

Этот пример ярко иллюстрирует тот факт, что конструкции языка, представленные выражением, делают язык гибче, а решения с их использованием делают код лаконичнее. Другими словами, язык становится выразительнее. Кроме описанного выше, у выражений есть еще одно огромное преимущество: они могут комбинироваться друг с другом и вкладываться друг в друга.

Ниже я продемонстрирую варианты комбинирования выражений, но с акцентом на функции:

# Арифметические операции
*/
const r1 = 5;
const r2 = 5 + 8;
const r3 = 5 + 8 - Math.PI;
const r4 = 5 + 8 - Math.PI * Math.sqrt(16);
const r5 = f1() + f2() * f3();

/*
Вопросы могут возникнуть только в последней строчке. Насколько это допустимо? Вызов функции — это выражение, возвращающее результат, так что этот код допустим на 100%. Если функция вернет значение, неподходящее для сложения, то может возникнуть ошибка, но это будет логическая ошибка, а не синтаксическая.

Примечание: предополагается, что используемые в примерах этого урока функции и константы (например, f2 или isEditing) ранее где-то были определены. Их определение мы убрали из примеров, чтобы не отвлекать от главного.

# Логические операции

Все то же самое можно делать и с логическими выражениями:
*/

const r1 = true;
const r2 = true || false;
const r3 = true || false && isEditing;
const r4 = true || false && isEditing || isEmpty(data);
const r5 = f1() || f2() && f3();

/*
Из-за слабой типизации подобный код работать будет вообще всегда, даже если функции возвращают не true или false, но пользоваться этим не стоит. 

# Аргументы

А теперь чуть более сложный пример. Когда мы вызываем функцию, то в аргументах ожидается выражение: func(<expression>, <expression>, ...). А из этого следует, что мы можем сделать так:
*/

const r1 = f();
const r2 = f(5);
const r3 = f(5 + Math.PI);
const r4 = f(5 + Math.PI - cube(number));
const r5 = f(f1(f2(n3, f3(n1, n2))), f4());

/*
Пройдемся по примеру выше. f(f1(f2(n3, f3(n1, n2))), f4()) содержит в аргументах два выражения:

1. f4()
2. f1(f2(n3, f3(n1, n2)))
  этот вызов содержит один аргумент — вызов функции: f2(n3, f3(n1, n2)),
    который в свою очередь содержит два аргумента: n3 и вызов функции f3(n1, n2).


#  Порядок выполнения

Осталось понять, в какой последовательности происходят эти вызовы. JavaScript считается энергичным языком, то есть языком с аппликативным порядком вычисления, а это значит, что аргументы вычисляются до того, как попадают внутрь функций.    
*/

const f1 = () => console.log('called f1');
const f2 = () => console.log('called f2');
const f3 = () => console.log('called f3');
const f4 = () => console.log('called f4');
const f5 = () => console.log('called f5');
const f6 = () => console.log('called f6');

f1( f2(f4(), f5()), f3(f6()) ); // =>

// called f4
// called f5
// called f2
// called f6
// called f3
// called f1

// Как видно, вычисление идет с самого глубокого уровня слева направо.



/**@@@
Модуль tags содержит набор функций, позволяющих генерировать HTML с помощью функций.
*/

table(
  tr(td('one'), td('two')),
  tr(td('three'), td('four'))
);

/*
В результате вызовов возвращается вот такой HTML:
<table>
  <tr>
    <td>one</td>
    <td>two</td>
  </tr>
  <tr>
    <td>three</td>
    <td>four</td>
  </tr>
</table>
buildHtml.js
Реализуйте и экспортируйте по умолчанию функцию buildHtml, простой вызов которой:
*/

buildHtml();

/*
создаёт и возвращает следующий HTML:

<table>
  <tr>
    <td>lang</td>
    <td>comment</td>
  </tr>
  <tr>
    <td>php</td>
    <td>statements</td>
  </tr>
  <tr>
    <td>clojure</td>
    <td>expressions</td>
  </tr>
</table>

// file: buildHtml.js
**/
import { table, tr, td } from './tags';

export default () => table(
  tr(td('lang'), td('comment')),
  tr(td('php'), td('statements')),
  tr(td('clojure'), td('expressions')),
);

// ## TESTS:
// app/__tests__/buildHtml.test.js 

import { html } from 'js-beautify';
import buildHtml from '../buildHtml';

test('htmlBuilder', () => {
  expect(html(buildHtml())).toMatchSnapshot();
});


// app/__tests__/__snapshots__/buildHtml.test.js.snap 

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`htmlBuilder 1`] = `
"<table>
    <tr>
        <td>lang</td>
        <td>comment</td>
    </tr>
    <tr>
        <td>php</td>
        <td>statements</td>
    </tr>
    <tr>
        <td>clojure</td>
        <td>expressions</td>
    </tr>
</table>"
`;



>>>>>  Объекты первого класса <<<<<

/*
Продолжая тему предыдущего урока, познакомимся с понятием "first-class citizen" или "объекты первого класса".

Объектами первого класса в контексте конкретного языка программирования называются элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идет обо всем, что может быть данными. Самые простые типы данных — это числа и строки. Как вы потом увидите, все остальные типы данных также являются объектами первого класса.

А теперь посмотрите внимательно на этот код: const x = () => console.log('hey'). Ничего необычного, вы видели и писали подобное множество раз. Если вы считаете, что в этом коде создается функция x, на самом деле это не так. Здесь происходят следующие две операции:

1. Создание функции: () => console.log('hey')
2. Создание константы со значением в виде функции: const x =

Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: () => {}. Это пустая функция с пустым телом, которая не делает ничего. Присваивать ее константе или нет — вопрос отдельный. Вполне допустимо написать и выполнить подобную программу: (a, b) => a + b;.

Из примеров выше можно сделать вывод, что функция — тоже данные, ведь ее можно присвоить константе. Рассмотрим это утверждение на практике:
*/

const identity = v => v; // функция: v => v, константа: identity
console.log(identity(10)); // => 10

const z = identity;
console.log(z === identity); // => true

const x = 5;
console.log(z(x) === identity(x)); // => true

/*
Главный вывод, который можно сделать из кода выше, заключается в том, что определение функции (не вызов!) — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать ее без создания промежуточной константы:
*/

// Определяем функцию v = v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

/*
Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нем создается функция, принимающая на вход другую функцию v и вызывающая ее внутри с аргументом 'run'.

Попробуем усложнить:
*/
identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

/*
Первым идет пример вызова функции по идентификатору, а во втором примере я заменил идентификатор на определение функции, сделав подстановку. Результат получился тот же самый. Еще раз посмотрите на этот шаблон (<тут определение функции>)(). Попробуйте самостоятельно разобрать пример ниже:
*/

((a, b) => a + b)(3, 2); // => 5
// const sum = (a, b) => a + b;
// sum(3, 2); // => 5


// Теперь попробуем использовать функции как данные:
const sqrt = identity(Math.sqrt);
console.log(sqrt === Math.sqrt); // true
sqrt(4); // => 2

/*
В первой строчке вызывается функция identity, в которую передается Math.sqrt. Результатом этого вызова будет все та же функция Math.sqrt.

Здесь мы видим сразу два новых аспекта: передача функции как аргумента и возврат функции как значения. Функции, которые принимают на вход другие функции или возвращают другие функции, называются функциями высшего порядка. В функциональных языках большинство задач, связанных с обработкой данных, работают именно через них. JavaScript в этом смысле ведет себя точно также.

В следующем примере внутрь функции передается другая функция, определяемая в аргументах. В комментариях показан альтернативный способ через создание константы с функцией.
*/

const sum = identity((a, b) => a + b);
sum(3, 5); // => 8

// const f = (a, b) => a + b;
// const sum = identity(f);
// sum(3, 5); // => 8

/*
Подобная передача функций в функции с определением прямо в аргументах встречается повсеместно в реальном коде. Как правило, те функции, которые передаются в аргументах, нужны только здесь и сейчас.

Возникает вопрос: есть ли имя у функций, определенных подобным образом? Имени нет даже у такой функции const f = () => {}. Мы просто связали константу с функцией, но сама функция ничего про константу не знает. Звучит слегка безумно, но это так. Ведь мы можем взять и связать эту функцию уже с другой константой. По этой причине такие функции часто называют анонимными. Другое распространенное название — лямбда-функция. Своим названием лямбда-функция обязана лямбда-исчислению (математическая формальная система, легшая в основу языков семейства lisp). Только в отличие от языков программирования, "лямбды" в лямбда-исчислении — всегда функции от одного аргумента, поэтому общее с функциями из js у них, в первую очередь, анонимность, и то, что они являются объектами первого класса.

Попробуем сделать что-нибудь полезное. Иногда встречается задача, в рамках которой нужно применить одну и ту же функцию несколько раз, например, так: Math.sqrt(Math.sqrt(16)). Создав функцию высшего порядка, можно упростить эту задачу. Рассмотрим пример с двойным применением одноаргументной функции:
*/

const callTwice = (f, arg) => f(f(arg));

callTwice(Math.sqrt, 16); // => 2
callTwice(x => x ** 2, 3); // => 81
// const f = x => x ** 2;
// f(f(3));

// callTwice применяет переданную функцию к своему аргументу два раза. Если расписать подробнее, то происходит следующее:

const res1 = f(arg);
const res2 = f(res1);
return res2;

const result = ((a, b) => a ** b)(5, 2); // функции можно вызывать сразу после определения.

// Все функции в языке JavaScript являются объектами первого класса.



/**@@
Реализуйте и экспортируйте по умолчанию функцию apply, которая принимает на вход три параметра:

1. Количество раз, которое нужно применить функцию к аргументу (ряд последовательных вызовов, где каждому следующему вызову передается аргумент, являющийся результатом предыдущего вызова функции)
2. Функцию для применения
3. Аргумент для применения
*/

apply(0, Math.sqrt, 4); // => 4
apply(1, Math.sqrt, 4); // => 2

// Math.sqrt(Math.sqrt(16));
apply(2, Math.sqrt, 16); // => 2
// Math.sqrt(Math.sqrt(Math.sqrt(256)));
apply(3, Math.sqrt, 256); // => 2

apply(1, v => v ** 2, 3); // => 9
apply(5, v => v + 10, 3); // => 53

// file: app/apply.js 
const apply = (count, fn, value) => count === 0 ? value : apply(count - 1, fn, fn(value));

export default apply;


// ## TEST
// file: app/__tests__/apply.js 

import apply from '../apply';

test('apply', () => {
  expect(apply(0, Math.sqrt, 4)).toBe(4);
  expect(apply(1, Math.sqrt, 4)).toBe(2);
  expect(apply(2, Math.sqrt, 16)).toBe(2);

  expect(apply(1, v => v ** 2, 3)).toBe(9);
  expect(apply(5, v => v + 10, 3)).toBe(53);
});



>>>>> Лексическое окружение (LexicalEnvironment) <<<<<

/*
Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь LexicalEnvironment (лексическое окружение), привязанный к этому вызову. Все определения констант, переменных и прочего внутри функции автоматически записываются в словарь. Имя определения (идентификатор, то есть имя константы, переменной и так далее) становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и т.д. Лексическое окружение — это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.

В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.
*/

const showWarning = (field) => {
  // LexicalEnvironment = { field: 'email' }
  const warning = `verify your ${field}, please`;
  // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
  console.log(warning);
}

showWarning('email'); // => verify your email, please

/*
Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.

В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.

Из этого поведения есть исключение — возврат функции. В следующем уроке мы рассмотрим связанный с ним механизм так называемых «замыканий». 

Окружение есть не только у функций. Любой идентификатор, определенный на уровне модуля, попадает в лексическое окружение модуля. Кроме того, существует и глобальное окружение. Благодаря ему мы с легкостью используем в JS такие функции, как console.log или Math.sqrt, даже особо не задумываясь, откуда они берутся.
*/

const number = 5;
const square = () => number ** 2;
square(); // => 25

/*
Такой код работает — и это для нас не секрет, но как он вяжется с механизмом окружений? А вот как: интерпретатор производит поиск значения идентификатора не только в локальном лексическом окружении (в том, где используется идентификатор), но и во внешнем окружении. Поиск начинается с локального окружения, и если в нём не найден нужный идентификатор, то просмотр идет дальше, вплоть до уровня модуля, а затем и до глобального уровня.

Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена (а не вызвана!). Если разбить пример выше на два файла, то разница станет очевидной.

Так сработает:
*/

// module1.js
const number = 5;
export const square = () => number ** 2;

// module2.js
import { square } from './module1';
square(); // => 25

// А так нет:

// module1.js
export const square = () => number ** 2;

// module2.js
import { square } from './module1';

const number = 5;
square(); // => ReferenceError: number is not defined

/*
Если подумать логически, так и должно быть. Представьте: если бы сработал второй вариант, то автоматически это бы означало, что вы можете случайно создать имя переменной, совпадающее с именем переменной внутри функции, написанной другим человеком. Как при этом будет работать код — предположить невозможно.

Попробуйте самостоятельно ответить на вопрос: сработает ли такой код, в котором константа определена позже её использования внутри функции?
*/

const square = () => number ** 2;
const number = 5;

square(); // => 25

/*
Ответ: сработает.

Окружение — это не «всё, что было объявлено до функции, в которой я использую эти объявления». Не важно, что number появился позже использования внутри функции. Главное, что вызов функции square происходит позже определения number, а значит к этому времени идентификатор уже был добавлен в окружение, внутри которого была создана функция square.

# Переменные
Когда мы работаем с константами, всё просто. Нет изменений — нет проблем. В случае с переменными ситуация становится сложнее.
*/

const square = () => number ** 2;

let number = 5;
square(); // => 25

number = 3;
square(); // => 9

/*
Изменение переменной следует читать как «изменение значения ключа в окружении». Соответственно, обращение к number всегда вернет последнее присвоенное значение. Завязка на переменные, описанная в коде выше, должна восприниматься как абсолютное зло. Она порождает неявные зависимости, сложный код и отладку. Функция автоматически перестает быть чистой, так как начинает зависеть от внешнего контекста.

# Вложенные функции
*/

const factorial = (n) => {
  const iter = (counter, acc) => {
    if (counter > n) {
      return acc;
    }
    return iter(counter + 1, counter * acc);
  }

  return iter(1, 1);
}

factorial(5); // => 120

/*
В этом коде реализовано вычисление факториала с применением итеративного процесса. Внутри функции factorial определяется внутренняя функция iter, которая накапливает аккумулятор, вызываясь рекурсивно. Условие выхода из рекурсии — попытка посчитать число большее, чем нужно.

В этой проверке используется переменная n, которая явно в iter не передавалась. Но благодаря тому, как работают окружения, любые функции (в том числе и вложенные), определенные внутри factorial, имеют к ней доступ. Как видно из кода, n используется как константа, а значит такое использование абсолютно безопасно.



# Перекрытие (Shadowing)

Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем. Причем не важно, что это: аргумент функции, константа или переменная.
*/

const f = (coll) => {
  const iter(item, coll) => {
    // using coll
  }
  // ...
}

/*
Несмотря на то, что сам код остается рабочим, перекрытие больше не позволяет обратиться к идентификатору из внешнего окружения, ведь поиск всегда происходит сначала в локальном окружении, а уже затем во внешних. Но еще большей проблемой является то, что такой код сложнее в анализе. Глядя на него недостаточно видеть имена, нужно также учитывать их контекст, так как одно и то же имя на разных строках может означать разные вещи. Если запустить линтер для подобного кода, то он укажет на перекрытие как на плохую практику программирования. Подробнее об этом можно прочитать в правилах Eslint https://eslint.org/docs/rules/no-shadow.


Когда внутри функции создается локальное окружение?
> Во время вызова

Когда функция запоминает внешнее окружение?
> Во время определения



/**@@
Реализуйте функцию reverse, переворачивающую строку. В этот раз, используя итеративный процесс. Работа функции основана на двух принципах.
**/

// file: app/reverse.js
export default (str) => {
  const lastIndex = str.length - 1;
  
  const iter = (index, acc) => {
    if (index > lastIndex) {
      return acc;
    }
    return iter(index + 1, `${str[index]}${acc}`);
  }
  
  return iter(0, '');
}


// ## TESTS:
// file: app/__tests__/reverse.test.js:
import reverse from '../reverse';

test('reverse', () => {
  expect(reverse('')).toBe('');
  expect(reverse('z')).toBe('z');
  expect(reverse('zz')).toBe('zz');
  expect(reverse('zza')).toBe('azz');
  expect(reverse('qwerty')).toBe('ytrewq');
});



>>>>> Возврат функций из функций <<<<< 

const identity = v => v;
identity('wow'); // => wow

const sum = identity((a, b) => a + b);
sum(1, 8); // => 9

/*
Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций. Мы даже можем определить функцию внутри другой функции и вернуть её наружу. И в этом нет ничего удивительного. Константы можно создавать где угодно.
*/

const generateSumFinder = () => {
  const sum = (a, b) => a + b;     // создали функцию
  return sum;                      // и вернули её
}

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа


/*
Можно даже обойтись без промежуточного создания константы:
вызвали функцию, которая возвращает функцию, и тут же вызвали возвращенную функцию
*/

generateSumFinder()(1, 5); // => 6
// ((a, b) => a + b)(1, 5)

/*
Всегда, когда видите подобные вызовы f()()(), знайте: функции возвращаются!
Теперь посмотрим, как еще можно описать функцию generateSumFinder:
*/

// предыдущий вариант для сравнения
// const generateSumFinder = () => {
//   const sum = (a, b) => a + b;
//   return sum;
// }

// новый вариант
const generateSumFinder = () => (a, b) => a + b;

// Для понятности можно расставить скобки:
const generateSumFinder = () => ((a, b) => a + b);

/*
Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:
*/

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

sum(1)(3)(5); // => 9

/*
Ту же функцию можно представить другим способом, вынеся каждую функцию в свою собственную константу. Этот способ полезен как мысленный эксперимент, чтобы понять где заканчивается одна и начинается другая функция, но сам по себе он не заработает, потому что теряется замыкание.
*/

const inner1 = z => x + y + z;
const inner2 = y => inner1;
const sum = x => inner2;

/*
Попробуем последовательно пройтись по вызовам функции выше, чтобы понять, как получается результат. После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.
*/

sum(1)(3)(5); // => 9

const sum1 = x => y => z => x + y + z;

// sum(1);
const sum2 = y => z => 1 + y + z; // inner2

// sum(1)(3)
const sum3 = z => 1 + 3 + z; // inner1

// sum(1)(3)(5)
const sum4 = 1 + 3 + 5; // => 9

/*
Как видно выше, sum1, sum2 и sum3 — это функции, а sum4 уже число, так как были вызваны все внутренние функции.
Давайте распишем все функции:
*/

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));

/*
Функция sum принимает x и возвращает функцию, которая
  принимает y и возвращает функцию, которая
    принимает z и возвращает функцию, которая
      возвращает сумму x + y + z

Попробуем развить идею функции callTwice из предыдущего урока. Напишем функцию generate, которая не применяет функцию сразу, а генерирует новую.      
*/

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));

/*
Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:

Создадим функцию f1. Она будет той функцией, которую вернет generate если передать ей функцию Math.sqrt (она вычисляет квадратный корень числа).

Получается, f1 — это функция, которая принимает число и возвращает корень корня — Math.sqrt(Math.sqrt(x)):
*/

const f1 = generate(Math.sqrt);
f1(16); // => 2
// generate(Math.sqrt)(16);

/*
Ещё пример: передадим в функцию generate новую функцию на ходу, без предварительного создания. Переданная функция возводит число в квадрат.
*/

const f2 = generate(x => x ** 2);
f2(4); // => 256
// generate(x => x ** 2)(4);

/*
Теперь функция f2 возводит число в квадрат два раза: (42)2.

Функция generate имеет такое имя не просто так. Дело в том, что возврат функции порождает каждый раз новую функцию при каждом вызове, даже если тела этих функций совпадают:
*/

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false

/*
Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию. 
Запомнить довольно просто, если вы где-то слышите или читаете что происходит генерация функций, значит кто-то их возвращает.

# Замыкание
Работа практически всех описанных примеров базировалась на одном интересном свойстве, которое называется «замыкание». 
*/

const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);

/*
Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.


Функция, которая была возвращена из generateDouble, называется замыканием. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

В СИКП дается прекрасный пример на понимание замыканий. Представьте себе, что мы проектируем систему, в которой нужно запомнить пароль пользователя, а потом проверять его, когда пользователь будет заново заходить. Можно смоделировать функцию savePassword, которая принимает на вход пароль и возвращает предикат, то есть функцию, возвращающую true или false, для его проверки. Посмотрите, как это выглядит:
*/

const secret = 'qwerty';
// Возвращается предикат.
const isCorrectPassword = savePassword(secret);

// Теперь можно проверять
console.log(isCorrectPassword('wrong password')); // => false
console.log(isCorrectPassword('qwerty')); // => true

// А вот как выглядит код функции savePassword:

const savePassword = password => passwordForCheck => password === passwordForCheck;

/*
# Возврат функций в реальном мире (Debug)
Логгирование — неотъемлемая часть разработки. Для понимания того, что происходит внутри кода, используют специальные библиотеки, с помощью которых можно логгировать (выводить) информацию о проходящих внутри процессах, например в файл. Типичный лог веб-сервера, обрабатывающего HTTP запросы выглядит так:


[  DEBUG] [2015-11-19 19:02:30.836222] accept: HTTP/1.1 GET - / - 200, 4238
[   INFO] [2015-11-19 19:02:32.106331] config: server has reload its config in 200 ms
[WARNING] [2015-11-19 19:03:12.176262] accept: HTTP/1.1 GET - /info - 404, 829
[  ERROR] [2015-11-19 19:03:12.002127] accept: HTTP/1.1 GET - /info - 503, 829


В js самой популярной библиотекой для логгирования считается Debug. 

Обратите внимание на левую часть каждой строки. Debug для каждой выводимой строчки использует так называемый неймспейс, некоторую строчку, которая указывает принадлежность выводимой строчки к определенной подсистеме или части кода. Он используется для фильтрации, когда логов становится много. Другими словами, можно указать "выводи сообщения только для http". А вот как это работает:
*/

import debug from 'debug';

const logHttp = debug('http');
const logHandler = debug('handler');

logHttp('hello!');
logHttp('i am from http');

logHandler('hello from handler!');
logHandler('i am from handler');

/* Что приведет к такому выводу:

http hello! +0ms
http i am from http +2ms
handler hello from handler! +0ms
handler i am from handler +1ms

Получается, что импортированный debug — это функция, которая принимает на вход неймспейс в виде строки и возвращает другую функцию, которая уже используется для логгирования.
*/



/**@@
Во многих языках программирования существует интересная функция flip. Её необычность заключается в том, что единственная цель этой функции — это преобразовать другую функцию так, чтобы порядок её аргументов был обратным.

Например, у нас может быть функция pow, которая возводит первый аргумент в степень второго. flip вернет нам новую функцию, у которой первый аргумент — это степень, а второй — это число, которое нужно возводить в эту степень.

Эта функция бывает очень полезна при активной работе с функциями высшего порядка, она часто упрощает возможность комбинировать функции между собой.

Реализуйте и экспортируйте по умолчанию функцию flip. Данная версия flip работает только с функциями от двух аргументов.
**/

// subtraction:
const sub = (a, b) => a - b;
const reverseSub = flip(sub);

sub(5, 3); // 2
reverseSub(5, 3); // -2

// exponentiation:
const wop = flip(Math.pow);

Math.pow(1, 2); // 1
wop(1, 2); // 2

Math.pow(3, 2); // 9
wop(3, 2); // 8


// file: app/flip.js
// #1:
const flip = f => (...args) => { // 
  const revArgs = args.reverse();

  return f(...revArgs);  
}


// #2:
const flip = f => (a, b) => f(b,a);

export default: flip;

// ## TESTS:
// file: app/__tests__/flip.test.js
import flip from '../flip';

test('reverseSub', () => {
  const sub = (a, b) => a - b;
  const reverseSub = flip(sub);
  expect(reverseSub(1, 2)).toBe(1);
  expect(reverseSub(5, 3)).toBe(-2);
});

test('wop', () => {
  const wop = flip((a, b) => a ** b);
  expect(wop(1, 2)).toBe(2);
  expect(wop(3, 2)).toBe(8);
});



>>>>> Частичное применение <<<<<

/*
Частичное применение функций, техника основанная на возможности возвращать функции из других функций. Допустим у нас есть функция sum суммирующая три числа.
*/

const sum = (a, b, c) => a + b + c;
sum(4, 3, 1); // 8
sum(1, 1, 1); // 3

/*
Частичное применение позволяет на основе старой функции, создать новую, которая "частично применена". Для начала вспомним что такое применение функции. Математики никогда не говорят что функция вызывается с некоторыми аргументами, вместо этого они говорят что функция была применена к этим аргументам. В примере выше функция sum была применена к трем аргументам 4, 3 и 1. Такое применение можно назвать полным, то есть в функцию было передано столько аргументов сколько и ожидалось. Здесь возникает вопрос, а можно было по другому? Да можно.

Частичное применение, техника которую проще всего объяснить в отрыве от языков программирования, на языке близком к математике (для простоты назову его Ha). Представьте что наша функция выше, имеет вот такое определение:

-- Слева имя функции, затем идет список параметров
-- разделенных пробелами и после знака => тело функции
*/
sum a b c => a + b + c

/*
А ее вызов выглядит так:
-- Скобок и запятых нет, но это равносильно sum(4, 3, 1) в js
*/

sum 4 3 1 -- 8
sum 1 1 1 -- 3

/*
Ha необычный язык, если внутри него вызвать функцию с неполным набором параметров, то в отличии от js он не вызовет саму функцию (или не упадет с ошибкой как во многих других языках). Он вернет новую функцию, которая "частично применена".

-- sum2 новая функция, полученная частичным применением функции sum к числу четыре
-- Применение "частичное" потому что в функцию sum передается только один параметр, а не три
*/

sum2 = sum 4
sum2 1 1 -- 6
sum2 3 2 -- 9

/*
Другими словами, такой вызов создает новую функцию, которая работает точно так же как и исходная, но, при этом, часть ее аргументов как будто уже подставлены. То есть наш вызов sum2 1 1 в действительности приведет к вызову sum 4 1 1. Этот трюк работает с любым количеством аргументов. Посмотрите на частичное применение двух аргументов:
*/

sum3 = sum 1 1
-- sum3 принимает только один аргумент
sum3 2 -- 4
sum3 1 -- 3

/*
Арифметика аргументов очень простая. Если исходная функция принимала 3 параметра, то после частичного применения одного параметра, новая функция будет принимать на вход два параметра (2 + 1 = 3), если частично применились два параметра, то новая функция принимает на вход 1 параметр. А можно ли частично применить три параметра для функции которая принимает на вход 3 параметра? Конечно нет, ведь это будет обычный вызов функции со всеми параметрами. Довольно несложно догадаться как выглядело бы определение функций sum2 и sum3 если бы мы их описали явно:
*/

sum a b c => a + b + c
sum2 b c => 4 + b + c
sum3 c => 1 + 1 + c

// Ha настолько необычный язык, что позволяет частично применять то что уже было частично применено:
// -- Создаем первую функцию с 3 - 1 аргументами
sum4 = sum 2
// -- Создаем вторую функцию с 2 - 1 аргументами
sum5 = sum4 3
// -- Вызываем то что получилось. В реальности вычисляется 2 + 3 + 1
sum5 1 -- 6
sum5 4 -- 9

// В js эта возможность не встроена прямо в сам язык, но ее можно реализовать с помощью дополнительной функции:
const sum = (a, b, c) => a + b + c;

// Берем исходную функцию sum и отдаем ее в функцию partialApply
const sumWithFour = partialApply(sum, 4);
sumWithFour(3, 1); // 8
sumWithFour(10, 3); // 17

const sumWithFourAndTwo = partialApply(sumWithFour, 2);
sumWithFourAndTwo(3); // 9

/*
Функция partialApply принимает на вход исходную функцию и параметры которые нужно применить, а возвращает новую, частично примененную функцию.
Вот как может выглядеть реализация partialApply для функций от трёх аргументов (таких как sum):
*/

const partialApply = (fn, arg1) => (arg2, arg3) => fn(arg1, arg2, arg3);

/*
Немного примеров из реальности. Предположим, что мы пишем программу, вычисляющую зарплату людей разных специальностей по всему миру. Для этого используется функция getAverageSalary.
*/

const salary1 = getAverageSalary('programmer', 'spain');
const salary2 = getAverageSalary('programmer', 'russia');
const salary3 = getAverageSalary('programmer', 'usa');

/*
Первым параметром функция принимает на вход название профессии, вторым — страну, на выходе — годовая зарплата. Все довольно примитивно, но часть данных дублируется. Вычисляется зарплата программистов в разных странах, что приводит к постоянному вызову функции с первым параметром programmer. В этом нет ничего криминального, но существует способ устранить подобное повторение. Убрать с помощью введения дополнительной константы.
*/

const job = 'programmer'
const salary1 = getAverageSalary(job, 'spain');
const salary2 = getAverageSalary(job, 'russia');
const salary3 = getAverageSalary(job, 'usa');

/*
Название профессии больше не повторяется, но нам по-прежнему приходится подставлять его в каждый вывод. Здесь на помощь приходит так называемое частичное применение функции.
*/

const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Принцип действия частичного применения функции основан на генерации (в нашем случае с помощью функции partialApply) новой функции оборачивающей старую, причем так, что она принимает на вход меньшее количество аргументов. Для нашей задачи мы применили один аргумент, но это не обязательно. Применять можно любое число аргументов исходной функции (но, естественно, не все, ведь в таком случае мы получим обычный вызов функции). И хотя пример выше выглядит слегка искусственным, в реальной жизни этот прием применяется часто. Причем нередко частично применяется больше одного аргумента за раз.

Тело функции getProgrammersSalaryByCountry выглядит предсказуемо. Внутри вызывается исходная функция с подставленным в аргумент значением.
*/

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

// А partialApply для функций от двух аргументов, реализуется способом очень похожим на реализацию flip.
const partialApply = (fn, arg1) => arg2 => fn(arg1, arg2);

/*
То есть функция partialApply возвращает (генерирует) функцию, которая внутри себя замыкает два параметра: fn и arg1.

Частичное применение для JS — практически как воздух для живых организмов. Из-за асинхронной природы JS часто бывают ситуации, когда одни параметры функции задаются в одном месте, а другие в другом, так как они становятся доступны только после выполнения асинхронной операции. Поскольку вы еще не обладаете достаточными знаниями для понимания соответствующего кода, я не буду приводить более сложных примеров, чтобы не сбивать вас с толку, но уверяю, что в дальнейших курсах все, что изучалось здесь, будет использоваться на полную катушку.

Возможно ли частичное применение без замыкания?
> Нет. Частичное применение подразумевает запоминание аргументов функции/


/**
Реализуйте и экспортируйте по умолчанию функцию partialApply. Эта функция умеет частично применять один (второй) аргумент у переданной функции:
**/

const pow = (a, b) => a ** b;
const f1 = partialApply(pow, 2);
f1(1); // => 1
f1(10); // => 100

const f2 = partialApply((a, b) => a * b, 5);
f2(2); // => 10
f2(5); // => 25


// file: app/partialApply.js:

export default (f, second) => first => f(first, second);

export default partialApply;


// ## TESTS:
// file: app/__tests__/partialApply.test.js:

import partialApply from '../partialApply';

test('partialApply', () => {
  const f1 = partialApply((a, b) => a ** b, 2);
  expect(f1(1)).toBe(1);
  expect(f1(10)).toBe(100);

  const f2 = partialApply((a, b) => a * b, 5);
  expect(f2(2)).toBe(10);
  expect(f2(5)).toBe(25);
});



>>>>> Каррирование <<<<<

/*
Каррирование — очень интересная техника, позволяющая сильно упростить использование частичного применения на практике. Многие путают эти понятия, но, как вы увидите далее, они обозначают совершенно разные вещи.

В предыдущем уроке нам приходилось писать функцию-обертку для применения.
*/

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Eсли бы наша функция getAverageSalary была каррирована, то все было бы значительно проще. Каррирование — это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.

Предположим, что у нас есть функция const sum = (a, b, c) => a + b + c, которая складывает три числа. Тогда ее каррированная версия будет выглядеть так: const sum2 = a => b => c => a + b + c, а использование таким: sum2(5)(10)(-2). То же самое, разложенное по функциям:
*/

const sum2 = (a) => {
  return (b) => {
    return (c) => {
      return a + b + c;
    };
  };
}

/*
Посмотрите внимательно на определение a => b => c => a + b + c. Эта запись очень краткая и одновременно очень емкая. Суммарное количество функций считается очень легко, оно равно сумме всех стрелок =>. Для лучшего понимания можно добавить скобки a => (b => (c => a + b + c)). Для каждого определения функции все, что находится справа от стрелки, является ее телом, каким бы сложным оно не было. Поначалу такая запись может помочь понять, как друг в друга вложены функции, но со временем, когда вы привыкните к обычной записи, она будет больше мешать.

С другой стороны, если нам нужно каррировать существующую функцию без ее реализации, то делается это так: const sum2 = a => b => c => originalSum(a, b, c). То есть создается цепочка вложенных функций, в которой количество вложений равно количеству аргументов исходной функции и в конце которой происходит вызов оригинальной функции.

Разберем происходящее по шагам.
*/

const sum = a => b => c => a + b + c;
const sum1 = sum(10); // sum1 = b => c => 10 + b + c
const sum2 = sum1(3); // sum2 = c => 10 + 3 + c
const result = sum2(0); // result = 10 + 3 + 0
console.log(result); // 13

/*
То же самое происходит и при таком вызове: sum(10)(3)(0), разница только в том, что вызовы происходят без создания промежуточных констант.

И задача для самоконтроля. Сколько раз нужно вызвать цепочку функций const greeting = () => () => () => () => console.log('Hey!'), чтобы дойти до конца? Обязательно попробуйте прямо сейчас выполнить это задание на repl.it.

Теперь вернемся к нашей функции расчета зарплаты в ее каррированном виде. Представим, что теперь у нас в распоряжении две вложенных функции от одного аргумента: const getAverageSalary = job => country => /* body */:

const salary1 = getAverageSalary('programmer')('spain');
const salary2 = getAverageSalary('programmer')('russia');
const salary3 = getAverageSalary('programmer')('usa');

// Попробуем частично применить:

const getProgrammersSalaryByCountry = getAverageSalary('programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Применение в реальной жизни

В функциональных языках, подобных haskell, вопросов об использовании каррированных функций просто не встает. Они там используются постоянно, начиная с самых азов. Это одна из причин, почему стоит учить подобные языки, даже если вы не будете писать на них программы. В императивных языках такое происходит значительно реже, но не в JS. JS по своей сути очень близок к функциональным языкам. Изначально он должен был быть написан на Scheme, языке из семейства Lisp, и функции в нем занимают центральное место. Каррирование используется в различных библиотеках и иногда является их ключевой "фичей", как, например, здесь: https://github.com/substantial/updeep.




/**@@
Удивительно, но факт — условные конструкции можно реализовать самостоятельно с использованием одних лишь каррированных функций.

В этой практике мы реализуем упрощённую версию, имитирующую работу условной конструкции if.

Экспортируйте тройку True, False, If, используя только функции, внутри которых только функции ;) То есть нельзя пользоваться встроенными в язык if, а также true и false. Сами функции должны быть каррированы.

Пример использования:
**/

import { If, True, False } from './logic';

If(True)('one')('two');  // one
If(False)('one')('two'); // two

/*
Подсказки
Общая схема работы функций такова:
*/

If(func)('one')('two'); // ?

/*
То есть, в итоге должно вернуться то или иное значение, в зависимости от того, какая функция передана на вход If.
Если функции If была передана True, то выражение ниже вернёт значение аргумента первого вызова (one):
*/
const ConditionTFunction = If(True);
ConditionTFunction('one')('two'); // => one

// Если функции If была передана False, то выражение ниже вернёт значение аргумента второго вызова (two):
const ConditionRFunction = If(False);
ConditionRFunction('one')('two'); // => two


// file: app/logic.js 
export const True = x => () => x;
export const False = () => y => y;

export const If = f => f;


// # TESTS:
import { If, True, False } from '../logic';

test('Boolean', () => {
  expect(If(True)('fo')('bar')).toBe('fo');
  expect(If(False)('foo')('ba')).toBe('ba');
  expect(True()()).toBeUndefined();
  expect(False()()).toBeUndefined();
});



/**@@
Реализуйте и экспортируйте по умолчанию каррированую версию функции, которая принимает на вход три строки и возвращает новую строчку составленную из трех входных.
**/
// исходная версия
concat('a', 'bc', 'f'); // => abcf

// каррированая версия
concat('a')('bc')('f'); // => abcf


// file: app/concat.js
export default str1 => str2 => str3 => `${str1}${str2}${str3}`;


// file: app/__tests__/compose.test.js

import concat from '../concat';

test('compose', () => {
  expect(concat('')('')('')).toBe('');
  expect(concat('a')('bc')('f')).toBe('abcf');
});



/**@@
Реализуйте и экспортируйте по умолчанию функцию compose, которая принимает на вход две других одноаргументных функции и возвращает новую функцию. Эта новая функция также принимает на вход один параметр и при вызове применяет его последовательно к переданным функциям в обратном порядке.

Примеры ниже помогут понять, как должна работать функция:
**/

const f = compose(Math.sqrt, Math.abs);
f(-4); // => 2

compose(v => v, v => v)(10); // => 10
compose(v => v + 2, v => v)(10); // => 12
compose(v => v, v => v - 2)(10); // => 8
compose(v => v ** 2, v => v - 2)(2); // => 0
compose(v => v - 2, v => v ** 2)(2); // => 2


// file: app/compose.js:
export default (f, g) => x => f(g(x));


// # TESTS:
// file: app/__tests__/compose.test.js:

import compose from '../compose';

test('compose', () => {
  expect(compose(v => v, v => v)(10)).toBe(10);
  expect(compose(v => v + 2, v => v)(10)).toBe(12);
  expect(compose(v => v, v => v - 2)(10)).toBe(8);
  expect(compose(v => v ** 2, v => v - 2)(2)).toBe(0);
  expect(compose(v => v - 2, v => v ** 2)(2)).toBe(2);
});


/** 
Числа Черча
В 30-х годах прошлого века перед математиками встала так называемая проблема разрешения (Entscheidungsproblem), сформулированная Давидом Гильбертом. Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение. Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? Ответ был найден двумя великими учёными того времени Алонзо Чёрчем и Аланом Тьюрингом. Они показали (первый — с помощью изобретённого им λ-исчисления, а второй — теории машины Тьюринга), что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима.

Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики. Пока в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…

В основе лямбда-исчисления лежит понятие, известное ныне каждому программисту, — анонимная функция. В нём нет встроенных констант, элементарных операторов, чисел, арифметических операций, условных выражений, циклов и т. п. — только функции, только хардкор. Потому что лямбда-исчисление — это не язык программирования, а формальный аппарат, способный определить в своих терминах любую языковую конструкцию или алгоритм. В этом смысле оно созвучно машине Тьюринга, только соответствует функциональной парадигме, а не императивной.

Как уже говорилось ранее, в чистом бестиповом лямбда-исчислении отсутствует всё, кроме функций. Так что даже такие элементарные вещи, как числа или булевы значения необходимо реализовывать самим. Точнее, надо создать некие активные сущности, которые будут вести себя подобно необходимым нам объектам. И, естественно, процесс кодирования будет заключаться в написании соответствующих функций.

Натуральные числа реализованные посредством лямбда-исчисления, называются числами Черча, и являются отличной разминкой для мозга. В основе реализации по-прежнему будут лежать функции, ведущие себя в заданном контексте подобно единице, двойке и т.д. Собственно, это одна из особенностей лямбда-исчисления: сущности, записанные в его терминах, не обладают самодостаточностью, поскольку воплощают поведение того или иного объекта.

Реализуйте число Zero и операцию Succ (увеличение на единицу). Не забудьте про экспорт.
Пример:
*/

const two = Succ(Succ(Zero));

// Немного хитрый способ трансформировать число черча в обычное представление.
// Откровенно говоря, устройство самих чисел еще хитрее ;)

two(x => x + 1)(0); // 2

const four = Succ(Succ(two));
four(x => x + 1)(0); // 4


// file: app/numerals.js:
const Zero = 0;
const Succ = (num) => num + 1;


// ## TESTS:
// file: app/__tests__/numerals.test.js

import { Zero, Succ } from '../numerals';

it('numerals', () => {
  const two = Succ(Succ(Zero));
  expect(two(x => x + 1)(0)).toBe(2);

  const four = Succ(Succ(two));
  expect(four(x => x + 1)(0)).toBe(4);

  expect(four(two(x => x + 1))(0)).toBe(8);
});




############################### JS: Настройка окружения ###############################

// Ubuntu
$ curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash -
$ sudo apt install -y nodejs

/*
Теперь убедимся в том, что Node.js поставлена и работает. Вероятно, в некоторых операционных системах понадобится перезапустить терминал или даже перезагрузиться.
Проверяем:
*/

$ node -v
v10.0.0

/*
Версия, которую вы увидите, должна быть не ниже 8.

Если все прошло удачно, самое время повыполнять код на js. Node.js поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для ее запуска достаточно набрать node:
*/

$ node
>

/*
Если все прошло успешно, то REPL выведет приглашение для ввода инструкций: >. Попробуйте поиграться с ним. Наберите любое арифметическое выражение, например, 1 + 3 и нажмите Enter. Обратите внимание на то, что нет необходимости использовать console.log. REPL автоматически распечатывает последний вычисленный результат.

Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
*/

$ node
> a = 5
5
> b = 10
10
> a + b
15

/*
Чтобы выйти из REPL, нужно либо набрать .exit и нажать Enter, либо два раза нажать CTRL + C

Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением js, например, index.js, а затем запустить:
*/
// file: index.js
console.log('hello!');

$ node index.js
hello!

/*
# NVM
Совсем другой способ установки Node.js — утилита nvm. Кроме установки любых версий Node.js, она позволяет удобно переключаться между версиями. Это может понадобится, когда вы одновременно работаете над двумя проектами, требующими разные версии Node.js.


# ECMAScript
Основа js — язык ECMAScript. ECMAScript — это встраиваемый, расширяемый, не имеющий средств ввода-вывода (то есть он не может писать и читать файлы) язык программирования, используемый в качестве основы для построения других скриптовых языков. По сути, он существует только на бумаге. Стандартизирован международной организацией ECMA в спецификации ECMA-262. JS основан на ECMAScript, но расширяет его. Кстати, js не единственный язык, расширяющий ECMAScript. Кроме него также используются JScript и ActionScript.

Интересно, что сам по себе ECMAScript никакого отношения ни к браузерам, ни к вебу не имеет. Несмотря на это, сам ECMAScript развивается и имеет не одну версию, которая также называется стандартом:

es3
es5.1
strict mode
ECMAScript 2015 (es6)
es7 ?


# JavaScript
JavaScript — динамический, слабо типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.

# Интерпретируемый
У js отсутствует стадия компиляции, как у языков, подобных Java или C. Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на js состоит из текстовых файлов.
*/
$ node
> eval('10 * 3 + Math.random()')

/*
# Динамический
В отличие от статических языков, проверка типов в js происходит в момент выполнения кода. А значит, если мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статическими анализаторами кода. Слово статический как раз означает, что программа не выполняется. Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок. 

# Слабо типизированный
Слабая типизация означает, что js автоматически приводит типы там, где считает нужным. Подробнее этот механизм описан в спецификации. С одной стороны, слабая типизация позволяет писать более короткий код. С другой стороны, количество ошибок резко возрастает, так как вместо остановки выполнения, код продолжает работать там, где он не должен работать. Например, мы можем сложить число со строкой по ошибке, и js молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Никогда не полагайтесь на эту особенность языка, во избежание проблем.
*/

$ node
> 3 + '8ha'
'38ha'
> '8ha' * 3
NaN
> true + 1
2



>>>>> NPM <<<<<

/*
Node.js поставляется вместе с программой NPM. Она выполняет множество функций, которые не представляется возможным рассмотреть в рамках текущего курса. Рекомендуем периодически посматривать на ее команды и изучать информацию по ним. Ключевая задача, которую решает NPM — управление зависимостями, и именно о ней мы поговорим.

Практически с самого зарождения программирования: с тех пор, когда код стал храниться в памяти компьютера, появилась идея повторного использования кода не только в рамках одного проекта, но и во многих других. В разных проектах используются одни и те же функции для работы с датами, математическими формулами, всевозможными расчетами. Подобное переиспользование кода приводит к резкому росту производительности. Программисты современности могут сосредоточиться на решении уникальных задач бизнеса, вместо создания своих велосипедов для решения инфраструктурных задач. Все стало еще проще с появлением git и github.

Первоначально общий код выносился в файлы, которые программисты часто держали на своих собственных компьютерах и копировали из проекта в проект. Такой способ обладает рядом существенных недостатков:

Код сложно передать другим.
У каждого разработчика своя собственная копия одинаковых или почти одинаковых решений одних задач.
Доработкой занимается только автор.
Существует много разных копий без возможности быстрого обновления.
Из-за того, что код копируется прямо в другой проект, он, как правило, модифицируется и становится специфичным.
Если использовать git, то часть проблем решается автоматически. Cоздается набор общих файлов, который называется "библиотека". Конечные проекты, в свою очередь, начинают использовать библиотеки, написанные нами или сторонними разработчиками. Но тут возникает следующая сложность: когда таких библиотек становится много, у них также появляется общий код более низкого уровня. Например, финансовые библиотеки могут использовать функции для преобразования валют. Чтобы подобный код не дублировался, хочется вынести его в общедоступное место. Этот процесс может продолжаться бесконечно. Одни библиотеки зависят от других, те в свою очередь от третьих и так далее. С точки зрения переиспользования кода все хорошо: большое число маленьких библиотек, решающих всевозможные задачи, позволяет быстро двигаться вперед в разработке. Но с точки зрения управления этим зоопарком появляются проблемы:

Появляются новые версии библиотек. Из-за этого они начинают зависеть не только друг от друга, но и от разных версий друг друга. Зачем это нужно? Предположим, что создатель сторонней библиотеки, от которой зависит наша библиотека, обновил ее так, что изменил сигнатуры функций или, как говорят, сломал обратную совместимость. Теперь в них другое число параметров, другие параметры, другой возврат. Если мы обновим стороннюю библиотеку, наша первоначальная библиотека перестанет работать. Она рассчитывала на одно поведение библиотеки, от которой зависела, а получила другое.
Необходимо стандартизировать способ создания библиотек. Только в таком случае станет возможным автоматизировать процесс их соединения. Стандартный веб-проект может зависеть от сотни библиотек, которые в свою очередь зависят от сотен других библиотек. Общее число зависимостей может легко перевалить за тысячу. Управлять таким количеством зависимостей вручную невозможно.
Из проблемы, описанной выше, вытекает необходимость в автоматизированном средстве управления зависимостями: их обновлению, установке и удалению.
Всеми этими вопросами и занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.


# Терминология

В NPM используются следующие понятия:

Пакет (Package) — базовая единица, которой управляет NPM как единым целым. Может содержать любое количество файлов и кода. NPM позволяет устанавливать пакеты, обновлять или удалять.

Реестр (Registry) — хранилище пакетов NPM. Каждый желающий может опубликовать пакет в npm registry, потратив буквально минуту, а остальные смогут его использовать. В хранилище на текущий момент сотни тысяч пакетов и их количество стремительно растет. Исходный код пакетов, как правило, хранится на гитхабе. Несмотря на это, пакеты в npm никак не связаны с git и github.

# Глобальная установка пакетов

Многие пакеты в npm представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту sloc, которая умеет считать количество строк кода в указанной папке. Инструкция по установке обычно находится на странице репозитория в гитхабе.
*/
$ sudo npm install -g sloc

/*
Отмечу несколько моментов:
  -g — этот флаг говорит о том, что нужно установить пакет глобально, то есть в такое место, которое доступно для всех пользователей системы.
  sudo — нужно потому, что это место чаще всего недоступно для записи обычным пользователям (в Ubuntu это, скорее всего, /usr/local/lib).
после команды install можно перечислять любое количество пакетов через пробел.
Глобальная установка пакета sloc:

Процесс установки занимает некоторое время, в течение которого видно, как скачивается не только сам пакет, но и его зависимости. Дальше ничего делать не нужно, так как sloc создан утилитой командной строки и сразу готов к использованию.

# Создайте файл index.js в любом месте вашей файловой системы и добавьте туда любой код (например, печать на экран)
# Затем вызовите программу sloc, используя терминал. Для этого перейдите в директорию, содержащую этот файл, и выполните команду:
*/
$ sloc index.js // =>

/*
---------- Result ------------

            Physical :  2
              Source :  2
             Comment :  0
 Single-line comment :  0
       Block comment :  0
               Mixed :  0
               Empty :  0
               To Do :  0

Number of files read :  1

------------------------------

# Пакет

NPM работает таким образом, что объединяет понятия "проект" и "библиотека" в одно целое. И то и другое оформляется, как пакет NPM. Причем проект может быть любых размеров. Даже если ваше приложение состоит из 3 строчек кода, вам понадобится работать с ним, как с полноценным проектом.

Для создания пакета необходимо выполнить команду npm init в той директории, где вы собираетесь писать код. С этого момента эта папка будет корневой для вашего пакета.
*/
$ npm init

/*
После ввода данной команды вам предложат ответить на десяток вопросов, например, ввести имя вашего проекта, его описание, имя автора (вас как создателя) и тому подобное. Некоторые вопросы имеют ответы по умолчанию, например имя проекта или его версия. NPM предлагает для названия проекта использовать имя директории, внутри которой запускается npm init. Это полезное соглашение, которого стоит придерживаться (по необходимости переименуйте саму директорию).

# Если нажать Enter, то ответом на вопрос станет значение по умолчанию
*/
package name: (js_setup_environment_course) // ответ по умолчанию указан в скобках

// Когда вопросы закончатся, npm покажет конечный результат в виде JSON. JSON — это формат для представления структурированных данных.

{
  "name": "My Super Project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

/*
В этом JSON содержатся ответы которые вы дали ранее. NPM спросит все ли хорошо с ним? Если вы ответите утвердительно, то NPM создаст файл package.json, куда поместит данный вывод (JSON). В дальнейшем вы всегда сможете открыть его в обычном текстовом редакторе и поправить, если понадобится. Файл package.json крайне важен для правильной работы NPM. Кроме информационных полей типа имени автора, есть и функциональные поля, которые влияют на то как будет работать пакет. Они изучаются далее на протяжении всего курса.

# Проблемы

Если в файле package.json содержатся синтаксические ошибки, иными словами, там нарушены правила форматирования JSON, то при попытке сделать что-то с проектом будут появляться подобные ошибки:
*/
npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected string in JSON at position 225 while parsing '{
npm ERR!   "name": "gendiff_freetonik",
npm ERR!   "vers'
npm ERR! File: /Users/a/cpackage.json
npm ERR! Failed to parse package.json data.

// или такие:

npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected token n in JSON at position 207 while parsing near '...
npm ERR!   "engines": {
npm ERR!     node: 8
npm ERR!   },
npm ERR!   "scri...'
npm ERR! File: /Users/a/c/package.json
npm ERR! Failed to parse package.json data.

/*
Обычно любое сообщение с «неожиданными» (unexpected) символами или строками означает наличие синтаксической ошибки.

Воспользуйтесь валидаторами JSON для проверки верности своего файла: jsonlint.com или другими подобными инструментами, которые можно загуглить по запросу "json validator".

Другая проблема связана с тем, что NPM во время установки пакетов нередко выводит подобные сообщения:
*/

npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0.

/*
Бояться их не надо, это не сообщения об ошибках. Deprecated warning — сообщение, сигнализирующее о том, что нечто устарело. Под этим «нечто» может скрываться все, что угодно и часто не по вашей вине. Например, в package.json могут использоваться свойства, которые в новых версиях NPM называются по-другому. К этим предупреждениям стоит прислушиваться, но на работу они не влияют.


# Код пакета

После завершения процесса инициализации, можно приступать к самому главному — написанию кода. По умолчанию код пакета создается внутри файла index.js, лежащего в корне проекта (там, где создан файл package.json). Это не значит, что весь пакет состоит из одного файла. Файлов с кодом можно создавать сколько угодно, главное, при этом, что основная работа происходит внутри index.js, куда импортируется код из остальных файлов.


# Самостоятельная работа

Клонируйте nodejs-package к себе на компьютер (документация по клонированию https://help.github.com/articles/cloning-a-repository/).
Установите (глобально) пакет sloc.
Выполните команду sloc path/to/nodejs-package и изучите вывод. Где path/to/nodejs-package путь до директории nodejs-package клонированного на ваш компьютер.

Дополнительные материалы
NPM https://www.npmjs.com/
Документация NPM https://docs.npmjs.com/


В чём разница между секциями dependencies и devDependencies в структуре конфигурационного файла package.json?
> Секцию dependencies необходимо использовать для описания зависимостей, которые будут нужны при использовании программы, а devDependencies только для тестирования и локальной разработки.

Как правильно использовать установленную библиотеку (например hexlet-pairs) в файле с кодом?
*/
import { cons, car, cdr } from 'hexlet-pairs';




>>>>>> Публикация пакета <<<<<<

/*
Утилита sloc, которую мы использовали в прошлом уроке, создана обычным программистом как пакет NPM. Каким образом она стала доступна для установки? Дело в том, что недостаточно просто создать пакет и залить (git push) его код на гитхаб. Так NPM ничего о нем не узнает. При установке неизвестного пакета NPM выдаст соответствующее предупреждение:
*/

$ npm install unkownpackagename // =>
/*
npm ERR! code E404
npm ERR! 404 Not Found: unkownpackagename@latest


Утилита npm не смогла найти пакет в своем хранилище пакетов, о чем радостно нам и сообщила. Разберемся с добавлением нашего пакета в хранилище NPM.

Если мы хотим дать разработчикам возможность использовать наш пакет, то необходимо выполнить его публикацию. Публикация пакета сводится к запуску команды npm publish в корне нашего проекта:

Ниже показан процесс публикации пакета из репозитория https://github.com/hexlet-boilerplates/nodejs-package
*/
$ cd nodejs-package
$ npm publish

/* =>
> nodejs-package@0.0.2 prepublishOnly .
> npm run build

> nodejs-package@0.0.2 build /Users/hex/projects/nodejs-package
> NODE_ENV=production babel src --out-dir dist --source-maps inline

src/bin/hexlet.js -> dist/bin/hexlet.js
src/half.js -> dist/half.js
src/index.js -> dist/index.js
+ nodejs-package@0.0.2


Вывод может быть довольно большим. Главное, что здесь не видно явных ошибок и в конце такая строчка: + nodejs-package@0.0.2. Она сигнализирует о том, что пакет с именем nodejs-package был добавлен в NPM хранилище под версией 0.0.2. Как только публикация пройдет, ваш пакет автоматически станет доступным для установки. Убедиться в этом можно следующим образом:
*/

$ sudo npm install -g nodejs-package

/* =>
npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0. Please update to graceful-fs@^4.0.0 as soon as possible. Use 'npm ls graceful-fs' to find it in the tree.
/usr/local/bin/hexlet -> /usr/local/lib/node_modules/nodejs-package/dist/bin/hexlet.js
+ nodejs-package@0.0.2
added 187 packages in 16.11s

Как видите, в конце снова появляется строчка + nodejs-package@0.0.2, но теперь она означает, что пакет nodejs-package версии 0.0.2 был установлен.


И для полноты картины еще два способа найти нужный пакет и убедиться, что он есть в NPM хранилище:

1. Поискать на сайте https://www.npmjs.com/
2. Выполнить команду npm info nodejs-package. Если вы увидите информацию о пакете, то все хорошо. В противном случае возникнет ошибка.

Для успешной публикации должны выполниться два условия:

Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет, что и понятно, ведь тогда станет невозможным разобраться чей ставить пакет при указании этого имени.
Вы зарегистрированы на сайте https://www.npmjs.com/ и выполнили локально аутентификацию, запустив в командной строке npm login (синоним команды npm adduser). Такое требование важно с точки зрения безопасности. Пакет может публиковать только зарегистрированный пользователь, а обновлять — автор пакета.
В случае обновления, версия нового пакета должна быть выше версии текущего опубликованного пакета. Подробнее об этом пункте в разделе Версионирование.


Иногда требуется простая провека, что все настройки публикации выполнены правильно. Для этого не обязательно публиковать cам пакет в хранилище. Можно воспользоваться опцией --dry-run. Она сохраняет весь процесс публикации кроме фактического добавления пакета в NPM. При этом будут выведены подробности публикации:
*/

$ npm publish --dry-run


/* =>
> nodejs-package@0.0.3 prepublishOnly .
> npm run build

> nodejs-package@0.0.3 build /Users/hex/projects/nodejs-package
> NODE_ENV=production babel src --out-dir dist --source-maps inline

Successfully compiled 3 files with Babel.
npm notice
npm notice 📦  nodejs-package@0.0.3
npm notice === Tarball Contents ===
npm notice 1.6kB package.json
npm notice 1.1kB README.md
npm notice 852B  dist/bin/hexlet.js
npm notice 622B  dist/half.js
npm notice 711B  dist/index.js
npm notice === Tarball Details ===
npm notice name:          nodejs-package
npm notice version:       0.0.3
npm notice package size:  2.3 kB
npm notice unpacked size: 4.8 kB
npm notice shasum:        e9d86f87706327cb5afd3d2d594a3c8922dd2f4d
npm notice integrity:     sha512-xnK7Kuq2e7IGI[...]ZIMd7JXP9YPjA==
npm notice total files:   5
npm notice
+ nodejs-package@0.0.3



# Версионирование

В разработке принято версионировать программное обеспечение. Версия — это номер либо группа номеров (иногда с буквами или словами), которая обозначает какой-то конкретный этап разработки данного кода. Вот некоторые примеры: 0.0.2, 1.0.32, 1.33. С конкретной версией кода всегда связаны какие-то изменения относительно предыдущей версии, например, новые фичи, исправления багов или улучшения, такие как повышение производительности.

Зачем нужны версии в библиотеках? В первую очередь из-за обратной совместимости. Жизнь течёт, всё меняется и со временем библиотеки начинают работать по-другому, используют более удобные и современные подходы. В свою очередь код который их использует, не меняется одновременно с ними, а значит мы не можем гарантировать того, что наш код заработает с другой, более новой версией библиотеки. Поэтому нужна возможность фиксировать версию до тех пор, пока наш код не будет готов к использованию новой. Подробнее поговорим об этом в уроке про зависимости.

Современное версионирование кода основано на универсальном стандарте, который называется SEMVER http://semver.org/lang/ru (семантическое версионирование). По стандарту, версия представляет из себя три числа разделенных точками: 1.23.5. Каждое из этих чисел имеет собственно имя и предназначение:

Первое число (1 в примере выше) — мажорная версия. Меняется только в случае серьезных изменений, как правило, ломающих обратную совместимость
Второе число (23 в примере выше) — минорная версия. Не должна ломать обратную совместимость (в идеале). Меняется при добавлении новых возможностей.
Третье число (5) — патч. Гарантировано не должна менять обратную совместимость (к сожалению такое бывает). Меняется только при исправлении багов.
К сожалению, соответствие требованиям, целиком и полностью ответственность разработчиков. Автоматическая проверка (верификация) невозможна. Поэтому бывают сбои, когда версионирование происходит неверно, но в целом такой подход работает и упрощает работу.

Обратите внимание на то, что версия 1.12.3 выше, чем версия 1.3.3, потому что 12 больше чем 3.

# Самостоятельная работа
Зарегистрируйтесь на сайте https://www.npmjs.com/ (это пригодится для участия в проектах).
*/

>>>>>> Зависимости <<<<<<
/*
Основное предназначение пакетов - удобный способ делиться общим кодом. Возьмем для примера библиотеку lodash, которая очень широко используется в JavaScript и добавляет много маленьких функций, решающих различные повседневные задачи. Посмотрите на список функций слева https://lodash.com/docs/4.17.11. Их там больше сотни! Ниже типичный пример использования:
*/

// По общепринятому соглашению, lodash импортируется под именем _
import _ from 'lodash';

// capitalize делает первую букву заглавной
_.capitalize('hello'); // Hello

/*
Как только мы добавили подобный код (с импортом кода из другой библиотеки, а не локального файла) в наш проект (или библиотеку), мы получили так называемую зависимость. Теперь наш проект зависит от пакета lodash. Обратите внимание на то, как написано слово lodash. Перед ним нет указания текущей директории ./, именно так NPM понимает, что это внешняя зависимость, а не файл, лежащий рядом.

Возникает закономерный вопрос, как начать использовать эту библиотеку в своем коде? Если мы попытаемся импортировать ее как в примере выше, то получим закономерную ошибку о том, что пакет не найден. Во время запуска кода, все что импортируется, должно быть установлено локально в директорию node_modules лежащую в корне проекта. Делается это уже знакомой нам командой npm install, но в этот раз без флага глобальной установки. Для добавления пакета lodash, перейдите в корневую директорию того пакета, который вы разрабатываете и выполните следующую команду:

Имя пакета всегда совпадает с именем, которое указывается в части импорта, идущей после from
from 'lodash';
*/
$ npm install lodash

// После завершения установки, вы увидите что файл package.json изменился. В него добавилась секция dependencies с таким содержимым:
"dependencies": {
  "lodash": "^4.2.1"
}

/*
Отличие от глобальной установки состоит в том, что здесь нет флага -g и не нужно использовать sudo. При таком подходе зависимости ставятся в директорию node_modules, находящуюся в корне проекта. Кроме того, NPM создаст файл package-lock.json рядом с файлом package.json. Этот файл должен храниться в репозитории, а его значение я объясню в следующем уроке.

Теперь NPM знает о том что ваш проект (он же пакет) зависит от lodash.

Кроме обычных зависимостей, NPM отдельно обрабатывает зависимости необходимые только во время разработки. К таким пакетам относятся тестовые фреймворки и тому подобные вещи. Их установка немного отличается:
*/
$ npm install --save-dev jest

/*
Флаг --save-dev приводит к тому что зависимость добавляется в секцию devDependencies файла package.json. Эти зависимости никак не используются при публикации пакета, что позволяет экономить память. В остальном механизм работы тот же: они скачиваются и сохраняются в директорию node_modules и импортируются внутри кода как и любой другой код.
*/

"devDependencies": {
  "jest": "^23.6.0",
  "jest-cli": "^23.6.0"
}

/*
К сожалению, на текущем этапе код, указанный выше, не будет работать в любом случае. Связано это с тем, что Node.js напрямую не поддерживает синтаксис импортов и для их использования нужно подключить пакет Babel. 

Сами зависимости не хранятся в git-репозитории и должны быть добавлены в .gitignore:
*/

// FILE: .gitignore
node_modules

/*
Если вы клонировали репозиторий с гитхаба, директория node_modules будет отсутствовать, как и пакеты в ней. Первое, что нужно сделать в этом случае — выполнить команду npm install. Эта команда, запущенная без аргументов, выполняет установку тех пакетов, которые указаны в файле package.json. Она запускается в разных случаях: если вы удалили папку node_modules и хотите снова ее восстановить или если вы только что клонировали репозиторий. Установка пакетов — идемпотентная операция, поэтому ее можно запускать сколько угодно раз, не боясь что-либо сломать.

# Самостоятельная работа:
Изучите зависимости в репозитории nodejs-package https://github.com/hexlet-boilerplates/nodejs-package. Попробуйте найти репозитории зависимых пакетов.
*/



>>>>>> Lock файл <<<<<<

/*
Поговорим об обновлении зависимостей. Для обновления всех зависимостей нужно выполнить команду npm update. Чтобы выполнить обновление конкретной зависимости — npm update name, где name — имя библиотеки. А вот то, как будет происходить обновление, зависит от того, что написано в package.json.

Рассмотрим все доступные варианты:
*/

dependencies {
  'package1': "*",
  'package2': "1.3.5",
  'package3': "~2.3.4",
  'package4': "^2.3.4",
}


/*
* означает, что можно ставить любую версию библиотеки. После выполнения команды обновления в папке node_modules окажется последняя доступная версия package1.
1.3.5 - конкретный номер. Если версия библиотеки жестко зафиксирована, никакая команда не сможет обновить ее.


Самый интересный сценарий происходит в случае использования тильды (~). Напомню, что в семантическом версионировании считается, что patch (последняя цифра в версии) изменяется только в случае исправления ошибок, а значит обратная совместимость не должна теряться. На практике это не всегда так, код может работать с учетом ошибок в зависимостях. Как правило, в проектах десятки, а то и сотни зависимостей, причем обновляются они очень часто. С одной стороны, можно всегда писать *, но тогда мажорные обновления библиотек могут сломать систему. С другой стороны, можно зафиксировать все версии, но тогда обновлять все придется вручную, а значит, по закону Мерфи, никто не будет этого делать. Поэтому появился третий вариант. Добавление тильды приводит к тому, что в автоматическом режиме обновляются только патчи. Предположим, что после добавления зависимости в проект, версия была установлена в ~2.10.3. Если после нее в npm репозитории появилась 2.10.5, то она будет установлена командой обновления. То же самое произойдет, если потом будет выпущена версия 2.10.15. Но если создатель библиотеки опубликует изменения в мажорной или минорной версии, например 2.11.5 или 3.0.0, то npm их проигнорирует.

Примерно то же самое происходит и при использовании ^ ("крышки"), только в отличие от тильды, она фиксирует мажорную версию, а минорная обновляется наравне с патчем.

# Lock

На предыдущем шаге каждая новая установка зависимостей сначала создавала, а потом обновляла файл package-lock.json.

Попытаемся разобраться, зачем он нужен. Как мы помним, в package.json указываются зависимости, и мы научились устанавливать и обновлять их. У каждой зависимости могут быть свои собственные зависимости, которые тоже обновляются — и так до бесконечности. Зависимости зависимостей называются транзитивными и с ними не все так просто. Настолько не просто, что существует понятие "dependency hell" (ад зависимостей).


Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей. Предположим, что в нашем пакете есть зависимость A с зафиксированной версией 1.3.2, у которой в зависимостях стоит пакет B с версией *. В такой ситуации в отсутствие лок файла npm install установит указанную версию зависимости A и последнюю доступную версию пакета B. Такое поведение не детерминировано. Если создатель пакета B обновит его так, что нарушится обратная совместимость, наш проект просто сломается, так как перестанет работать A. Если мы полгода не заходим в проект, а затем зайдем и поставим зависимости заново, удалив папку node_modules или выполнив новое клонирование, то почти наверняка ничего не заработает. Пакеты обновляются часто, и какой-нибудь из них обязательно изменит мажорную версию за столь длинный срок.

Очевидный, но не рабочий выход из данной ситуации — вручную отслеживать зависимости всех зависимостей и явно прописывать их версии в package.json. Такой способ сработает, но даже в проекте на js, который содержит всего 5 зависимостей, транзитивных зависимостей будут сотни! Вдумайтесь в эту цифру. Я уже не говорю про то, что пакеты обновляются и меняются. Такую ситуацию невозможно контролировать, и зависимости просто перестанут обновляться.

Другой выход — требовать, чтобы создатели всех библиотек всегда жестко указывали версии. Из-за человеческого фактора этот вариант обречен на провал. Автоматизация такого процесса привела бы к полному параличу системы пакетов и библиотек, а значит и разработки программ.

И тут на сцену выходит lock-файл. Он представляет собой автоматизированное решение первого способа. Его содержимое выглядит примерно так:
*/

{
  "name": "hexlet-co",
  "version": "0.1.4",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "JSONStream": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.1.tgz",
      "integrity": "sha1-cH92HgHa6eFvG8+TcDt4xwlmV5o=",
      "requires": {
        "jsonparse": "1.3.1",
        "through": "2.3.8"
      }
    },
    "abab": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/abab/-/abab-1.0.4.tgz",
      "integrity": "sha1-X6rZwsB/YN12dw9xzwJbYqY8/U4=",
      "dev": true
    },
    "acorn": {
      "version": "4.0.13",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-4.0.13.tgz",
      "integrity": "sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c="
    },
    ...
  }
}

/*
Первый запуск установки зависимостей формирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные, и их версии. При дальнейших запусках npm install всегда ставится то, что указано в lock файле, даже если стереть папку node_modules, а в npm-хранилище добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь всегда можно быть уверенным, что если заработало сейчас, то заработает потом и не только у нас.

Наличие lock файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в package.json, обновился и может быть обновлен до указанной версии, то загрузится новая версия, а файл lock обновится автоматически. После этого нужно не забыть залить его в git-репозиторий.

На самом деле, lock-файл ведет себя сложнее, но для понимания схемы его работы достаточно описанного выше. Если хотите разобраться в теме от и до — изучите официальную документацию.

Как и любой автоматически генерируемый файл, lock-файл не может правиться вручную, потому что ваши изменения сразу будут сброшены при следующей генерации.

# Самостоятельная работа
Клонируйте репозиторий nodejs-package, а затем выполните внутри него команду npm update. Изучите вывод команды git diff.
Попробуйте изменить версию любого пакета в package.json, указав точную версию без использования ^, и выполните npm install. Доступные версии пакета можно посмотреть командой: npm view <packagename> versions, например: npm view eslint versions.

В каких случаях происходит создание и обновление файла package-lock.json?
> При установке новых зависимостей
> При установке доступных обновлений существующих зависимостей
*/

>>>>>> NPX <<<<<<

/*
Не все устанавливаемые зависимости, используются внутри кода как библиотеки. Некоторые нужны для различных утилитарных задач. К подобным пакетам относится eslint. Eslint - это программа для проверки кода на соответствие стандартам кодирования, она используется на Хекслете для проверки ваших решений как в практике к урокам так и в проектах, где вы будете устанавливать ее самостоятельно. Существует два способа ее установки, глобальный и локальный.

Глобальная установка позволяет установить eslint один раз и затем использовать его во всех необходимых пакетах, которые мы разрабатываем:
*/
$ sudo npm install -g eslint
$ cd my-package

// eslint требует указать директорию, в которой нужно искать файлы для проверки. Точка означает текущую директорию:
$ eslint .

/*
Хотя такой способ установки кажется заманчивым, все же, его стоит избегать. Глобальные зависимости не ставятся при первоначальной настройке пакета. То есть если мы выполним команду npm install в свежесклонированном репозитории, eslint не поставится, а значит придется устанавливать его отдельно. И это придется делать не только нам, но и всем кто участвует в разработке данного пакета. К тому же возможны проблемы с версиями. Если у кого-то стоит eslint старой версии, это может помешать нормальной проверке, и в такой ситуации не будет никакой возможности обновить версию пакета автоматически, это произойдет только если разработчик сам вспомнит о том, что пакет стоит обновить.

Поэтому наш выбор - локальная установка. Подобные пакеты всегда используются только при разработке, поэтому не забываем указывать флаг --save-dev во время локальной установки:
# В корне проекта
*/
$ npm install --save-dev eslint

/*
Но здесь нас ожидает сюрприз. Если попробовать его запустить как обычно, то bash скажет что команда не найдена (если, конечно, вы не установили его глобально ранее).
# В корне проекта
*/

$ eslint .
bash: eslint: command not found

/*
Такое поведение вполне ожидаемо. Вспомните, курс по основам командной строки и урок посвященный запуску программ из консоли. Исполняемый файл программы ищется по путям перечисленным в переменной окружения $PATH. В случае локальной установки, пакет устанавливается в директорию node_modules и только туда, никакие файлы больше никуда не добавляются. Другими словами bash не может узнать о том, что вы установили какую-то программу.

Из этой ситуации есть два выхода: правильный и неправильный. Неправильный - запустить исполняемый файл указав прямой путь. Для eslint он будет таким:
*/
$ ./node_modules/.bin/eslint --init // инициализация линтера, во время которой создается конфигурационный файл
$ ./node_modules/.bin/eslint . // запуск проверки в текущей и всех вложенных директориях

/*
Проблема такого подхода в том, что идет завязка на конкретный путь внутри самого пакета. Если разработчики поменяют его или банально переименуют файл eslint.js, то все запуски сломаются. Поэтому нужно использовать правильный способ:
*/
$ npx eslint --init
$ npx eslint .

//  npx - специальная программа, которая автоматически устанавливается вместе с утилитой npm (убедитесь что вы ставите одну из последних версий Node.js). Она имеет такой формат работы:

$ npx <тут любая программа, установленная как локальный пакет NPM> <тут опции этой программы>

/*
То есть npx добавляется слева к любому вызову, при этом сама команда никак не меняется.

Как работает npx? Эта утилита меняет $PATH для конкретного вызова, добавляя туда путь ./node_modules/.bin. Именно поэтому начинают работать локально установленные программы.

Например для написания тестов в js, мы используем тестовый фреймворк Jest. Он ставится как обычная зависимость в проект и дальше запускается через команду jest:
*/

$ npm install --save-dev jest

// Пример вызова без npx
$ jest
// => bash: jest: command not found

// А теперь правильно
$ npx jest
// =>  тут побежали тесты



>>>>>> Scripts <<<<<<

// Секция Scripts позволяет описывать произвольные команды, которые затем можно выполнять.
"scripts": {
  "test": "jest",
  "build": "NODE_ENV=production babel src --out-dir dist --source-maps inline",
  "prepublishOnly": "npm run build"
}

// Рассмотрим пример. Предположим, что мы установили программу sloc как зависимость и хотим ее запускать с определенными параметрами.
"scripts": {
    ...
    "sloc": "sloc",
    ...
}

/*
Имя свойства используется как команда в командной строке, значение — исполняемая программа. Теперь, если вы попробуете сделать так: npm run sloc, то все отработает как и ожидается.

Некоторые свойства в Scripts имеют особое значение. Например, на Хекслете код проверяется автоматическими тестами с использованием библиотеки jest. Она содержит бинарник с тем же именем и все, что нужно сделать для запуска тестов - выполнить команду jest. Мы могли бы сделать в скриптах такую запись: "jest": "jest", но именно для тестов NPM предлагает делать так: "test": "jest". Главное отличие подобных встроенных команд — в их способе запуска. Достаточно набрать npm test вместо npm run test, хотя второй вариант также сработает.
*/

nodejs-package$ npm test

/* =>
> nodejs-package@0.0.1 test /Users/mokevnin/hexlet/nodejs-package
> jest

 PASS  __tests__/half.test.js
  ✓ half (3ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.242s, estimated 1s
Ran all test suites.

# Hooks

Есть целый набор предопределенных свойств в Scripts, которые NPM запускает автоматически в разные моменты жизни. Подробнее об этом можно прочитать в официальной документации https://docs.npmjs.com/misc/scripts. Одним из таких свойств является свойство prepublishOnly, которое используется тогда, когда перед публикацией пакета в репозиторий NPM необходимо выполнить некоторые действия, например, сгенерировать документацию. Команда, указанная в нем, запустится во время выполнения npm publish.

Самостоятельная работа
Попробуйте выполнить скрипт test в пакете nodejs-package https://github.com/hexlet-boilerplates/nodejs-package


Допустим, в файле package.json прописан следующий скрипт:

"scripts": {
  "eslint": "eslint --colors"
}


Как выполнить проверку файла index.js линтером используя npm?
> npm run eslint index.js


Допустим, в файле package.json прописан следующий скрипт:
"scripts": {, так как в секции scripts есть скрипт с ключом start
  "start": "bin/index.js"
}
Какими способами нужно запускать скрипт start используя npm? Выберите все правильные ответы.
> npm run start, так как в секции scripts есть скрипт с ключом start
> npm start, так как start является дефолтной для npm командой, а значит ключ run можно опустить
*/




>>>>>> Babel <<<<<<

/*
Итак, мы знаем, что есть спецификация, а есть ее реализация. Знаем, что реализация зачастую отстает от спецификации. Более того, разные реализации по-разному отстают от спецификации. Написав код, мы не можем гарантировать, где он будет запускаться, а где — нет.

Исходя из этого можно сделать вывод, что нужно писать код, придерживаясь старых стандартов. К счастью, есть другой путь: мы можем писать код с использованием всех возможных фич, но перед публикацией автоматически транслировать его (то есть переводить из одного вида в другой) в старую версию. Звучит сложно, но на практике все просто.

Сама природа JS и его способы использования готовят нас к тому, что никогда не настанет светлых времен с современными рантаймами. Люди использовали и продолжат использовать разные браузеры и разные версии браузеров, разные версии Node.js и так далее. Использование новых синтаксических конструкций в такой ситуации практически невозможно. Запуск кода на платформе, не поддерживающей новый синтаксис приведет к синтаксической ошибке. Закономерным решением этой проблемы стало появление Babel — программы, которая берет указанный код и возвращает тот же код, но транслированный в старую версию JS. Фактически, в современном мире Babel стал неотъемлемой частью JS. Его не используют только в старых проектах, также называемых легаси-проектами. Все новые проекты так или иначе делают с его использованием.

У Babel есть собственный онлайн REPL https://babeljs.io/repl/. Попробуйте вставить туда любой код, который вы писали на Хекслете, и посмотрите, во что он превратится. Такая трансляция называется транспайлингом, а сам Babel называют транспайлером, от transpiler https://en.wikipedia.org/wiki/Source-to-source_compiler.
*/

// before:
const factorial = (n) => {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

// after:
"use strict";

var factorial = function factorial(n) {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
};

/*
Babel состоит из многих частей:

Пакет @babel/core содержит код, который выполняет всю работу по трансляции, но не содержит внутри себя правил преобразования. Правила описаны в отдельных пакетах, называемых плагинами (например, babel-plugin-transform-constant-string).

@babel/preset-env. Пресет - это группа плагинов, которую можно подключить к Babel целиком. preset-env - основной пресет поддерживаемый командой Babel, который содержит внутри себя плагины, реализующие стандартизированные возможности js.

Пакет @babel/cli обеспечивает возможность работы с бабелем через терминал. Предоставляет командную утилиту babel. Ниже рассматривается ее использование.

Пакет @babel/node - еще одна утилита командной строки: babel-node. 


# Установка
*/
$ npm install --save-dev @babel/core @babel/cli @babel/node @babel/preset-env


/*
# Настройка

Babel полагается на наличие файла babel.config.js в корне проекта. Именно через него он узнает, как нужно транслировать код.

Этот файл нужно создать самостоятельно. Если вы забудете добавить туда плагин или пресет, то на выходе Babel отдаст тот же код, что был и на входе.
*/

module.exports = {
  presets: [
    ['@babel/env', {
      targets: {
        node: 'current',
        firefox: '60',
        chrome: '67',
        safari: '11.1',
      },
    }],
  ],
};

/*
Разные среды исполнения поддерживают (или не поддерживают) разные возможности и синтаксические конструкции языка. В свойстве targets перечисляются конкретные окружения (и их версии), для которых пишете код. Если код предназначен для выполнения на nodejs, то достаточно указать только его. В таком случае babel будет транслировать конструкции, поддерживаемые на nodejs, и ничего лишнего:
*/

module.exports = {
  presets: [
    ['@babel/env', {
      targets: {
        node: 'current',
      },
    }],
  ],
};

/*
Минимально достаточно подключить пресет @babel/preset-env. Он добавляет возможности JS, которые входят в стандарт.

# Использование

При появлении в проекте Babel, изменяется файловая структура проекта. Так как код существует в двух состояниях: исходном и транслированном, то удобно создать две директории, под каждый набор исходников. 
Исходный код, принято хранить в директории src в корне проекта, а код полученный в результате трансляции - в директории dist.

# Команда babel предоставляется пакетом @babel/cli:
*/
$ npx babel src --out-dir dist

/*
Эта команда берет весь код из файлов в директории src и создает его транслированную версию в директории dist. Запускается он точно так же, как и любой другой код, и фактически именно этот код нужно доставить в NPM-репозиторий. Другими словами, пользователи вашего пакета запускают код из директории dist, а не src, хотя сами об этом не знают. Сама директория dist добавляется в .gitignore, так как сгенерированный код нужен только в момент публикации пакета для упаковки в архив, который уходит в NPM-репозиторий. В процессе разработки пакета, запуск сборки не требуется.

Есть только один маленький нюанс. Изначально я сказал, что NPM никак не интегрирован с Git, но это не совсем правда. По умолчанию NPM смотрит в файл .gitignore. Все, что там перечислено, не попадет в NPM-репозиторий при публикации пакета. В нашем случае такой директорией является dist, но именно ее мы и хотим опубликовать. Выходов из этой ситуации несколько. Один связан с файлом .npmignore и описан в документации, про другой я скажу подробнее. NPM позволяет указать список файлов и папок, которые нужно опубликовать. Достаточно добавить секцию files в package.json. Содержимое files — массив директорий и файлов:
*/

"files": [
  "dist"
]

/*
Существует два способа подготовки пакета к публикации. Первый подход заключается в том, чтобы перед выполнением npm publish вручную сгенерировать каталог dist, используя скрипты: npx babel src --out-dir dist. Подход рабочий, но сопряжён с постоянными ошибками в стиле "ой, забыл собрать новый код". К тому же, это действие может быть автоматизировано — именно эту идею и реализует второй подход. NPM содержит множество предопределённых скриптов, которые выполняются автоматически в определённые этапы работы. Например, prepublishOnly запускается перед непосредственным выполнением публикации. То, что нам и требуется.
*/

"scripts": {
  "build": "NODE_ENV=production babel src --out-dir dist",
  "prepublishOnly": "npm run build"
}


/*
В примере выше используется небольшой трюк. В prepublishOnly вызывается другой скрипт — build. Этот приём используется широко, и он действительно удобен. Бывают ситуации, когда все же нужно запускать сборку руками. Поэтому удобно иметь отдельную команду только для генерации. Скрипт build как раз и призван решить эту задачу.

Подчеркну еще раз: каталог dist не должен храниться в git-репозитории, и вы не найдете его на Гитхабе. Посмотрите lodash. Она генерируется только в момент публикации пакета и заливается в npm-репозиторий. Каждая новая публикация должна генерировать этот каталог заново. Только в этом случае обновится код в пакете.

Подведём итог. В git-репозитории хранится исходный код, ещё не обработанный babel. Это значит, что вы всегда можете найти библиотеку и изучить её содержимое на github. А вот пакет, установленный к вам в систему содержит обработанный код, предназначенный для запуска, а не для чтения. Этот код не хранится в git-репозитории. Он попадает в NPM-репозиторий в момент публикации новой версии пакета за счет выполнения команды prepublishOnly (в которую вы сами должны прописать вызов трансляции).

# Babel-node

При использовании новых возможностей js, запуск кода на выполнение node file.js, упадет с ошибкой, потому что внутри файла используется синтаксис, который нода не понимает. Для запуска кода после каждого изменения, необходимо выполнять трансляцию. Этот процесс выглядит так:

1 Делаем изменение.
2 Транслируем код с помощью Babel.
3 Запускаем на выполнение.

Разработчики Babel предусмотрели эту ситуацию. В этом случае можно установить пакет @babel/node. Теперь код можно вызывать так: npx babel-node src/index.js. Команда babel-node делает одновременно две вещи. Транслирует код и сразу же запускает его на выполнение. В отличие от команды babel, babel-node не сохраняет результат трансляции. Все происходит во время работы в памяти. Обратите внимание на то, что вам все равно понадобится правильно настроенный файл babel.config.js в корне проекта иначе babel-node не сможет произвести трансляцию и так же завершится с ошибкой синтаксиса на момент запуска.

# Самостоятельная работа
Попробуйте выполнить скрипт build в пакете nodejs-package. Изучите результаты его работы в папке dist. Вы должны увидеть, что содержимое файлов внутри dist отличается от содержимого тех же файлов внутри src. Вместо const использован var, вместо import - require. В целом код остается читаем, хотя и выглядит странновато.



Как устанавливать Babel?
> Добавить необходимые пакеты в devDependencies и создать конфигурационный файл babel.config.js

С помощью какой утилиты можно сразу увидеть результат выполнения Babel кода?
> babel-cli

Как автоматизировать процесс доставки кода прошедшего через Babel в NPM репозиторий?
> Использовать скрипт prepublishOnly, который выполняется автоматически перед командой npm publish

Какой код в итоге должен попасть в NPM репозиторий?
> Исходный код прошедший обработку через Babel. Только так будет обеспечена максимальная совместимость со всеми интерпретаторами.

Рассмотрим ситуацию, когда в файле .gitignore имеется следующее содержимое:
.*.swp
dist
npm-debug.log
Как опубликовать пакет так, чтоб в него попал каталог dist не меняя при этом содержимое файла .gitignore?
> Создать файл .npmignore (можно даже пустой), так как для NPM он представляет наибольший приоритет
> Добавить в package.json секцию files и записать в неё dist
*/



>>>>>> Source Map <<<<<<

/*
В самых простых случаях транслированный код выглядит почти так же, как и исходный. Но стоит начать использовать чуть более продвинутые возможности JS, как код изменяется до неузнаваемости:
*/

// Было:
const defaultState = { channels: {}, messages: {} };
let state = { ...defaultState };

export default router => router.put('refresh', '/refresh', async (ctx) => {
  state = { ...defaultState };
});

// Стало:

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultState = { channels: {}, messages: {} };
var state = _extends({}, defaultState);

exports.default = function (router) {
  return router.put('refresh', '/refresh', function (ctx) {
    state = _extends({}, defaultState);
    ctx.status(200);
  });
};

/*
Трансляция не дается бесплатно. Получившийся код нечитаем и его невозможно нормально отладить. Ведь теперь запускается не наш первоначальный код, а транслированный. Это значит, что любая логическая ошибка нашего кода будет указывать на транслированный код, который в свою очередь очень сильно отличается от исходного, поскольку:

 - Babel может заменять имена переменных.
 - Строчки, на которые указывает stacktrace — отчет о вызванных функциях после возникновения ошибки в программе, в исходном и транслированном файле не совпадают. Более того, stacktrace указывает только на транслированный код.
 - В одних и тех же ситуациях возникают разные ошибки. Например, если вы забыли экспортировать функцию по умолчанию, то после трансляции вы увидите такое сообщение: TypeError: (0 , _path2.default) is not a function вместо Module 'path' has no default export.


Для решения этой проблемы используется специальный механизм под названием "source map" или "маппинг". Его принцип действия следующий. При транспайлинге кода создается структура определенного формата, в которой описана связь сгенерированного кода с исходным кодом. Затем эта структура записывается либо в отдельный, либо прямо в сгенерированный файл в виде комментария (inline mode). Затем, во время выполнения программы, она используется интерпретатором для построения правильных стектрейсов и ссылок.

Пример содержимого файла index.js.map с маппингом: 
*/
{"version":3,"sources":["../src/index.js"],"names":["co","generator","args","iterator","enerator","next","result","value","Promise","resolve","done","then","res","throw","err","reject"],"mappings":";;;;;;AAEA;;;;AAEA;;;;;;;;;;;;;AAaA,IAAMA,KAAK,SAALA,EAAK,CAACC,SAAD,EAAyC;AAAA,oCAAdC,IAAc;AAAdA,QAAc;AAAA;;AAClD,MAAMC,WAAWC,6CAAYF,IAAZ,EAAjB;;AAEA,MAAMG,OAAO,SAAPA,IAAO,CAACC,MAAD,EAAY;AACvB,QAAMC,QAAQC,QAAQC,OAAR,CAAgBH,OAAOC,KAAvB,CAAd;AACA,QAAID,OAAOI,IAAX,EAAiB;AACf,aAAOH,KAAP;AACD;;AAED,WAAOA,MAAMI,IAAN,CACL;AAAA,aAAON,KAAKF,SAASE,IAAT,CAAcO,GAAd,CAAL,CAAP;AAAA,KADK,EAEL;AAAA,aAAOP,KAAKF,SAASU,KAAT,CAAeC,GAAf,CAAL,CAAP;AAAA,KAFK,CAAP;AAID,GAVD;;AAYA,MAAI;AACF,WAAOT,KAAKF,SAASE,IAAT,EAAL,CAAP;AACD,GAFD,CAEE,OAAOS,GAAP,EAAY;AACZ,WAAON,QAAQO,MAAR,CAAeD,GAAf,CAAP;AACD;AACF,CApBD;;kBAsBed,E","file":"index.js","sourcesContent":["// @flow\n\nimport 'source-map-support/register';\n\n/**\n * Generator based control flow\n * @name co\n * @example\n * co(function* () {\n *   const result = yield Promise.resolve(true);\n *   return result;\n * }).then(value => {\n *   console.log(value);\n * }, err => {\n *   console.error(err.stack);\n * });\n */\nconst co = (generator: () => void, ...args: any) => {\n  const iterator = enerator(...args);\n\n  const next = (result) => {\n    const value = Promise.resolve(result.value);\n    if (result.done) {\n      return value;\n    }\n\n    return value.then(\n      res => next(iterator.next(res)),\n      err => next(iterator.throw(err)),\n    );\n  };\n\n  try {\n    return next(iterator.next());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n};\n\nexport default co;\n"]}

// А в конце сгенерированного файла index.js будет такая строчка:
//# sourceMappingURL=index.js.map

/*
Эта техника не является специфичной для JS. Она используется повсеместно там, где применяется транспайлинг.

Babel

Babel поддерживает source map из коробки. Для его генерации достаточно добавить флаг --source-maps в процесс компиляции:
*/
$ npx babel script.js --out-file script-compiled.js --source-maps inline


/*
После выполнения этой команды в конце транслированных файлов появится source map в виде комментария. Однако, если речь идет про Node.js (а не браузер), то этого недостаточно. На текущий момент Node.js не имеет встроенной поддержки source map, поэтому даже если вы их сгенерировали, нода никак не отреагирует на их наличие. Их поддержку можно добавить с помощью npm пакета https://github.com/evanw/node-source-map-support https://github.com/evanw/node-source-map-support.

# Самостоятельная работа
Пропустите код nodejs-package https://github.com/hexlet-boilerplates/nodejs-package через Babel, включив генерацию Source Map в отдельных файлах.


Для чего нужен Source Map?
> Для отладки кода прошедшего транспайлинг путём добавления карты, указывающей на реальную структуру исходных файлов

Как сгенерировать source map для файла hexlet.js используя Babel?
> npx babel hexlet.js --out-file hexlet-compiled.js --source-maps

Как автоматически сгенерировать source map для всех файлов в папке dist при сборке пакета?
> Добавить babel src --out-dir dist --source-maps в значение ключа build секции scripts
*/




>>>>>> Точка Входа <<<<<<

/*
В курсе "Введение в программирование" использовался только один вид импортов — импорт из локальных файлов. Подобные импорты отличает указание относительного пути (./) в секции from.
*/

import { length } from './strings';
import factorial from './factorial';

/*
Все подобные импорты объединяет то, что в них мы обращаемся к конкретному файлу, лежащему где-то рядом. Его всегда можно открыть и посмотреть содержимое. Но в реальных проектах и дальше в курсах, вам будут встречаться нелокальные импорты:
*/

import path from 'path';
import fs from 'fs';
import lodash from 'lodash';

/*
Как видите, в импортах выше, нет начального ./. Некоторые из них, по сути, тоже локальные — это импорты из стандартной библиотеки. В указанном примере к ним относятся первые два импорта из модулей path и fs. Эти модули лежат где-то в системных директориях — там, куда они были помещены во время установки Node.js. Посмотреть список всех модулей стандартной библиотеки можно в официальной документации https://nodejs.org/api/modules.html

Самое интересное происходит при импорте сторонних npm-пакетов: import lodash from 'lodash';. Дело в том, что пакет — не то же самое что и модуль. Модуль — один файл, а пакет — набор файлов, в которые входят модули и package.json. Посмотрите содержимое репозитория lodash. В корне проекта находится, наверное, сотня файлов.


Возникает закономерный вопрос. Если внутри одного пакета множество модулей, то что же импортируется если мы пишем import lodash from 'lodash'?

В npm принято соглашение, что по умолчанию всегда импортируется файл index.js, находящийся в корне проекта. Этот файл является точкой входа в пакет. Все остальные модули, как правило, собираются внутри index.js. Но это поведение можно изменить. За это отвечает свойство main (главный) в файле package.json. Посмотрите его значение в пакете lodash. В нашем эталонном пакете nodejs-package эта строчка выглядит так:
*/
"main": "dist/index.js"

/*
Сам файл dist/index.js в репозитории отсутствует, как впрочем и папка dist. Как вы помните из урока про babel, эта директория формируется только в момент публикации пакета и заливается в npm, но в репозиторий ее не добавляют.


В какой секции файла package.json задаётся точка входа?
> "main": "path/to/file"

Какой файл вашего проекта является точкой входа по умолчанию?
> index.js
*/



>>>>>> Исполняемые файлы <<<<<<

/*
Многие пакеты представляют из себя приложения командной строки, так называемые cli-утилиты, взаимодействие (запуск команд, передача аргументов и опций, вывод результатов) которых с пользователем происходит интерактивным образом через терминал. Для обеспечения такой возможности (запуск файлов из командной строки) в npm существует секция bin конфигурационного файла package.json, например:
*/

"bin": {
    "hexlet": "dist/bin/hexlet.js"
}

/*
Эта запись означает, что при установке пакета в операционной системе будет физически создан файл (а точнее, его особая разновидность — символическая ссылка, symlink) с именем hexlet, запуск которого приведёт к запуску файла вашего проекта по адресу dist/bin/hexlet.js. Также обратите внимание, что количество ссылок может быть множество (столько, сколько сами укажете в секции bin).

Месторасположение символической ссылки и способ её запуска из командной строки различаются в зависимости от способа установки пакета: глобального (с флагом -g: npm -g install packageName) или локального. Рассмотрим каждый случай отдельно.


# Глобальная установка: генерация ссылок и запуск исполняемых файлов
При глобальной установке пакета npm создаёт символические ссылки в каталоге по умолчанию /usr/bin (или /usr/local/bin, в разных системах значение может отличаться, кроме того оно может конфигурироваться https://docs.npmjs.com/misc/config с помощью npm). Это каталог для прикладных программ общего назначения, распространённый в операционных системах семейства UNIX, и путь к нему прописан в переменной окружения PATH. Именно поэтому мы можем запускать приложение по имени символической ссылки из командной строки, находясь в любой точке файловой системы (ведь при поиске исполняемых файлов командная оболочка ищет их последовательно по всем путям, прописанных в переменной окружения PATH).

Посмотреть, в какую директорию npm складывает ссылки на исполняемые файлы можно с помощью команды:
*/
$npm bin -g // npm bin --global.

// Посмотреть содержание переменной окружения PATH в вашей системе можно так:
echo $PATH
echo $PATH | grep /usr/bin


// Если вы пользуетесь системой управления версиями nvm (Node Version Manager, позволяет удобно использовать разные версии nodejs в рамках одной операционной системы), то каталог для символических ссылок может быть другой, например:
npm -g bin

/*
Как видно, для каждой версии nodejs менеджер nvm создаёт отдельный каталог bin для ссылок на исполняемые файлы устанавливаемых на нём пакетов. Но суть от этого не меняется — самое главное, чтобы путь к каталогу был в переменной окружения PATH (в данном случае nvm автоматически добавляет путь к каталогу в PATH).

Пример
Давайте создадим и опубликуем пакет, который для краткости и наглядности будет очень простым, состоящим всего из двух исполняемых файлов, запуск которых выводит соответственно приветствие и прощание с Хекслетом.

Структура проекта:
*/
~/projects/smallTalkWithHexlet$ ls -al
drwxrwxr-x  2 hex hex 4096 июн 12 16:35 ./
drwxrwxr-x 18 hex hex 4096 июн 12 16:22 ../
-rw-rw-r--  1 hex hex  340 июн 12 16:49 package.json
-rwxrwxr-x  1 hex hex   69 июн 12 16:29 sayBye.js*
-rwxrwxr-x  1 hex hex   52 июн 12 16:31 sayHi.js*


// Содержимое исполняемого файла sayHi.js:
~/projects/smallTalkWithHexlet$ cat sayHi.js
#!/usr/bin/env node

console.log('Hello, Hexlet!');

// Содержимое исполняемого файла sayBye.js:
~/projects/smallTalkWithHexlet$ cat sayBye.js
#!/usr/bin/env node

console.log('Bye-bye! See you later, Hexlet!');


// Содержимое конфигурационнного файла package.json:
~/projects/smallTalkWithHexlet$ cat package.json
{
  "name": "small_talk_with_hexlet",
  "version": "1.0.0",
  "description": "Small talk with Hexlet",
  "main": "",
  "bin": {
    "sayHi": "./sayHi.js",
    "sayBye": "./sayBye.js"
  },
  "keywords": [
    "hexlet"
  ],
  "author": "hex",
  "license": "MIT"
}


/*
Небольшое отступление про исполняемые файлы:

1 Для возможности запуска файла из командной строки у пользователя должно быть право на выполнение (атрибут x) этого файла.
2 Если исполняемый файл содержит код, то надо указать командной оболочке интерпретатор, который будет исполнять этот код при запуске исполняемого файла. Это делается с помощью так называемого шебанга. В примерах выше (#!/usr/bin/env node) мы указали в качестве интерпретатора node, а путь к нему задали не абсолютный (в разных системах node может лежать по совершенно разным путям), а с помощью специальной утилиты env.

Итак, пакет опубликован и теперь доступен для установки под именем small_talk_with_hexlet (если решите опубликовать аналогичный пакет, то вам надо будет придумать своё уникальное имя для него).

Теперь установим этот пакет в систему глобально.

Но сначала убедимся, что никаких символических ссылок в директории не существует.
*/
$ npm bin --global
$ ls -al /usr/bin | grep 'say'

/*
Здесь с помощью фильтра grep мы попытались найти файлы, содержащие в своём имени (как наши ссылки в секции bin) строчку "say". Но поиск не дал результатов, потому что таких файлов (до установки пакета) нет.

Далее глобально устанавливаем пакет в систему:
*/
$ npm -g install small_talk_with_hexlet

/*
Как видно из лога установки выше, создалось две символические ссылки с указанием на какие файлы приложения они ведут.

Теперь снова проверим с помощью grep директорию установки исполняемых файлов.
*/
$ ls -al /usr/bin/ | grep 'say'
$ ls -al /usr/bin/say*

/*
Как и ожидалось, в этом каталоге лежат символические ссылки (об этом свидетельствует первый символ l, определяющий тип файла в строке атрибутов файла lrwxrwxrwx), которые мы можем запускать из любой точки файловой системы:
*/
$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!
$ cd /media/
$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!


/*
Из примера видно, что мы можем успешно запускать одни и те же команды из разных директорий. Почему так происходит подробно обсуждалось выше.

# Что происходит при локальной установке
В подавляющем большинстве случаев для целей разработки пакеты устанавливаются не глобально, а локально. При такой установке они "привязываются" к конкретному проекту и размещаются внутри его каталога по пути ./node_modules/. При этом ссылки на исполняемые файлы устанавливаемых пакетов npm размещает в каталоге ./node_modules/.bin.

Ссылки на исполняемые файлы локально установленных пакетов "заточены" на использование их в скриптах (секция scripts конфигурационного файла package.json), для чего существует особенный синтаксис. Эту тему мы проходили в одном из предыдущих уроков, посвящённых скриптам.

Естественно, к символическим ссылкам можно также обратиться напрямую, указав нужный путь. Давайте рассмотрим это на примере, подключив к нашему разрабатываемому проекту small_talk_with_hexlet пакет babel-node https://babeljs.io/docs/en/babel-node:

~/projects/smallTalkWithHexlet$ npm install --save-dev @babel/node


Если в корневом каталоге проекта установить какой-либо пакет с флагом --save-dev (npm i some_package --save-dev) — то он автоматически добавится в зависимости проекта: в раздел devDependencies файла package.json. Этой возможностью мы и воспользовались.

Как и ожидалось, появился каталог ./node_modules/, в котором лежит код подключенного пакета, а также других пакетов, от которых он, в свою очередь, зависит.

Узнать место, где npm складывает ссылки на исполняемые файлы локально подключаемых пакетов, позволяет команда npm bin (обратите внимание, что здесь нет параметра --global или -g). В нашем случае это каталог ./node_modules/.bin, заглянем в него:
*/
$ npm bin
$ ls -al node_modules/.bin/


// Давайте запустим babel-node (REPL-утилита, позволяющая "на лету" комплировать и исполнять новый ES6 код):
$ ./node_modules/.bin/babel-node
> ['hi', undefined, 'bye'].fill('Hexlet', 1, 2)
['hi', undefined, 'bye']
> .exit

$ babel-node
bash: babel-node: command not found

/*
Программа отработала корректно — мы успешно сделали вычисление в REPL-режиме babel-node.

Затем была попытка запустить исполняемый файл из командной строки только по имени, но она привела к неудаче — bash: babel-node: command not found — командная оболочка просто не нашла его (в отличие от того, как это было бы при глобальной установке).

# Установка пакета без публикации
В npm существует удобная команда для работы — npm link. Она позволяет поставить свой пакет в систему без публикации в NPM. Так вы можете убедиться в том что всё работает без полного цикла выкладки. Для удаления такого пакета воспользуйтесь командой npm unlink.


# Заключение
В этом уроке мы рассмотрели как общие принципы, так и отдельные нюансы работы Npm с исполняемыми файлами проекта. Важно отметить, что эти принципы характерны для большинства других пакетных менеджеров из разных языков (например, composer в php). Поэтому, если в будущем вам придётся столкнуться с чем-то из них, то это не должно вызвать затруднений.
*/



############################### JS: Составные данные ############################### 


>>>>>> Точки <<<<<<

// # Интерфейс:
const x = 5;
const y = -7;

// Конструктор
const point = makePoint(x, y);

// Селекторы
getX(point);
getY(point);

toString(point); // (5, -7)

// # Манипуляции:
const symmetricalXPoint = point => makePoint(getX(point), -getY(point));

const point = makePoint(10, 10);
symmetricalXPoint(point); // (10, -10)

// # Манипуляции:
const point = makePoint(3, 4);
const point2 = makePoint(0, 0);

quadrant(point); // 1
distance(point, point2); // 5

/*
# Итог: 
Абстрактные данные: Точка. Характеризуется двуся значениями (координатами): x и y.

Конкретные данные: На текущий момент неизвестно как реализованы точки.

Интерфейс:
*/

// Конструктор:
makePoint(<x>, <y>);

// Селекторы:
getX(<point>);
getY(<point>);



/**@@
Реализуйте и экспортируйте следующие функции для работы с точками:

getQuadrant - функция, которая вычисляет квадрант, в котором находится точка. Ниже приведена схема, показывающая номера квадрантов на плоскости.

      +
      2 | 1
        |
+----------------+
        |
      3 | 4
        +
*/
const point = makePoint(1, 5);
getQuadrant(point); // 1
getQuadrant(makePoint(3, -3)); // 4

// Если точка не принадлежит ни одному квадранту (т.е., если она лежит хотя бы на одной из осей координат), то функция должна возвращать null:

const point = makePoint(0, 7);
getQuadrant(point); // null
getQuadrant(makePoint(2, 0)); // null


// getSymmetricalPoint - функция, возвращающая новую точку, симметричную относительно начала координат. Такая симметричность означает, что меняются знаки у x и y.

getSymmetricalPoint(makePoint(1, 5)); // makePoint(-1, -5)


// calculateDistance - функция, вычисляющая расстояние между точками по формуле: d = sqrt((x2−x1)^2+(y2−y1)^2)

calculateDistance(makePoint(-2, -3), makePoint(-4, 4)); // ≈ 7.28

// FILE: points.js
import { makePoint, getX, getY } from 'hexlet-points';

export const getQuadrant = point => {
  const x = getX(point);
  const y = getY(point);

  if (x > 0 && y > 0) {
    return 1;
  } else if (x < 0 && y > 0) {
    return 2;
  } else if (x < 0 && y < 0) {
    return 3;
  } else if (x > 0 && y < 0) {
    return 4;
  }

  return null;
}

export const getSymmetricalPoint = point => {
  return makePoint(-getX(point), -getY(point));
}

export const calculateDistance = (point1, point2) => {
  const dX = getX(point2) - getX(point1);
  const dY = getY(point2) - getY(point1);

  return Math.sqrt((dX ** 2) + (dY ** 2));
}



>>>>>> Пары <<<<<<

import { cons, car, cdr } from 'hexlet-pairs';

// Конструктор
const pairs = cons(8, 7);

car(pair); // 8
cdr(pair); // 7

const pair2 = cons(3, pair);

// # Представление точек:

import { cons, car, cdr } from 'hexlet-pairs';

const makePoint = (x, y) => cons(x, y);

const getX = point => car(point);
const getY = point => cdr(point);

const toString = point => toString(point);




############################### JS: DOM API ###############################   

/*
Большое количество языков либо созданы поверх js либо позволяют транслировать свой код в js. 
К таким языкам относятся: clojurescript, typescript, kotlin, java, elm.

#  JavaScript в браузере
<html>
  <body>
    <script>
      const greeting = 'hello, world!';
      alert(greeting);
    </script>
  </body>
</html>

alert, confirm и prompt - эти функции присутствуют только в браузерах и недоступны в серверных версиях js. Это первый пример, когда мы видим как браузер "расширяет" js, добавляя туда новые возможности. Но не возможности самого языка, язык-то как раз остается тем же, а возможности по взаимодействию со средой.
*/


>>>>> JavaScript в браузере <<<<<

/*
# Внешние скрипты

Инлайн скриптинг, как правило, используется для небольших кусков кода, или для вызова кода, загруженного из внешних скриптов. Загружаются внешние скрипты следующим образом:

<body>
<html>
  <head>
    <script src="/assets/application.js"></script>
  </head>
  <body>
  </body>
</html>

Довольно часто можно увидеть подобный вариант загрузки:

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/core.js"></script>

В примере выше, файл грузится с CDN (https://ru.wikipedia.org/wiki/Content_Delivery_Network), что может давать определенные преимущества в скорости загрузки.

# Скорость
В зависимости от того, в каком месте документа появляются теги script, вы можете наблюдать серьезные изменения как в скорости отрисовки сайта, так и в скорости загрузки.

# Server (Nodejs) vs Client (Browser)

В браузере отсутствует множество тех вещей, с которыми мы привыкли иметь дело работая в серверном окружении. Среди них:

# Стандартная библиотека
Про библиотеку (https://nodejs.org/api/modules.html) можно забыть. Из коробки никаких assert, events, net, http, url и всего остального. Для любой простейшей задачи придется подключать библиотеку из npm.

# Модули
До недавнего времени, модульной системы в браузерах не существовало. Сейчас она появляется, но пока только в экспериментальном варианте.

На текущий момент, любой загруженный код, работает в глобальной области видимости. Такое поведение привело к большому количеству обходных маневров используемых повсеместно для ручной изоляции кусков js друг от друга.

<html>
  <body>
    <script>
      const greeting = 'hello, world!';
    </script>
    <script>
      alert(greeting);
    </script>
  </body>
</html>

Самый распространенный способ изоляции называется Immediately-Invoked Function Expression. Его принцип действия крайне прост: весь код, который должен быть выполнен в браузере, заворачивается в анонимную функцию, которая сразу же вызывается:
*/

(function() {
 // some code…
})();


/*
Как вы позже увидите, современные системы сборки избавляют нас от необходимости делать такие манипуляции руками. Мы можем продолжать использовать привычный и полноценный javascript.

Версии и движки
Еще один существенный недостаток js в браузере в том, что реализация js в разных браузерах отличается и иногда весьма существенно. Более того, даже разные версии одного и того же браузера могут отличаться катастрофически. Причем, эту проблему решить невозможно, она является следствием самой природы фронтенда. У каждого пользователя будет стоять тот браузер, который ему нравится, той версии, до которой он не забыл обновиться.

Сборка
К счастью, современный мир фронтенда смог выкрутиться из этой ситуации. Мы по прежнему можем пользоваться всеми (почти) современными фишками js, включая систему модулей. Возможно это благодаря babel с одной стороны и сборщиками, подобными webpack, с другой. Ну и нельзя не упомянуть про полифиллы, которым будет посвящен отдельный урок.

Принцип работы этой связки заключается в том, что сборщик по определенным правилам собирает все наши ресурсы (css, fonts, images) и файлы с кодом, пропускает их через обработчики, например, babel и на выходе мы получаем файлы, готовые к использованию в браузере.


Безопасность
Во всех браузерах поддерживается механизм под названием cookies, который мы изучали в курсе по протоколу http. Этот механизм играет центральную роль в реализации такой вещи, как аутентификация. После того, как сайт вас опознал, он выставляет специальную сессионную куку и на основе нее определяет залогинены вы на сайте или нет.

Как вы, возможно, помните, js позволяет обращаться к вашим кукам. Это автоматически означает, что если злоумышленнику удастся разместить произвольный код на странице сайта, то он сможет прочитать вашу сессионную куку и передать ее в нужное место. Так легко и беззаботно уводятся сессии и пользователи внезапно оказываются без своего аккаунта. Ни антивирус, ни фаервол в такой ситуации ничем помочь не смогут.

Внедрение произвольного кода на сайт называется XSS (Cross-Site Scripting) и является популярным способом атаки, кроме него так же распространен CSRF (Cross-Site Request Forgery).
*/


>>>>> Глобальный объект Window <<<<<


/*
Если в консоли браузера выполнить команду console.log(this), то на экран будет выведен некий Window.

Window — это глобальный объект, то есть доступный из любого места всегда. Он не является частью js и предоставляется браузерами. Как правило, к нему обращаются по имени window, так как this из-за позднего связывания указывает на него не всегда.

Обратите внимание на то, что функция alert находится в объекте window. Другими словами, когда мы вызываем функцию alert, то в действительности происходит вызов window.alert. Более того, все глобальные объекты js тоже принадлежат window.
*/
window.console.log('hey');
window.Math.abs(5);

/*
# Объектная модель браузера
Это набор глобальных объектов, управляющих поведением браузера. Все они так же находятся внутри window. Разберем некоторые из них.

# Navigator
Предоставляет информацию о браузере, такую как версию, название, используемую локаль, доступные права, подключенные плагины.

# Location
Позволяет управлять адресной строкой. Например, вот так можно инициировать загрузку другой страницы:
*/

location.href = "https://hexlet.io";

/*
# History
С помощью этого объекта можно перемещаться по истории переходов, а так же формировать ее в тех ситуациях, когда не происходит реального переход по страницам. Это особенно актуально для SPA.

# Fetch
Современный метод для выполнения AJAX запросов. Именно с помощью fetch происходит общение с сервером и другими сайтами.
*/


>>>>> Что такое DOM? <<<<<

/*
С высоты птичьего полета процесс отображения страницы можно представить следующим образом:

1. Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью DNS)

  GET /courses HTTP/1.1
  HOST: ru.hexlet.io

2. Пришедший в ответ html парсится, и на его основе строится DOM дерево

3. Браузер рисует страницу, используя DOM дерево (упрощенно).

Чтобы понять, что такое DOM и, в частности, DOM дерево, рассмотрим следующий пример.
*/

const json = '{ "key": "value" }';
const obj = JSON.parse(json);

console.log(obj.key); // value

/*
Как мы помним, json — это текстовый формат, используемый для взаимодействия между разными программами, которые, возможно, написаны на совершенно разных языках. Одна программа сериализует данные в json, а другая десереализует их во внутренние структуры своего языка.

Думаю, достаточно очевидно, что программа, получившая какие-то данные в виде json, не сможет работать с ним, если он останется в текстовом представлении, ведь по сути это строчка текста.

Теперь, попробуем понять смысл DOM дерева:
*/

// Гипотетический пример, так как модуля HTML не существует в природе

const html = `
  <body>
    <p>hello, <b>world</b>!</p>
  </body>
`;

const document = HTML.parse(html);
console.log(document.firstChild.name); // html

/*
Грубо говоря, html можно сравнить с json. Другими словами, html — это текстовое представление DOM дерева, не зависящее от языка программирования. То, что оно является деревом, видно невооруженным взглядом, так как теги вкладываются в теги.

Каждый html-тег становится узлом этого дерева, а теги, вложенные в него, становятся дочерними узлами. Для представления текста создаются специальные текстовые узлы.

Важно то, что в DOM дерево попадают все элементы, представленные в html, включая пробелы и переводы строк.

С DOM tree разобрались, теперь попробуем разобраться с тем, что же, собственно, такое DOM.

Объектная модель документа (Document Object Model) - это не зависящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

На практике, во фронтенд разработке это сводится к тому, что браузер предоставляет специальный объект document, который содержит внутри себя DOM tree и который наполнен большим количеством методов (согласно спецификации DOM) для манипулирования этим деревом. Любые изменения, которые производятся с ним, сразу же отображаются браузером на странице.

Подавляющее число возможностей, связанных с DOM, описаны в спецификациях раз https://dom.spec.whatwg.org/ и два https://html.spec.whatwg.org/ и, по идее, должны работать одинаково во всех браузерах. К сожалению, это не так. DOM развивается, но браузеры двигаются медленнее. Кроме того, существует множество исторических решений, которые приводят к проблемам.

# Восстановление
Те, кто сталкивались с html в реальной жизни, прекрасно знают, что если подать на вход браузеру невалидный html с незакрытыми тегами, нарушенной вложенностью и другими проблемами, то мы не получим сообщений об ошибках. Браузер переварит этот html и что-то отобразит на экране. Возможно, вам не понравится то, что вы увидите, но, по крайней мере, оно будет работать.

Браузер действительно восстанавливает структуру и делает это по очень хитрым правилам. И это логично, иначе было бы невозможно произвести парсинг в принципе. Но есть и другая причина: даже если сам html будет валидным, браузер при создании DOM tree добавляет в него узлы (представленные тегами в html), которые вы, возможно, пропустили, но стандарт требует их наличия. Например, в таблицы добавляется tbody.


Именно DOM открывает практически безграничные возможности по изменению страниц. Все библиотеки (jquery и другие) и фреймворки (angular, react) внутри себя манипулируют DOM. Это та база, вокруг которой построено всё во фронтенд разработке.
*/


>>>>> DOM Дерево <<<<<

/*
Корневым элементом в DOM дереве считается элемент html. Доступ к нему можно получить так: document.documentElement.

Навигация по дереву достаточно интуитивная, поэтому можно смело экспериментировать в браузере:
*/

const html = document.documentElement;
// Read-only
html.childNodes; // [head, text, body]
html.firstChild; // <head>...</head>
html.lastChild; // <body>...</body>
html.childNodes[1]; // #text

// Из-за того, что body и head всегда присутствуют внутри документа, их вынесли на уровень объекта document для более простого доступа:

document.head;
document.body;

// Кроме того, что можно идти вглубь дерева, так же можно идти и наружу:

document.documentElement === document.body.parentNode;
document.body === document.body.childNodes[2].parentNode;

/*
# childNodes

В работе с childNodes есть несколько интересных моментов.

1. Это свойство доступно только для чтения. Попытка что то записать в конкретный элемент не приведет к успеху:
*/

document.body.childNodes[0] = 'hey';

/*
Изменение DOM дерева осуществляется специальным набором методов.

Хотя childNodes и является коллекцией, это все же не массив. В нем отсутствует привычные методы, такие как map, filter и другие. Для перебора элементов можно воспользоваться итератором или сделать так:
*/

const elements = document.documentElement.childNodes;

elements.toString()
"[object NodeList]"

[...elements]; // теперь это массив

// либо так
elements.forEach(el => console.log(el));

/*
# Иерархия

Хотя каждый узел дерева и представлен типом Node, но в реальности это базовый тип. А каждый конкретный элемент имеет свой. Другими словами, у нас есть определенная иерархия типов.

Ноды с типами Text и Comment являются листовыми, то есть они не могут иметь детей. А вот элементы — это то, с чем приходится иметь дело чаще всего. Как видите, в DOM HTMLElement — это отдельное направление, потому что DOM также может представлять и xml документы.

На практике чаще всего нас интересуют не ноды, а элементы. Именно ими мы манипулируем, перемещаемся сквозь них. Это настолько важно, что в DOM есть альтернативный способ обхода дерева, который построен только на элементах

# Специальная навигация

Некоторые элементы обладают специальными свойствами для навигации по ним, к таким элементам относятся, например, формы и таблицы.

<table>
  <tr>
    <td>1.1</td>
    <td>1.2</td>
    <td>1.3</td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>2.2</td>
    <td>2.3</td>
  </tr>
</table>

*/

const table = document.body.firstElementChild
table.rows[0].cells[2];

// Этот способ навигации не заменяет основные. Он сделан исключительно для удобства в тех местах где это имеет смысл.