/**####### JS #######*/


// <<<<< Введение >>>>>
/**
 # Стиль
 Как и при работе с естественными языками, код нужно оформлять определенным образом для того, чтобы он был более понятным и простым в поддержке. Конкретно в js самым распространенным стандартом является https://github.com/airbnb/javascript. Он был написан программистами компании airbnb и теперь используется повсеместно. Периодически просматривайте его и улучшайте свой код. Следование стандартам не только входит в практики экстремального программирования, но и является неотъемлемой частью при работе в команде.

 В любом языке программирования существуют специальные инструменты, так называемые линтеры, задачей которых является проверка кода на соответствие стандартам. В js это eslint http://eslint.org/.

 repl.it
 */



// <<<<< Cтроки >>>>>

const longString = "This is a very long \
string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

// # Интерполяция
const a = 5;
const b = 10;

console.log(`Fifteen is ${a + b} and not $(2 * a + b).`);

// # Сравнение строк:
// Лексикографический порядок
'a' < 'b'; // true
'a ' > 'a'; // true

'7' > '3'; // true
'5' > '10'; // true

/**
 В javascript строки являются неизменяемыми, так же говорят immutable. Это означает, что какие бы вы к ним не применяли функции, они не производят in-place замены (то есть не производят изменения самой строки). Любые строковые функции, примененные к строкам, возвращают новую строку. Это верно и в том случае, когда мы обращаемся к конкретному символу в строке.
 */


/***@@@
 Функции lessThan, greaterThan и isEqual в модуле comparers сравнивают две строки и возвращают true/false.

 Сравнение идет по количеству заглавных символов в строке (больше заглавных — больше строка).

 Специальные символы (например, пробел) не имеют заглавных эквивалентов и в данном задании считаются заглавными.

 Примеры:
 */
greaterThan('AD', 'ad sd'); // true, сравнение на > (больше)
greaterThan('AD', '   Ad sd'); // false, сравнение на > (больше)
lessThan('ghe df', 'dfwe r D'); // true, сравнение на < (меньше)
isEqual('liSp', 'lisP'); // true


/**
 comparers.js
 Допишите необходимые части функций bigLettersCount и compare для того, чтобы заработали функции lessThan, greaterThan и isEqual.

 Функция compare, принимающая две строки first и second, работает по следующему алгоритму:

 Если в первой строке больше заглавных символов, то возвращается 1.
 Если во второй строке больше заглавных символов, то возвращается -1.
 Иначе возвращается 0.
 Подсказки
 Функция bigLettersCount должна принимать на вход строку str и высчитывать количество заглавных символов в ней.
 Вычисление длины строки: length(str).
 Перевод строки в верхний регистр: toUpperCase(str).
 Проверка на то, что символ в верхнем регистре: toUpperCase(char) === char;
 */

// FILE: /app/
import { length, toUpperCase } from './strings';

const bigLettersCount = (str) => {
    let result = 0;

    for (let i = 0; i < length(str); i += 1) {
        if (toUpperCase(str[i]) === str[i]) {
            result += 1;
        }
    }

    return result;
};


const compare = (first, second) => {
    const firstCount = bigLettersCount(first);
    const secondCount = bigLettersCount(second);

    if (firstCount > secondCount) {
        return 1;
    } else if (firstCount < secondCount) {
        return -1;
    }

    return 0;
};

export const greaterThan = (first, second) => (
    compare(first, second) === 1);

export const lessThan = (first, second) => (
    compare(first, second) === -1);

export const isEqual = (first, second) => (
    compare(first, second) === 0);



/***@@@
 solution.js
 Реализуйте и экспортируйте по умолчанию функцию, которая делает заглавной первую букву каждого слова в предложении.
 */
solution('hello, world!'); // Hello, World!

// FILE: /app/solution.js:

import { length, toUpperCase } from './strings';

export default (str) => {
    let result = '';
    for (let i = 0; i < length(str); i += 1) {
        const shouldBeBig = (i === 0 || str[i - 1] === ' ');
        result += shouldBeBig ? toUpperCase(str[i]) : str[i];
    }

    return result;
};



/***@@@
 addDigits.js
 Реализуйте и экспортируйте по умолчанию функцию addDigits, которая работает следующим образом:

 Дано неотрицательное целое число num. Складывать все входящие в него цифры до тех пор, пока не останется одна цифра.

 Для числа 38 процесс будет выглядеть так:

 3 + 8 = 11
 1 + 1 = 2
 Результат: 2

 Пример:
 */
ddDigits(10); // 1
addDigits(19); // 1
addDigits(38); // 2
addDigits(1259); // 8


// FILE: /app/addDigits.js:
import { length } from './strings';

const sum = (str) => {
    let result = 0;

    for (let i = 0; i < length(str); i += 1) {
        result += Number(str[i]);
    }

    return result;
};

const addDigits = (num) => {
    let result = num;

    while (result >= 10) {
        result = sum(String(result));
    }

    return result;
};

export default addDigits;



// <<<<< Типы данных >>>>>

// # Примитивные типы:
typeof 10; // number
typeof 10.12; // number
typeof NaN; // number

typeof 'name'; // string
typeof true; // boolean

typeof undefined; // undefined

// В динамической типизации ошибки типизации отслеживаются в момент выполнения программы (в рантайме)
i = 0;

// В статической типизации код проходит проверку до выполнения:
int i = 0;

// <<<<< null >>>>>

null; // значение отсуствует
undefined; // значение не определено


// <<<<< Числа >>>>>

0.3 - 0.2; // 0.09999999999999998

/**
 В ограниченную память вместить неограниченное количество чисел.

 # IEEE754
 Стандарт, описывающий формат представления чисел с плавающей точкой.
 > Формат
 > Специальные значения (Бесконечность, Нечисла, нули)
 > Операции
 > Исключительные ситуации (Деление на нуль,...)
 */

// # Infinity
1 / 0; // Infinity
-1 / 0; // -Infinity


// # NaN - Not a Number
0 / 0;
3 % 0;
0 * Infinity;
-Infinity + Infinity;
3 / 'qwerty';
// NaN != NaN

// # +0 -0
1/(1/Infinity); // Infinity
1/(1/-Infinity); // -Infinity

// # Нормализованная форма (экспоненциальная фsорма):
1.23e5; // 1.23 - мантисса, 5 - степень (1.23e+5) => 123000
123000; // 1.23 * 10^5

1.23e-5;
0.0000123; // 123 * 10^-5

// # Округления
Math.round(20.49); // 20
Math.round(20.5); // 21

Math.ceil(7.004); // в большую 8
Math.floor(45.95); // в меньшую 45



// <<<<< Функции >>>>>
/**
 # Выражения
 Единица кода, которая вычисляется в значение

 # Формальные и Фактические параметры функции
 Немного терминологии. Формальными параметрами функции называются имена переменных в определении функции, например у функции const f = (a, b) => a - b; формальные параметры это a и b. А фактически параметры — это то, что было передано в функцию в момент вызова, например если предыдущую функцию вызвать так f(5, z), где const z = 8, то фактическими параметрами являются 5 и z. Результатом этого вызова будет число -3, а внутри функции, на момент конкретного вызова, параметр a становится равным 5 и b становится равным 8.
 */
const f = x => x * x;

const y = 5;
console.log(f(y)); // 25
const z = 3;
console.log(f(z)); // 9

/***@@@
 squares.js:
 Реализуйте функцию square, которая возвращает квадрат числа.
 Реализуйте функцию sumOfSquares, которая возвращает сумму квадратов двух чисел.
 Реализуйте функцию squareSumOfSquares, которая возвращает квадрат суммы квадратов двух чисел.
 */
square(5); // 25
square(10); // 100
sumOfSquares(5, 10); // 125
sumOfSquares(10, -9); // 181
squareSumOfSquares(1, 1); // 4
squareSumOfSquares(2, 3); // 169

// FILE: /app/squares.js:
const square = num => num * num;

const sumOfSquares = (num1, num2) =>
    square(num1) + square(num2);

const squareSumOfSquares = (num1, num2) =>
    square(sumOfSquares(num1, num2));

export default {
    square,
    sumOfSquares,
    squareSumOfSquares,
};


// <<<<< Модули >>>>>

/**
 # Что такое модуль и зачем он нужен

 Модули в JavaScript (ES6) реализованы на основе файлов, и находятся они с файлами в отношении "один-к-одному". Попросту говоря, какой-либо конкретный файл, содержащий js-код, можно смело считать отдельным модулем. При этом, как следует из вышенаписанного, один файл представляет лишь один модуль, в нём не может быть (по крайней мере, на текущий момент) организовано размещение одновременно нескольких модулей.

 Любой ваш проект (программа, задача, приложение) - это код. И этого кода может быть очень много. Но даже в небольших по объёму проектах без должной структуризации кода весьма легко запутаться в используемых константах и переменных (далее - переменные), функциях и классах и допустить ошибки. Так вот, базовым и наиболее естественным средством структуризации вашего кода служит его разбиение на отдельные модули. И это помогает решить ряд задач и проблем:

 - С использованием модулей ваш код становится легче писать, сопровождать и читать - в общем, его качество растёт по "всем фронтам". Конечно, для этого надо грамотно классифицировать код и осуществить его разбиение по модулям, но это тема, даже не статей, а целых книг. Тем не менее, даже построение на самом базовом уровне системы модулей, каждый из которых несёт чётко определённую функциональность (имеет свою зону ответственности) даёт по сравнению с неструктурированным кодом все те профиты, о которых писалось выше. Обратите внимание, как устроена каждая практика в наших курсах: в каждом упражнении есть модуль (один или несколько), в котором нужно написать программу (функцию); отдельный модуль выделен для тестирования вашего кода; возможны дополнительные модули, в которых содержатся вспомогательные функции.

 - Разрешаются конфликты имён. А они неизбежно возникают, когда в коде используются от нескольких десятков до нескольких сотен (и более!) идентификаторов и все они находятся в одной общей области видимости. Теперь же, разделив код на модули, в каждом из которых свои собственные области видимости, никак не пересекающиеся между собой, Вам не надо "держать и перебирать" в голове весь остальной код, не относящийся к модулю, с которым вы в настоящий момент работаете - очевидно, задача разрешения (предотвращения) конфликта имён кардинально упрощается.

 - Меньше ошибок, выше надёжность. С помощью модулей осуществляется инкапсуляция кода. Модуль изолирует одну часть вашего проекта от других, одновременно предоставляя возможность контролируемого доступа к отдельным своим компонентам - "всему остальному миру" (другим модулям) будут видны только те переменные, функции и классы, которые вы сами посчитаете нужным экспортировать (инструкции export и/или default export). Таким образом снижается вероятность непреднамеренного или злонамеренного изменения кода одной части программы из другой части, повышается уровень безопасности.

 Далее будут подробно рассмотрены синтаксис модулей, способы и примеры экспортирования и импортирования.

 # Анализ кода
 Почти все последующие уроки этого курса, а также все остальные курсы на Хекслете активно используют модули. Такой подход максимально приближает нас к реальной жизни, когда проекты состоят из сотен, а то и тысяч файлов и библиотек, которые активно пользуются друг другом.

 При работе с модулями будет полезным сразу наработать некоторые модели поведения, позволяющие вам с легкостью определять, какой код вам доступен на исполнение, откуда пришел этот код и как его увидеть. Фидбек, который мы получаем от наших пользователей, говорит о том, что, как раз, в этом моменте больше всего затыков.

 Ниже описан основной алгоритм, по которому нужно анализировать файл с кодом, над которым вы сейчас работаете. Этот алгоритм не является специфичным для работы в среде Хекслета, так нужно делать в принципе:

 1. Внимательно изучите все импорты, описанные в начале файла. Так вы узнаете, какие модули и функции доступны внутри вашего файла (не считая глобальных функций и модулей, которые доступны и без импорта, например, Math).
 2. Попробуйте классифицировать импортируемые функции. Если импорт выглядит так from './..., то есть содержит ./, значит импортируется модуль, содержимое которого находится в текущей файловой системе. Это автоматически означает несколько вещей. Первое, вы всегда можете открыть этот файл и посмотреть, что там написано, второе, вы не сможете импортировать этот модуль в другой среде, что очевидно, ведь этого файла там нет.
 3. Если from 'name' содержит только имя, без лидирующего ./, это означает, что модуль подгружается либо из стандартной библиотеки nodejs, либо из установленных пакетов. Визуально невозможно отличить одно от другого. В данном случае необходимо проявить смекалку и попробовать загуглить имя таким способом nodejs name. Если в выдаче будет ссылка на официальную документацию, то значит это модуль ноды, если на репозиторий npm, значит это обычный пакет, который почти наверняка лежит на гитхабе, что можно проверить таким запросом github js name, где name это имя пакета.

 # Дополнительные возможности

 # Варианты импорта
 Если из модуля экспортировано множество функций, то, как мы уже знаем, импортировать их можно с помощью такой строчки:
 */
import * as name from './name';
// name.someFunction();

// Иногда бывает удобнее импортировать функции в текущий модуль напрямую, без необходимости указывать исходный модуль, и достичь этого можно таким образом:
import { someFunction, anotherFunction } from './name';
// someFunction();

/**
 Часто встречаются ситуации, в которых нужно импортировать функции из нескольких разных модулей, но имена этих функций совпадают. Как мы помним из теории, это одна из ключевых целей модулей, предотвратить коллизии имен. Так вот, пока функции живут внутри своих модулей, эта коллизия разруливается автоматически, но при необходимости использовать эти функции в третьем модуле, нужен дополнительный механизм. Выражается он в том, что при импорте мы можем локально переименовать любую функцию, другими словами ей можно задать алиас.
 */
import { request as r, get } from 'http'

r();


/**
 # Варианты экспорта
 По умолчанию также можно экспортировать любую константу, что открывает такую возможность:
 */
const func = () => {}

export default func;

/**
 Такая возможность нужна, например, если у нас функция используется внутри модуля, в том числе если она рекурсивная. При этом снаружи это имя никак не используется, любой экспорт по умолчанию импортируется под любым именем.

 Синтаксис экспорта по умолчанию таков, что после обязательных ключевых слов export default можно указать выражение, будь то переменная:
 */
const favColour = 'red';

export default favColour;

// или анонимная функция:

export default () => 'Hello, world!';
/**
 вариант для функции типа 'Function Expression'
 export default function() {
  return 'Hello, world!';
}
 */

// или даже просто литерал, например:
export default 'Hello, world!';

// В отличие от именованного экспорта здесь после ключевых слов недопустимо указывать объявления переменных (с использованием const, let, var) и возможен только один дефолтный экспорт на модуль.


// Пример Module:cube:
// FILE: index.js:
import cube from './cube';

cube(4); // 64

// FILE: cube.js:
export default num => num * num * num;


/**
 # Экспорт и импорт в действии
 donor.js - файл, в котором размещены экспортные функции. acceptor.js - файл, в котором происходит импорт функций.

 Давайте наполним donor.js экспортными константами и функциями. Для полноты картины к именованному экспорту мы добавили ещё и экспорт по умолчанию (это допустимо, хотя и не принято так делать, по смыслу экспорта по умолчанию он должен быть единственным экспортом на модуль):
 */
// donor.js
export const getFirstWeekday = () => 'Monday';
export const getSecondWeekday = () => 'Tuesday';
/** экспортируем функцию типа 'Function Declaration' */
export function getThirdWeekday () {
    return 'Wednesday';
}
export const fourthWeekday = 'Thursday';
const getFifthWeekday = () => 'Friday';
export default getFifthWeekday // export default () => 'Friday'
/** две функции ниже не будут экспортированы */
const firstWeekendDay = 'Saturday';
const getLastWeekendDay = () => 'Sunday';

/**
 аналогичный альтернативный вариант экспорта заключается в том, что не надо помечать функции и
 переменныe ключевым словом 'export' ('default export'), вместо этого достаточно написать
 следующее выражение (сформировать объект для экспорта):
 export { getFirstWeekday, getSecondWeekday, getThirdWeekday, fourthWeekday, getFifthWeekday as default };


 Теперь рассмотрим несколько вариантов, как можно импортировать эти переменные и функции (далее для краткости - функции) в модуль acceptor.js:

 ---> Импортируем все функции из donor.js в виде объекта, которому необходимо дать произвольный (соответствующий общим правилам именования переменных) псевдоним. Обращаемся к импортированным функциям как к свойствам этого объекта:
 */
// acceptor.js
import * as someName from './donor'; // имя модуля можно указывать без расширения

// посмотрим, что из себя представляет импортированный объект someName
console.log(someName);
/**
 { getThirdWeekday: [Function: getThirdWeekday],
  getFirstWeekday: [Function: getFirstWeekday],
  getSecondWeekday: [Function: getSecondWeekday],
  fourthWeekday: 'Thursday',
  default: [Function: getFifthWeekday]
}
 */
someName.getFirstWeekday(); // 'Monday'
someName.getThirdWeekday(); // 'Wednesday'
someName.fourthWeekday; // 'Thursday'
someName.default(); // доступ (при данном виде импорта) к значению по умолчанию: 'Friday'
someName.firstWeekendDay; // undefined, такого свойства не существует, потому что переменная не была экспортирована

/**
 ---> Сделаем выборочный импорт функций из donor.js. Для этого перечислим в фигурных скобках имена интересующих нас функций. Обращаемся к импортированным функциям по этим именам. При этом им можно давать псевдонимы, далее в текущем модуле доступ к таким функциям будет происходить только по псевдониму (это может пригодится в том случае, если в модуле уже существует функция с таким именем, для разрешения конфликта имён):
 */
// acceptor.js
import { getFirstWeekday, getThirdWeekday, fourthWeekday as fourthDay } from './donor';

// константа с именем 'fourthWeekday' уже существует в модуле
const fourthWeekday = 'This is Thursday';

getFirstWeekday(); // 'Monday'
getThirdWeekday(); // 'Wednesday'
fourthDay; // 'Thursday'
fourthWeekday; // 'This is Thursday'

/**
 ---> Импортируем из модуля donor.js значение по умолчанию. Для этого достаточно просто указать после ключевого слова import произвольное (наиболее подходящее и удобное) имя. В таком случае по этому имени можно будет обращаться к значению по умолчанию из импортируемого модуля:
 */
// acceptor.js
import nameOfDefault from './donor';

// как вы помните, значением по умолчанию модуля donor.js является функция, возвращающая строку 'Friday'
nameOfDefault(); // 'Friday'

// Также есть возможность импортировать одновременно и значение по умолчанию и другие экспортированные компоненты. Это можно сделать несколькими способами, приведём примеры:

// acceptor.js
// важно: имя значения по умолчанию стоит первым и не заключено в фигурные скобки
import nameOfDefault, { getFirstWeekday, getSecondWeekday } from './donor';

// как вы помните, значением по умолчанию модуля donor.js является функция, возвращающая строку 'Friday'
nameOfDefault(); // 'Friday'
getFirstWeekday(); // 'Monday'
getSecondWeekday(); // 'Tuesday'

// тот же самый результат можно получить ещё одним альтернативным способом:
// acceptor.js
import { default as nameOfDefault, getFirstWeekday, getSecondWeekday } from './donor';

// как вы помните, значением по умолчанию модуля donor.js является функция, возвращающая строку 'Friday'
nameOfDefault(); // 'Friday'
getFirstWeekday(); // 'Monday'
getSecondWeekday(); // 'Tuesday'



// <<<<< Итеративный и рекурсивный процесс >>>>>

const factorial = n => {
    const iter = (current, acc) =>
        current === 0 ? acc : iter(current - 1, acc * current);

    return iter(n, 1);
};

/***@@@
 sequenceSum.js
 Реализуйте (с использованием рекурсивного процесса) функцию sequenceSum, которая находит сумму последовательности целых чисел. Последовательность задается двумя значениями: begin - начало последовательности, end - конец последовательности. Например: begin = 2 и end = 6 дают нам такую последовательность 2, 3, 4, 5, 6. Сумма такой последовательности будет: 20.

 Подсказки
 Последовательность, в которой begin > end, не содержит ни одного числа, т.е. является "пустой". Вычислить сумму чисел такой последовательности не представляется возможным, в этом случае возвращаем NaN
 Сумма чисел последовательности, в которой begin === end, равна begin (или end)
 */

const sequenceSum = (begin, end) => {
    if (begin > end) {
        return NaN;
    }

    if (begin === end) {
        return begin;
    }

    return begin + sequenceSum(begin + 1, end);
};

export default sequenceSum;




/***@@@
 smallestDivisor.js
 Реализуйте и экспортируйте по умолчанию функцию smallestDivisor, используя итеративный процесс. Функция должна находить минимальный делитель переданного числа.

 Для этого достаточно последовательно проверять делимость, начиная с двойки. Если делитель не найден, значит число простое и делителем является само число.

 Доп. условия: число, передаваемое в функцию, больше нуля (т.е. соответсвующую проверку делать не надо); делитель должен быть больше единицы, за исключением случая, когда аргументом является единица (наименьшим делителем которой является также единица).
 */

smallestDivisor(15); // 3
smallestDivisor(17); // 17



const smallestDivisor = (num) => {
    const iter = (acc) => {
        if (acc > num / 2) {
            return num;
        }

        if (num % acc === 0) {
            return acc;
        }

        return iter(acc + 1);
    };

    return iter(2);
};

export default smallestDivisor;



/***@@@
 Наибольшим общим делителем (НОД) для двух целых чисел m и n называется наибольший из их общих делителей. Пример: для чисел 70 и 105 наибольший общий делитель равен 35. Наибольший общий делитель существует и однозначно определён, если хотя бы одно из чисел m или n не равно нулю.

 gcd.js
 Экспортируйте функцию по умолчанию, которая находит наибольший общий делитель двух целых положительных чисел.
 */

const gcd = (a, b) => {
    if (b === 0) {
        return a;
    }

    return gcd(b, a % b);
};

export default gcd;



/***@@@
 sum.js
 Реализуйте и экспортируйте функцию по умолчанию, которая считает сумму всех натуральных чисел, меньших чем n (первый аргумент), которые делятся на числа a или b (второй и третий аргументы) без остатка. n - может быть только натуральным числом.
 */

// 1 % 2 || 1 % 4
// 2 % 2 || 2 % 4
// ...
// 9 % 2 || 9 % 4
sum(10, 2, 4); // 20

// FILE: /app/sum.js:
export default (num, divisor1, divisor2) => {
    let sum = 0;

    for (let i = 1; i < num; i += 1) {
        if (i % divisor1 === 0 || i % divisor2 === 0) {
            sum += i;
        }
    }

    return sum;
};




// ############################### JS: Функции ###############################

// <<<<< Guard Expression >>>>>

/**
 Одни функции устроены сложнее других. Иногда так происходит в силу объективных причин (необходимая сложность). Иногда — в силу особенностей писавшего её программиста (случайная сложность). И хотя нельзя однозначно описать эту сложность, существуют способы, позволяющие хотя бы частично её оценить.

 # Цикломатическая сложность
 Цикломатическая сложность — это структурная, или топологическая, мера сложности компьютерной программы, разработанная Томасом Дж. Маккейбом в 1976 году.

 Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только один маршрут через код.

 Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один, если условие оператора if имеет значение true, и один — если false.

 Такую оценку можно применять как в целом к программе, так и к отдельным функциям.
 */

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);
abs(10); // => 10
abs(-3); // => 3

/**
 В примере выше у функции sum цикломатическая сложность равна единице, а у функции abs — двойке, так как она содержит ветвление, а значит два независимых пути выполнения.

 Чем больше возможных путей выполнения, тем сложнее функцию понять, отладить и модифицировать. Очевидно, что, с одной стороны, функции нужно дробить, а с другой — описывать логику программы так, чтобы не появлялись лишние пути. Даже опытные разработчики часто сталкиваются с этой проблемой.

 Линтеры многих языков измеряют показатель сложности и сигнализируют, если он, скажем, больше 5 для одной функции.

 # Guard Expression
 Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:
 */

const f = (age, sex) => {
    if (age >= 18) {
        if (sex === 'male') {
            return 'yes';
        } else if (sex === 'female') {
            return 'no';
        }
    }

    return null;
}

/**
 Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.
 */

const f = (age, sex) => {
    if (age < 18) {
        return null;
    }

    if (sex === 'male') {
        return 'yes';
    } else if (sex === 'female') {
        return 'no';
    }
}

/**
 Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.




 /***@@@
 Реализуйте и экспортируйте по умолчанию функцию isPalindrome с использованием рекурсии.

 Примеры использования:
 */

import isPalindrome from './isPalindrome';

isPalindrome('radar'); // => true
isPalindrome('a');     // => true
isPalindrome('abs');   // => false


// file: App/isPalindrome.js:
const isPalindrome = (string) => {
    if (string.length <= 1) {
        return true;
    }

    const firstSymbol = string[0];
    const lastSymbol = string[string.length - 1];

    if (firstSymbol !== lastSymbol) {
        return false;
    }

    const stringWithoutFirstAndLastSymbols = string.substr(1, string.length - 2);

    return isPalindrome(stringWithoutFirstAndLastSymbols);
};

export default isPalindrome;

// ## TESTS:
// file: __tests__/isPalindrome.test.js:
import isPalindrome from '../isPalindrome';

test('isPalindrome', () => {
    expect(isPalindrome('a')).toBe(true);
    expect(isPalindrome('aa')).toBe(true);
    expect(isPalindrome('404')).toBe(true);
    expect(isPalindrome('abba')).toBe(true);
    expect(isPalindrome('radar')).toBe(true);
    expect(isPalindrome('absba')).toBe(true);
    expect(isPalindrome('aibohphobia')).toBe(true);

    expect(isPalindrome('abaoba')).toBe(false);
    expect(isPalindrome('aashgkhdj')).toBe(false);
    expect(isPalindrome('palindrome')).toBe(false);
    expect(isPalindrome('aibohapohobia')).toBe(false);
});





// <<<<< Параметры по умолчанию >>>>>

// Опишем функцию greeting, которая печатает на экран приветствие:
const greeting = name => console.log(`Hi, ${name}!`);

greeting('John'); // => Hi, John!


// Но что произойдёт, если при вызове функции передать ей меньшее число аргументов, чем у неё установлено параметров? Давайте посмотрим:
greeting(); // => Hi, undefined!

// Правило здесь простое: параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined. Проиллюстрируем это подробнее на примере функции, которая принимает на вход три параметра и распечатывает их значения:

const foo = (a, b, c) => {
    const output = `a - ${a}; b - ${b}, c - ${c}`;
    console.log(output);
}

foo('I', 'am', 'here'); // => a - I; b - am, c - here

foo('I', 'am'); // => a - I; b - am, c - undefined

foo('I'); // => a - I; b - undefined, c - undefined

foo(); // => a - undefined; b - undefined, c - undefined

/**
 Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.

 Допустим, мы хотим, чтобы при вызове функции greeting без параметров, она выводила сообщение Hi, anonymous!.

 Тогда мы можем реализовать её следующим образом:
 */

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

// Однако, JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:
const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);
greeting(); // => Hi, anonymous!


const pow = (base, exp = 2) => base ** exp;

pow(5); // => 25
pow(5, 2); // => 25
pow(5, 1); // => 5

// Кроме того, в значениях по умолчанию можно использовать идентификаторы:
const f = (x = Math.PI) => {}

// И даже вызовы функций:
const f = (x, y = Math.sqrt(x)) => {}


const getSum = (a = 10, b = 2 * a, c = 3 * b) => a + b + c;
const result = getSum(); // <-> 10 + 20 + 60 => 90
const result = getSum(2); // <-> 2 + 4 + 12 => 18
const result = getSum(2, 3); // <-> 2 + 3 + 9 => 14
const result = getSum(2, 3, 4); // <-> 2 + 3 + 4 => 9


const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`); // интерполяция - работает только со строками в бэктиках.

/**
 Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования.

 Примечание
 В этом уроке мы рассмотрели случай, когда в функцию передаётся меньше параметров, чем она ожидает. У вас может возникнуть вопрос, что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?

 Ответ: ничего не произойдёт они будут просто проигнорированы.

 Дополнительные материалы
 Default function parameters https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters

 /***@@@
 Реализуйте и экспортируйте по умолчанию функцию substr, которая возвращает подстроку из переданной строки. Подстрокой называется любая выбранная часть строки. Например для строки hello можно выделить следующие подстроки: ello, llo, o, el и множество других.

 Функция принимает на вход три параметра:
 > Строка.
 > Начальный индекс. Значение по умолчанию: 0.
 > Длина подстроки. Значение по умолчанию: длина всей строки.
 */
substr('abba', 0, 1);    // => a
substr('abba', 1, 2);    // => bb
substr('abba', -10, 2);  // => ab
substr('abba', -1, 100); // => abba
substr('abba', -1, -1);  // => a
substr('abba', 1, -10);  // => b
substr('abba', 1, 10);   // => bba
substr('abba', 1, 0);    // => ''
substr('abba', 100, 3);  // => ''

// По умолчанию, то есть если не переданы дополнительные параметры, возвращается сама строка:
substr('');     // => ''
substr('abba'); // => abba

/**
 У этой функции множество вариантов поведения:
 Если переданная длина отрицательная, то внутри она становится единицей
 Если переданная длина равна нулю, то возвращается пустая строка
 Если конечный индекс (переданная длина + начальный индекс - 1) выходит за границу строки, то берется подстрока от начального индекса до конца строки.
 */
substr('abba', 1, 10);   // => bba

/**
 Конечный индекс 1 + 10. Он выходит за границу строки, так как длина строки 4 символа. Поэтому возвращается подстрока, от начального индекса 1 и до конца строки.

 Если начальный индекс отрицательный, то внутри он становится нулем
 Если начальный индекс выходит за границу слова справа, то всегда возвращается пустая строка

 Для реализации этой функции, используйте подход, который называется "нормализация". Он заключается в том, что перед тем как делать вычисления, данные приводятся к виду, с которым удобно работать. Например, длина строки для substr может иметь следующие неудобные значения:

 Отрицательное число
 Число, выходящее за границу строки
 Индекс + Длина выходят за границу строки
 В каждой из этих ситуаций длину строки можно изменить на такое значение, которое будет удобно для обработки сразу всех возможных случаев. Если число отрицательное, то длина становится равной единице (из условия), если оно выходит за границу строки, то его нужно сделать равным длине строки. В последнем случае длина должна стать числом Длина Строки - Индекс. После этих манипуляций процесс взятия подстроки становится универсальным и не содержащим условия.
 */

// file: app/substr.js
export default (str, index = 0, substrLength = str.length) => {
    if (index >= str.length) {
        return '';
    }

    const currentIndex = index < 0 ? 0 : index;

    let lastIndex = currentIndex + (substrLength - 1);

    if (lastIndex + 1 < currentIndex) {
        lastIndex = currentIndex;
    } else if (lastIndex > str.length - 1) {
        lastIndex = str.length - 1;
    }

    let result = '';

    for (let i = currentIndex; i <= lastIndex; i += 1) {
        result = `${result}${str[i]}`;
    }

    return result;
};


// ## TESTS:
// file: app/__tests__/substr.test.js:
import substr from '../substr';

test('substr', () => {
    expect(substr('')).toEqual('');
    expect(substr('abba', 4, -10)).toEqual('');
    expect(substr('abba')).toEqual('abba');
    expect(substr('abba', 1, 0)).toEqual('');
    expect(substr('abba', 0, 1)).toEqual('a');
    expect(substr('abba', 1, 2)).toEqual('bb');
    expect(substr('abba', -10, 2)).toEqual('ab');
    expect(substr('abba', -1, 100)).toEqual('abba');
    expect(substr('abba', -1, -1)).toEqual('a');
    expect(substr('abba', 1, -10)).toEqual('b');
    expect(substr('abba', 1, 10)).toEqual('bba');
});




// >>>>> Выполнение функций <<<<<

/**
 Вспомним несколько важных понятий из прошлого курса:

 Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

 Выражения — вычисляются.
 Инструкции — исполняются.

 К выражениям относятся:
 * Вызов функции
 * Арифметические и логические операции
 * Тернарный оператор
 * и другие

 К инструкциям относятся:
 * for
 * while
 * break
 * return
 * if
 * и другие

 Необходимо знать разницу между ними — это позволит лучше понимать, как могут взаимодействовать друг с другом различные конструкции языка.

 Возьмем условный оператор if. В некоторых языках он представлен инструкцией, в некоторых — выражением. Посмотрите на код ниже и подумайте, возможно ли такое в JavaScript и почему:
 */

const value = if (something) {
    one
} else {
    two
}

/**
 Такой код в JavaScript невозможен только по одной простой причине: if — это инструкция, а не выражение.

 Но такой код возможен и часто используется в языках вроде Ruby или Python. Зачем же нужен if, если есть тернарный оператор, который как раз и является выражением?

 Дело вот в чем. Если бы if был выражением, то тернарный оператор стал бы попросту не нужен, несмотря на то, что он является более лаконичной заменой if. Но и тернарный оператор бывает неудобен в тех ситуациях, когда вычисление слишком большое и не помещается в одну строку, а его результат должен быть записан в одну и ту же константу или переменную в каждой из веток. В такой ситуации как раз пригодился бы if как выражение.

 Этот пример ярко иллюстрирует тот факт, что конструкции языка, представленные выражением, делают язык гибче, а решения с их использованием делают код лаконичнее. Другими словами, язык становится выразительнее. Кроме описанного выше, у выражений есть еще одно огромное преимущество: они могут комбинироваться друг с другом и вкладываться друг в друга.

 Ниже я продемонстрирую варианты комбинирования выражений, но с акцентом на функции:

 # Арифметические операции
 */
const r1 = 5;
const r2 = 5 + 8;
const r3 = 5 + 8 - Math.PI;
const r4 = 5 + 8 - Math.PI * Math.sqrt(16);
const r5 = f1() + f2() * f3();

/**
 Вопросы могут возникнуть только в последней строчке. Насколько это допустимо? Вызов функции — это выражение, возвращающее результат, так что этот код допустим на 100%. Если функция вернет значение, неподходящее для сложения, то может возникнуть ошибка, но это будет логическая ошибка, а не синтаксическая.

 Примечание: предополагается, что используемые в примерах этого урока функции и константы (например, f2 или isEditing) ранее где-то были определены. Их определение мы убрали из примеров, чтобы не отвлекать от главного.

 # Логические операции

 Все то же самое можно делать и с логическими выражениями:
 */

const r1 = true;
const r2 = true || false;
const r3 = true || false && isEditing;
const r4 = true || false && isEditing || isEmpty(data);
const r5 = f1() || f2() && f3();

/**
 Из-за слабой типизации подобный код работать будет вообще всегда, даже если функции возвращают не true или false, но пользоваться этим не стоит.

 # Аргументы

 А теперь чуть более сложный пример. Когда мы вызываем функцию, то в аргументах ожидается выражение: func(<expression>, <expression>, ...). А из этого следует, что мы можем сделать так:
 */

const r1 = f();
const r2 = f(5);
const r3 = f(5 + Math.PI);
const r4 = f(5 + Math.PI - cube(number));
const r5 = f(f1(f2(n3, f3(n1, n2))), f4());

/**
 Пройдемся по примеру выше. f(f1(f2(n3, f3(n1, n2))), f4()) содержит в аргументах два выражения:

 1. f4()
 2. f1(f2(n3, f3(n1, n2)))
 этот вызов содержит один аргумент — вызов функции: f2(n3, f3(n1, n2)),
 который в свою очередь содержит два аргумента: n3 и вызов функции f3(n1, n2).


 #  Порядок выполнения

 Осталось понять, в какой последовательности происходят эти вызовы. JavaScript считается энергичным языком, то есть языком с аппликативным порядком вычисления, а это значит, что аргументы вычисляются до того, как попадают внутрь функций.
 */

const f1 = () => console.log('called f1');
const f2 = () => console.log('called f2');
const f3 = () => console.log('called f3');
const f4 = () => console.log('called f4');
const f5 = () => console.log('called f5');
const f6 = () => console.log('called f6');

f1( f2(f4(), f5()), f3(f6()) ); // =>

// called f4
// called f5
// called f2
// called f6
// called f3
// called f1

// Как видно, вычисление идет с самого глубокого уровня слева направо.



/***@@@
 Модуль tags содержит набор функций, позволяющих генерировать HTML с помощью функций.
 */

table(
    tr(td('one'), td('two')),
    tr(td('three'), td('four'))
);

/**
 В результате вызовов возвращается вот такой HTML:
 <table>
 <tr>
 <td>one</td>
 <td>two</td>
 </tr>
 <tr>
 <td>three</td>
 <td>four</td>
 </tr>
 </table>
 buildHtml.js
 Реализуйте и экспортируйте по умолчанию функцию buildHtml, простой вызов которой:
 */

buildHtml();

/**
 создаёт и возвращает следующий HTML:

 <table>
 <tr>
 <td>lang</td>
 <td>comment</td>
 </tr>
 <tr>
 <td>php</td>
 <td>statements</td>
 </tr>
 <tr>
 <td>clojure</td>
 <td>expressions</td>
 </tr>
 </table>

 // file: buildHtml.js
 **/
import { table, tr, td } from './tags';

export default () => table(
    tr(td('lang'), td('comment')),
    tr(td('php'), td('statements')),
    tr(td('clojure'), td('expressions')),
);

// ## TESTS:
// app/__tests__/buildHtml.test.js

import { html } from 'js-beautify';
import buildHtml from '../buildHtml';

test('htmlBuilder', () => {
    expect(html(buildHtml())).toMatchSnapshot();
});


// app/__tests__/__snapshots__/buildHtml.test.js.snap

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`htmlBuilder 1`] = `
"<table>
    <tr>
        <td>lang</td>
        <td>comment</td>
    </tr>
    <tr>
        <td>php</td>
        <td>statements</td>
    </tr>
    <tr>
        <td>clojure</td>
        <td>expressions</td>
    </tr>
</table>"
`;



// >>>>>  Объекты первого класса <<<<<

/**
 Продолжая тему предыдущего урока, познакомимся с понятием "first-class citizen" или "объекты первого класса".

 Объектами первого класса в контексте конкретного языка программирования называются элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идет обо всем, что может быть данными. Самые простые типы данных — это числа и строки. Как вы потом увидите, все остальные типы данных также являются объектами первого класса.

 А теперь посмотрите внимательно на этот код: const x = () => console.log('hey'). Ничего необычного, вы видели и писали подобное множество раз. Если вы считаете, что в этом коде создается функция x, на самом деле это не так. Здесь происходят следующие две операции:

 1. Создание функции: () => console.log('hey')
 2. Создание константы со значением в виде функции: const x =

 Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: () => {}. Это пустая функция с пустым телом, которая не делает ничего. Присваивать ее константе или нет — вопрос отдельный. Вполне допустимо написать и выполнить подобную программу: (a, b) => a + b;.

 Из примеров выше можно сделать вывод, что функция — тоже данные, ведь ее можно присвоить константе. Рассмотрим это утверждение на практике:
 */

const identity = v => v; // функция: v => v, константа: identity
console.log(identity(10)); // => 10

const z = identity;
console.log(z === identity); // => true

const x = 5;
console.log(z(x) === identity(x)); // => true

/**
 Главный вывод, который можно сделать из кода выше, заключается в том, что определение функции (не вызов!) — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать ее без создания промежуточной константы:
 */

// Определяем функцию v = v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

/**
 Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нем создается функция, принимающая на вход другую функцию v и вызывающая ее внутри с аргументом 'run'.

 Попробуем усложнить:
 */
identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

/**
 Первым идет пример вызова функции по идентификатору, а во втором примере я заменил идентификатор на определение функции, сделав подстановку. Результат получился тот же самый. Еще раз посмотрите на этот шаблон (<тут определение функции>)(). Попробуйте самостоятельно разобрать пример ниже:
 */

((a, b) => a + b)(3, 2); // => 5
// const sum = (a, b) => a + b;
// sum(3, 2); // => 5


// Теперь попробуем использовать функции как данные:
const sqrt = identity(Math.sqrt);
console.log(sqrt === Math.sqrt); // true
sqrt(4); // => 2

/**
 В первой строчке вызывается функция identity, в которую передается Math.sqrt. Рез��льтатом этого вызова будет все та же функция Math.sqrt.

 Здесь мы видим сразу два новых аспекта: передача функции как аргумента и возврат функции как значения. Функции, которые принимают на вход другие функции или возвращают другие функции, называются функциями высшего порядка. В функциональных языках большинство задач, связанных с обработкой данных, работают именно через них. JavaScript в этом смысле ведет себя точно также.

 В следующем примере внутрь функции передается другая функция, определяемая в аргументах. В комментариях показан альтернативный способ через создание константы с функцией.
 */

const sum = identity((a, b) => a + b);
sum(3, 5); // => 8

// const f = (a, b) => a + b;
// const sum = identity(f);
// sum(3, 5); // => 8

/**
 Подобная передача функций в функции с определением прямо в аргументах встречается повсеместно в реальном коде. Как правило, те функции, которые передаются в аргументах, нужны только здесь и сейчас.

 Возникает вопрос: есть ли имя у функций, определенных подобным образом? Имени нет даже у такой функции const f = () => {}. Мы просто связали константу с функцией, но сама функция ничего про константу не знает. Звучит слегка безумно, но это так. Ведь мы можем взять и связать эту функцию уже с другой константой. По этой причине такие функции часто называют анонимными. Другое распространенное название — лямбда-функция. Своим названием лямбда-функция обязана лямбда-исчислению (математическая формальная система, легшая в основу языков семейства lisp). Только в отличие от языков программирования, "лямбды" в лямбда-исчислении — всегда функции от одного аргумента, поэтому общее с функциями из js у них, в первую очередь, анонимность, и то, что они являются объектами первого класса.

 Попробуем сделать что-нибудь полезное. Иногда встречается задача, в рамках которой нужно применить одну и ту же функцию несколько раз, например, так: Math.sqrt(Math.sqrt(16)). Создав функцию высшего порядка, можно упростить эту задачу. Рассмотрим пример с двойным применением одноаргументной функции:
 */

const callTwice = (f, arg) => f(f(arg));

callTwice(Math.sqrt, 16); // => 2
callTwice(x => x ** 2, 3); // => 81
// const f = x => x ** 2;
// f(f(3));

// callTwice применяет переданную функцию к своему аргументу два раза. Если расписать подробнее, то происходит следующее:

const res1 = f(arg);
const res2 = f(res1);
return res2;

const result = ((a, b) => a ** b)(5, 2); // функции можно вызывать сразу после определения.

// Все функции в языке JavaScript являются объектами первого класса.



/***@@
 Реализуйте и экспортируйте по умолчанию функцию apply, которая принимает на вход три параметра:

 1. Количество раз, которое нужно применить функцию к аргументу (ряд последовательных вызовов, где каждому следующему вызову передается аргумент, являющийся результатом предыдущего вызова функции)
 2. Функцию для применения
 3. Аргумент для применения
 */

apply(0, Math.sqrt, 4); // => 4
apply(1, Math.sqrt, 4); // => 2

// Math.sqrt(Math.sqrt(16));
apply(2, Math.sqrt, 16); // => 2
// Math.sqrt(Math.sqrt(Math.sqrt(256)));
apply(3, Math.sqrt, 256); // => 2

apply(1, v => v ** 2, 3); // => 9
apply(5, v => v + 10, 3); // => 53

// file: app/apply.js
const apply = (count, fn, value) => count === 0 ? value : apply(count - 1, fn, fn(value));

export default apply;


// ## TEST
// file: app/__tests__/apply.js

import apply from '../apply';

test('apply', () => {
    expect(apply(0, Math.sqrt, 4)).toBe(4);
    expect(apply(1, Math.sqrt, 4)).toBe(2);
    expect(apply(2, Math.sqrt, 16)).toBe(2);

    expect(apply(1, v => v ** 2, 3)).toBe(9);
    expect(apply(5, v => v + 10, 3)).toBe(53);
});



// >>>>> Лексическое окружение (LexicalEnvironment) <<<<<

/**
 Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь LexicalEnvironment (лексическое окружение), привязанный к этому вызову. Все определения констант, переменных и прочего внутри функции автоматически записываются в словарь. Имя определения (идентификатор, то есть имя константы, переменной и так далее) становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и т.д. Лексическое окружение — это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.

 В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.
 */

const showWarning = (field) => {
    // LexicalEnvironment = { field: 'email' }
    const warning = `verify your ${field}, please`;
    // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
    console.log(warning);
};

showWarning('email'); // => verify your email, please

/**
 Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.

 В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.

 Из этого поведения есть исключение — возврат функции. В следующем уроке мы рассмотрим связанный с ним механизм так называемых «замыканий».

 Окружение есть не только у функций. Любой идентификатор, определенный на уровне модуля, попадает в лексическое окружение модуля. Кроме того, существует и глобальное окружение. Благодаря ему мы с легкостью используем в JS такие функции, как console.log или Math.sqrt, даже особо не задумываясь, откуда они берутся.
 */

const number = 5;
const square = () => number ** 2;
square(); // => 25

/**
 Такой код работает — и это для нас не секрет, но как он вяжется с механизмом окружений? А вот как: интерпретатор производит поиск значения идентификатора не только в локальном лексическом окружении (в том, где используется идентификатор), но и во внешнем окружении. Поиск начинается с локального окружения, и если в нём не найден нужный идентификатор, то просмотр идет дальше, вплоть до уровня модуля, а затем и до глобального уровня.

 Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена (а не вызвана!). Если разбить пример выше на два файла, то разница станет очевидной.

 Так сработает:
 */

// module1.js
const number = 5;
export const square = () => number ** 2;

// module2.js
import { square } from './module1';
square(); // => 25

// А так нет:

// module1.js
export const square = () => number ** 2;

// module2.js
import { square } from './module1';

const number = 5;
square(); // => ReferenceError: number is not defined

/**
 Если подумать логически, так и должно быть. Представьте: если бы сработал второй вариант, то автоматически это бы означало, что вы можете случайно создать имя переменной, совпадающее с именем переменной внутри функции, написанной другим человеком. Как при этом будет работать код — предположить невозможно.

 Попробуйте самостоятельно ответить на вопрос: сработает ли такой код, в котором константа определена позже её использования внутри функции?
 */

const square = () => number ** 2;
const number = 5;

square(); // => 25

/**
 Ответ: сработает.

 Окружение — это не «всё, что было объявлено до функции, в которой я использую эти объявления». Не важно, что number появился позже использования внутри функции. Главное, что вызов функции square происходит позже определения number, а значит к этому времени идентификатор уже был добавлен в окружение, внутри которого была создана функция square.

 # Переменные
 Когда мы работаем с константами, всё просто. Нет изменений — нет проблем. В случае с переменными ситуация становится сложнее.
 */

const square = () => number ** 2;

let number = 5;
square(); // => 25

number = 3;
square(); // => 9

/**
 Изменение переменной следует читать как «изменение значения ключа в окружении». Соответственно, обращение к number всегда вернет последнее присвоенное значение. Завязка на переменные, описанная в коде выше, должна восприниматься как абсолютное зло. Она порождает неявные зависимости, сложный код и отладку. Функция автоматически перестает быть чистой, так как начинает зависеть от внешнего контекста.

 # Вложенные функции
 */

const factorial = (n) => {
    const iter = (counter, acc) => {
        if (counter > n) {
            return acc;
        }

        return iter(counter + 1, counter * acc);
    }

    return iter(1, 1);
}

factorial(5); // => 120

/**
 В этом коде реализовано вычисление факториала с применением итеративного процесса. Внутри функции factorial определяется внутренняя функция iter, которая накапливает аккумулятор, вызываясь рекурсивно. Условие выхода из рекурсии — попытка посчитать число большее, чем нужно.

 В этой проверке используется переменная n, которая явно в iter не передавалась. Но благодаря тому, как работают окружения, любые функции (в том числе и вложенные), определенные внутри factorial, имеют к ней доступ. Как видно из кода, n используется как константа, а значит такое использование абсолютно безопасно.



 # Перекрытие (Shadowing)

 Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем. Причем не важно, что это: аргумент функции, константа или переменная.
 */

const f = (coll) => {
    const iter(item, coll) => {
        // using coll
    }
    // ...
}

/**
 Несмотря на то, что сам код остается рабочим, перекрытие больше не позволяет обратиться к идентификатору из внешнего окружения, ведь поиск всегда происходит сначала в локальном окружении, а уже затем во внешних. Но еще большей проблемой является то, что такой код сложнее в анализе. Глядя на него недостаточно видеть имена, нужно также учитывать их контекст, так как одно и то же имя на разных строках может означать разные вещи. Если запустить линтер для подобного кода, то он укажет на перекрытие как на плохую практику программирования. Подробнее об этом можно прочитать в правилах Eslint https://eslint.org/docs/rules/no-shadow.


 Когда внутри функции создается локальное окружение?
 > Во время вызова

 Когда функция запоминает внешнее окружение?
 > Во время определения



 /***@@
 Реализуйте функцию reverse, переворачивающую строку. В этот раз, используя итеративный процесс. Работа функции основана на двух принципах.
 **/

// file: app/reverse.js
export default (str) => {
    const lastIndex = str.length - 1;

    const iter = (index, acc) => {
        if (index > lastIndex) {
            return acc;
        }

        return iter(index + 1, `${str[index]}${acc}`);
    }

    return iter(0, '');
}


// ## TESTS:
// file: app/__tests__/reverse.test.js:
import reverse from '../reverse';

test('reverse', () => {
    expect(reverse('')).toBe('');
    expect(reverse('z')).toBe('z');
    expect(reverse('zz')).toBe('zz');
    expect(reverse('zza')).toBe('azz');
    expect(reverse('qwerty')).toBe('ytrewq');
});



// >>>>> Возврат функций из функций <<<<<

const identity = v => v;
identity('wow'); // => wow

const sum = identity((a, b) => a + b);
sum(1, 8); // => 9

/**
 Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций. Мы даже можем определить функцию внутри другой функции и вернуть её наружу. И в этом нет ничего удивительного. Константы можно создавать где угодно.
 */

const generateSumFinder = () => {
    const sum = (a, b) => a + b;     // создали функцию
    return sum;                      // и вернули её
}

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа


/**
 Можно даже обойтись без промежуточного создания константы:
 вызвали функцию, которая возвращает функцию, и тут же вызвали возвращенную функцию
 */

generateSumFinder()(1, 5); // => 6
// ((a, b) => a + b)(1, 5)

/**
 Всегда, когда видите подобные вызовы f()()(), знайте: функции возвращаются!
 Теперь посмотрим, как еще можно описать функцию generateSumFinder:
 */

// предыдущий вариант для сравнения
// const generateSumFinder = () => {
//   const sum = (a, b) => a + b;
//   return sum;
// }

// новый вариант
const generateSumFinder = () => (a, b) => a + b;

// Для понятности можно расставить скобки:
const generateSumFinder = () => ((a, b) => a + b);

/**
 Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:
 */

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

sum(1)(3)(5); // => 9

/**
 Ту же функцию можно представить другим способом, вынеся каждую функцию в свою собственную константу. Этот способ полезен как мысленный эксперимент, чтобы понять где заканчивается одна и начинается другая функция, но сам по себе он не заработает, потому что теряется замыкание.
 */

const inner1 = z => x + y + z;
const inner2 = y => inner1;
const sum = x => inner2;

/**
 Попробуем последовательно пройтись по вызовам функции выше, чтобы понять, как получается результат. После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.
 */

sum(1)(3)(5); // => 9

const sum1 = x => y => z => x + y + z;

// sum(1);
const sum2 = y => z => 1 + y + z; // inner2

// sum(1)(3)
const sum3 = z => 1 + 3 + z; // inner1

// sum(1)(3)(5)
const sum4 = 1 + 3 + 5; // => 9

/**
 Как видно выше, sum1, sum2 и sum3 — это функции, а sum4 уже число, так как были вызваны все внутренние функции.
 Давайте распишем все функции:
 */

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));

/**
 Функция sum принимает x и возвращает функцию, которая
 принимает y и возвращает функцию, которая
 принимает z и возвращает функцию, которая
 возвращает сумму x + y + z

 Попробуем развить идею функции callTwice из предыдущего урока. Напишем функцию generate, которая не применяет функцию сразу, а генерирует новую.
 */

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));

/**
 Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:

 Создадим функцию f1. Она будет той функцией, которую вернет generate если передать ей функцию Math.sqrt (она вычисляет квадратный корень числа).

 Получается, f1 — это функция, которая принимает число и возвращает корень корня — Math.sqrt(Math.sqrt(x)):
 */

const f1 = generate(Math.sqrt);
f1(16); // => 2
// generate(Math.sqrt)(16);

/**
 Ещё пример: передадим в функцию generate новую функцию на ходу, без предварительного создания. Переданная функция возводит число в квадрат.
 */

const f2 = generate(x => x ** 2);
f2(4); // => 256
// generate(x => x ** 2)(4);

/**
 Теперь функция f2 возводит число в квадрат два раза: (42)2.

 Функция generate имеет такое имя не просто так. Дело в том, что возврат функции порождает каждый раз новую функцию при каждом вызове, даже если тела этих функций совпадают:
 */

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false

/**
 Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию.
 Запомнить довольно просто, если вы где-то слышите или читаете что происходит генерация функций, значит кто-то их возвращает.

 # Замыкание
 Работа практически всех описанных примеров базировалась на одном интересном свойстве, которое называется «замыкание».
 */

const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);

/**
 Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

 Но та функция, которую вернула generateDouble все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.


 Функция, которая была возвращена из generateDouble, называется замыканием. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

 В СИКП дается прекрасный пример на понимание замыканий. Представьте себе, что мы проектируем систему, в которой нужно запомнить пароль пользователя, а потом проверять его, когда пользователь будет заново заходить. Можно смоделировать функцию savePassword, которая принимает на вход пароль и возвращает предикат, то есть функцию, возвращающую true или false, для его проверки. Посмотрите, как это выглядит:
 */

const secret = 'qwerty';
// Возвращается предикат.
const isCorrectPassword = savePassword(secret);

// Теперь можно проверять
console.log(isCorrectPassword('wrong password')); // => false
console.log(isCorrectPassword('qwerty')); // => true

// А вот как выглядит код функции savePassword:

const savePassword = password => passwordForCheck => password === passwordForCheck;

/**
 # Возврат функций в реальном мире (Debug)
 Логгирование — неотъемлемая часть разработки. Для понимания того, что происходит внутри кода, используют специальные библиотеки, с помощью которых можно логгировать (выводить) информацию о проходящих внутри процессах, например в файл. Типичный лог веб-сервера, обрабатывающего HTTP запросы выглядит так:


 [  DEBUG] [2015-11-19 19:02:30.836222] accept: HTTP/1.1 GET - / - 200, 4238
 [   INFO] [2015-11-19 19:02:32.106331] config: server has reload its config in 200 ms
 [WARNING] [2015-11-19 19:03:12.176262] accept: HTTP/1.1 GET - /info - 404, 829
 [  ERROR] [2015-11-19 19:03:12.002127] accept: HTTP/1.1 GET - /info - 503, 829


 В js самой популярной библиотекой для логгирования считается Debug.

 Обратите внимание на левую часть каждой строки. Debug для каждой выводимой строчки использует так называемый неймспейс, некоторую строчку, которая указывает принадлежность выводимой строчки к определенной подсистеме или части кода. Он используется для фильтрации, когда логов становится много. Другими словами, можно указать "выводи сообщения только для http". А вот как это работает:
 */

import debug from 'debug';

const logHttp = debug('http');
const logHandler = debug('handler');

logHttp('hello!');
logHttp('i am from http');

logHandler('hello from handler!');
logHandler('i am from handler');

/** Что приведет к такому выводу:

 http hello! +0ms
 http i am from http +2ms
 handler hello from handler! +0ms
 handler i am from handler +1ms

 Получается, что импортированный debug — это функция, которая принимает на вход неймспейс в виде строки и возвращает другую функцию, которая уже используется для логгирования.
 */



/***@@
 Во многих языках программирования существует интересная функция flip. Её необычность заключается в том, что единственная цель этой функции — это преобразовать другую функцию так, чтобы порядок её аргументов был обратным.

 Например, у нас может быть функция pow, которая возводит первый аргумент в степень второго. flip вернет нам новую функцию, у которой первый аргумент — это степень, а второй — это число, которое нужно возводить в эту степень.

 Эта функция бывает очень полезна при активной работе с функциями высшего порядка, она часто упрощает возможность комбинировать функции между собой.

 Реализуйте и экспортируйте по умолчанию функцию flip. Данная версия flip работает только с функциями от двух аргументов.
 **/

// subtraction:
const sub = (a, b) => a - b;
const reverseSub = flip(sub);

sub(5, 3); // 2
reverseSub(5, 3); // -2

// exponentiation:
const wop = flip(Math.pow);

Math.pow(1, 2); // 1
wop(1, 2); // 2

Math.pow(3, 2); // 9
wop(3, 2); // 8


// file: app/flip.js
// #1:
const flip = f => (...args) => { //
    const revArgs = args.reverse();

    return f(...revArgs);
}

// #2:
const flip = f => (a, b) => f(b,a);

export default flip;


// ## TESTS:
// file: app/__tests__/flip.test.js
import flip from '../flip';

test('reverseSub', () => {
    const sub = (a, b) => a - b;
    const reverseSub = flip(sub);
    expect(reverseSub(1, 2)).toBe(1);
    expect(reverseSub(5, 3)).toBe(-2);
});

test('wop', () => {
    const wop = flip((a, b) => a ** b);
    expect(wop(1, 2)).toBe(2);
    expect(wop(3, 2)).toBe(8);
});




// >>>>> Частичное применение <<<<<

/**
 Частичное применение функций, техника основанная на возможности возвращать функции из других функций. Допустим у нас есть функция sum суммирующая три числа.
 */

const sum = (a, b, c) => a + b + c;
sum(4, 3, 1); // 8
sum(1, 1, 1); // 3

/**
 Частичное применение позволяет на основе старой функции, создать новую, которая "частично применена". Для начала вспомним что такое применение функции. Математики никогда не говорят что функция вызывается с некоторыми аргументами, вместо этого они говорят что функция была применена к этим аргументам. В примере выше функция sum была применена к трем аргументам 4, 3 и 1. Такое применение можно назвать полным, то есть в функцию было передано столько аргументов сколько и ожидалось. Здесь возникает вопрос, а можно было по другому? Да можно.

 Частичное применение, техника которую проще всего объяснить в отрыве от языков программирования, на языке близком к математике (для простоты назову его Ha). Представьте что наша функция выше, имеет вот такое определение:

 -- Слева имя функции, затем идет список параметров
 -- разделенных пробелами и после знака => тело функции
 */
sum a b c => a + b + c

/**
 А ее вызов выглядит так:
 -- Скобок и запятых нет, но это равносильно sum(4, 3, 1) в js
 */

sum 4 3 1 -- 8
sum 1 1 1 -- 3

/**
 Ha необычный язык, если внутри него вызвать функцию с неполным набором параметров, то в отличии от js он не вызовет саму функцию (или не упадет с ошибкой как во многих других языках). Он вернет новую функцию, которая "частично применена".

 -- sum2 новая функция, полученная частичным применением функции sum к числу четыре
 -- Применение "частичное" потому что в функцию sum передается только один параметр, а не три
 */

sum2 = sum 4
sum2 1 1 -- 6
sum2 3 2 -- 9

/**
 Другими словами, такой вызов создает новую функцию, которая работает точно так же как и исходная, но, при этом, часть ее аргументов как будто уже подставлены. То есть наш вызов sum2 1 1 в действительности приведет к вызову sum 4 1 1. Этот трюк работает с любым количеством аргументов. Посмотрите на частичное применение двух аргументов:
 */

sum3 = sum 1 1
-- sum3 принимает только один аргумент
sum3 2 -- 4
sum3 1 -- 3

/**
 Арифметика аргументов очень простая. Если исходная функция принимала 3 параметра, то после частичного применения одного параметра, новая функция будет принимать на вход два параметра (2 + 1 = 3), если частично применились два параметра, то новая функция принимает на вход 1 параметр. А можно ли частично применить три параметра для функции которая принимает на вход 3 параметра? Конечно нет, ведь это будет обычный вызов функции со всеми параметрами. Довольно несложно догадаться как выглядело бы определение функций sum2 и sum3 если бы мы их описали явно:
 */

sum a b c => a + b + c
sum2 b c => 4 + b + c
sum3 c => 1 + 1 + c

// Ha настолько необычный язык, что позволяет частично применять то что уже было частично применено:
// -- Создаем первую функцию с 3 - 1 аргументами
sum4 = sum 2
// -- Создаем вторую функцию с 2 - 1 аргументами
sum5 = sum4 3
// -- Вызываем то что получилось. В реальности вычисляется 2 + 3 + 1
sum5 1 -- 6
sum5 4 -- 9

// В js эта возможность не встроена прямо в сам язык, но ее можно реализовать с помощью дополнительной функции:
const sum = (a, b, c) => a + b + c;

// Берем исходную функцию sum и отдаем ее в функцию partialApply
const sumWithFour = partialApply(sum, 4);
sumWithFour(3, 1); // 8
sumWithFour(10, 3); // 17

const sumWithFourAndTwo = partialApply(sumWithFour, 2);
sumWithFourAndTwo(3); // 9

/**
 Функция partialApply принимает на вход исходную функцию и параметры которые нужно применить, а возвращает новую, частично примененную функцию.
 Вот как может выглядеть реализация partialApply для функций от трёх аргументов (таких как sum):
 */

const partialApply = (fn, arg1) => (arg2, arg3) => fn(arg1, arg2, arg3);

/**
 Немного примеров из реальности. Предположим, что мы пишем программу, вычисляющую зарплату людей разных специальностей по всему миру. Для этого используется функция getAverageSalary.
 */

const salary1 = getAverageSalary('programmer', 'spain');
const salary2 = getAverageSalary('programmer', 'russia');
const salary3 = getAverageSalary('programmer', 'usa');

/**
 Первым параметром функция принимает на вход название профессии, вторым — страну, на выходе — годовая зарплата. Все довольно примитивно, но часть данных дублируется. Вычисляется зарплата программистов в разных странах, что приводит к постоянному вызову функции с первым параметром programmer. В этом нет ничего криминального, но существует способ устранить подобное повторение. Убрать с помощью введения дополнительной константы.
 */

const job = 'programmer';
const salary1 = getAverageSalary(job, 'spain');
const salary2 = getAverageSalary(job, 'russia');
const salary3 = getAverageSalary(job, 'usa');

/**
 Название профессии больше не повторяется, но нам по-прежнему приходится подставлять его в каждый вывод. Здесь на помощь приходит так называемое частичное применение функции.
 */

const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/**
 Принцип действия частичного применения функции основан на генерации (в нашем случае с помощью функции partialApply) новой функции оборачивающей старую, причем так, что она принимает на вход меньшее количество аргументов. Для нашей задачи мы применили один аргумент, но это не обязательно. Применять можно любое число аргументов исходной функции (но, естественно, не все, ведь в таком случае мы получим обычный вызов функции). И хотя пример выше выглядит слегка искусственным, в реальной жизни этот прием применяется часто. Причем нередко частично применяется больше одного аргумента за раз.

 Тело функции getProgrammersSalaryByCountry выглядит предсказуемо. Внутри вызывается исходная функция с подставленным в аргумент значением.
 */

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

// А partialApply для функций от двух аргументов, реализуется способом очень похожим на реализацию flip.
const partialApply = (fn, arg1) => arg2 => fn(arg1, arg2);

/**
 То есть функция partialApply возвращает (генерирует) функцию, которая внутри себя замыкает два параметра: fn и arg1.

 Частичное применение для JS — практически как воздух для живых организмов. Из-за асинхронной природы JS часто бывают ситуации, когда одни параметры функции задаются в одном месте, а другие в другом, так как они становятся доступны только после выполнения асинхронной операции. Поскольку вы еще не обладаете достаточными знаниями для понимания соответствующего кода, я не буду приводить более сложных примеров, чтобы не сбивать вас с толку, но уверяю, что в дальнейших курсах все, что изучалось здесь, будет использоваться на полную катушку.

 Возможно ли частичное применение без замыкания?
 > Нет. Частичное применение подразумевает запоминание аргументов функции/


 /***@@@
 Реализуйте и экспортируйте по умолчанию функцию partialApply. Эта функция умеет частично применять один (второй) аргумент у переданной функции:
 */

const pow = (a, b) => a ** b;
const f1 = partialApply(pow, 2);
f1(1); // => 1
f1(10); // => 100

const f2 = partialApply((a, b) => a * b, 5);
f2(2); // => 10
f2(5); // => 25


// file: app/partialApply.js:

export default (f, second) => first => f(first, second);

export default partialApply;


// ## TESTS:
// file: app/__tests__/partialApply.test.js:

import partialApply from '../partialApply';

test('partialApply', () => {
    const f1 = partialApply((a, b) => a ** b, 2);
    expect(f1(1)).toBe(1);
    expect(f1(10)).toBe(100);

    const f2 = partialApply((a, b) => a * b, 5);
    expect(f2(2)).toBe(10);
    expect(f2(5)).toBe(25);
});




// >>>>> Каррирование <<<<<

/**
 Каррирование — очень интересная техника, позволяющая сильно упростить использование частичного применения на практике. Многие путают эти понятия, но, как вы увидите далее, они обозначают совершенно разные вещи.

 В предыдущем уроке нам приходилось писать функцию-обертку для применения.
 */

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/**
 Eсли бы наша функция getAverageSalary была каррирована, то все было бы значительно проще. Каррирование — это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.

 Предположим, что у нас есть функция const sum = (a, b, c) => a + b + c, которая складывает три числа. Тогда ее каррированная версия будет выглядеть так: const sum2 = a => b => c => a + b + c, а использование таким: sum2(5)(10)(-2). То же самое, разложенное по функциям:
 */

const sum2 = (a) => {
    return (b) => {
        return (c) => {
            return a + b + c;
        };
    };
}

/**
 Посмотрите внимательно на определение a => b => c => a + b + c. Эта запись очень краткая и одновременно очень емкая. Суммарное количество функций считается очень легко, оно равно сумме всех стрелок =>. Для лучшего понимания можно добавить скобки a => (b => (c => a + b + c)). Для каждого определения функции все, что находится справа от стрелки, является ее телом, каким бы сложным оно не было. Поначалу такая запись может помочь понять, как друг в друга вложены функции, но со временем, когда вы привыкните к обычной записи, она будет больше мешать.

 С другой стороны, если нам нужно каррировать существующую функцию без ее реализации, то делается это так: const sum2 = a => b => c => originalSum(a, b, c). То есть создается цепочка вложенных функций, в которой количество вложений равно количеству аргументов исходной функции и в конце которой происходит вызов оригинальной функции.

 Разберем происходящее по шагам.
 */

const sum = a => b => c => a + b + c;
const sum1 = sum(10); // sum1 = b => c => 10 + b + c
const sum2 = sum1(3); // sum2 = c => 10 + 3 + c
const result = sum2(0); // result = 10 + 3 + 0
console.log(result); // 13

/**
 То же самое происходит и при таком вызове: sum(10)(3)(0), разница только в том, что вызовы происходят без создания промежуточных констант.

 И задача для самоконтроля. Сколько раз нужно вызвать цепочку функций const greeting = () => () => () => () => console.log('Hey!'), чтобы дойти до конца? Обязательно попробуйте прямо сейчас выполнить это задание на repl.it.

 Теперь вернемся к нашей функции расчета зарплаты в ее каррированном виде. Представим, что теперь у нас в распоряжении две вложенных функции от одного аргумента: const getAverageSalary = job => country => /** body */:

const salary1 = getAverageSalary('programmer')('spain');
const salary2 = getAverageSalary('programmer')('russia');
const salary3 = getAverageSalary('programmer')('usa');

// Попробуем частично применить:

const getProgrammersSalaryByCountry = getAverageSalary('programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/**
 Применение в реальной жизни

 В функциональных языках, подобных haskell, вопросов об использовании каррированных функций просто не встает. Они там используются постоянно, начиная с самых азов. Это одна из причин, почему стоит учить подобные языки, даже если вы не будете писать на них программы. В императивных языках такое происходит значительно реже, но не в JS. JS по своей сути очень близок к функциональным языкам. Изначально он должен был быть написан на Scheme, языке из семейства Lisp, и функции в нем занимают центральное место. Каррирование используется в различных библиотеках и иногда является их ключевой "фичей", как, например, здесь: https://github.com/substantial/updeep.




 /***@@
 Удивительно, но факт — условные конструкции можно реализовать самостоятельно с использованием одних лишь каррированных функций.

 В этой практике мы реализуем упрощённую версию, имитирующую работу условной конструкции if.

 Экспортируйте тройку True, False, If, используя только функции, внутри которых только функции ;) То есть нельзя пользоваться встроенными в язык if, а также true и false. Сами функции должны быть каррированы.

 Пример использования:
 **/

import { If, True, False } from './logic';

If(True)('one')('two');  // one
If(False)('one')('two'); // two

/**
 Подсказки
 Общая схема работы функций такова:
 */

If(func)('one')('two'); // ?

/**
 То есть, в итоге должно вернуться то или иное значение, в зависимости от того, какая функция передана на вход If.
 Если функции If была передана True, то выражение ниже вернёт значение аргумента первого вызова (one):
 */
const ConditionTFunction = If(True);
ConditionTFunction('one')('two'); // => one

// Если функции If была передана False, то выражение ниже вернёт значение аргумента второго вызова (two):
const ConditionRFunction = If(False);
ConditionRFunction('one')('two'); // => two


// file: app/logic.js
export const True = x => () => x;
export const False = () => y => y;

export const If = f => f;


// # TESTS:
import { If, True, False } from '../logic';

test('Boolean', () => {
    expect(If(True)('fo')('bar')).toBe('fo');
    expect(If(False)('foo')('ba')).toBe('ba');
    expect(True()()).toBeUndefined();
    expect(False()()).toBeUndefined();
});



/***@@
 Реализуйте и экспортируйте по умолчанию каррированую версию функции, которая принимает на вход три строки и возвращает новую строчку составленную из трех входных.
 **/
// исходная версия
concat('a', 'bc', 'f'); // => abcf

// каррированая версия
concat('a')('bc')('f'); // => abcf


// file: app/concat.js
export default str1 => str2 => str3 => `${str1}${str2}${str3}`;


// file: app/__tests__/compose.test.js

import concat from '../concat';

test('compose', () => {
    expect(concat('')('')('')).toBe('');
    expect(concat('a')('bc')('f')).toBe('abcf');
});



/***@@
 Реализуйте и экспортируйте по умолчанию функцию compose, которая принимает на вход две других одноаргументных функции и возвращает новую функцию. Эта новая функция также принимает на вход один параметр и при вызове применяет его последовательно к переданным функциям в обратном порядке.

 Примеры ниже помогут понять, как должна работать функция:
 **/

const f = compose(Math.sqrt, Math.abs);
f(-4); // => 2

compose(v => v, v => v)(10); // => 10
compose(v => v + 2, v => v)(10); // => 12
compose(v => v, v => v - 2)(10); // => 8
compose(v => v ** 2, v => v - 2)(2); // => 0
compose(v => v - 2, v => v ** 2)(2); // => 2


// file: app/compose.js:
export default (f, g) => x => f(g(x));


// # TESTS:
// file: app/__tests__/compose.test.js:

import compose from '../compose';

test('compose', () => {
    expect(compose(v => v, v => v)(10)).toBe(10);
    expect(compose(v => v + 2, v => v)(10)).toBe(12);
    expect(compose(v => v, v => v - 2)(10)).toBe(8);
    expect(compose(v => v ** 2, v => v - 2)(2)).toBe(0);
    expect(compose(v => v - 2, v => v ** 2)(2)).toBe(2);
});


/**@@@
 Числа Черча
 В 30-х годах прошлого века перед математиками встала так называемая проблема разрешения (Entscheidungsproblem), сформулированная Давидом Гильбертом. Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение. Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? Ответ был найден двумя великими учёными того времени Алонзо Чёрчем и Аланом Тьюрингом. Они показали (первый — с помощью изобретённого им λ-исчисления, а второй — теории машины Тьюринга), что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима.

 Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики. Пока в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…

 В основе лямбда-исчисления лежит понятие, известное ныне каждому программисту, — анонимная функция. В нём нет встроенных констант, элементарных операторов, чисел, арифметических операций, условных выражений, циклов и т. п. — только функции, только хардкор. Потому что лямбда-исчисление — это не язык программирования, а формальный аппарат, способный определить в своих терминах любую языковую конструкцию или алгоритм. В этом смысле оно созвучно машине Тьюринга, только соответствует функциональной парадигме, а не императивной.

 Как уже говорилось ранее, в чистом бестиповом лямбда-исчислении отсутствует всё, кроме функций. Так что даже такие элементарные вещи, как числа или булевы значения необходимо реализовывать самим. Точнее, надо создать некие активные сущности, которые будут вести себя подобно необходимым нам объектам. И, естественно, процесс кодирования будет заключаться в написании соответствующих функций.

 Натуральные числа реализованные посредством лямбда-исчисления, называются числами Черча, и являются отличной разминкой для мозга. В основе реализации по-прежнему будут лежать функции, ведущие себя в заданном контексте подобно единице, двойке и т.д. Собственно, это одна из особенностей лямбда-исчисления: сущности, записанные в его терминах, не обладают самодостаточностью, поскольку воплощают поведение того или иного объекта.

 Реализуйте число Zero и операцию Succ (увеличение на единицу). Не забудьте про экспорт.
 Пример:
 */

const two = Succ(Succ(Zero));

// Немного хитрый способ трансформировать число черча в обычное представление.
// Откровенно говоря, устройство самих чисел еще хитрее ;)

two(x => x + 1)(0); // 2

const four = Succ(Succ(two));
four(x => x + 1)(0); // 4


// file: app/numerals.js:
export const Zero = () => x => x;

export const Succ = n => f => x => f(n(f)(x));


// ## TESTS:
// file: app/__tests__/numerals.test.js

import { Zero, Succ } from '../numerals';

it('numerals', () => {
    const two = Succ(Succ(Zero));
    expect(two(x => x + 1)(0)).toBe(2);

    const four = Succ(Succ(two));
    expect(four(x => x + 1)(0)).toBe(4);

    expect(four(two(x => x + 1))(0)).toBe(8);
});




//############################### JS: Настройка окружения ###############################

// Ubuntu
$ curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash -
    $ sudo apt install -y nodejs

/**
 Теперь убедимся в том, что Node.js поставлена и работает. Вероятно, в некоторых операционных системах понадобится перезапустить терминал или даже перезагрузиться.
 Проверяем:
 */

$ node -v
v10.0.0

/**
 Версия, которую вы увидите, должна быть не ниже 8.

 Если все прошло удачно, самое время повыполнять код на js. Node.js поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для ее запуска достаточно набрать node:
 */

$ node
>

/**
 Если все прошло успешно, то REPL выведет приглашение для ввода инструкций: >. Попробуйте поиграться с ним. Наберите любое арифметическое выражение, например, 1 + 3 и нажмите Enter. Обратите внимание на то, что нет необходимости использовать console.log. REPL автоматически распечатывает последний вычисленный результат.

 Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
 */

$ node
> a = 5
5
> b = 10
10
> a + b
15

/**
 Чтобы выйти из REPL, нужно либо набрать .exit и нажать Enter, либо два раза нажать CTRL + C

 Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением js, например, index.js, а затем запустить:
 */

// file: index.js
console.log('hello!');

$ node index.js
hello!

    /**
     # NVM
     Совсем другой способ установки Node.js — утилита nvm. Кроме установки любых версий Node.js, она позволяет удобно переключаться между версиями. Это может понадобится, когда вы одновременно работаете над двумя проектами, требующими разные версии Node.js.


     # ECMAScript
     Основа js — язык ECMAScript. ECMAScript — это встраиваемый, расширяемый, не имеющий средств ввода-вывода (то есть он не может писать и читать файлы) язык программирования, используемый в качестве основы для построения других скриптовых языков. По сути, он существует только на бумаге. Стандартизирован международной организацией ECMA в спецификации ECMA-262. JS основан на ECMAScript, но расширяет его. Кстати, js не единственный язык, расширяющий ECMAScript. Кроме него также используются JScript и ActionScript.

     Интересно, что сам по себе ECMAScript никакого отношения ни к браузерам, ни к вебу не имеет. Несмотря на это, сам ECMAScript развивается и имеет не одну версию, которая также называется стандартом:

     es3
     es5.1
     strict mode
     ECMAScript 2015 (es6)
     es7 ?


     # JavaScript
     JavaScript — динамический, слабо типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.

     # Интерпретируемый
     У js отсутствует стадия компиляции, как у языков, подобных Java или C. Код непосредственно передается в интерпретатор, который его выполняет по мере чтения. Поэтому любая программа на js состоит из текстовых файлов.
     */

    $ node
> eval('10 * 3 + Math.random()')

/**
 # Динамический
 В отличие от статических языков, проверка типов в js происходит в момент выполнения кода. А значит, если мы случайно ошиблись и, например, вызываем несуществующую функцию, то ошибка всплывет только во время вызова этой функции. В статических языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение. Такие инструменты называются статическими анализаторами кода. Слово статический как раз означает, что программа не выполняется. Для динамических языков они тоже существуют, но отслеживают значительно меньшее число ошибок.

 # Слабо типизированный
 Слабая типизация означает, что js автоматически приводит типы там, где считает нужным. Подробнее этот механизм описан в спецификации. С одной стороны, слабая типизация позволяет писать более короткий код. С другой стороны, количество ошибок резко возрастает, так как вместо остановки выполнения, код продолжает работать там, где он не должен работать. Например, мы можем сложить число со строкой по ошибке, и js молча выполнит эту операцию. В языках типа ruby/python подобное невозможно. Выполнение кода прекратится с сообщением о невозможности выполнить операцию для этих типов. Никогда не полагайтесь на эту особенность языка, во избежание проблем.
 */

$ node
> 3 + '8ha'
'38ha'
> '8ha' * 3
NaN
> true + 1
2



// >>>>> NPM <<<<<

/**
 Node.js поставляется вместе с программой NPM. Она выполняет множество функций, которые не представляется возможным рассмотреть в рамках текущего курса. Рекомендуем периодически посматривать на ее команды и изучать информацию по ним. Ключевая задача, которую решает NPM — управление зависимостями, и именно о ней мы поговорим.

 Практически с самого зарождения программирования: с тех пор, когда код стал храниться в памяти компьютера, появилась идея повторного использования кода не только в рамках одного проекта, но и во многих других. В разных проектах используются одни и те же функции для работы с датами, математическими формулами, всевозможными расчетами. Подобное переиспользование кода приводит к резкому росту производительности. Программисты современности могут сосредоточиться на решении уникальных задач бизнеса, вместо создания своих велосипедов для решения инфраструктурных задач. Все стало еще проще с появлением git и github.

 Первоначально общий код выносился в файлы, которые программисты часто держали на своих собственных компьютерах и копировали из проекта в проект. Такой способ обладает рядом существенных недостатков:

 Код сложно передать другим.
 У каждого разработчика своя собственная копия одинаковых или почти одинаковых решений одних задач.
 Доработкой занимается только автор.
 Существует много разных копий без возможности быстрого обновления.
 Из-за того, что код копируется прямо в другой проект, он, как правило, модифицируется и становится специфичным.
 Если использовать git, то часть проблем решается автоматически. Cоздается набор общих файлов, который называется "библиотека". Конечные проекты, в свою очередь, начинают использовать библиотеки, написанные нами или сторонними разработчиками. Но тут возникает следующая сложность: когда таких библиотек становится много, у них также появляется общий код более низкого уровня. Например, финансовые библиотеки могут использовать функции для преобразования валют. Чтобы подобный код не дублировался, хочется вынести его в общедоступное место. Этот процесс может продолжаться бесконечно. Одни библиотеки зависят от других, те в свою очередь от третьих и так далее. С точки зрения переиспользования кода все хорошо: большое число маленьких библиотек, решающих всевозможные задачи, позволяет быстро двигаться вперед в разработке. Но с точки зрения управления этим зоопарком появляются проблемы:

 Появляются новые версии библиотек. Из-за этого они начинают зависеть не только друг от друга, но и от разных версий друг друга. Зачем это нужно? Предположим, что создатель сторонней библиотеки, от которой зависит наша библиотека, обновил ее так, что изменил сигнатуры функций или, как говорят, сломал обратную совместимость. Теперь в них другое число параметров, другие параметры, другой возврат. Если мы обновим стороннюю библиотеку, наша первоначальная библиотека перестанет работать. Она рассчитывала на одно поведение библиотеки, от которой зависела, а получила другое.
 Необходимо стандартизировать способ создания библиотек. Только в таком случае станет возможным автоматизировать процесс их соединения. Стандартный веб-проект может зависеть от сотни библиотек, которые в свою очередь зависят от сотен других библиотек. Общее число зависимостей может легко перевалить за тысячу. Управлять таким количеством зависимостей вручную невозможно.
 Из проблемы, описанной выше, вытекает необходимость в автоматизированном средстве управления зависимостями: их обновлению, установке и удалению.
 Всеми этими вопросами и занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.


 # Терминология

 В NPM используются следующие понятия:

 Пакет (Package) — базовая единица, которой управляет NPM как единым целым. Может содержать любое количество файлов и кода. NPM позволяет устанавливать пакеты, обновлять или удалять.

 Реестр (Registry) — хранилище пакетов NPM. Каждый желающий может опубликовать пакет в npm registry, потратив буквально минуту, а остальные смогут его использовать. В хранилище на текущий момент сотни тысяч пакетов и их количество стремительно растет. Исходный код пакетов, как правило, хранится на гитхабе. Несмотря на это, пакеты в npm никак не связаны с git и github.

 # Глобальная установка пакетов

 Многие пакеты в npm представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту sloc, которая умеет считать количество строк кода в указанной папке. Инструкция по установке обычно находится на странице репозитория в гитхабе.
 */

$ sudo npm install -g sloc

/**
 Отмечу несколько моментов:
 -g — этот флаг говорит о том, что нужно установить пакет глобально, то есть в такое место, которое доступно для всех пользователей системы.
 sudo — нужно потому, что это место чаще всего недоступно для записи обычным пользователям (в Ubuntu это, скорее всего, /usr/local/lib).

 после команды install можно перечислять любое количество пакетов через пробел.
 Глобальная установка пакета sloc:

 Процесс установки занимает некоторое время, в течение которого видно, как скачивается не только сам пакет, но и его зависимости. Дальше ничего делать не нужно, так как sloc создан утилитой командной строки и сразу готов к использованию.

 # Создайте файл index.js в любом месте вашей файловой системы и добавьте туда любой код (например, печать на экран)
 # Затем вызовите программу sloc, используя терминал. Для этого перейдите в директорию, содержащую этот файл, и выполните команду:
 */

$ sloc index.js // =>

/**
 ---------- Result ------------

 Physical :  2
 Source :  2
 Comment :  0
 Single-line comment :  0
 Block comment :  0
 Mixed :  0
 Empty :  0
 To Do :  0

 Number of files read :  1

 ------------------------------

 # Пакет

 NPM работает таким образом, что объединяет понятия "проект" и "библиотека" в одно целое. И то и другое оформляется, как пакет NPM. Причем проект может быть любых размеров. Даже если ваше приложение состоит из 3 строчек кода, вам понадобится работать с ним, как с полноценным проектом.

 Для создания пакета необходимо выполнить команду npm init в той директории, где вы собираетесь писать код. С этого момента эта папка будет корневой для вашего пакета.
 */

$ npm init

/**
 После ввода данной команды вам предложат ответить на десяток вопросов, например, ввести имя вашего проекта, его описание, имя автора (вас как создателя) и тому подобное. Некоторые вопросы имеют ответы по умолчанию, например имя проекта или его версия. NPM предлагает для названия проекта использовать имя директории, внутри которой запускается npm init. Это полезное соглашение, которого стоит придерживаться (по необходимости переименуйте саму директорию).

 # Если нажать Enter, то ответом на вопрос станет значение по умолчанию
 */

package name: (js_setup_environment_course) // ответ по умолчанию указан в скобках

// Когда вопросы закончатся, npm покажет конечный результат в виде JSON. JSON — это формат для представления структурированных данных.

{
    "name": "My Super Project",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
},
    "author": "",
    "license": "ISC"
}

/**
 В этом JSON содержатся ответы которые вы дали ранее. NPM спросит все ли хорошо с ним? Если вы ответите утвердительно, то NPM создаст файл package.json, куда поместит данный вывод (JSON). В дальнейшем вы всегда сможете открыть его в обычном текстовом редакторе и поправить, если понадобится. Файл package.json крайне важен для правильной работы NPM. Кроме информационных полей типа имени автора, есть и функциональные поля, которые влияют на то как будет работать пакет. Они изучаются далее на протяжении всего курса.

 # Проблемы

 Если в файле package.json содержатся синтаксические ошибки, иными словами, там нарушены правила форматирования JSON, то при попытке сделать что-то с проектом будут появляться подобные ошибки:
 */
npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected string in JSON at position 225 while parsing '{
npm ERR!   "name": "gendiff_freetonik",
    npm ERR!   "vers'
npm ERR! File: /Users/a/cpackage.json
npm ERR! Failed to parse package.json data.

// или такие:

    npm ERR! code EJSONPARSE
npm ERR! Failed to parse json
npm ERR! Unexpected token n in JSON at position 207 while parsing near '...
npm ERR!   "engines": {
    npm ERR!     node: 8
    npm ERR!   },
npm ERR!   "scri...'
npm ERR! File: /Users/a/c/package.json
npm ERR! Failed to parse package.json data.

    /**
     Обычно любое сообщение с «неожиданными» (unexpected) символами или строками означает наличие синтаксической ошибки.

     Воспользуйтесь валидаторами JSON для проверки верности своего файла: jsonlint.com или другими подобными инструментами, которые можно загуглить по запросу "json validator".

     Другая проблема связана с тем, что NPM во время установки пакетов нередко выводит подобные сообщения:
     */

    npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0.

    /**
     Бояться их не надо, это не сообщения об ошибках. Deprecated warning — сообщение, сигнализирующее о том, что нечто устарело. Под этим «нечто» может скрываться все, что угодно и часто не по вашей вине. Например, в package.json могут использоваться свойства, которые в новых версиях NPM называются по-другому. К этим предупреждениям стоит прислушиваться, но на работу они не влияют.


     # Код пакета

     После завершения процесса инициализации, можно приступать к самому главному — написанию кода. По умолчанию код пакета создается внутри файла index.js, лежащего в корне проекта (там, где создан файл package.json). Это не значит, что весь пакет состоит из одного файла. Файлов с кодом можно создавать сколько угодно, главное, при этом, что основная работа происходит внутри index.js, куда импортируется код из остальных файлов.


     # Самостоятельная работа

     Клонируйте nodejs-package к себе на компьютер (документация по клонированию https://help.github.com/articles/cloning-a-repository/).
     Установите (глобально) пакет sloc.
     Выполните команду sloc path/to/nodejs-package и изучите вывод. Где path/to/nodejs-package путь до директории nodejs-package клонированного на ваш компьютер.

     Дополнительные материалы
     NPM https://www.npmjs.com/
     Документация NPM https://docs.npmjs.com/


     В чём разница между секциями dependencies и devDependencies в структуре конфигурационного файла package.json?
     > Секцию dependencies необходимо использовать для описания зависимостей, которые будут нужны при использовании программы, а devDependencies только для тестирования и локальной разработки.

     ? Как правильно использовать установленную библиотеку (например hexlet-pairs) в файле с кодом?
     */

    import { cons, car, cdr } from 'hexlet-pairs';




// >>>>>> Публикация пакета <<<<<<

/**
 Утилита sloc, которую мы использовали в прошлом уроке, создана обычным программистом как пакет NPM. Каким образом она стала доступна для установки? Дело в том, что недостаточно просто создать пакет и залить (git push) его код на гитхаб. Так NPM ничего о нем не узнает. При установке неизвестного пакета NPM выдаст соответствующее предупреждение:
 */

$ npm install unkownpackagename // =>
/**
 npm ERR! code E404
 npm ERR! 404 Not Found: unkownpackagename@latest


 Утилита npm не смогла найти пакет в своем хранилище пакетов, о чем радостно нам и сообщила. Разберемся с добавлением нашего пакета в хранилище NPM.

 Если мы хотим дать разработчикам возможность использовать наш пакет, то необходимо выполнить его публикацию. Публикация пакета сводится к запуску команды npm publish в корне нашего проекта:

 Ниже показан процесс публикации пакета из репозитория https://github.com/hexlet-boilerplates/nodejs-package
 */

$ cd nodejs-package
$ npm publish

/** =>
 > nodejs-package@0.0.2 prepublishOnly .
 > npm run build

 > nodejs-package@0.0.2 build /Users/hex/projects/nodejs-package
 > NODE_ENV=production babel src --out-dir dist --source-maps inline

 src/bin/hexlet.js -> dist/bin/hexlet.js
 src/half.js -> dist/half.js
 src/index.js -> dist/index.js
 + nodejs-package@0.0.2


 Вывод может быть довольно большим. Главное, что здесь не видно явных ошибок и в конце такая строчка: + nodejs-package@0.0.2. Она сигнализирует о том, что пакет с именем nodejs-package был добавлен в NPM хранилище под версией 0.0.2. Как только публикация пройдет, ваш пакет автоматически станет доступным для установки. Убедиться в этом можно следующим образом:
 */

$ sudo npm install -g nodejs-package

/** =>
 npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
 npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
 npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0. Please update to graceful-fs@^4.0.0 as soon as possible. Use 'npm ls graceful-fs' to find it in the tree.
 /usr/local/bin/hexlet -> /usr/local/lib/node_modules/nodejs-package/dist/bin/hexlet.js
 + nodejs-package@0.0.2
 added 187 packages in 16.11s

 Как видите, в конце снова появляется строчка + nodejs-package@0.0.2, но теперь она означает, что пакет nodejs-package версии 0.0.2 был установлен.


 И для полноты картины еще два способа найти нужный пакет и убедиться, что он есть в NPM хранилище:

 1. Поискать на сайте https://www.npmjs.com/
 2. Выполнить команду npm info nodejs-package. Если вы увидите информацию о пакете, то все хорошо. В противном случае возникнет ошибка.

 Для успешной публикации должны выполниться два условия:

 Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет, что и понятно, ведь тогда станет невозможным разобраться чей ставить пакет при указании этого имени.
 Вы зарегистрированы на сайте https://www.npmjs.com/ и выполнили локально аутентификацию, запустив в командной строке npm login (синоним команды npm adduser). Такое требование важно с точки зрения безопасности. Пакет может публиковать только зарегистрированный пользователь, а обновлять — автор пакета.
 В случае обновления, версия нового пакета должна быть выше версии текущего опубликованного пакета. Подробнее об этом пункте в разделе Версионирование.


 Иногда требуется простая провека, что все настройки публикации выполнены правильно. Для этого не обязательно публиковать cам пакет в хранилище. Можно воспользоваться опцией --dry-run. Она сохраняет весь процесс публикации кроме фактического добавления пакета в NPM. При этом будут выведены подробности публикации:
 */

$ npm publish --dry-run


/** =>
 > nodejs-package@0.0.3 prepublishOnly .
 > npm run build

 > nodejs-package@0.0.3 build /Users/hex/projects/nodejs-package
 > NODE_ENV=production babel src --out-dir dist --source-maps inline

 Successfully compiled 3 files with Babel.
 npm notice
 npm notice 📦  nodejs-package@0.0.3
 npm notice === Tarball Contents ===
 npm notice 1.6kB package.json
 npm notice 1.1kB README.md
 npm notice 852B  dist/bin/hexlet.js
 npm notice 622B  dist/half.js
 npm notice 711B  dist/index.js
 npm notice === Tarball Details ===
 npm notice name:          nodejs-package
 npm notice version:       0.0.3
 npm notice package size:  2.3 kB
 npm notice unpacked size: 4.8 kB
 npm notice shasum:        e9d86f87706327cb5afd3d2d594a3c8922dd2f4d
 npm notice integrity:     sha512-xnK7Kuq2e7IGI[...]ZIMd7JXP9YPjA==
 npm notice total files:   5
 npm notice
 + nodejs-package@0.0.3



 # Версионирование

 В разработке принято версионировать программное обеспечение. Версия — это номер либо группа номеров (иногда с буквами или словами), которая обозначает какой-то конкретный этап разработки данного кода. Вот некоторые примеры: 0.0.2, 1.0.32, 1.33. С конкретной версией кода всегда связаны какие-то изменения относительно предыдущей версии, например, новые фичи, исправления багов или улучшения, такие как повышение производительности.

 Зачем нужны версии в библиотеках? В первую очередь из-за обратной совместимости. Жизнь течёт, всё меняется и со временем библиотеки начинают работать по-другому, используют более удобные и современные подходы. В свою очередь код который их использует, не меняется одновременно с ними, а значит мы не можем гарантировать того, что наш код заработает с другой, более новой версией библиотеки. Поэтому нужна возможность фиксировать версию до тех пор, пока наш код не будет готов к использованию новой. Подробнее поговорим об этом в уроке про зависимости.

 Современное версионирование кода основано на универсальном стандарте, который называется SEMVER http://semver.org/lang/ru (семантическое версионирование). По стандарту, версия представляет из себя три числа разделенных точками: 1.23.5. Каждое из этих чисел имеет собственно имя и предназначение:

 Первое число (1 в примере выше) — мажорная версия. Меняется только в случае серьезных изменений, как правило, ломающих обратную совместимость
 Второе число (23 в примере выше) — минорная версия. Не должна ломать обратную совместимость (в идеале). Меняется при добавлении новых возможностей.
 Третье число (5) — патч. Гарантировано не должна менять обратную совместимость (к сожалению такое бывает). Меняется только при исправлении багов.
 К сожалению, соответствие требованиям, целиком и полностью ответственность разработчиков. Автоматическая проверка (верификация) невозможна. Поэтому бывают сбои, когда версионирование происходит неверно, но в целом такой подход работает и упрощает работу.

 Обратите внимание на то, что версия 1.12.3 выше, чем версия 1.3.3, потому что 12 больше чем 3.

 # Самостоятельная работа
 Зарегистрируйтесь на сайте https://www.npmjs.com/ (это пригодится для участия в проектах).
 */




// >>>>>> Зависимости <<<<<<

/**
 Основное предназначение пакетов - удобный способ делиться общим кодом. Возьмем для примера библиотеку lodash, которая очень широко используется в JavaScript и добавляет много маленьких функций, решающих различные повседневные задачи. Посмотрите на список функций слева https://lodash.com/docs/4.17.11. Их там больше сотни! Ниже типичный пример использования:
 */

// По общепринятому соглашению, lodash импортируется под именем _
import _ from 'lodash';

// capitalize делает первую букву заглавной
_.capitalize('hello'); // Hello

/**
 Как только мы добавили подобный код (с импортом кода из другой библиотеки, а не локального файла) в наш проект (или библиотеку), мы получили так называемую зависимость. Теперь наш проект зависит от пакета lodash. Обратите внимание на то, как написано слово lodash. Перед ним нет указания текущей директории ./, именно так NPM понимает, что это внешняя зависимость, а не файл, лежащий рядом.

 Возникает закономерный вопрос, как начать использовать эту библиотеку в своем коде? Если мы попытаемся импортировать ее как в примере выше, то получим закономерную ошибку о том, что пакет не найден. Во время запуска кода, все что импортируется, должно быть установлено локально в директорию node_modules лежащую в корне проекта. Делается это уже знакомой нам командой npm install, но в этот раз без флага глобальной установки. Для добавления пакета lodash, перейдите в корневую директорию того пакета, который вы разрабатываете и выполните следующую команду:

 Имя пакета всегда совпадает с именем, которое указывается в части импорта, идущей после from
 from 'lodash';
 */

$ npm install lodash

// После завершения установки, вы увидите что файл package.json изменился. В него добавилась секция dependencies с таким содержимым:
"dependencies": {
    "lodash": "^4.2.1"
}

/**
 Отличие от глобальной установки состоит в том, что здесь нет флага -g и не нужно использовать sudo. При таком подходе зависимости ставятся в директорию node_modules, находящуюся в корне проекта. Кроме того, NPM создаст файл package-lock.json рядом с файлом package.json. Этот файл должен храниться в репозитории, а его значение я объясню в следующем уроке.

 Теперь NPM знает о том что ваш проект (он же пакет) зависит от lodash.

 Кроме обычных зависимостей, NPM отдельно обрабатывает зависимости необходимые только во время разработки. К таким пакетам относятся тестовые фреймворки и тому подобные вещи. Их установка немного отличается:
 */

$ npm install --save-dev jest

/**
 Флаг --save-dev приводит к тому что зависимость добавляется в секцию devDependencies файла package.json. Эти зависимости никак не используются при публикации пакета, что позволяет экономить память. В остальном механизм работы тот же: они скачиваются и сохраняются в директорию node_modules и импортируются внутри кода как и любой другой код.
 */

"devDependencies": {
    "jest": "^23.6.0",
        "jest-cli": "^23.6.0"
}

/**
 К сожалению, на текущем этапе код, указанный выше, не будет работать в любом случае. Связано это с тем, что Node.js напрямую не поддерживает синтаксис импортов и для их использования нужно подключить пакет Babel.

 Сами зависимости не хранятся в git-репозитории и должны быть добавлены в .gitignore:
 */

// FILE: .gitignore
node_modules

/**
 Если вы клонировали репозиторий с гитхаба, директория node_modules будет отсутствовать, как и пакеты в ней. Первое, что нужно сделать в этом случае — выполнить команду npm install. Эта команда, запущенная без аргументов, выполняет установку тех пакетов, которые указаны в файле package.json. Она запускается в разных случаях: если вы удалили папку node_modules и хотите снова ее восстановить или если вы только что клонировали репозиторий. Установка пакетов — идемпотентная операция, поэтому ее можно запускать сколько угодно раз, не боясь что-либо сломать.

 # Самостоятельная работа:
 Изучите зависимости в репозитории nodejs-package https://github.com/hexlet-boilerplates/nodejs-package. Попробуйте найти репозитории зависимых пакетов.
 */




// >>>>>> Lock файл <<<<<<

/**
 Поговорим об обновлении зависимостей. Для обновления всех зависимостей нужно выполнить команду npm update. Чтобы выполнить обновление конкретной зависимости — npm update name, где name — имя библиотеки. А вот то, как будет происходить обновление, зависит от того, что написано в package.json.

 Рассмотрим все доступные варианты:
 */

dependencies {
    'package1': "*",
        'package2': "1.3.5",
        'package3': "~2.3.4",
        'package4': "^2.3.4",
}


/**
 * означает, что можно ставить любую версию библиотеки. После выполнения команды обновления в папке node_modules окажется последняя доступная версия package1.
 1.3.5 - конкретный номер. Если версия библиотеки жестко зафиксирована, никакая команда не сможет обновить ее.


 Самый интересный сценарий происходит в случае использования тильды (~). Напомню, что в семантическом версионировании считается, что patch (последняя цифра в версии) изменяется только в случае исправления ошибок, а значит обратная совместимость не должна теряться. На практике это не всегда так, код может работать с учетом ошибок в зависимостях. Как правило, в проектах десятки, а то и сотни зависимостей, причем обновляются они очень часто. С одной стороны, можно всегда писать *, но тогда мажорные обновления библиотек могут сломать систему. С другой стороны, можно зафиксировать все версии, но тогда обновлять все придется вручную, а значит, по закону Мерфи, никто не будет этого делать. Поэтому появился третий вариант. Добавление тильды приводит к тому, что в автоматическом режиме обновляются только патчи. Предположим, что после добавления зависимости в проект, версия была установлена в ~2.10.3. Если после нее в npm репозитории появилась 2.10.5, то она будет установлена командой обновления. То же самое произойдет, если потом будет выпущена версия 2.10.15. Но если создатель библиотеки опубликует изменения в мажорной или минорной версии, например 2.11.5 или 3.0.0, то npm их проигнорирует.

 Примерно то же самое происходит и при использовании ^ ("крышки"), только в отличие от тильды, она фиксирует мажорную версию, а минорная обновляется наравне с патчем.

 # Lock

 На предыдущем шаге каждая новая установка зависимостей сначала создавала, а потом обновляла файл package-lock.json.

 Попытаемся разобраться, зачем он нужен. Как мы помним, в package.json указываются зависимости, и мы научились устанавливать и обновлять их. У каждой зависимости могут быть свои собственные зависимости, которые тоже обновляются — и так до бесконечности. Зависимости зависимостей называются транзитивными и с ними не все так просто. Настолько не просто, что существует понятие "dependency hell" (ад зависимостей).


 Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей. Предположим, что в нашем пакете есть зависимость A с зафиксированной версией 1.3.2, у которой в зависимостях стоит пакет B с версией *. В такой ситуации в отсутствие лок файла npm install установит указанную версию зависимости A и последнюю доступную версию пакета B. Такое поведение не детерминировано. Если создатель пакета B обновит его так, что нарушится обратная совместимость, наш проект просто сломается, так как перестанет работать A. Если мы полгода не заходим в проект, а затем зайдем и поставим зависимости заново, удалив папку node_modules или выполнив новое клонирование, то почти наверняка ничего не заработает. Пакеты обновляются часто, и какой-нибудь из них обязательно изменит мажорную версию за столь длинный срок.

 Очевидный, но не рабочий выход из данной ситуации — вручную отслеживать зависимости всех зависимостей и явно прописывать их версии в package.json. Такой способ сработает, но даже в проекте на js, который содержит всего 5 зависимостей, транзитивных зависимостей будут сотни! Вдумайтесь в эту цифру. Я уже не говорю про то, что пакеты обновляются и меняются. Такую ситуацию невозможно контролировать, и зависимости просто перестанут обновляться.

 Другой выход — требовать, чтобы создатели всех библиотек всегда жестко указывали версии. Из-за человеческого фактора этот вариант обречен на провал. Автоматизация такого процесса привела бы к полному параличу системы пакетов и библиотек, а значит и разработки программ.

 И тут на сцену выходит lock-файл. Он представляет собой автоматизированное решение первого способа. Его содержимое выглядит примерно так:
 */

{
    "name": "hexlet-co",
    "version": "0.1.4",
    "lockfileVersion": 1,
    "requires": true,
    "dependencies": {
    "JSONStream": {
        "version": "1.3.1",
            "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.1.tgz",
            "integrity": "sha1-cH92HgHa6eFvG8+TcDt4xwlmV5o=",
            "requires": {
            "jsonparse": "1.3.1",
                "through": "2.3.8"
        }
    },
    "abab": {
        "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/abab/-/abab-1.0.4.tgz",
            "integrity": "sha1-X6rZwsB/YN12dw9xzwJbYqY8/U4=",
            "dev": true
    },
    "acorn": {
        "version": "4.0.13",
            "resolved": "https://registry.npmjs.org/acorn/-/acorn-4.0.13.tgz",
            "integrity": "sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c="
    },
...
}
}

/**
 Первый запуск установки зависимостей формирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные, и их версии. При дальнейших запусках npm install всегда ставится то, что указано в lock файле, даже если стереть папку node_modules, а в npm-хранилище добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь всегда можно быть уверенным, что если заработало сейчас, то заработает потом и не только у нас.

 Наличие lock файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в package.json, обновился и может быть обновлен до указанной версии, то загрузится новая версия, а файл lock обновится автоматически. После этого нужно не забыть залить его в git-репозиторий.

 На самом деле, lock-файл ведет себя сложнее, но для понимания схемы его работы достаточно описанного выше. Если хотите разобраться в теме от и до — изучите официальную документацию.

 Как и любой автоматически генерируемый файл, lock-файл не может правиться вручную, потому что ваши изменения сразу будут сброшены при следующей генерации.

 # Самостоятельная работа
 Клонируйте репозиторий nodejs-package, а затем выполните внутри него команду npm update. Изучите вывод команды git diff.
 Попробуйте изменить версию любого пакета в package.json, указав точную версию без использования ^, и выполните npm install. Доступные версии пакета можно посмотреть командой: npm view <packagename> versions, например: npm view eslint versions.

 В каких случаях происходит создание и обновление файла package-lock.json?
 > При установке новых зависимостей
 > При установке доступных обновлений существующих зависимостей
 */




// >>>>>> NPX <<<<<<

/**
 Не все устанавливаемые зависимости, используются внутри кода как библиотеки. Некоторые нужны для различных утилитарных задач. К подобным пакетам относится eslint. Eslint - это программа для проверки кода на соответствие стандартам кодирования, она используется на Хекслете для проверки ваших решений как в практике к урокам так и в проектах, где вы будете устанавливать ее самостоятельно. Существует два способа ее установки, глобальный и локальный.

 Глобальная установка позволяет установить eslint один раз и затем использовать его во всех необходимых пакетах, которые мы разрабатываем:
 */

$ sudo npm install -g eslint
$ cd my-package

// eslint требует указать директорию, в которой нужно искать файлы для проверки. Точка означает текущую директорию:
$ eslint .

    /**
     Хотя такой способ установки кажется заманчивым, все же, его стоит избегать. Глобальные зависимости не ставятся при первоначальной настройке пакета. То есть если мы выполним команду npm install в свежесклонированном репозитории, eslint не поставится, а значит придется устанавливать его отдельно. И это придется делать не только нам, но и всем кто участвует в разработке данного пакета. К тому же возможны проблемы с версиями. Если у кого-то стоит eslint старой версии, это может помешать нормальной проверке, и в такой ситуации не будет никакой возможности обновить версию пакета автоматически, это произойдет только если разработчик сам вспомнит о том, что пакет стоит обновить.

     Поэтому наш выбор - локальная установка. Подобные пакеты всегда используются только при разработке, поэтому не забываем указывать флаг --save-dev во время локальной установки:
     # В корне проекта
     */

    $ npm install --save-dev eslint

/**
 Но здесь нас ожидает сюрприз. Если попробовать его запустить как обычно, то bash скажет что команда не найдена (если, конечно, вы не установили его глобально ранее).
 # В корне проекта
 */

$ eslint .
    bash: eslint: command not found

/**
 Такое поведение вполне ожидаемо. Вспомните, курс по основам командной строки и урок посвященный запуску программ из консоли. Исполняемый файл программы ищется по путям перечисленным в переменной окружения $PATH. В случае локальной установки, пакет устанавливается в директорию node_modules и только туда, никакие файлы больше никуда не добавляются. Другими словами bash не может узнать о том, что вы установили какую-то программу.

 Из этой ситуации есть два выхода: правильный и неправильный. Неправильный - запустить исполняемый файл указав прямой путь. Для eslint он будет таким:
 */
$ ./node_modules/.bin/eslint --init // инициализация линтера, во время которой создается конфигурационный файл
$ ./node_modules/.bin/eslint . // запуск проверки в текущей и всех вложенных директориях

    /**
     Проблема такого подхода в том, что идет завязка на конкретный путь внутри самого пакета. Если разработчики поменяют его или банально переименуют файл eslint.js, то все запуски сломаются. Поэтому нужно использовать правильный способ:
     */
    $ npx eslint --init
$ npx eslint .

    /**
     npx - специальная программа, которая автоматически устанавливается вместе с утилитой npm (убедитесь что вы ставите одну из последних версий Node.js). Она имеет такой формат работы:

     $ npx <тут любая программа, установленная как локальный пакет NPM> <тут опции этой программы>


     То есть npx добавляется слева к любому вызову, при этом сама команда никак не меняется.

     Как работает npx? Эта утилита меняет $PATH для конкретного вызова, добавляя туда путь. Именно поэтому начинают работать локально установленные программы.

     Например для написания тестов в js, мы используем тестовый фреймворк Jest. Он ставится как обычная зависимость в проект и дальше запускается через команду jest:
     */

    $ npm install --save-dev jest

// Пример вызова без npx
$ jest
// => bash: jest: command not found

// А теперь правильно
$ npx jest
// =>  тут побежали тесты




// >>>>>> Scripts <<<<<<

// Секция Scripts позволяет описывать произвольные команды, которые затем можно выполнять.
"scripts": {
    "test": "jest",
        "build": "NODE_ENV=production babel src --out-dir dist --source-maps inline",
        "prepublishOnly": "npm run build"
}

// Рассмотрим пример. Предположим, что мы установили программу sloc как зависимость и хотим ее запускать с определенными параметрами.
"scripts": {
...
    "sloc": "sloc",
...
}

/**
 Имя свойства используется как команда в командной строке, значение — исполняемая программа. Теперь, если вы попробуете сделать так: npm run sloc, то все отработает как и ожидается.

 Некоторые свойства в Scripts имеют особое значение. Например, на Хекслете код проверяется автоматическими тестами с использованием библиотеки jest. Она содержит бинарник с тем же именем и все, что нужно сделать для запуска тестов - выполнить команду jest. Мы могли бы сделать в скриптах такую запись: "jest": "jest", но именно для тестов NPM предлагает делать так: "test": "jest". Главное отличие подобных встроенных команд — в их способе запуска. Достаточно набрать npm test вместо npm run test, хотя второй вариант также сработает.
 */

nodejs-package$ npm test

/** =>
 > nodejs-package@0.0.1 test /Users/mokevnin/hexlet/nodejs-package
 > jest

 PASS  __tests__/half.test.js
 ✓ half (3ms)

 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        0.242s, estimated 1s
 Ran all test suites.

 # Hooks

 Есть целый набор предопределенных свойств в Scripts, которые NPM запускает автоматически в разные моменты жизни. Подробнее об этом можно прочитать в официальной документации https://docs.npmjs.com/misc/scripts. Одним из таких свойств является свойство prepublishOnly, которое используется тогда, когда перед публикацией пакета в репозиторий NPM необходимо выполнить некоторые действия, например, сгенерировать документацию. Команда, указанная в нем, запустится во время выполнения npm publish.

 Самостоятельная работа
 Попробуйте выполнить скрипт test в пакете nodejs-package https://github.com/hexlet-boilerplates/nodejs-package


 Допустим, в файле package.json прописан следующий скрипт:

 "scripts": {
  "eslint": "eslint --colors"
}


 Как выполнить проверку файла index.js линтером используя npm?
 > npm run eslint index.js


 Допустим, в файле package.json прописан следующий скрипт:
 "scripts": {, так как в секции scripts есть скрипт с ключом start
  "start": "bin/index.js"
}
 Какими способами нужно запускать скрипт start используя npm? Выберите все правильные ответы.
 > npm run start, так как в секции scripts есть скрипт с ключом start
 > npm start, так как start является дефолтной для npm командой, а значит ключ run можно опустить
 */




// >>>>>> Babel <<<<<<

/**
 Итак, мы знаем, что есть спецификация, а есть ее реализация. Знаем, что реализация зачастую отстает от спецификации. Более того, разные реализации по-разному отстают от спецификации. Написав код, мы не можем гарантировать, где он будет запускаться, а где — нет.

 Исходя из этого можно сделать вывод, что нужно писать код, придерживаясь старых стандартов. К счастью, есть другой путь: мы можем писать код с использованием всех возможных фич, но перед публикацией автоматически транслировать его (то есть переводить из одного вида в другой) в старую версию. Звучит сложно, но на практике все просто.

 Сама природа JS и его способы использования готовят нас к тому, что никогда не настанет светлых времен с современными рантаймами. Люди использовали и продолжат использовать разные браузеры и разные версии браузеров, разные версии Node.js и так далее. Использование новых синтаксических конструкций в такой ситуации практически невозможно. Запуск кода на платформе, не поддерживающей новый синтаксис приведет к синтаксической ошибке. Закономерным решением этой проблемы стало появление Babel — программы, которая берет указанный код и возвращает тот же код, но транслированный в старую версию JS. Фактически, в современном мире Babel стал неотъемлемой частью JS. Его не используют только в старых проектах, также называемых легаси-проектами. Все новые проекты так или иначе делают с его использованием.

 У Babel есть собственный онлайн REPL https://babeljs.io/repl/. Попробуйте вставить туда любой код, который вы писали на Хекслете, и посмотрите, во что он превратится. Такая трансляция называется транспайлингом, а сам Babel называют транспайлером, от transpiler https://en.wikipedia.org/wiki/Source-to-source_compiler.
 */

// before:
const factorial = (n) => {
    if (n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

// after:
"use strict";

var factorial = function factorial(n) {
    if (n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
};

/**
 Babel состоит из многих частей:

 Пакет @babel/core содержит код, который выполняет всю работу по трансляции, но не содержит внутри себя правил преобразования. Правила описаны в отдельных пакетах, называемых плагинами (например, babel-plugin-transform-constant-string).

 @babel/preset-env. Пресет - это группа плагинов, которую можно подключить к Babel целиком. preset-env - основной пресет поддерживаемый командой Babel, который содержит внутри себя плагины, реализующие стандартизированные возможности js.

 Пакет @babel/cli обеспечивает возможность работы с бабелем через терминал. Предоставляет командную утилиту babel. Ниже рассматривается ее использование.

 Пакет @babel/node - еще одна утилита командной строки: babel-node.


 # Установка
 */
$ npm install --save-dev @babel/core @babel/cli @babel/node @babel/preset-env


/**
 # Настройка

 Babel полагается на наличие файла babel.config.js в корне проекта. Именно через него он узнает, как нужно транслировать код.
 Этот файл нужно создать самостоятельно. Если вы забудете добавить туда плагин или пресет, то на выходе Babel отдаст тот же код, что был и на входе.
 */

module.exports = {
    presets: [
        ['@babel/env', {
            targets: {
                node: 'current',
                firefox: '60',
                chrome: '67',
                safari: '11.1',
            },
        }],
    ],
};

/**
 Разные среды исполнения поддерживают (или не поддерживают) разные возможности и синтаксические конструкции языка. В свойстве targets перечисляются конкретные окружения (и их версии), для которых пишете код. Если код предназначен для выполнения на nodejs, то достаточно указать только его. В таком случае babel будет транслировать конструкции, поддерживаемые на nodejs, и ничего лишнего:
 */

module.exports = {
    presets: [
        ['@babel/env', {
            targets: {
                node: 'current',
            },
        }],
    ],
};

/**
 Минимально достаточно подключить пресет @babel/preset-env. Он добавляет возможности JS, которые входят в стандарт.

 # Использование

 При появлении в проекте Babel, изменяется файловая структура проекта. Так как код существует в двух состояниях: исходном и транслированном, то удобно создать две директории, под каждый набор исходников.
 Исходный код, принято хранить в директории src в корне проекта, а код полученный в результате трансляции - в директории dist.

 # Команда babel предоставляется пакетом @babel/cli:
 */

$ npx babel src --out-dir dist

/**
 Эта команда берет весь код из файлов в директории src и создает его транслированную версию в директории dist. Запускается он точно так же, как и любой другой код, и фактически именно этот код нужно доставить в NPM-репозиторий. Другими словами, пользователи вашего пакета запускают код из директории dist, а не src, хотя сами об этом не знают. Сама директория dist добавляется в .gitignore, так как сгенерированный код нужен только в момент публикации пакета для упаковки в архив, который уходит в NPM-репозиторий. В процессе разработки пакета, запуск сборки не требуется.

 Есть только один маленький нюанс. Изначально я сказал, что NPM никак не интегрирован с Git, но это не совсем правда. По умолчанию NPM смотрит в файл .gitignore. Все, что там перечислено, не попадет в NPM-репозиторий при публикации пакета. В нашем случае такой директорией является dist, но именно ее мы и хотим опубликовать. Выходов из этой ситуации несколько. Один связан с файлом .npmignore и описан в документации, про другой я скажу подробнее. NPM позволяет указать список файлов и папок, которые нужно опубликовать. Достаточно добавить секцию files в package.json. Содержимое files — массив директорий и файлов:
 */

"files": [
    "dist"
]

/**
 Существует два способа подготовки пакета к публикации. Первый подход заключается в том, чтобы перед выполнением npm publish вручную сгенерировать каталог dist, используя скрипты: npx babel src --out-dir dist. Подход рабочий, но сопряжён с постоянными ошибками в стиле "ой, забыл собрать новый код". К тому же, это действие может быть автоматизировано — именно эту идею и реализует второй подход. NPM содержит множество предопределённых скриптов, которые выполняются автоматически в определённые этапы работы. Например, prepublishOnly запускается перед непосредственным выполнением публикации. То, что нам и требуется.
 */

"scripts": {
    "build": "NODE_ENV=production babel src --out-dir dist",
        "prepublishOnly": "npm run build"
}


/**
 В примере выше используется небольшой трюк. В prepublishOnly вызывается другой скрипт — build. Этот приём используется широко, и он действительно удобен. Бывают ситуации, когда все же нужно запускать сборку руками. Поэтому удобно иметь отдельную команду только для генерации. Скрипт build как раз и призван решить эту задачу.

 Подчеркну еще раз: каталог dist не должен храниться в git-репозитории, и вы не найдете его на Гитхабе. Посмотрите lodash. Она генерируется только в момент публикации пакета и заливается в npm-репозиторий. Каждая новая публикация должна генерировать этот каталог заново. Только в этом случае обновится код в пакете.

 Подведём итог. В git-репозитории хранится исходный код, ещё не обработанный babel. Это значит, что вы всегда можете найти библиотеку и изучить её содержимое на github. А вот пакет, установленный к вам в систему содержит обработанный код, предназначенный для запуска, а не для чтения. Этот код не хранится в git-репозитории. Он попадает в NPM-репозиторий в момент публикации новой версии пакета за счет выполнения команды prepublishOnly (в которую вы сами должны прописать вызов трансляции).

 # Babel-node

 При использовании новых возможностей js, запуск кода на выполнение node file.js, упадет с ошибкой, потому что внутри файла используется синтаксис, который нода не понимает. Для запуска кода после каждого изменения, необходимо выполнять трансляцию. Этот процесс выглядит так:

 1 Делаем изменение.
 2 Транслируем код с помощью Babel.
 3 Запускаем на выполнение.

 Разработчики Babel предусмотрели эту ситуацию. В этом случае можно установить пакет @babel/node. Теперь код можно вызывать так: npx babel-node src/index.js. Команда babel-node делает одновременно две вещи. Транслирует код и сразу же запускает его на выполнение. В отличие от команды babel, babel-node не сохраняет результат трансляции. Все происходит во время работы в памяти. Обратите внимание на то, что вам все равно понадобится правильно настроенный файл babel.config.js в корне проекта иначе babel-node не сможет произвести трансляцию и так же завершится с ошибкой синтаксиса на момент запуска.

 # Самостоятельная работа
 Попробуйте выполнить скрипт build в пакете nodejs-package. Изучите результаты его работы в папке dist. Вы должны увидеть, что содержимое файлов внутри dist отличается от содержимого тех же файлов внутри src. Вместо const использован var, вместо import - require. В целом код остается читаем, хотя и выглядит странновато.



 Как устанавливать Babel?
 > Добавить необходимые пакеты в devDependencies и создать конфигурационный файл babel.config.js

 С помощью какой утилиты можно сразу увидеть результат выполнения Babel кода?
 > babel-cli

 Как автоматизировать процесс доставки кода прошедшего через Babel в NPM репозиторий?
 > Использовать скрипт prepublishOnly, который выполняется автоматически перед командой npm publish

 Какой код в итоге должен попасть в NPM репозиторий?
 > Исходный код прошедший обработку через Babel. Только так будет обеспечена максимальная совместимость со всеми интерпретаторами.

 Рассмотрим ситуацию, когда в файле .gitignore имеется следующее содержимое:
 .*.swp
 dist
 npm-debug.log
 Как опубликовать пакет так, чтоб в него попал каталог dist не меняя при этом содержимое файла .gitignore?
 > Создать файл .npmignore (можно даже пустой), так как для NPM он представляет наибольший приоритет
 > Добавить в package.json секцию files и записать в неё dist
 */



// >>>>>> Source Map <<<<<<

/**
 В самых простых случаях транслированный код выглядит почти так же, как и исходный. Но стоит начать использовать чуть более продвинутые возможности JS, как код изменяется до неузнаваемости:
 */

// Было:
const defaultState = { channels: {}, messages: {} };
let state = { ...defaultState };

export default router => router.put('refresh', '/refresh', async (ctx) => {
    state = { ...defaultState };
});

// Стало:

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultState = { channels: {}, messages: {} };
var state = _extends({}, defaultState);

exports.default = function (router) {
    return router.put('refresh', '/refresh', function (ctx) {
        state = _extends({}, defaultState);
        ctx.status(200);
    });
};

/**
 Трансляция не дается бесплатно. Получившийся код нечитаем и его невозможно нормально отладить. Ведь теперь запускается не наш первоначальный код, а транслированный. Это значит, что любая логическая ошибка нашего кода будет указывать на транслированный код, который в свою очередь очень сильно отличается от исходного, поскольку:

 - Babel может заменять имена переменных.
 - Строчки, на которые указывает stacktrace — отчет о вызванных функциях после возникновения ошибки в программе, в исходном и транслированном файле не совпадают. Более того, stacktrace указывает только на транслированный код.
 - В одних и тех же ситуациях возникают разные ошибки. Например, если вы забыли экспортировать функцию по умолчанию, то после трансляции вы увидите такое сообщение: TypeError: (0 , _path2.default) is not a function вместо Module 'path' has no default export.

 Для решения этой проблемы используется специальный механизм под названием "source map" или "маппинг". Его принцип действия следующий. При транспайлинге кода создается структура определенного формата, в которой описана связь сгенерированного кода с исходным кодом. Затем эта структура записывается либо в отдельный, либо прямо в сгенерированный файл в виде комментария (inline mode). Затем, во время выполнения программы, она используется интерпретатором для построения правильных стектрейсов и ссылок.

 Пример содержимого файла index.js.map с маппингом:
 */
{"version":3,"sources":["../src/index.js"],"names":["co","generator","args","iterator","enerator","next","result","value","Promise","resolve","done","then","res","throw","err","reject"],"mappings":";;;;;;AAEA;;;;AAEA;;;;;;;;;;;;;AAaA,IAAMA,KAAK,SAALA,EAAK,CAACC,SAAD,EAAyC;AAAA,oCAAdC,IAAc;AAAdA,QAAc;AAAA;;AAClD,MAAMC,WAAWC,6CAAYF,IAAZ,EAAjB;;AAEA,MAAMG,OAAO,SAAPA,IAAO,CAACC,MAAD,EAAY;AACvB,QAAMC,QAAQC,QAAQC,OAAR,CAAgBH,OAAOC,KAAvB,CAAd;AACA,QAAID,OAAOI,IAAX,EAAiB;AACf,aAAOH,KAAP;AACD;;AAED,WAAOA,MAAMI,IAAN,CACL;AAAA,aAAON,KAAKF,SAASE,IAAT,CAAcO,GAAd,CAAL,CAAP;AAAA,KADK,EAEL;AAAA,aAAOP,KAAKF,SAASU,KAAT,CAAeC,GAAf,CAAL,CAAP;AAAA,KAFK,CAAP;AAID,GAVD;;AAYA,MAAI;AACF,WAAOT,KAAKF,SAASE,IAAT,EAAL,CAAP;AACD,GAFD,CAEE,OAAOS,GAAP,EAAY;AACZ,WAAON,QAAQO,MAAR,CAAeD,GAAf,CAAP;AACD;AACF,CApBD;;kBAsBed,E","file":"index.js","sourcesContent":["// @flow\n\nimport 'source-map-support/register';\n\n/***\n * Generator based control flow\n * @name co\n * @example\n * co(function* () {\n *   const result = yield Promise.resolve(true);\n *   return result;\n * }).then(value => {\n *   console.log(value);\n * }, err => {\n *   console.error(err.stack);\n * });\n */\nconst co = (generator: () => void, ...args: any) => {\n  const iterator = enerator(...args);\n\n  const next = (result) => {\n    const value = Promise.resolve(result.value);\n    if (result.done) {\n      return value;\n    }\n\n    return value.then(\n      res => next(iterator.next(res)),\n      err => next(iterator.throw(err)),\n    );\n  };\n\n  try {\n    return next(iterator.next());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n};\n\nexport default co;\n"]}

// А в конце сгенерированного файла index.js будет такая строчка:
sourceMappingURL=index.js.map

/**
 Эта техника не является специфичной для JS. Она используется повсеместно там, где применяется транспайлинг.

 Babel

 Babel поддерживает source map из коробки. Для его генерации достаточно добавить флаг --source-maps в процесс компиляции:
 */
$ npx babel script.js --out-file script-compiled.js --source-maps inline


/**
 После выполнения этой команды в конце транслированных файлов появится source map в виде комментария. Однако, если речь идет про Node.js (а не браузер), то этого недостаточно. На текущий момент Node.js не имеет встроенной поддержки source map, поэтому даже если вы их сгенерировали, нода никак не отреагирует на их наличие. Их поддержку можно добавить с помощью npm пакета https://github.com/evanw/node-source-map-support https://github.com/evanw/node-source-map-support.

 # Самостоятельная работа
 Пропустите код nodejs-package https://github.com/hexlet-boilerplates/nodejs-package через Babel, включив генерацию Source Map в отдельных файлах.


 ? Для чего нужен Source Map?
 > Для отладки кода прошедшего транспайлинг путём добавления карты, указывающей на реальную структуру исходных файлов

 ? Как сгенерировать source map для файла hexlet.js используя Babel?
 > npx babel hexlet.js --out-file hexlet-compiled.js --source-maps

 ? Как автоматически сгенерировать source map для всех файлов в папке dist при сборке пакета?
 > Добавить babel src --out-dir dist --source-maps в значение ключа build секции scripts
 */




// >>>>>> Точка Входа <<<<<<

/**
 В курсе "Введение в программирование" использовался только один вид импортов — импорт из локальных файлов. Подобные импорты отличает указание относительного пути (./) в секции from.
 */

import { length } from './strings';
import factorial from './factorial';

/**
 Все подобные импорты объединяет то, что в них мы обращаемся к конкретному файлу, лежащему где-то рядом. Его всегда можно открыть и посмотреть содержимое. Но в реальных проектах и дальше в курсах, вам будут встречаться нелокальные импорты:
 */

import path from 'path';
import fs from 'fs';
import lodash from 'lodash';

/**
 Как видите, в импортах выше, нет начального ./. Некоторые из них, по сути, тоже локальные — это импорты из стандартной библиотеки. В указанном примере к ним относятся первые два импорта из модулей path и fs. Эти модули лежат где-то в системных директориях — там, куда они были помещены во время установки Node.js. Посмотреть список всех модулей стандартной библиотеки можно в официальной документации https://nodejs.org/api/modules.html

 Самое интересное происходит при импорте сторонних npm-пакетов: import lodash from 'lodash';. Дело в том, что пакет — не то же самое что и модуль. Модуль — один файл, а пакет — набор файлов, в которые входят модули и package.json. Посмотрите содержимое репозитория lodash. В корне проекта находится, наверное, сотня файлов.


 Возникает закономерный вопрос. Если внутри одного пакета множество модулей, то что же импортируется если мы пишем import lodash from 'lodash'?

 В npm принято соглашение, что по умолчанию всегда импортируется файл index.js, находящийся в корне проекта. Этот файл является точкой входа в пакет. Все остальные модули, как правило, собираются внутри index.js. Но это поведение можно изменить. За это отвечает свойство main (главный) в файле package.json. Посмотрите его значение в пакете lodash. В нашем эталонном пакете nodejs-package эта строчка выглядит так:
 */
"main": "dist/index.js"

/**
 Сам файл dist/index.js в репозитории отсутствует, как впрочем и папка dist. Как вы помните из урока про babel, эта директория формируется только в момент публикации пакета и заливается в npm, но в репозиторий ее не добавляют.


 ? В какой секции файла package.json задаётся точка входа?
 > "main": "path/to/file"

 ? Какой файл вашего проекта является точкой входа по умолчанию?
 > index.js
 */




// >>>>>> Исполняемые файлы <<<<<<

/**
 Многие пакеты представляют из себя приложения командной строки, так называемые cli-утилиты, взаимодействие (запуск команд, передача аргументов и опций, вывод результатов) которых с пользователем происходит интерактивным образом через терминал. Для обеспечения такой возможности (запуск файлов из командной строки) в npm существует секция bin конфигурационного файла package.json, например:
 */

"bin": {
    "hexlet": "dist/bin/hexlet.js"
}

/**
 Эта запись означает, что при установке пакета в операционной системе будет физически создан файл (а точнее, его особая разновидность — символическая ссылка, symlink) с именем hexlet, запуск которого приведёт к запуску файла вашего проекта по адресу dist/bin/hexlet.js. Также обратите внимание, что количество ссылок может быть множество (столько, сколько сами укажете в секции bin).

 Месторасположение символической ссылки и способ её запуска из командной строки различаются в зависимости от способа установки пакета: глобального (с флагом -g: npm -g install packageName) или локального. Рассмотрим каждый случай отдельно.


 # Глобальная установка: генерация ссылок и запуск исполняемых файлов
 При глобальной установке пакета npm создаёт символические ссылки в каталоге по умолчанию /usr/bin (или /usr/local/bin, в разных системах значение может отличаться, кроме того оно может конфигурироваться https://docs.npmjs.com/misc/config с помощью npm). Это каталог для прикладных программ общего назначения, распространённый в операционных системах семейства UNIX, и путь к нему прописан в переменной окружения PATH. Именно поэтому мы можем запускать приложение по имени символической ссылки из командной строки, находясь в любой точке файловой системы (ведь при поиске исполняемых файлов командная оболочка ищет их последовательно по всем путям, прописанных в переменной окружения PATH).

 Посмотреть, в какую директорию npm складывает ссылки на исполняемые файлы можно с помощью команды:
 */

$ npm bin -g // npm bin --global.

// Посмотреть содержание переменной окружения PATH в вашей системе можно так:
$ echo $PATH
$ echo $PATH | grep /usr/bin


// Если вы пользуетесь системой управления версиями nvm (Node Version Manager, позволяет удобно использовать разные версии nodejs в рамках одной операционной системы), то каталог для символических ссылок может быть другой, например:
$ npm -g bin

/**
 Как видно, для каждой версии nodejs менеджер nvm создаёт отдельный каталог bin для ссылок на исполняемые файлы устанавливаемых на нём пакетов. Но суть от этого не меняется — самое главное, чтобы путь к каталогу был в переменной окружения PATH (в данном случае nvm автоматически добавляет путь к каталогу в PATH).

 Пример
 Давайте создадим и опубликуем пакет, который для краткости и наглядности будет очень простым, состоящим всего из двух исполняемых файлов, запуск которых выводит соответственно приветствие и прощание с Хекслетом.

 Структура проекта:
 */

~/projects/smallTalkWithHexlet$ ls -al
drwxrwxr-x  2 hex hex 4096 июн 12 16:35 ./
drwxrwxr-x 18 hex hex 4096 июн 12 16:22 ../
-rw-rw-r--  1 hex hex  340 июн 12 16:49 package.json
-rwxrwxr-x  1 hex hex   69 июн 12 16:29 sayBye.js*
-rwxrwxr-x  1 hex hex   52 июн 12 16:31 sayHi.js*


// Содержимое исполняемого файла sayHi.js:
~/projects/smallTalkWithHexlet$ cat sayHi.js
#!/usr/bin/env node

console.log('Hello, Hexlet!');

// Содержимое исполняемого файла sayBye.js:
~/projects/smallTalkWithHexlet$ cat sayBye.js
#!/usr/bin/env node

console.log('Bye-bye! See you later, Hexlet!');


// Содержимое конфигурационнного файла package.json:
~/projects/smallTalkWithHexlet$ cat package.json
{
    "name": "small_talk_with_hexlet",
    "version": "1.0.0",
    "description": "Small talk with Hexlet",
    "main": "",
    "bin": {
    "sayHi": "./sayHi.js",
        "sayBye": "./sayBye.js"
},
    "keywords": [
    "hexlet"
],
    "author": "hex",
    "license": "MIT"
}


/**
 Небольшое отступление про исполняемые файлы:

 1 Для возможности запуска файла из командной строки у пользователя должно быть право на выполнение (атрибут x) этого файла.
 2 Если исполняемый файл содержит код, то надо указать командной оболочке интерпретатор, который будет исполнять этот код при запуске исполняемого файла. Это делается с помощью так называемого шебанга. В примерах выше (#!/usr/bin/env node) мы указали в качестве интерпретатора node, а путь к нему задали не абсолютный (в разных системах node может лежать по совершенно разным путям), а с помощью специальной утилиты env.

 Итак, пакет опубликован и теперь доступен для установки под именем small_talk_with_hexlet (если решите опубликовать аналогичный пакет, то вам надо будет придумать своё уникальное имя для него).

 Теперь установим этот пакет в систему глобально.

 Но сначала убедимся, что никаких символических ссылок в директории не существует.
 */

$ npm bin --global
$ ls -al /usr/bin | grep 'say'

/**
 Здесь с помощью фильтра grep мы попытались найти файлы, содержащие в своём имени (как наши ссылки в секции bin) строчку "say". Но поиск не дал результатов, потому что таких файлов (до установки пакета) нет.

 Далее глобально устанавливаем пакет в систему:
 */

$ npm -g install small_talk_with_hexlet

/**
 Как видно из лога установки выше, создалось две символические ссылки с указанием на какие файлы приложения они ведут.

 Теперь снова проверим с помощью grep директорию установки исполняемых файлов.
 */

$ ls -al /usr/bin/ | grep 'say'
$ ls -al /usr/bin/say*

/**
 Как и ожидалось, в этом каталоге лежат символические ссылки (об этом свидетельствует первый символ l, определяющий тип файла в строке атрибутов файла lrwxrwxrwx), которые мы можем запускать из любой точки файловой системы:
 */

$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!
$ cd /media/
$ sayHi // => Hello, Hexlet!
$ sayBay // => Bay-bye! See you latter, Hexlet!


/**
 Из примера видно, что мы можем успешно запускать одни и те же команды из разных директорий. Почему так происходит подробно обсуждалось выше.


 # Что происходит при локальной установке
 В подавляющем большинстве случаев для целей разработки пакеты устанавливаются не глобально, а локально. При такой установке они "привязываются" к конкретному проекту и размещаются внутри его каталога по пути ./node_modules/. При этом ссылки на исполняемые файлы устанавливаемых пакетов npm размещает в каталоге ./node_modules/.bin.

 Ссылки на исполняемые файлы локально установленных пакетов "заточены" на использование их в скриптах (секция scripts конфигурационного файла package.json), для чего существует особенный синтаксис. Эту тему мы проходили в одном из предыдущих уроков, посвящённых скриптам.

 Естественно, к символическим ссылкам можно также обратиться напрямую, указав нужный путь. Давайте рассмотрим это на примере, подключив к нашему разрабатываемому проекту small_talk_with_hexlet пакет babel-node https://babeljs.io/docs/en/babel-node:

 ~/projects/smallTalkWithHexlet$ npm install --save-dev @babel/node


 Если в корневом каталоге проекта установить какой-либо пакет с флагом --save-dev (npm i some_package --save-dev) — то он автоматически добавится в зависимости проекта: в раздел devDependencies файла package.json. Этой возможностью мы и воспользовались.

 Как и ожидалось, появился каталог ./node_modules/, в котором лежит код подключенного пакета, а также других пакетов, от которых он, в свою очередь, зависит.

 Узнать место, где npm складывает ссылки на исполняемые файлы локально подключаемых пакетов, позволяет команда npm bin (обратите внимание, что здесь нет параметра --global или -g). В нашем случае это каталог ./node_modules/.bin, заглянем в него:
 */

$ npm bin
$ ls -al node_modules/.bin/


// Давайте запустим babel-node (REPL-утилита, позволяющая "на лету" комплировать и исполнять новый ES6 код):
$ ./node_modules/.bin/babel-node
> ['hi', undefined, 'bye'].fill('Hexlet', 1, 2)
    ['hi', undefined, 'bye']
> .exit

$ babel-node
bash: babel-node: command not found

/**
 Программа отработала корректно — мы успешно сделали вычисление в REPL-режиме babel-node.

 Затем была попытка запустить исполняемый файл из командной строки только по имени, но она привела к неудаче — bash: babel-node: command not found — командная оболочка просто не нашла его (в отличие от того, как это было бы при глобальной установке).

 # Установка пакета без публикации
 В npm существует удобная команда для работы — npm link. Она позволяет поставить свой пакет в систему без публикации в NPM. Так вы можете убедиться в том что всё работает без полного цикла выкладки. Для удаления такого пакета воспользуйтесь командой npm unlink.


 # Заключение
 В этом уроке мы рассмотрели как общие принципы, так и отдельные нюансы работы Npm с исполняемыми файлами проекта. Важно отметить, что эти принципы характерны для большинства других пакетных менеджеров из разных языков (например, composer в php). Поэтому, если в будущем вам придётся столкнуться с чем-то из них, то это не должно вызвать затруднений.
 */




// ############################### JS: Составные данные ###############################


// >>>>>> Точки <<<<<<

// # Интерфейс:
const x = 5;
const y = -7;

// Конструктор
const point = makePoint(x, y);

// Селекторы
getX(point);
getY(point);

toString(point); // (5, -7)

// # Манипуляции:
const symmetricalXPoint = point => makePoint(getX(point), -getY(point));

const point = makePoint(10, 10);
symmetricalXPoint(point); // (10, -10)

// # Манипуляции:
const point = makePoint(3, 4);
const point2 = makePoint(0, 0);

quadrant(point); // 1
distance(point, point2); // 5

/**
 # Итог:
 Абстрактные данные: Точка. Характеризуется двуся значениями (координатами): x и y.

 Конкретные данные: На текущий момент неизвестно как реализованы точки.

 Интерфейс:

 // Конструктор:
 makePoint(<x>, <y>);

 // Селекторы:
 getX(<point>);
 getY(<point>);
 */




/***@@
 Реализуйте и экспортируйте следующие функции для работы с точками:

 getQuadrant - функция, которая вычисляет квадрант, в котором находится точка. Ниже приведена схема, показывающая номера квадрантов на плоскости.

 +
 2 | 1
 |
 +----------------+
 |
 3 | 4
 +
 */
const point = makePoint(1, 5);
getQuadrant(point); // 1
getQuadrant(makePoint(3, -3)); // 4

// Если точка не принадлежит ни одному квадранту (т.е., если она лежит хотя бы на одной из осей координат), то функция должна возвращать null:

const point = makePoint(0, 7);
getQuadrant(point); // null
getQuadrant(makePoint(2, 0)); // null


// getSymmetricalPoint - функция, возвращающая новую точку, симметричную относительно начала координат. Такая симметричность означает, что меняются знаки у x и y.

getSymmetricalPoint(makePoint(1, 5)); // makePoint(-1, -5)


// calculateDistance - функция, вычисляющая расстояние между точками по формуле: d = sqrt((x2−x1)^2+(y2−y1)^2)

calculateDistance(makePoint(-2, -3), makePoint(-4, 4)); // ≈ 7.28

// FILE: points.js
import { makePoint, getX, getY } from 'hexlet-points';

export const getQuadrant = point => {
    const x = getX(point);
    const y = getY(point);

    if (x > 0 && y > 0) {
        return 1;
    } else if (x < 0 && y > 0) {
        return 2;
    } else if (x < 0 && y < 0) {
        return 3;
    } else if (x > 0 && y < 0) {
        return 4;
    }

    return null;
}

export const getSymmetricalPoint = point => {
    return makePoint(-getX(point), -getY(point));
}

export const calculateDistance = (point1, point2) => {
    const dX = getX(point2) - getX(point1);
    const dY = getY(point2) - getY(point1);

    return Math.sqrt((dX ** 2) + (dY ** 2));
}



// >>>>>> Пары <<<<<<

import { cons, car, cdr } from 'hexlet-pairs';

// Конструктор
const pairs = cons(8, 7);

car(pair); // 8
cdr(pair); // 7

const pair2 = cons(3, pair);

// # Представление точек:

import { cons, car, cdr } from 'hexlet-pairs';

const makePoint = (x, y) => cons(x, y);

const getX = point => car(point);
const getY = point => cdr(point);

const toString = point => toString(point);

// # Представление отрезков:

const point1 = makePoint(1, 2);
const point2 = makePoint(10, -2);

const segment = makeSegment(point1, point2);

startSegment(segment); // (1, 2)
endSegment(segment);   // (10, -2)


/**@@
 В этом задании мы немного потренируемся работать с парами. Без фанатизма и по шагам.

 Шаг 1 - reversePair.js
 Реализуйте функцию reversePair, которая принимает на вход пару и возвращает другую, в которой значения переставлены местами:
 */
import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons('one', 'two');
console.log(toString(reversePair(pair))); // ('two', 'one')

/**
 Шаг 2 - sumOfPairs.js
 Реализуйте функцию sumOfPairs, которая принимает на вход две пары и возвращает новую пару, в элементах которой находятся суммы элементов из исходных пар:
 */

import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair1 = cons(4, 10);
const pair2 = cons(100, 0);
console.log(toString(sumOfPairs(pair1, pair2))); // (104, 10)

/**
 Шаг 3 - findPrimitiveBox.js
 Однажды вы сидели дома, когда курьер Василий принес вам коробку. С коробкой шла записка следующего содержания:

 Коробка состоит из двух отсеков, в одном из которых письмо, а в другом лежит еще одна коробка, в которой также два отсека и точно также один отсек с письмом, а в другом - коробка. Коробки могут быть вложены друг в друга сколько угодно раз. Вам нужно добраться до коробки, внутри которой нет вложенной коробки ни в одном из двух отсеков, и отдать ее курьеру.

 Подчеркну, что во всех коробках, кроме той последней, в одном отсеке письмо (любые данные, которые не являются парой), а в другом - всегда коробка, но никогда не две коробки одновременно. Сами отсеки при этом могут меняться, то есть в одной коробке отсеком с письмом может быть первый, а в другой - последний.

 Реализуйте рекурсивную функцию findPrimitiveBox, которая принимает на вход "коробку" (пару), находит внутри нее пару без вложенных пар (как описано выше) и возвращает наружу.
 */

import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons(
    null,
    cons('one', 'two'),
);
toString(findPrimitiveBox(pair)); // ('one', 'two')

const pair2 = cons(
    cons(null, cons(1, 5)),
    null,
);
toString(findPrimitiveBox(pair2)); // (1, 5)

/**
 Подсказки
 Выполняйте практику строго по порядку (по шагам): от простых упражнений к более сложным.
 Функция isPair из библиотеки hexlet-pairs проверяет, является ли переданный ей параметр парой. Более подробное описание функции смотрите в документации библиотеки (файл hexlet-pairs.md в каталоге docs).
 Функцию toString из библиотеки hexlet-pairs можно использовать (при необходимости) для отладки решений.
 */

// FILE: sumOfPairs.js:
import { cons, car, cdr, toString } from 'hexlet-pairs';

const sumOfPairs = (pair1, pair2) => cons(car(pair1) + car(pair2), cdr(pair1) + cdr(pair2));

export default sumOfPairs;


// FILE: reversePair.js:
import { cons, car, cdr, toString } from 'hexlet-pairs';

const reversePair = pair => cons(cdr(pair), car(pair));

export default reversePair;


// FILE: findPrimitiveBox.js:
import { car, cdr, isPair, toString } from 'hexlet-pairs';

const findPrimitiveBox = (pair) => {
    const first = car(pair);
    const last = cdr(pair);

    if (!isPair(first) && !isPair(last)) {
        return pair;
    }

    const next = isPair(first) ? first : last;

    return findPrimitiveBox(next);
};

export default findPrimitiveBox;




// >>>>>> Моделирование <<<<<<

/**
 Абстракции позволяют нам моделировать необходимую предметную область. Попробуем понять это утверждение на конкретном примере. Допустим, мы хотим сделать программу-каталог для управления коллекцией книг. Вы можете сразу кинуться писать код, но так делать не стоит :)

 В первую очередь необходимо проанализировать предметную область (книги + каталоги) и сформировать базовую модель. Нужно начать с определения сущностей и операций над ними. В случае нашего каталога у нас есть по крайней мере две сущности: книга и коллекция. Базовыми операциями сделаем добавление книги в коллекцию и удаление ее из коллекции.

 Напишем код операции для добавления сущности в коллекцию:
 */

const book1 = makeBook('Дети капитана Гранта');
const book2 = makeBook('Приключения Тома Сойера');
const coll = makeColl('приключения');
const updatedColl1 = addBookToColl(coll, book1);
const updatedColl2 = addBookToColl(updatedColl1, book2);


/**
 Мы создаем две книги, одну коллекцию и добавляем эти книги в коллекцию. Что значит "создали книгу"? Что такое "книга"? Книга — это сущность, которая ведет себя как книга. Что это значит?

 Так как мы работаем с языком программирования, то конструктор makeBook, создающий книгу, возвращает какие-то данные: примитивные (число, строку) или составные, используя пары. Главное — нам не важно, как они устроены.

 Организовать эти данные можно тысячью разных способов, и конкретный способ зависит от разработчика, его предпочтений и данных, которые необходимо хранить. То, что книга является книгой, определяется не её внутренним устройством, а тем, что к ней применим набор операций, созданный для книг. Например, операция «получить имя книги». Сами операции знают, как устроены данные, иначе они не смогли бы ими манипулировать. Запомните: это детали реализации. Не заглянув внутрь операций, мы не узнаем, как они устроены, но нам это и не нужно.

 В этом и заключается вся суть абстракции. Мы знаем, как создать сущность и какие операции к ней применимы. Обычно это и называется дизайном кода, а сами операции + конструктор — это API или интерфейс модуля/пакета/библиотеки.


 Получаем следующий алгоритм:

 1 Анализируем предметную область. Выделяем сущности.
 2 Реализуем конструктор. Внутреннее представление сущностей выбираем на основе того, что мы планируем в них хранить.
 3 Реализуем необходимые операции.

 В примере с книгами видно, что мы храним только название, а это значит, что нам достаточно хранить одну строчку.

 Тогда реализация конструктора будет такой:
 */

const makeBook = name => name;

const book = makeBook('Дети капитана Гранта');
console.log(toString(book)); // Дети капитана Гранта

// А что, если мы захотим дополнительно хранить версию издания книги? Тогда мы можем использовать пары для хранения составных данных, и у нас уже появляются составные данные, так как нужно хранить два параметра.

const makeBook = (name, rev) => cons(name, rev);
const book = makeBook('Дети капитана Гранта', 3);
console.log(toString(book)); // ('Дети капитана Гранта', 3);

/**
 Поменяется ли клиентский код, использующий нашу библиотеку, при изменении внутреннeй структуры? Как видно из примеров выше, ничего не поменяется, кроме вызова конструкторов. Это и есть хорошая абстракция, при которой наш код не рассыпается в случае любых изменений внутренней реализации.

 # Примеры других абстракций

 Пример с книгами — это всего лишь один из многих вариантов. Программисты в своей работе постоянно перекладывают сущности реального мира на код, создавая всевозможные абстракции данных. Давайте попробуем пофантазировать и накидать еще вариантов. Я добавлю только три, а еще три додумайте сами. В реальной жизни абстракции будут сложнее, так как должны включать больше данных, но суть от этого не поменяется.

 1 Товар. Все, что продается и покупается. Предположим, что нам интересны только два параметра: цена и название. Саму сущность можно назвать product. Тогда наша абстракция будет содержать как минимум три следующих функции:
 */

// интерфейсные функции (абстракция)
const makeProduct = (name, cost) => cons(name, cost);
const getName = product => car(product);
const getCost = product => cdr(product);

// использование
const product = makeProduct('Сыр Пармезан', 100);
getName(product); // Сыр Пармезан
getCost(product); // 100

/**
 2 Текстовый документ. Например, как в Google Docs. В нашем примере он будет состоять из названия и содержимого.
 */

// интерфейсные функции (абстракция)
const makeDocument = (name, body) => cons(name, body);
const getName = document => car(document);
const getBody = document => cdr(document);

// использование
const document = makeDocument('Как я провел лето', 'Много текста');
getName(document); // Как я провел лето
getBody(document); // Много текста

// 3 А вот пример, в котором нужно хранить не два значения, а три. Это точка в пространстве.

// интерфейсные функции (абстракция)
const make3dPoint = (x, y, z) => cons(cons(x, y), z); // альтернатива cons(x, cons(y, z));
const getX = point => car(car(point));
const getY = point => cdr(car(point));
const getZ = point => cdr(point);

// использование
const point = make3dPoint(1, 10, -3);

/**
 И теперь самое интересное. Любая абстракция, построенная таким образом, может выступать в роли строительных блоков в другой абстракции.

 Предположим, что мы продаем документы как продукты:
 */

const document = makeDocument('Как я провел лето', 'Много текста');
const product = makeProduct(document, 100);

// А дальше все по аналогии.

/***@@
 Рассмотрим задачу представления отрезков на прямой плоскости. Каждый отрезок представляется как пара точек: начало и конец. Он может быть описан, например, так: [(1, 3), (5, 4)]. Это означает, что наш отрезок начинается в точке (1, 3) и заканчивается в точке (5, 4) координатной плоскости.

 В этом задании необходимо разработать абстракцию для работы с отрезками (англ. segment), которая позволяет строить их из точек, извлекать из отрезков составные части (начало или конец сегмента), а также получать текстовое представление сегмента.

 Абстракция заключается в том, что конкретное представление сегмента определяется внутри функций, описывающих работу с отрезками и зависит от создателя библиотеки. С точки зрения клиента библиотеки (кода который ее вызывает), не важно как конкретно устроен сегмент, важно только то, что есть некоторый набор функций (абстракция), позволяющий работать с ним.

 segments.js

 Определите и экспортируйте следующие функции:
 - Конструктор makeSegment, который принимает на вход две точки и возвращает сегмент. Первая точка это начало сегмента, вторая это конец.
 - Селекторы startSegment и endSegment, которые извлекают из сегмента его начальную и конечную точку соответственно.
 - Вспомогательную функцию segmentToString, которая возвращает текстовое представление сегмента: [(1, 2), (-4, -2)].
 - Функцию midpointSegment, которая находит точку на середине отрезка по формулaм: x = (x1 + x2) / 2 и y = (y1 + y2) / 2.

 Пример использования абстракции:
 */

import { makePoint, getX, getY, toString as pointToString } from 'hexlet-points';

// не важно, чем является segment с точки зрения реализации, главное, что с ним можно
// работать используя функции для работы с сегментами
const segment = makeSegment(makePoint(1, 2), makePoint(-4, -2));
console.log(segmentToString(segment)); // [(1, 2), (-4, -2)]

const point1 = startSegment(segment);
console.log(pointToString(point1)); // (1, 2)

const point2 = endSegment(segment);
console.log(pointToString(point2)); // (-4, -2)

pointToString(startSegment(segment)) === pointToString(makePoint(1, 2)); // true

pointToString(midpointSegment(segment)); // (-1.5, 0)

/**
 Поскольку на текущий момент мы знакомы только с парами для работы с составными данными, то и реализация сегментов должна быть основана на них.

 Описание функции toString (в коде она импортирована под псевдонимом pointToString) из библиотеки hexlet-points можно посмотреть в файле документации docs/hexlet-points.md
 */


// FILE: segments.js:
import {
    makePoint, getX, getY, toString as pointToString,
} from 'hexlet-points';
import { cons, car, cdr } from 'hexlet-pairs';

export const makeSegment = (point1, point2) => cons(point1, point2);

export const startSegment = segment => car(segment);

export const endSegment = segment => cdr(segment);

export const segmentToString = segment => `[${pointToString(startSegment(segment))}, ${pointToString(endSegment(segment))}]`;

export const midpointSegment = (segment) => {
    const startPoint = startSegment(segment);
    const endPoint = endSegment(segment);
    const x = (getX(startPoint) + getX(endPoint)) / 2;
    const y = (getY(startPoint) + getY(endPoint)) / 2;

    return makePoint(x, y);
};




// >>>>> Барьеры абстракции <<<<<

/**
 Идея абстракции данных состоит в том, чтобы определить для каждого типа объектов данных набор базовых операций, через которые будут выражаться все действия с объектами этого типа. Если представить эту идею графически, то мы можем увидеть следующую картину:

 На самом верхнем уровне находятся программы, которые используют наши графические примитивы и делают это на максимально высоком уровне. Далее мы определяем графические примитивы уже в терминах функций для доступа к более низкому уровню. Например, у нас есть функции distance и makeSegment, которые работают с отрезками и обращаются к точкам. А точки, в свою очередь, построены на парах. При этом любой части программы на любом уровне всё равно, как устроены пары, от этого ничего не должно поменяться. При этом, конечно, абстракция может "протекать". Это означает, что более высоким уровням приходится напрямую обращаться к более низким, минуя расположенные между ними уровни. Например, программа пытается пользоваться точками как парами. В таких случаях принято считать, что абстракция не очень хороша, и это приводит к проблемам в дальнейшем при модификации программы.

 Барьеры абстракции в современной литературе часто именуют другим термином — принцип одного уровня абстракции. Это означает, что работая в одной предметной области на определенном срезе, оперируют объектами только этого среза, избегая объектов, к нему не относящихся.

 Итак, какие же преимущества нам даёт такой подход, когда мы строим всё независимыми слоями или ярусами? Во-первых, нам проще рассуждать о программе, потому что на том уровне абстракции, на котором мы работаем, мы оперируем небольшим ограниченным набором сущностей, которые к тому же соответствуют одному уровню мышления о них. Во-вторых, нам проще комбинировать разные части программы, склеивая их через определенные нами интерфейсы для получения нового более сложного поведения. И, наконец, нам гораздо проще поддерживать и изменять наши программы, потому что код, отделенный барьером абстракции на определенном уровне, не зависит от реализации более низких уровней. Это позволяет в любой момент переписывать отдельные уровни, например, для большей производительности.

 Когда мы говорили о данных, мы говорили о том, что они реализуются некоторым интерфейсом, набором конструкторов и селекторов. Но, строго говоря, этого определения недостаточно, потому что структура данных реализуется не любым набором конструкторов и селекторов, они должны быть связаны между собой определенным образом. Формально можно сказать так: для любых x и y, если p есть точка makePoint(x, y), (getX(p), getY(p)) является точкой (x, y). Такое определение оказывается крайне простым, если просто подумать о нем логически: положенное в конструктор должно быть получено селекторами. Если это правило выполняется, то можно сказать, что мы имеем некоторые данные, с которыми мы можем работать, и они будут вести себя предсказуемым образом. По сути, у нас есть правило (может быть даже не одно), которое описывает связи между данными.

 Увеличение уровня абстракции и разделения уровней абстракции позволяет
 > упростить мыслительный процесс при рассмотрении данных
 > упростить комбинирование различных данных или частей программы

 При движении от пар к точкам, отрезкам и далее, к более сложным объектам, в какую сторону мы двигаемся по воображаемой «лестнице» абстракции?
 > вверх, повышая уровень абстракции
 */

/**@@
 rectangles.js
 Реализуйте абстракцию (набор функций) для работы с прямоугольником, стороны которого всегда параллельны осям. Прямоугольник может располагаться в любом месте координатной плоскости.

 При такой постановке задачи достаточно знать только три параметра для однозначного задания прямоугольника на плоскости: координаты левой-верхней точки, ширину и высоту. Зная их, мы всегда можем построить прямоугольник одним единственным способом.
 |
 4 |    точка   ширина
 |       *-------------
 3 |       |            |
 |       |            | высота
 2 |       |            |
 |       --------------
 1 |
 |
 ------|---------------------------
 0 |  1   2   3   4   5   6   7
 |
 |
 |

 Основной интерфейс:
 makeRectangle (конструктор) - создаёт прямоугольник. Принимает параметры: левую-верхнюю точку, ширину и высоту.
 Селекторы getStartPoint, getWidth и getHeight

 Вспомогательные функции для выполнения расчетов:

 square - возвращает площадь прямоугольника (a * b).
 perimeter - возвращает периметр прямоугольника (2 * (a + b)).
 containsTheOrigin - проверяет, принадлежит ли центр координат прямоугольнику (не лежит на границе прямоугольника, а находится внутри). Чтобы в этом убедиться, достаточно проверить, что все вершины прямоугольника лежат в разных квадрантах (их можно вычислить в момент проверки).
 Так как это интерфейсные функции, то они должны быть экспортированы. Если этого не сделать, система модулей js не даст ими воспользоваться.
 */

// Создание прямоугольника:
// p - левая верхняя точка
// 5 - ширина
// 4 - высота
//
// p    5
// -----------
// |         |
// |         | 4
// |         |
// -----------

const p = makePoint(0, 1);
const rectangle = makeRectangle(p, 5, 4);

// Вычисление площади прямоугольника
square(rectangle); // 20;

perimeter(rectangle); // 18
containsTheOrigin(rectangle); // false

const rectangle02 = makeRectangle(makePoint(-4, 3), 5, 4);
containsTheOrigin(rectangle02); // true

containsTheOrigin(makeRectangle(makePoint(-4, 4), 5, 2)); // false
containsTheOrigin(makeRectangle(makePoint(-4, 3), 2, 8)); // false



// >>>>>> Реализация пар <<<<<<

/**
 Вот мы и подобрались к тому, чтобы рассмотреть пары поподробнее и понять, как они устроены внутри. Давайте ещё раз вспомним, что такое пара и какие условия должны быть соблюдены для того, чтобы выполнялись наши требования к данным:
 */
const pair = cons(a, b);

a === car(pair); // true
b === cdr(pair); // true

/**
 Итак, пара — это соединение a и b, при этом a мы получаем через car, b — через cdr; a и b — это какие-то другие данные и они тоже могут быть парами. По сути, пара — это конструктор, селекторы и правила, которые определяют соотношения между конструктором, селекторами и данными.
 */

const cons = (a, b) => (message) => {
    switch (message) {
        case 'car':
            return a;
        case 'cdr':
            return b;
    }
};

const car = (pair) => pair('car');
const cdr = (pair) => pair('cdr');

/**
 Начнем с определения cons: это функция, которая принимает a и b, а внутри (и тут самое удивительное) содержит другую функцию, которая будет возвращена наружу. Внутри этой другой функции мы делаем switch, и если message равен 'car', возвращаем a, если 'cdr' — возвращаем b. Итак, в результате создания пары снаружи оказывается функция. Как же она работает? Очень просто: селекторы принимают пару и вызывают её как функцию, передавая в неё соответствующие сообщения. Если это селектор car, то передается сообщение 'car', если селектор cdr — то 'cdr'. А поскольку пара — это функция, которая принимает сообщение, то мы получаем то или иное значение в зависимости от переданного сообщения. Значения же сохраняются во внутренней функции за счёт замыкания.

 Для примера давайте представим, что мы определяем внутреннюю функцию руками для конкретных a и b:
 */

const pair = cons(4, 5);
// const pair = (message) => {
//   switch (message) {
//     case 'car':
//       return a;
//     case 'cdr':
//       return b;
//   }
// };

car(pair); // 4
// pair('car');



/**
 В этом примере мы можем представить, что пара — это функция, которая принимает сообщение, и если сообщение равно 'car', то возвращает 4, если 'cdr' — возвращает 5. Вызывая селектор car c аргументом pair, мы внутри вызываем эту функцию с сообщением 'car'.

 Возможно, такое определение пар вас шокирует, ведь мы в нём не используем ничего, кроме функций и свойства замыкания. Тем не менее, это вполне рабочий и адекватный способ определять структуры данных. Есть несколько причин, по которым мы именно так реализовали пары.

 Во-первых, языки программирования вполне могли бы реализовывать (а некоторые, возможно, реализуют) свои структуры данных таким образом. Вы об этом наверняка не знаете, но гарантировано, если бы это был эффективный способ, то им бы и пользовались. Скорее всего, он не очень эффективный, но показывает, что нет никаких ограничений.

 Во-вторых, это отличная иллюстрация того, каким мощным инструментом являются функции, когда они используются как объекты первого класса. Это позволяет строить очень компактные, лаконичные, но при этом насыщенные смыслом программы из простых компонентов, постепенно усложняя поведение. Дополнительно мы увидели такой механизм, как передача сообщений, когда мы не просто вызываем какую-то функцию, а передаем туда сообщение. На данный момент мы не будем подробно разбирать эту технику, но в будущем она будет иметь огромное значение как один из элементов так называемого объектно-ориентированного программирования, о котором мы будем говорить позже.

 И, наконец, такой подход, выбранный нами для обучения, очень сильно влияет на развитие функционального мышления, что позволяет легче понимать то, как соединять между собой части и учиться мыслить гораздо более абстрактно. Обычно при классическом обучении происходит смещение в императивную область, из-за чего люди лишены возможности глубокого понимания того, как писать модульные программы без необходимости дублировать код. И функциональное мышление вам в этом крайне сильно поможет.
 */

/**@@
 Рассмотренный в уроке способ создания пар не является единственным возможным, даже если мы говорим только о реализации на функциях.

 pairs.js
 Напишите и экспортируйте функции car и cdr, основываясь на реализации функции cons:
 */

const cons = (x, y) => f => f(x, y);

// При таком определении как выше, пара будет представлять из себя функцию f => f(x, y). Например:
const pair = cons(5, 3);
// const pair = f => f(5, 3);

/**
 Теперь догадаться до решения не так уж и сложно. По сути car и cdr должны вызвать внутри себя pair (ведь это функция, не забыли?), и передать туда функцию, которая в зависимости от ситуации вернет либо первый, либо второй аргумент.
 */
export const cons = (x, y) => f => f(x, y);

export const car = z => z(x => x);
export const cdr = z => z((x, y) => y);

/**@@
 Рациональное число — число, представляемое обыкновенной дробью m/n, числитель m — целое число, а знаменатель n — натуральное число. Пример рационального числа: 2/3.

 Формулы
 Сложение
 a/b + c/d = (a * d + b * c) / (b * d)
 Вычитание
 a/b - c/d = (a * d - b * c) / (b * d)
 Умножение
 a/b * c/d = (a * c) / (b * d)
 Деление
 a/b / c/d = (a * d) / (b * c)
 Равенство
 a/b = c/d, если a * d = c * b
 rational.js
 Реализуйте абстракцию для работы с рациональными числами, используя пары:

 Конструктор make(numer, denom).
 Селекторы numer (числитель) и denom (знаменатель).

 Функцию toString, возвращающую строковое представление рационального числа. Например для дроби 3/4 созданной так make(3, 4), строковым представлением будет 3 / 4.

 Предикат isEqual, проверяющую равенство двух рациональных чисел. Например isEqual(make(1, 2), make(2, 4)).

 Функцию add, выполняющую сложение дробей.
 Функцию sub, выполняющую вычитание дробей.
 Функцию mul, выполняющую умножение дробей.
 Функцию div, выполняющую деление дробей.

 Экспортируйте созданные функции.

 Обратите внимание, что результатом любой арифметической операции над рациональным числом будет рациональное число.

 Примеры
 */
const rat1 = make(2, 3);
const rat12 = make(4, 6);
const rat2 = make(7, 2);

toString(rat12); // '4 / 6'
isEqual(rat1, rat12); // true

add(rat1, rat2); // 25/6
sub(rat2, rat1); // 17/6
mul(rat1, rat2); // 14/6
div(rat1, rat2); // 4/21

import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs';

// BEGIN (write your solution here)

// END


/***@@
 Пары неотрицательных целых чисел можно представить числами и арифметическими операциями. Можно считать, что пара чисел a и b – это 2^a * 3^b.

 Функции car и cdr при этом будут просто вычислять значения a и b (кратности двойки и тройки, соответственно), раскладывая аргумент на множители.

 Например, имея пару 5, 8 в виде числа 209952 (2^5 * 3^8), можно получить первый элемент пары, разложив число на множители и вычислив факторизацию для числа 2, а второй элемент пары – разложив число на множители и вычислив факторизацию для числа 3.

 pairs.js
 Реализуйте и экспортируйте следующие функции в соответствии с алгоритмом выше:

 cons
 car
 cdr
 Пример:
 */

const pair = cons(5, 8); // => 2^5 * 3^8 = 209952
car(pair); // 5
cdr(pair); // 8

/**
 Подсказки
 Пара – это число, поэтому, чтобы получить из него исходные значения a и b, нужно раскладывать число на множители.
 */

const factor = (base, value) => {
    if (value % base !== 0) {
        return 0;
    }

    return 1 + factor(base, value / base);
};

export const cons = (a, b) => (2 ** a) * (3 ** b);
export const car = pair => factor(2, pair);
export const cdr = pair => factor(3, pair);



/***@@
 Кроме пар можно создавать абстрактные типы данных, которые содержат внутри себя три и более элемента.

 В данном испытании необходимо реализовать структуру данных тройка, позволяющую хранить три значения. Как и в случае с парами создаётся конструктор make и селекторы get1, get2, get3, которые будут извлекать соответствующие значения.

 triple.js
 Реализуйте и экспортируйте следующие функции:

 make
 get1
 get2
 get3
 Пример
 */

const triple = make(3, 5, 'I am element from triple');
get1(triple); // 3
get2(triple); // 5
get3(triple); // I am element from triple


// FILE: /app/triple.js:
/** eslint default-case: 0, consistent-return: 0 */

// BEGIN (write your solution here)
export const make = (a, b, c) => (
    (message) => {
        switch (message) {
            case 'get1':
                return a;
            case 'get2':
                return b;
            case 'get3':
                return c;
        }
    }
);

export const get1 = triple => triple('get1');

export const get2 = triple => triple('get2');

export const get3 = triple => triple('get3');
// END



// #TESTS FILE: /app/__tests__/triple.test.js:
import {
    make,
    get1,
    get2,
    get3,
} from '../triple';

test('triple', () => {
    const triple = make(1, 2, 3);
    expect(get1(triple)).toBe(1);
    expect(get2(triple)).toBe(2);
    expect(get3(triple)).toBe(3);
});

test('triple in triple', () => {
    const triple1 = make(14, 22, 32);
    const triple2 = make(11, 12, triple1);
    expect(get1(triple2)).toBe(11);
    expect(get2(triple2)).toBe(12);
    expect(get3(triple2)).toBe(triple1);
});

test('triple string', () => {
    const triple = make('str', 44);
    expect(get1(triple)).toBe('str');
    expect(get2(triple)).toBe(44);
    expect(get3(triple)).toBe(undefined);
});


/***@@
 Пару можно создать на основе строки. Для хранения двух значений применим разделитель. Им может выступить любой символ, однако во избежание совпадений с исходными данными лучше взять редко используемое значение.

 Для этого подойдёт так называемая управляющая или escape-последовательность, которая начинается с обратной косой черты. Мы будем использовать специальный символ \0, обозначающий нулевой символ (NUL).

 Функции car и cdr должны получить содержимое строки до и после разделителя соответственно.

 Управляющая последовательность воспринимается интерпретатором как одиночный символ, т.е. имеет длину, равную 1.

 Обязательным условием является отсутсвие данного символа в строках, которые объединяются в пару.

 pairs.js
 Реализуйте и экспортируйте следующие функции в соответствии с алгоритмом выше:

 cons
 car
 cdr
 Пример
 */

const pair = cons('computer', 'science');   // => computer\0science
car(pair); // computer
cdr(pair); // science

/**
 Подсказки
 Для подсчёта длины строки используйте функцию length() из модуля strings.
 */

// FILE: /app/pairs.js:
import length from './strings';

const separator = '\0';

const getSeparatorPosition = (str) => {
    const iter = i => (str[i] === separator ? i : iter(i + 1));

    return iter(0);
};

const getValue = (pair, begin, end) => {
    const iter = (acc, i) => {
        if (i >= end) {
            return acc;
        }

        const newAcc = `${acc}${pair[i]}`;

        return iter(newAcc, i + 1);
    };

    return iter('', begin);
};

export const cons = (a, b) => `${a}${separator}${b}`;
export const car = pair => getValue(pair, 0, getSeparatorPosition(pair));
export const cdr = pair => getValue(pair, getSeparatorPosition(pair) + 1, length(pair));


// #TESTS FILE: /app/__tests__/pairs.test.js:
import { cons, car, cdr } from '../pairs';

describe('Pairs', () => {
    it('1 set', () => {
        const pair = cons(0, 0);
        expect(pair).toBe(1);
        expect(car(pair)).toBe(0);
        expect(cdr(pair)).toBe(0);
    });

    it('2 set', () => {
        const pair = cons(1, 2);
        expect(pair).toBe(18);
        expect(car(pair)).toBe(1);
        expect(cdr(pair)).toBe(2);
    });

    it('3 set', () => {
        const pair = cons(2, 1);
        expect(pair).toBe(12);
        expect(car(pair)).toBe(2);
        expect(cdr(pair)).toBe(1);
    });

    it('4 set', () => {
        const pair = cons(5, 8);
        expect(pair).toBe(209952);
        expect(car(pair)).toBe(5);
        expect(cdr(pair)).toBe(8);
    });

    it('5 set', () => {
        const pair = cons(0, 0);
        const transit = cons(1, 1);
        expect(pair).toBe(1);
        expect(car(pair)).toBe(0);
        expect(cdr(pair)).toBe(0);
        expect(car(transit)).toBe(1);
        expect(cdr(transit)).toBe(1);
    });
});



// #TESTS FILE: /app/__tests__/pairs.test.js:
import { cons, car, cdr } from '../pairs';

describe('Pairs on strings', () => {
    it('1 set', () => {
        const pair = cons('hi', 'hexlet');
        expect(car(pair)).toBe('hi');
        expect(cdr(pair)).toBe('hexlet');
    });

    it('2 set', () => {
        const pair = cons('Hello!', '');
        expect(car(pair)).toBe('Hello!');
        expect(cdr(pair)).toBe('');
    });

    it('3 set', () => {
        const pair = cons('', 'XXI');
        expect(car(pair)).toBe('');
        expect(cdr(pair)).toBe('XXI');
    });
});





// ############################### JS: Последовательности ###############################

// >>>>>> Введение <<<<<<

/**
 Документация функций по работе с парами https://github.com/hexlet-components/js-pairs/tree/master/docs

 Последовательность — упорядоченная совокупность объектов данных. Совокупность — некая единая сущность. Данные — любая информация: числа, строки, составные объекты вроде пар и так далее.

 Некоторые разделы математики сфокусированы на последовательностях чисел.
 */



// >>>>>> Представление последовательностей <<<<<<

/**
 Пары и списки
 В этом уроке мы реализовали абстрактный тип данных Список на основе ранее пройденных пар. Ключевой особенностью списка является его интерфейс, а именно функции, реализующие такие операции, как "получить голову" (возвращает первый элемент списка), "получить хвост" (возвращает новый список, полученный из исходного списка отсечением у него первого элемента), "добавить новую голову" (добавление элемента в начало списка). И здесь следует обратить внимание на несколько вещей.

 Во-первых, не стоит отождествлять между собой пары и списки. Пары в данном случае были использованы как подходящий инструмент для создания списка. Абстрактный список (см. первый абзац) может быть реализован в конкретных структурах данных. В нашем случае это односвязный список. Важной характеристикой этой структуры данных является то, что каждый элемент списка, помимо определённого хранимого значения (числа, строки, даты, адреса, имени и любой другой информации), содержит ссылку на другой такой же по структуре элемент. Таким образом, между элементами списка существует связь, и мы можем последовательно "путешествовать" (перемещаться) от текущего элемента к следующему, от начала списка к его концу.

 И, как видим, пары вполне позволяют реализовать особенности списка как структуры данных. Ведь пара, помимо основного значения, может содержать ещё другую пару аналогичной структуры (значение + ссылка на другую пару) — и такая последовательность может длиться бесконечно.
 */

import { cons, toString } from 'hexlet-pairs';

const(5, 8);

const pair = cons(5, cons(2, 9));
toString(pair); // (5, (2, 9))

cons(1, cons(2, cons(3, cons(4, cons(5, ...
    cons('one', cons('two', cons('three', cons('four', cons('five', ...


        /**
         Однако, надо понимать, что сделать это можно не только с помощью пар. Представимы списки на основе массивов, а также некоторых других типов данных. Поэтому, если мы пользуемся списком, то к нему нельзя напрямую применять функции по работе с парами даже если мы знаем, что данный конкретный список состоит из пар. Для этого вводятся специальные функции для работы со списками, учитывающие его внутреннюю реализацию, которая может изменяться.

         Во-вторых, коль скоро мы реализовали список именно на основе пар, то следует понимать, что не каждая пара, с которой мы имеем дело, какой бы «сложной» она ни была, является списком. У списка есть начало и конец, и мы должны иметь возможность последовательно перемещаться от одного элемента к другому. Для того, чтобы понять, что мы достигли последнего элемента списка и перемещаться дальше уже нет смысла, мы вводим специальный маркер конца списка — пустую пару l(). По предварительному соглашению в роли маркера могут также выступать другие подходящие значения, например, null. Как только мы встречаем очередную пару, в cdr которой находится пустая пара, это означает, что очередное значение списка, лежащее в car пары, является последним элементом списка. Отметим также, что у пустого списка (списка, в котором нет ни одного элемента) не может быть ни головы, ни хвоста. Поэтому соответствующие операции, примененные к пустому списку (взятие head или tail), приводят к возникновению ошибки. Чтобы её избежать, вводят функцию для проверки списка на «пустоту» (например, isEmpty), а далее берут голову или хвост у списка, предварительно убедившись, что он не является пустым.

         Ниже приведены примеры пар, которые нельзя назвать списками. Они не реализуют требования, предъявляемые к односвязным спискам: в них отсутствует последовательная связь между элементами и/или нет маркера конца списка:
         */

        cons(1, cons(cons(3, null), 2));
cons(1, cons(2, cons(3, 4)));
cons(cons(1, 2), cons(3, cons(4, null)));

// Теперь покажем пары, которыми мы можем смело пользоваться как списками:

cons(1, cons(2, cons(3, null)));
cons('This', cons('is', cons('a', cons('list', null))));

/**
 # l() - отвлекаемся от деталей и повышаем уровень абстракции

 В уроке мы отметили, что следующие две записи, конструирующие список, являются эквивалентными:
 */

import {l, cons, head, tail, isEmpty, toString} from 'hexlet-pairs-data';

const list = l(1, 2, 3 , 4); // -> cons(1, cons(2, cons(3, cons(4, null)))) -> (1, 2, 3, 4, 5)
cons(10, list); // (10, 1, 2, 3, 4)
toString(list) // => (1, 2, 3 , 4)

head(list); // => 1
tail(list); .. l(2, 3, 4)

isEmpty(l(4)); // => false
isEmpty(l()); // => true

/**
 Для генерации списка мы создали функцию l, несмотря на то, что у нас уже есть конструктор cons. Это необходимо по нескольким причинам. Отметим наиболее важные из них:

 Выделив код создания списка в отдельную функцию и дав ей имя l (сокращ. от list), мы ввели отдельную и понятную абстракцию, отвечающую за создание списков (и ничего другого!). Выше говорилось, что списки могут быть реализованы не только на парах, но и на массивах, а также других типах данных. Так вот, наша абстракция l позволяет отвлечься от внутреннего устройства списка. Тот, кто будет пользоваться этой функцией, не обязан знать, какими способами она конструирует список, а в случае необходимости может изменить его внутреннее устройство "незаметно и безболезненно" для пользователей l.
 Хорошая абстракция делает код более понятным и повышает его читабельность. Теперь, видя в коде l, мы однозначно понимаем, что здесь происходит. Тогда как в ином случае, цепляясь глазом за множественные, разбросанные среди строк cons, мы каждый раз должны будем определять, что же делает данная конкретная пара: то ли создаёт список, то ли хранит временные данные, то ли печёт пирожки ?! ;)

 Посмотрите на «безликие» нагромождения пар, создающие разные сущности, которые мы проходили в прошлых курсах. Только комментарии помогают понять, что здесь происходит.
 */
cons(5, cons(2, cons(7, cons(11, cons(6, cons(14, null)))))); // создание списка
cons(3, 17); // создание точки
cons(8, 17); // создание рационального числа
cons(cons(3, 33), cons(-2, -22)); // создание сегмента (отрезка)
const rectangle = cons(cons(-2, 23), cons(5, 11)); // создание прямоугольника
2 * (car(cdr(rectangle)) + cdr(cdr(rectangle))); // вычисление периметра прямоугольника

// А вот как выглядит код с введёнными абстракциями. Комментарии здесь уже не нужны:

list(5, 2, 7, 11, 6, 14);
makePoint(3, 17);
makeRational(8, 17);
makeSegment(makePoint(3, 33), makePoint(-2, -22));
const point = makePoint(-2, 23);
const rectangle = makeRectangle(point, 5, 11);
perimeter(rectangle);


// Естественно, введение функции устраняет дублирование кода. Каждый раз писать при создании списка такое нагромождение кода в виде вложенных cons, демонстрируя при этом все внутренности создаваемой конструкции, — не лучший стиль написания кода.

const { l, head, tail } = require('hexlet-pairs-data');

const list = l(5, 3, 9);
console.log(head(tail(list)));


/**@@
 Все создаваемые функции, в рамках этого задания, должны быть реализованы независимо друг от друга, то есть их нельзя использовать для реализации друг друга.

 list.js
 Реализуйте и экспортируйте функцию has, которая проверяет, является ли переданное значение элементом списка.
 */
const numbers = l(3, 4, 5, 8);
has(numbers, 8); // true
has(numbers, 0); // false
// Реализуйте и экспортируйте функцию reverse, которая переворачивает список, используя итеративный процесс.

const numbers = l(3, 4, 5);
reverse(numbers); // (5, 4, 3)

// Реализуйте и экспортируйте функцию concat, которая соединяет два списка, используя рекурсивный процесс (попробуйте сначала представить, как работала бы функция copy, которая принимает на вход список и возвращает его копию).

const numbers = l(3, 4, 5, 8);
const numbers2 = l(3, 2, 9);
concat(numbers, numbers2); // (3, 4, 5, 8, 3, 2, 9)

import { l, cons, head, tail, isEmpty, toString as listToString } from 'hexlet-pairs-data';

export const has = (list, element) => {
    if (isEmpty(list)) {
        return false;
    }

    if (head(list) === element) {
        return true;
    }

    return has(tail(list), element);
};

export const reverse = (list) => {
    const iter = (items, acc) => (
        isEmpty(items) ? acc : iter(tail(items), cons(head(items), acc))
    );

    return iter(list, l());
};

export const concat = (list1, list2) => {
    if (isEmpty(list1)) {
        return list2;
    }

    return cons(head(list1), concat(tail(list1), list2));
};




// >>>>>>> Разметка <<<<<<

import {
    make, append, toString, node
} from 'hexlet-html-tags';

const html1 = make();
const html2 = append(html1, node('h1', 'hexlet'));
const p1 = node('p', 'hello, world');
const html3 = append(html2, p1);

toString(html3);
// <h1>hexlet</h1>
// <p>hello, world</p>


/***@@
 html-tags.js
 Реализуйте абстракцию для создания html. Она включает в себя следующие функции:

 make — конструктор. Уже реализован. Не принимает параметров, и создает html-список.
 node — создает новый тег. Содержит два элемента, имя тега и его содержимое. Дополнительно реализуйте селекторы тега: name и value.
 const tag = node('div', 'what is love?');
 getName(tag); // => div
 getValue(tag); // => what is love?
 append — добавляет элемент (тег), созданный с помощью node, в html-список. Возвращает новый html-список. Новый элемент должен добавляться в начало ("голову") списка.
 toString — возвращает текстовое представление html на основании html-списка.
 Пример использования этого интерфейса:
 */
import { make, append, toString, node } from './html-tags';

// Создаем новый html-список
const dom1 = make();

// Создаем тег и сразу добавляем его в html
const dom2 = append(dom1, node('h1', 'hello, world'));
// Еще раз
const dom3 = append(dom2, node('h2', 'header2'));

// Создаем новый тег
const tag = node('h3', 'header3');
// Добавляем созданный тег в html-список
const dom = append(dom3, tag);

// Преобразуем html-список в строчку
toString(dom);
// => <h1>hello, world</h1><h2>header2</h2><h3>header3</h3>

// Пример без создания промежуточных переменных
toString(append(make(), node('p', 'this is Sparta!')));
// <p>this is Sparta!</p>

// Экспортируйте все созданные функции.

// FILE: /src/html-tags.js:
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs';

import { l, isEmpty, head, tail, cons as consList, toString as listToString } from 'hexlet-pairs-data';

export const make = () => l();

export const append = (dom, element) => consList(element, dom);

export const node = (tag, content) => cons(tag, content);

export const getName = element => car(element);
export const getValue = element => cdr(element);

export const toString = (elements) => {
    if (isEmpty(elements)) {
        return '';
    }

    const element = head(elements);
    const tag = getName(element);

    return `${toString(tail(elements))}<${tag}>${getValue(element)}</${tag}>`;
};




// >>>>>> Отображение списков <<<<<<

/**
 map — функция для преобразования списков. Это функция высшего порядка. У неё два аргумента:
 1. Функция, преобразующая элемент
 2. Список (набор элементов)

 С функцией map мы добились следующих преимуществ:

 - Код стал универсальным: не нужно делать кучу отдельных функций для каждого вида преобразования
 - Код абстрагирован от структуры информации
 - Код декларативный, и как результат — решение менее хрупкое, без изменяемого состояния
 */
[1, 2, 3].map(x => 10 * x);

// Сравните с императивным решением:
const result = [];

for (let i of [1,2,3]) {
    result.push(i * 10);
}

/**
 В императивном подходе описан набор шагов для достижения результата. В декларативном стиле описан сам результат. Такая запись по сути является спецификацией.

 Мы выходим на новый уровень абстракции: map создал новый барьер абстракции, отделяющий нас от деталей и особенностей реализации.

 Map (отображение) — универсальная абстракция. В каждом языке есть перечислимые типы данных: например, массивы или списки, и для них почти наверняка есть встроенная функция map. Она работает всегда одинаково. Принимает на вход коллекцию и функцию-трансформер, которая берет элемент и возвращает его преобразование (конкретное действие зависит от конкретной ситуации). Различается только способ вызова и иногда порядок аргументов. То же самое касается и любой абстракции, построенной поверх коллекций. Все, что может быть перечислено, может быть отображено. Неизменным в этих отображениях всегда остается количество элементов. Отображенная коллекция элементов всегда такого же размера, как и исходная.

 # Пример
 */
import { l, map, toString } from 'hexlet-pairs-data';

const list = l(4, 16, 64);
const list2 = map(Math.sqrt, list);
console.log(toString(list2));

const list3 = map(item => item + 5, list);
console.log(toString(list3));


/***@@
 html-tags.js
 Реализуйте и экспортируйте функцию map для библиотеки html-tags. Реализация должна быть построена с использованием итеративного процесса (без циклов, на основе рекурсии). Эта функция подобна той что описывалась в теории для списков, только текущая реализация работает с html-списком. Параметры и их порядок у функций аналогичный. Первый — функция-трансформер, второй — коллекция (в нашем случае список html-тегов).
 */

import { make, append, node, value, is } from 'hexlet-html-tags';

const dom1 = make();
const dom2 = append(dom1, node('h1', 'scheme'));
const dom3 = append(dom2, node('p', 'is a lisp'));

// Отображение в результате которого в html-списке заменяются теги h1 на теги h2
const processedDom = map((element) => {
    if (is('h1', element)) {
        return node('h2', value(element));
    }

    return element;
}, dom3);


// Реализуйте и экспортируйте функцию mirror, которая переворачивает содержимое тегов, так чтобы читать его нужно было справа налево, а не слева направо.

import { make, append, node, value, is, toString as htmlToString } from 'hexlet-html-tags';

const dom1 = make();
const dom2 = append(dom1, node('h1', 'scheme'));
const dom3 = append(dom2, node('p', 'is a lisp'));

// <h1>emehcs</h1>
// <p>psil a si</p>
htmlToString(mirror(dom3));

/**
 Экспортируйте все созданные функции.

 Примечание
 Функцию b2p можно использовать для наглядного сопоставления частного варианта операции отображения с обобщённой реализацией операции отображения (собственно, map).

 Подсказки
 Функция reverseStr (псевдоним функции reverse из модуля по работе со строками strings) делает переворот строки.
 При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-html-tags и использовать её для отладки решений. Эта функция возвращает строковое представление html-списка
 Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */

// FILE: /app/html-tags.js:
import {
    l, isEmpty, head, tail, cons, reverse
} from 'hexlet-pairs-data';

import {
    getName, getValue, node, is
} from 'hexlet-html-tags';

import { reverse as reverseStr } from './strings';

// Рекурсивный процесс
// export const map = (func, elements) => {
//   if (isEmpty(elements)) {
//     return l();
//   }

//   return cons(func(head(elements)), map(func, tail(elements)));
// };

// Итеративный процесс (рекурсивно)
export const map = (func, elements) => {
    const iter = (items, acc) => {
        if (isEmpty(items)) {
            return reverse(acc);
        }

        return iter(tail(items), cons(func(head(items)), acc));
    };

    return iter(elements, l());
};

export const mirror = elements => (
    map(element => node(getName(element), reverseStr(getValue(element))), elements)
);

export const b2p = (elements) => {
    if (isEmpty(elements)) {
        return l();
    }

    let newElement;
    const element = head(elements);
    if (is('blockquote', element)) {
        newElement = node('p', getValue(element));
    } else {
        newElement = element;
    }

    return cons(newElement, b2p(tail(elements)));
};



// >>>>>> Фильтрация списков <<<<<<

/**
 filter — функция для фильтрации списков. Например, её можно использовать для удаления из списка HTML-элементов всех элементов-заголовков. Фильтр не делает никаких преобразований самих элементов.

 Аналогично функции map, функция filter принимает два аргумента:
 1. Функция-предикат
 2. Список (набор элементов)

 Функция-предикат принимает элемент и возвращает true или false в зависимости от того, следует ли сохранять элемент в итоговом списке или нет.

 # Пример
 */
import { l, filter, toString } from 'hexlet-pairs-data';

const list = l('', 0, 10, 'go go', -5, 'string');
const list2 = filter(Number.isInteger, list);
console.log(toString(list2));

const list3 = filter(item => typeof item === 'string', list);
console.log(toString(list3));



/***@@@
 html-tags.js
 Реализуйте и экспортируйте функцию filter для библиотеки html-tags, используя итеративный процесс:
 */
import { node, append, make, filter, toString as htmlToString } from 'hexlet-html-tags';

const html1 = append(make(), node('h1', 'header1'));
const html2 = append(html1, node('h1', 'header2'));
const html3 = append(html2, node('p', 'content'));

const processedHtml = filter((element) =>
    !is('h1', element), html3);

//<p>content</p>
htmlToString(processedHtml);

// Реализуйте и экспортируйте функцию quotes, которая извлекает из html тексты цитат и возвращает список цитат.

import { toString as pairToString } from 'hexlet-pairs-data';
import { make, append, node } from 'hexlet-html-tags';

const dom1 = make();
const dom2 = append(dom1, node('h1', 'scheme'));
const dom3 = append(dom2, node('p', 'is a lisp'));
const dom4 = append(dom3, node('blockquote', 'live is life'));
const dom5 = append(dom4, node('blockquote', 'i am sexy, and i know it'));

listToString(quotes(dom5)); // ('i am sexy, and i know it', 'live is life');

/**
 Примечание
 Функцию removeHeaders можно использовать для наглядного сопоставления частного варианта операции фильтрации с обобщённой реализацией операции отображения (собственно, filter).

 Подсказки
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-html-tags и использовать её для отладки решений. Эта функция возвращает строковое представление html-списка
 - Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */

// FILE: /app/html-tags.js:
import {
    l, isEmpty, head, tail, cons, reverse,
} from 'hexlet-pairs-data';

import { getValue, is, map } from 'hexlet-html-tags';


export const filter = (func, elements) => {
    const iter = (items, acc) => {
        if (isEmpty(items)) {
            return reverse(acc);
        }

        const item = head(items);
        const newAcc = func(item) ? cons(item, acc) : acc;

        return iter(tail(items), newAcc);
    };

    return iter(elements, l());
};

export const quotes = (elements) => {
    const filtered = filter(element => is('blockquote', element), elements);
    const result = map(getValue, filtered);

    return result;
};


export const removeHeaders = (elements) => {
    if (isEmpty(elements)) {
        return l();
    }

    const element = head(elements);
    const tailElements = tail(elements);

    if (is('h1', element)) {
        return removeHeaders(tailElements);
    }

    return cons(element, removeHeaders(tailElements));
};




// >>>>>> Свертка <<<<<<
import { l, cons, reduce, toString, head } from 'hexlet-pairs-data';

const list = l(0, -10, 2, 38, 2, -2);
const list2 = reduce(Math.max, head(list), list);
console.log(toString(list2));

const list3 = reduce((item, acc) => item + acc, 0, list);
console.log(toString(list3));


/***@@@
 html-tags.js
 Реализуйте и экспортируйте функцию reduce для библиотеки html-tags:
 */
import { node, append, make, reduce } from 'hexlet-html-tags';

const html1 = append(make(), node('h1', 'header1'));
const html2 = append(html1, node('h1', 'header2'));
const html3 = append(html2, node('p', 'content'));

reduce((element, acc) => {
    return is('h1', element) ? acc + 1 : acc;
}, 0, html3); // 2

// Реализуйте и экспортируйте функцию emptyTagsCount, которая считает количество пустых тегов. Тип тега задается первым параметром функции.

import { make, append, node } from 'hexlet-html-tags';

const html1 = make();
const html2 = append(html1, node('h1', 'scheme'));
const html3 = append(html2, node('p', 'is a lisp'));
const html4 = append(html3, node('blockquote', ''));
const html5 = append(html4, node('blockquote', ''));
const html6 = append(html5, node('blockquote', 'quote'));

emptyTagsCount('blockquote', html6); // 2

/**
 Примечания
 Функцию headersCount можно использовать для наглядного сопоставления частного варианта свёртки с обобщённой реализацией операции отображения (собственно, reduce).

 Подсказки
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-html-tags и использовать её для отладки решений. Эта функция возвращает строковое представление html-списка
 - Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */

// FILE: /app/html-tags.js:
import { isEmpty, head, tail } from 'hexlet-pairs-data';
import { getValue, is } from 'hexlet-html-tags';

export const reduce = (func, acc, elements) => {
    if (isEmpty(elements)) {
        return acc;
    }

    return reduce(func, func(head(elements), acc), tail(elements));
};

export const emptyTagsCount = (tagName, elements) => {
    const predicate = element => is(tagName, element) && getValue(element) === '';
    const func = (element, acc) => (predicate(element) ? acc + 1 : acc);

    return reduce(func, 0, elements);
};

export const headersCount = (tagName, elements) => {
    const iter = (items, acc) => {
        if (isEmpty(items)) {
            return acc;
        }

        const item = head(items);
        const newAcc = is(tagName, item) ? acc + 1 : acc;

        return iter(tail(items), newAcc);
    };

    return iter(elements, 0);
};


/***@@@
 html-tags.js
 Реализуйте и экспортируйте функцию extractHeaders, которая извлекает тексты всех заголовков h2 из переданного html и возвращает html в котором каждый из этих текстов обернут в p.

 Например такой html в строковом представлении <h2>header1</h2><h2>header2</h2><p>content</p> превратится в такой <p>header1</p><p>header2</p>. Ниже развернутый пример.
 */
import { node, append, make, reduce, toString as htmlToString } from 'hexlet-html-tags';

const html1 = append(make(), node('h2', 'header1'));
const html2 = append(html1, node('h2', 'header2'));
const html3 = append(html2, node('p', 'content'));
// => <h2>header1</h2><h2>header2</h2><p>content</p>

htmlToString(extractHeaders(html3));
// => <p>header1</p><p>header2</p>


// Реализуйте и экспортируйте функцию wordsCount, которая считает вхождения слова в определенный тег. Для подсчета слов в тексте одного тега воспользуйтесь вспомогательной функцией wc, которая уже импортирована в модуль html-tags.

import { make, append, node } from 'hexlet-html-tags';

const html1 = append(make(), node('h2', 'header1 lisp'));
const html2 = append(html1, node('p', 'content'));
const html3 = append(html2, node('h2', 'lisp header2 lisp'));
const html4 = append(html3, node('p', 'content lisp'));

wordsCount('h2', 'lisp', html4); // 3

/**
 Подсказки
 Подсчет слов в тексте: wc(word, text), где word искомое слово, а text это текст, в котором ведется поиск.
 */
wc('what', 'what, what, who, what'); // 3
wc('la', 'loli'); // 0

/**
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-html-tags и использовать её для отладки решений. Эта функция возвращает строковое представление html-списка
 - Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */

// FILE: /app/html-tags.js:
import {
    node, getValue, is, map, filter, reduce,
} from 'hexlet-html-tags';

import { wc } from './utils';

export const extractHeaders = (elements) => {
    const filtered = filter(element => is('h2', element), elements);

    return map(element => node('p', getValue(element)), filtered);
};

export const wordsCount = (tagName, word, elements) => {
    const filtered = filter(element => is(tagName, element), elements);
    const values = map(element => getValue(element), filtered);

    return reduce((text, acc) => wc(word, text) + acc, 0, values);
};




// >>>>>> Иерархические структуры <<<<<<

/**
 Обход деревьев — крайне важная тема. Иерархические структуры встречаются на каждом шагу: это и файловая система, и html и даже исходный код большинства языков программирования. Если вы научитесь решать задачи по обходу таких структур, то сможете справиться с большинством стандартных вычислительных задач на своей работе. Это мое мнение, которое подтверждается богатым опытом, но, конечно же, не является истиной в последней инстанции.

 В будущих курсах работа с деревьями будет более плотной, а здесь мы лишь немного познакомимся с ними.

 Начнем с самого простого примера, в котором не требуется накапливать результат. Предположим, что у нас есть список списков любой вложенности, который содержит числа. Все что нужно сделать — узнать, есть ли среди этих чисел хотя бы один ноль. Пример входных данных для подобной функции выглядит так: l(1, l(5, 0), 10, l(l(8), 3)).

 Прежде чем разбирать код, опишем алгоритм, по которому работает функция hasZero:

 - Рекурсивно обходим список:
 -- Если список закончился, а 0 не найден, то возвращаем false (guard expression).
 -- Если текущий элемент — не список, то проверяем, равен ли он нулю.
 -- Если равен нулю, то возвращаем true.
 -- Если текущий элемент — список, то запускаем hasZero рекурсивно, передав туда текущий элемент.
 -- Если результат этого вызова true, то возвращаем true.
 -- Если не сработали предыдущие терминальные условия, проверяем следующий элемент списка.

 Такой обход дерева называется обход в глубину. Сначала мы опускаемся до самого дна самой левой ветки, затем ветки чуть правее и так далее пока не дойдем до конца.
 */

import { l, cons, head, tail, isEmpty, isList, toString } from 'hexlet-pairs-data';

const hasZero = (list) => {
    if (isEmpty(list)) {
        return false;
    }

    const current = head(list);
    const rest = tail(list);

    if (!isList(current)) {
        if (current === 0) {
            return true;
        }
    } else if (hasZero(current)) {
        return true;
    }

    return hasZero(rest);
};

console.log(hasZero(l(1, 3, l(5, l(9), 3), 10)));
console.log(hasZero(l(1, l(l(5, 100), 0), 10)));


/**
 В отличие от плоской рекурсии, древовидная рекурсия требует запуска сразу нескольких веток на исполнение в рамках одного вызова.

 Более интересный и сложный пример связан с агрегацией: посчитать количество чего-либо в дереве или собрать список узлов, соответствующий какому-либо критерию. Общий механизм обхода в этих случаях останется абсолютно тем же, но к нему добавится аккумулятор, который нужно прокидывать до самой глубины. По сути, вся задача сводится к реализации рекурсивного reduce. Ниже код функции searchZeros, которая, в отличие от предыдущей реализации, возвращает число нулей в дереве:
 */
import { l, cons, head, tail, isEmpty, isList, toString } from 'hexlet-pairs-data';

const searchZeros = (tree) => {
    const iter = (list, acc) => {
        if (isEmpty(list)) {
            return acc;
        }

        const current = head(list);
        const rest = tail(list);

        if (!isList(current)) {
            const newAcc = current === 0 ? acc + 1 : acc;
            return iter(rest, newAcc);
        } else {
            return iter(rest, iter(current, acc));
        }
    };

    return iter(tree, 0);
};

console.log(searchZeros(l(1, 3, l(5, l(9), 3), 10)));
console.log(searchZeros(l(0, l(l(0, 100), 0), 10)));


/**
 Главное в этом коде находится тут: return iter(rest, iter(current, acc));. Если current список, то прежде чем продолжать проверять список, по которому идет алгоритм, нужно выполнить поиск в найденном поддереве и так далее до самого дна. Соответственно, сначала отработает код iter(current, acc), который вернет acc для поддерева, сложенный с текущим значением аккумулятора. В итоге, на выходе получится новый аккумулятор, который передается дальше.
 */

/***@@@
 Работа с древовидными структурами в промышленном программировании достаточно частая ситуация. Например, вывод файловой структуры в нашем редакторе — типичный пример работы с деревьями.

 select.js
 Реализуйте и экспортируйте по умолчанию функцию select, которая принимает на вход имя тега и html список, а возвращает список всех нод, соответствующих имени. Ноды возвращаются в том виде, в котором они представлены в дереве. Порядок, в котором ноды возвращаются — не важен.

 Предположим, что у нас есть такой html:

 <h1>scheme</h1>
 <p>is a lisp</p>
 <ul>
 <li>item 1</li>
 <li>item 2</li>
 </ul>
 <ol>
 <li>item 1</li>
 <li>item 2</li>
 </ol>
 <p>
 is a functional lang
 </p>
 <ul>
 <li>item</li>
 </ul>
 <div>
 <p>text</p>
 </div>
 <div>
 <div>
 <p>text</p>
 </div>
 </div>
 <h1>prolog</h1>
 <p>is about logic</p>

 Тогда:
 */

const dom1 = make(); // Список нод, то есть это лес, а не дерево
const dom2 = append(dom1, node('h1', 'scheme'));
const dom3 = append(dom2, node('p', 'is a lisp'));

const children1 = l(node('li', 'item 1'), node('li', 'item 2'));
const dom4 = append(dom3, node('ul', children1));
const children2 = l(node('li', 'item 1'), node('li', 'item 2'));
const dom5 = append(dom4, node('ol', children2));
const dom6 = append(dom5, node('p', 'is a functional language'));
const children3 = l(node('li', 'item'));
const dom7 = append(dom6, node('ul', children3));
const dom8 = append(dom7, node('div', l(node('p', 'text'))));
const dom9 = append(dom8, node('div', l(node('div', l(node('p', 'text'))))));

const dom10 = append(dom9, node('h1', 'prolog'));
const dom = append(dom10, node('p', 'is about logic'));

select('li', dom);
// [('li', 'item 1'), ('li', 'item 2'), ('li', 'item 1'), ('li', 'item 2'), ('li', 'item')]

select('p', dom);
// [('p', 'is a lisp'), ('p', 'text'), ('p', 'text'), ('p', 'is about logic'), ('p', 'is a functional language')]

/**
 Подсказки
 Посмотрите в документации примеры использования функций описанных ниже.

 - hasChildren — функция, которая проверяет, есть ли потомки у элемента
 - children — функция, которая возвращает список потомков
 - is - функция, которая проверяет соответствие ноды переданному имени

 Эту задачу можно решить разными способами, алгоритм самого простого выглядит так:
 1. Проходимся по списку нод редьюсом, который собирает результирующий список.
 2. Если текущая нода содержит детей, то запускаем select рекурсивно для детей, а результат вызова добавляем в аккумулятор.
 3. Если текущая нода соответствует тому, что мы ищем, добавляем её в аккумулятор.
 */

// FILE: /app/select.js:
import {
    l, cons as consList, isList, isEmpty, head, tail, concat, toString as listToString,
} from 'hexlet-pairs-data';

import {
    is, hasChildren, children, filter, reduce, toString as htmlToString,
} from 'hexlet-html-tags'; /** eslint-enable */

const select = (tagName, html) => reduce((element, acc) => {
        const acc2 = hasChildren(element) ? concat(select(tagName, children(element)), acc) : acc;

        return is(tagName, element) ? consList(element, acc2) : acc2;
    }, l(), html);

export default select;


/***@@@
 calculatePolygonPerimeter.js
 Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход упорядоченный список точек, являющихся вершинами многоугольника, вычисляет и возвращает периметр многоугольника.

 Примечания
 - Список реализован с помощью абстракции из библиотеки hexlet-pairs-data
 - Точка реализована с помощью абстракции из библиотеки hexlet-points
 - Многоугольник имеет не менее трёх вершин, поэтому, если на вход передан список, содержащий менее трёх точек, то функция должна вернуть null
 - Порядок точек, определяющих многоугольник, имеет значение (разный порядок может определять разные (неконгруэнтные) многоугольники). Поэтому при вычислении периметра надо придерживаться порядка, заданного во входном списке точек
 - В остальном считаем, что передан корректный многоугольник, то есть дополнительных проверок делать не надо

 Примеры
 За примерами работы обращайтесь в модуль с тестами: __tests__/calculatePolygonPerimeter.test.js

 Подсказки
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 - При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-points и использовать её для отладки решений. Эта функция возвращает строковое представление точки
 - Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */

import { getX, getY } from 'hexlet-points';
import { isEmpty, head, tail } from 'hexlet-pairs-data';


const areThereLessThenThreePoints = (points) => {
    const iter = (list, acc) => {
        if (acc > 2) {
            return false;
        }

        if (isEmpty(list)) {
            return true;
        }

        return iter(tail(list), acc + 1);
    };

    return iter(points, 0);
};

const getSegmentLength = (point1, point2) => {
    const x1 = getX(point1);
    const x2 = getX(point2);
    const y1 = getY(point1);
    const y2 = getY(point2);

    return Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
};

export default (points) => {
    if (areThereLessThenThreePoints(points)) {
        return null;
    }

    const startPoint = head(points);
    const iter = (list) => {
        const currentPoint = head(list);
        const rest = tail(list);
        if (isEmpty(rest)) {
            return getSegmentLength(currentPoint, startPoint);
        }

        const nextPoint = head(rest);
        return getSegmentLength(currentPoint, nextPoint) + iter(rest);
    };

    return iter(points);
};



/***@@@
 take.js
 Реализуйте и экспортируйте по умолчанию функцию take, которая возвращает список, состоящий из первых n (значение передается первым параметром) элементов исходного (переданного вторым параметром) списка. Остальные детали работы функции демонстрирует нижеприведённый код:
 */

take(3, l()); // ()
take(3, l(1, 2)); // (1, 2)
take(1, l(7, 2)); // (7)

/**
 Подсказки
 Используйте рекурсивный процесс
 */
const take = (count, list) => {
    if (isEmpty(list) || count === 0) {
        return l();
    }

    return cons(head(list), take(count - 1, tail(list)));
};

export default take;


/***@@@
 Частой задачей при работе с деревьями (особенно html), является необходимость выбрать список узлов по определенному критерию.

 Пара примеров из реальной жизни:

 XPath

 /bookstore/book/price[text()]
 price/@exchange/total
 book[excerpt]/author[degree]
 JQuery

 $("ul > li:first-child")
 $("p.class1, #p1")
 solution.js
 Реализуйте и экспортируйте по умолчанию функцию select, которая возвращает список нод в соответствии с запросом. Запрос это список из имен тегов, в котором каждый следующий тег это тег, вложенный в предыдущий. Порядок, в котором ноды возвращаются - не важен.

 У нас есть такой html:

 <h1>scheme</h1>
 <p>is a lisp</p>
 <p>
 <ul>
 <li>item 2</li>
 <li>item 1</li>
 </ul>
 </p>
 <ol>
 <li>item 2</li>
 <li>item 1</li>
 </ol>
 <p>is a functional language</p>
 <ul>
 <li>item</li>
 </ul>
 <div>
 <p>another text</p>
 </div>
 <div>
 <div>
 <p>
 <span>text</span>
 </p>
 </div>
 </div>
 <div>
 <a>
 <div>
 <p>
 <span>text</span>
 </p>
 </div>
 </a>
 </div>
 <h1>prolog</h1>
 <p>is about logic</p>
 Строим html следующим образом:
 */
const dom1 = make();
const dom2 = append(dom1, node('h1', 'scheme'));
const dom3 = append(dom2, node('p', 'is a lisp'));
const children1 = l(node('li', 'item 1'), node('li', 'item 2'));
const dom4 = append(dom3, node('p', l(node('ul', children1))));
const children2 = l(node('li', 'item 1'), node('li', 'item 2'));
const dom5 = append(dom4, node('ol', children2));
const dom6 = append(dom5, node('p', 'is a functional language'));
const children3 = l(node('li', 'item'));
const dom7 = append(dom6, node('ul', children3));
const dom8 = append(dom7, node('div', l(node('p', 'another text'))));
const dom9 = append(dom8, node('div', l(node('div', l(node('p', l(node('span', 'text'))))))));
const dom10 = append(dom9, node('div', l(node('a', l(node('div', l(node('p', l(node('span', 'text'))))))))));
const dom11 = append(dom10, node('h1', 'prolog'));
dom = append(dom11, node('p', 'is about logic'));

// Пример работы функции, где для наглядности показано какой она будет возвращать результат если выводить его на экран (htmlToString):
select(l('p', 'ul', 'li'), dom);
// <li>item 1</li><li>item 2</li>

select(l('div', 'div', 'p'), dom);
// <p><span>text</span></p>

select(l('div', 'p'), dom);
// <p>another text</p><p><span>text</span></p><p><span>text</span></p>

select(l('div'), dom));
// <div><a><div><p><span>text</span></p></div></a></div><div><p><span>text</span></p></div><div><div><p><span>text</span></p></div></div><div><p><span>text</span></p></div><div><p>another text</p></div>

/**
 Алгоритм работы функции

 Список тегов для поиска будем называть словом query.
 query ищется с любого уровня дерева, а не только с верхнего. Например, если наш query это p, то будут найдены все p на всех уровнях.
 Производится поиск только подряд идущих тегов, например, если запрос l('ul', 'li'), то будут найдены только те li, которые идут сразу за ul.


 Подсказки
 hasChildren - функция, которая проверяет, есть ли потомки у элемента
 children - функция, которая возвращает список потомков
 */
import { l, isEmpty, head, tail, concat, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line
import { is, toString as htmlToString, hasChildren, children, reduce, filter, map } from 'hexlet-html-tags'; // eslint-disable-line


const getChildrenFromElements = (elements) => {
    const mapped = map(element => (hasChildren(element) ? children(element) : l()), elements);
    const result = reduce((elementChildren, acc) => concat(elementChildren, acc), l(), mapped);

    return result;
};

const getSatisfiedChildren = (query, elements) => {
    const first = head(query);
    const rest = tail(query);
    const filtered = filter(element => is(first, element), elements);
    if (isEmpty(rest)) {
        return filtered;
    }

    return getSatisfiedChildren(rest, getChildrenFromElements(filtered));
};

const select = (query, dom) => {
    const iter = (restOfDom, result) => {
        if (isEmpty(restOfDom)) {
            return result;
        }
        const elements = getSatisfiedChildren(query, restOfDom);

        return iter(getChildrenFromElements(restOfDom), concat(elements, result));
    };

    return iter(dom, l());
};

export default select;



/***@@@
 Задача о восьми ферзях — широко известная задача по расстановке фигур на шахматной доске. Исходная формулировка: "Расставить на стандартной 64-клеточной шахматной доске 8 ферзей так, чтобы ни один из них не находился под боем другого". Подразумевается, что ферзь бьёт все клетки, расположенные по вертикалям, горизонталям и обеим диагоналям.

 // из материалов Википедии

 Задачу можно обобщить следующим образом: "На шахматной доске со стороной N, расставить N ферзей так, чтобы ни один из них не находился под боем другого".

 isSafeQueens.js
 Реализуйте и экспортируйте по умолчанию isSafeQueens, которая принимает комбинацию ферзей в виде списка и проверяет, является ли данная расстановка решением задачи.

 Комбинации формируются следующим образом:

 (2, 4, 1, 3)

 где каждое число — это позиция ферзя по вертикали, а порядок числа в списке — позиция ферзя по горизонтали.

 Для примера выше, доска будет выглядеть так:

 1   2   3   4
 ___ ___ ___ ___
 1  |___|___|_*_|___|
 2  |_*_|___|___|___|
 3  |___|___|___|_*_|
 4  |___|_*_|___|___|
 Пример работы:
 */
const queens = l(2, 4, 1, 3);

isSafeQueens(queens); // true


// FILE: /app/isSafeQueens.js:
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { l, isEmpty, reverse, toString as listToString, isList, head, tail, cons as consList, reduce } from 'hexlet-pairs-data'; // eslint-disable-line


const isSafeQueens = (list) => {
    if (isEmpty(list)) {
        return true;
    }

    const y1 = head(list);
    const checkSafe = reduce(
        (y2, x) => (!x || y1 === y2 || Math.abs(y1 - y2) === x ? false : x + 1),
        1,
        tail(list),
    );

    return checkSafe ? isSafeQueens(tail(list)) : false;
};

export default isSafeQueens;


/***@@@
 zip.js
 Напишите и экспортируйте по умолчанию функцию zip, которая принимает на вход два списка и возвращает третий, в котором каждый элемент это список элементов исходных списков, стоящих на тех же позициях.

 const list1 = l(1, 5, 3, 8, 9);
 const list2 = l(2, 3, 2, 1);

 //  ((1, 2), (5, 3), (3, 2), (8, 1))
 const result = zip(list1, list2);
 Как видно из примера, если списки различаются по длине, то длина результирующего списка равна длине короткого списка.
 */

// FILE: /app/zip.js:
import { l, isEmpty, head, tail, cons, reverse, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line

const zip = (list1, list2) => {
    const iter = (first, last, acc) => {
        if (isEmpty(first) || isEmpty(last)) {
            return acc;
        }

        const newAcc = cons(l(head(first), head(last)), acc);
        return iter(tail(first), tail(last), newAcc);
    };

    return reverse(iter(list1, list2, l()));
};

export default zip;



/***@@@
 flatten.js
 Реализуйте и экспортируйте по умолчанию функцию flatten, которая делает плоским вложенный список.

 const list = l(1, 2, l(3, 5), l(l(4, 3), 2));

 // (1, 2, 3, 5, 4, 3, 2)
 flatten(list);
 */

// FILE: /app/flatten.js:
import { l, reverse, toString as listToString, isList, cons, reduce } from 'hexlet-pairs-data'; // eslint-disable-line

const flatten = (list) => {
    const iter = (elements, accumulator) =>
        reduce((element, acc) =>
            (!isList(element) ? cons(element, acc) : iter(element, acc)), accumulator, elements);

    return reverse(iter(list, l()));
};

export default flatten;



/***@@@
 Необходимо реализовать набор функций для работы со списками, построенными на базе строк. Данный вид списка представляет собой текст, где каждая строчка — это элемент списка, например:

 hello
 world

 Это пример списка с двумя элементами hello и world.

 Подразумевается, что интерфейс работы этой абстракции абсолютно точно такой же, как и тот, что использовался в курсе. Другими словами, можно безболезненно переписать реализацию тех функций, которые делались в курсе, и весь код, использующий списки, будет работать как ни в чем не бывало.

 list.js
 Реализуйте и экспортируйте следующие функции:

 l(...items) — функция-конструктор. Уже реализована.
 */
const list = l('foo', 'bar', 'baz');

// toString(list) — возвращает строковое представление списка

const list = l('foo', 'bar', 'baz');
toString(list); // (foo, bar, baz)

// head(list) — возвращает первый элемент списка

const list = l('foo', 'bar', 'baz');
const first = head(list); // 'foo'

// tail(list) — возвращает "хвост" списка (все элементы, кроме первого)

const list = l('foo', 'bar', 'baz');
const rest = tail(list); // l('bar', 'baz')

// isEmpty(list) — проверяет, является ли список пустым

const list = l('foo', 'bar', 'baz');

console.log(isEmpty(list)); // false
console.log(isEmpty(l()));  // true

// cons(item, list) — добавляет элемент в начало списка и возвращает новый список

const list = l('foo', 'bar', 'baz');
const newList = cons('bas', list); // l('bas', 'foo', 'bar', 'baz')

// filter(predicate, list) — фильтрует список, используя предикат

const list = l('foo', 'bar', 'baz');
const filteredList = filter(item => item[0] === 'b', list); // l('bar', 'baz')

// map(callback, list) — преобразует список, используя callback-функцию

const list = l('foo', 'bar', 'baz');
const mappedList = map(item => item[0], list); // l('f', 'b', 'b')

// reduce(callback, init, list) — производит свертывание списка

const list = l('foo', 'bar', 'baz');
const result = reduce((item, acc) => acc ? `${acc},${item}` : item, '', list);
console.log(result); // foo,bar,baz

/**
 Подсказки
 Решение учителя на 100% функциональное
 Длина строки str находится так: str.length
 Чтобы получить подстроку из строки, используйте метод substr:
 */

'foo'.substr(1, 2); // 'oo';
// Чтобы получить индекс, по которому находится отдельный символ в строке, используйте метод indexOf

'bar'.indexOf('a'); // 1;

// FILE: /app/list.js:
const delimiter = '\n';

export const l = (...items) => items.join(delimiter);

export const head = (list) => {
    const index = list.indexOf(delimiter);

    return list.substr(0, index > -1 ? index : list.length);
};

export const tail = (list) => {
    const index = list.indexOf(delimiter);

    return index > -1 ? list.substr(index + delimiter.length) : l();
};

export const isEmpty = list => list.length === 0;

export const cons = (item, list) => (isEmpty(list) ? item : `${item}${delimiter}${list}`);

export const reverse = list => reduce((item, acc) => cons(item, acc), l(), list);

export const reduce = (func, init, list) => {
    const iter = (rest, acc) => {
        if (isEmpty(rest)) {
            return acc;
        }

        return iter(tail(rest), func(head(rest), acc));
    };

    return iter(list, init);
};

export const filter = (predicate, list) => {
    const reversedResult = reduce((item, acc) => (predicate(item) ? cons(item, acc) : acc), l(), list);

    return reverse(reversedResult);
};

export const map = (func, list) => {
    const reversedResult = reduce((item, acc) => cons(func(item), acc), l(), list);

    return reverse(reversedResult);
};

export const toString = (list) => {
    const str = reduce((item, acc) => `${acc}, ${item}`, head(list), tail(list));

    return `(${str})`;
};


/***@@@
 union.js
 Напишите и экспортируйте по умолчанию функцию union, которая принимает на вход два списка и возвращает третий, являющийся объединением уникальных значений двух исходных списков.

 const list1 = l(2, 3, 2, 1, 7);
 const list2 = l(1, 5, 3, 5, 8, 9);

 const result = union(list1, list2);
 // (2, 3, 1, 7, 5, 8, 9)
 Подсказки
 Порядок уникальных значений в итоговом списке должен соответствовать порядку появления этих значений в исходных списках (сначала в первом переданном списке, потом - во втором).
 */

// FILE: /app/union.js:
import { l, isEmpty, cons, reduce, has, reverse, toString as listToString } from 'hexlet-pairs-data';

const appendUniq = (base, list) => {
    const result = reduce(
        (value, acc) => (has(acc, value) ? acc : cons(value, acc)),
        reverse(base),
        list,
    );
    return reverse(result);
};

export default (list1, list2) => appendUniq(appendUniq(l(), list1), list2);


/***@@@
 sort.js
 Реализуйте и экспортируйте по умолчанию функцию sort, которая принимает на вход список и сортирует его по возрастанию.

 Примеры
 */
sort(l(3, 3, 0, -1, 0, 4, -5));
// (-5, -1, 0, 0, 3, 3, 4)

sort(l(5, -3, 2, 10, 4, 4, 5));
// (-3, 2, 4, 4, 5, 5, 10)

/**
 Алгоритм
 Быстрая сортировка, сортировка Хоара (англ. quicksort), часто называемая qsort (по имени в стандартной библиотеке языка Си) — широко известный алгоритм сортировки, разработанный английским информатиком Чарльзом Хоаром во время его работы в МГУ в 1960 году.

 Общая идея алгоритма состоит в следующем:

 Выбрать из списка элемент, называемый опорным. Это может быть любой из элементов списка или же число, вычисленное на основе значений элементов.
 Сравнить все остальные элементы с опорным и переставить их в списке так, чтобы разбить список на три непрерывных отрезка, следующих друг за другом: «меньшие опорного», «равные» и «большие».
 Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
 На практике список обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.
 */

import { l, isEmpty, head, tail, cons, concat, filter, toString as listToString } from 'hexlet-pairs-data';

const sort = (list) => {
    if (isEmpty(list)) {
        return l();
    }

    const divisor = head(list);
    const rest = tail(list);

    const left = filter(value => value <= divisor, rest);
    const right = filter(value => value > divisor, rest);

    return concat(sort(left), cons(divisor, sort(right)));
};

export default sort;


/***@@@
 sameParityFilter.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход список и возвращает новый, состоящий из элементов, у которых такая же чётность, как и у первого элемента входного списка.

 Примеры
 */
sameParity(l(-1, 0, 1, -3, 10, -2)); // (-1, 1, -3)

sameParity(l(2, 0, 1, -3, 10, -2)); // (2, 0, 10, -2)

sameParity(l()); // ()

// FILE /app/sameParityFilter.js:
import { l, isEmpty, head, tail, filter, toString as listToString } from 'hexlet-pairs-data';

const isEven = num => num % 2 === 0;

export default (list) => {
    if (isEmpty(list)) {
        return l();
    }

    const firstItem = head(list);
    const firstItemParity = isEven(firstItem);

    return filter(value => isEven(value) === firstItemParity, list);
};




// ############################### JS: Программирование, управляемое данными ###############################

// >>>>>> Введение <<<<<<
/**
 # Адитивность
 расширение функциональности системы без переписывания исходного кода.

 # Test Driven Development
 Дизайн кода, чтобы сосредотачиваться на внутреннем представлении, сначала прорабатываются варианты использования этого кода.
 */

// >>>>>> Игровой дизайн: карточный бой <<<<<<

// Тест:
import { cons } from 'hexlet-pairs';
import { l, length } from 'hexlet-pairs-data';
import { make } from 'hexlet-card-game';

const cards = l(
    cons('Костяная кочерга гробницы', () => 6)
);

const game = make(cards); // создание игры (принимает колоду карт)
const log = game('John', 'Ada'); // после автоматической игры -> возвращает лог игры

assert.equal(length(log), 5);

// Шаги:
// step((health1, health2), message)
const step1 = get(0, log);
assert.equal(toString(car(step1)), '(10, 10)');
const step2 = get(1, log);
assert.equal(toString(car(step1)), '(10, 4)');
const step3 = get(2, log);
assert.equal(toString(car(step1)), '(4, 4)');
const step4 = get(3, log);
assert.equal(toString(car(step1)), '(4, -2)');
const step5 = get(4 log);
assert.equal(toString(car(step1)), '(4, -2)');


/***@@@
 game.js
 Допишите функцию iter, которая является частью ядра игрового движка и описывает в себе логику одного хода

 Алгоритм
 1. Если здоровье игрока, которого атаковали на предыдущем шаге (в примерах этого и следующего пунктов мы предполагаем, что это первый игрок с именем name1), меньше или равно 0, то добавляем в лог элемент с сообщением вида ${name1} был убит и возвращаем лог. Игра закончена.

 2. В ином случае, берём рандомную карту, вычисляем урон, записываем новое здоровье, формируем сообщение формата:

 const message = `Игрок '${name1}' применил '${cardName}'
 против '${name2}' и нанес урон '${damage}'`;

 Формируем элемент лога формата cons(cons(health1, health2), message) и добавляем его в лог.

 3. Повторяем.

 Подсказки
 - Параметр order в функции iter нужен для определения того, какой игрок сейчас атакует.
 - Используйте функцию random для выбора карты из колоды.
 - Колода карт передаётся в игру через параметр cards.
 */

import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { cons as consList, l, random, head, reverse, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line

const run = (player1, player2, cards) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            return consList(cons(car(head(log)), `${name1} был убит`), log);
        }

        const card = random(cards);
        const cardName = car(card);
        const damage = cdr(card)();
        const newHealth = health2 - damage;

        const message = `Игрок '${name1}' применил '${cardName}'
      против '${name2}' и нанес урон '${damage}'`;
        let stats;
        // В логе игроки всегда должны быть на своих местах. Первый игрок слева, второй - справа
        if (order === 1) {
            stats = cons(cons(health1, newHealth), message);
        } else if (order === 2) {
            stats = cons(cons(newHealth, health1), message);
        }
        const newLog = consList(stats, log);
        // Хитрость решения учителя состоит в том, что данные игроков всегда меняются местами. Это видно
        // по вызову ниже. Параметры первого игрока становятся параметрами второго и наоборот.
        // Такой подход позволяет упростить логику и всегда считать что атакует игрок номер 1.
        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = cons(cons(startHealth, startHealth), 'Начинаем бой!');
    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default cards => (name1, name2) => run(name1, name2, cards);




// >>>>>> Инверсия <<<<<<

/**
 Проблема: код не поддаётся тестированию
 Наша игра работает, но обладает ограничением — мы не можем её полноценно тестировать.
 */

const cards = l(
    cons('Алчный натиск скорости', () => 4),
    cons('Демонов маршрут воздаяния', health => Math.round(health * 0.3)),
);

const game = make(cards);
const log = game('John', 'Ada');

// Если колода содержит две и более карты, то ход игры и её результат заранее определить и протестировать НЕ получится.
assert.equal(length(log), ?); // неизвестно

// Ведь в процессе игры карта выбирается случайным образом:
const card = random(cards); // эта строчка делает игру недетерминированной

const cardName = car(card);
const damage = cdr(card)(health2);

const newHealth = health2 - damage;


/**
 Вызов random(cards) возвращает случайную карту. Этот код располжен внутри функции с игрой, поэтому делает недетерминированной всю игру.

 # Решение: инвертирование

 Сейчас выбор карты осуществляется внутри игры, и мы не можем на это никак повлиять. Но ситуация изменится, если сделать так, чтобы алгоритм выбора карты игра получала "снаружи". Это легко реализовать с помощью передачи параметра.

 Рассмотрим простой пример: функция принимает на вход колоду карт cards, внутри происходит случайный выбор карты и какие-то другие дальнейшие манипуляции. Это принципиальная схема, если отвлечься от несущественных деталей.
 */

(cards) => {
    const card = random(cards);
    // to do something with card
};

/**
 Эта функция НЕ является чистой, она недетерминирована. И это нормально для игры, но не для тестов.

 Применим к функции технику инвертирования, реализовав передачу процесса выбора карты снаружи, через параметры:
 */

(cards, customRandom) => {
    const card = customRandom(cards);
    // to do something with card
}

/**
 Теперь мы можем управлять процессом выбора карты, передавая (в зависимости от ситуации и наших целей) ту или иную функцию в параметр customRandom.

 # Тесты
 Для тестирования нам не подойдёт обычный random. Поэтому определим и передадим в функцию игры специальную функцию выбора карты, обеспечивающую предсказуемое поведение:
 */

const cards = l(
    cons('Тусклый маниту диспута', () => 7),
    cons('Мыслительный рубитель ограды', health => Math.round(health * 0.8))
);

let cardIndex = 1;
const game = make(cards, (pack) => {
    cardIndex = cardIndex === 0 ? 1 : 0;

    return get(cardIndex, pack);
});

const log = game('John', 'Ada');

// Мы передали в игру (вторым параметром) анонимную функцию:
(pack) => {
    cardIndex = cardIndex === 0 ? 1 : 0;

    return get(cardIndex, pack);
};

// Её ядро заключается в строчке кода, определяющей текущий индекс:
cardIndex = cardIndex === 0 ? 1 : 0;

// Значение переменной cardIndex функция берёт из переменной, определённой во внешнем окружении:
let cardIndex = 1;

/**
 Это важно, так мы можем смоделировать нужное нам предсказуемое поведение. При каждом новом вызове значение cardIndex циклически меняется с нуля на единицу и наоборот (индексирование в списке карт начинается с нуля!). Это как раз то, что нужно для ситуации колоды, состоящей из двух карт.

 Обязательно проанализируйте процесс выбора карт в модуле с тестами в практике к этому уроку!

 На примере простой функции продемонстрируем принцип определения циклического (а значит предсказуемого!) изменения величины:
 */

let cardIndex = 1;

const getIndex = () => {
    cardIndex = cardIndex === 0 ? 1 : 0;

    return cardIndex;
};

for (let i = 0; i < 10; i += 1) {
    console.log(getIndex());
}


// Для колоды из трёх или какого-нибудь другого количества карт надо будет модифицировать функцию. Можно сразу написать более универсальный вариант:

const customRandom = (cardIndex, minIndex, maxIndex) => {
    return () => {
        if (cardIndex > maxIndex) {
            cardIndex = minIndex;
        }

        const currentIndex = cardIndex;
        cardIndex += 1;

        return currentIndex;
    };
};

console.log('Выводим индексы с 0 до 2. Начинаем с 0');

const getIndex = customRandom(0, 0, 2);

for (let i = 0; i < 6; i += 1) {
    console.log(getIndex());
}

console.log('Выводим индексы с 1 до 5. Начинаем с 2');

const getIndex2 = customRandom(2, 1, 5);

for (let i = 0; i < 10; i += 1) {
    console.log(getIndex2());
}

/**
 Выводы
 С помощью техники инвертирования мы добились следующих преимуществ:

 1. Предсказуемого поведения — код стало возможным тестировать. Теперь можем управлять процессом выбора в зависимости от целей: для игр передавать обычный random, для тестов — кастомный.
 2. В целом, добились расширения возможностей программы посредством делегирования части функциональности внешнему коду. Программа стала более гибкой в использовании.

 Для чего можно использовать инверсию?
 > Для замены недетерминированного поведения на детерминированное
 > Для устранения побочных эффектов в целях тестирования
 > Для изменения поведения системы, без переписывания исходного кода (особенно актуально для чужих библиотек)
 */


/***@@@
 Инверсия зависимостей всегда связана с изменением интерфейса (сигнатуры функции). Если ранее функция для запуска игры принимала на вход колоду карт и имена игроков, а возвращала лог игры, то теперь процесс игры разбился на два этапа: инициализация и сама игра.

 Во время инициализации в функцию, создающую игру, передается колода карт и пользовательская функция random (та, которая выбирает случайную карту из колоды). Результатом этого вызова будет функция, которая, в свою очередь, запускает игру на выполнение. Она принимает на вход имена игроков и возвращает лог. Задача этого упражнения - делегировать вызывающему коду формирование функции random. Другими словами, функция random должна передаваться при инициализации игры. Выглядит это так:
 */

// инициализация
const customRandom = (c) => {
    cardIndex = cardIndex === 0 ? 1 : 0;
    return get(cardIndex, c);
};
const game = make(cards, customRandom);

// игра
const log = game('John', 'Ada');


/**
 Такая инверсия позволит нам из недетерминированного кода сделать детерминированный. В примере выше как раз описывается алгоритм выбора карты, который всегда работает одинаковым способом.

 game.js
 - Создайте и экспортируйте по умолчанию функцию, которая принимает на вход колоду карт и функцию выбора случайного элемента из списка (списка карт). Второй аргумент — опциональный, его значение по умолчанию — функция random из hexlet-pairs-data. Ваша функция будет возвращать другую функцию. При этом возвращаемая функция работает следующим образом:
 1. принимает на вход имена игроков
 2. запускает игру
 3. возвращет лог игры
 Допишите вызов пользовательской функции random в функции run.
 */

import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { cons as consList, l, random, head, reverse, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line

const run = (player1, player2, cards, customRandom) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            return consList(cons(car(head(log)), `${name1} был убит`), log);
        }

        const card = customRandom(cards);
        const cardName = car(card);
        const damage = cdr(card)(health2);
        const newHealth = health2 - damage;

        const message = `Игрок '${name1}' применил '${cardName}'
      против '${name2}' и нанес урон '${damage}'`;
        let stats;

        if (order === 1) {
            stats = cons(cons(health1, newHealth), message);
        } else if (order === 2) {
            stats = cons(cons(newHealth, health1), message);
        }

        const newLog = consList(stats, log);

        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = cons(cons(startHealth, startHealth), 'Начинаем бой!');

    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default (cards, customRandom = random) => (
    (name1, name2) => run(name1, name2, cards, customRandom)
);




// >>>>>> Помеченные данные <<<<<<

// Недостатки имплементации:
const cards = l(cons('Костяная кочерга гробницы', ()  => 6)
);
const game = make(cards);

// inside...
const card = random(cards);
const cardName = pairs.car(card);
const damage = pairs.cdr(card)();
const newHealth = health2 - damage;


// Прячем реализацию:

// FILE: percentCard.js
import { cons, car, cdr } from 'hexlet-pairs';

export const make = (name, percent) => cons(name, percent);

export const getName = card => car(card);

export const damage = (card, health) => Math.round(health * (cdr(car) / 100));


// Используем
simpleCard.make('Ошарашивающие шорты равновесия', 7);
const cardName = simpleCard.getName(card);
const damage = simpleCard.damage(card);

// or

percentCard.make('Фаланговая знатность утешения', 80);
const cardName = percentCard.getName(card);
const damage = percentCard.damage(card, health2);


// С какой картой мы работаем?
const iter = (...) => {
    // some code ...

    const card = random(cards);
    const cardName = ?.getName(card);
    const damage = ?.damage(card, health2);
}

// Помеченные данные
import { cons, car, cdr } from 'hexlet-pairs';
import { cons, car, cdr } from './type';

export const make = (name, percent) => attach('PercentCard', cons(name, percent));

export const getName = self => car(contents(self)); // self - карта


// Реализация
import { cons, car, cdr } from 'hexlet-pairs';

export const attach = (tag, data) => cons(tag, data); // tag - метка типа

export const typetag = taggedData => car(taggedData);

export const contents = taggedData => cdr(taggedData);


// Тесты
import * as simpleCard from './simpleCard.js';
import * as percentCard from './percentCard';

let cardIndex = 2;
const cards = l(
    simpleCard.make('Ошарашивающие шорты', 7),
    percentCard.make('Фаланговая знатность', 80)
);

const game = make(cardsm (c) => {
    cardIndex = cardIndex === 1 ? 2 : 1;

    return get(cardIndex, c);
})

const log = game('John', 'Ada');

assert.equal(length(log), 5);


/***@@@
 simpleCard.js
 Реализуйте интерфейс работы карты с типом SimpleCard по аналогии с типом PercentCard. Второй параметр у конструктора - урон.

 simpleCard.make('Жесткий ломатель мироздания', 6);
 solution.js
 Реализуйте логику работы функции run.

 Подсказки
 Для определения типа карты воспользуйтесь функциями isSimpleCard и/или isPercentCard.
 */

// FILE: /app/simpleCard.js
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { attach, contents } from '@hexlet/tagged-types';

export const make = (name, damagePoints) => attach('SimpleCard', cons(name, damagePoints));

export const getName = self => car(contents(self));

export const damage = self => cdr(contents(self));


// FILE /app/percentCard.js
import { cons, car, cdr } from 'hexlet-pairs';
import { attach, contents } from '@hexlet/tagged-types';

export const make = (name, percent) => attach('PercentCard', cons(name, percent));

export const getName = self => car(contents(self));

export const damage = (self, health) => Math.round(health * (cdr(contents(self)) / 100));


// FILE: /app/solution.js:
import { cons, car, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { cons as consList, l, random, head, reverse, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line
import { typeTag } from '@hexlet/tagged-types';
import { getName as getSimpleCardName, damage as simpleCardDamage } from './simpleCard';
import { getName as getPercentCardName, damage as percentCardDamage } from './percentCard';

const isSimpleCard = card => typeTag(card) === 'SimpleCard';
const isPercentCard = card => typeTag(card) === 'PercentCard';

const run = (player1, player2, cards, customRandom) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            return consList(cons(car(head(log)), `${name1} был убит`), log);
        }
        const card = customRandom(cards);

        let cardName;
        let damage;

        // Populate cardName and damage using suitable card
        // use imports from  percentCard.js and simpleCard.js
        if (isSimpleCard(card)) {
            cardName = getSimpleCardName(card);
            damage = simpleCardDamage(card);
        } else if (isPercentCard(card)) {
            cardName = getPercentCardName(card);
            damage = percentCardDamage(card, health2);
        }

        const newHealth = health2 - damage;

        const message = `Игрок '${name1}' применил '${cardName}'
      против '${name2}' и нанес урон '${damage}'`;
        let stats;
        if (order === 1) {
            stats = cons(cons(health1, newHealth), message);
        } else if (order === 2) {
            stats = cons(cons(newHealth, health1), message);
        }
        const newLog = consList(stats, log);
        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = cons(cons(startHealth, startHealth), 'Начинаем бой!');
    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default (cards, customRandom = random) => {
    const inner = (name1, name2) => run(name1, name2, cards, customRandom);
    return inner;
};



// >>>>>> Диспетчеризация по типу. Аддитивность. <<<<<<

/**
 Решаемая задача: реализовать диспетчеризацию по типу своими руками.

 Разложим весь процесс на примере библиотеки для работы с геометрическими фигурами. Предположим, что мы можем создавать разные фигуры, такие как треугольник, круг или квадрат. Кроме специфических свойств, у фигур есть и общие, например, периметр или площадь. А так как мы, гипотетически, хотим работать с фигурами единообразно, то реализуем диспетчеризацию по типу на примере функции, вычисляющей общую площадь фигур, размещенных на воображаемом холсте (так обычно называется область, на которой происходит рисование в графических редакторах)

 При отсутствии готовой диспетчеризации нам придется делать ее руками в том месте, где требуется обобщенное поведение:
 */
import { reduce } from 'js-pairs-data';
import * as circle from './circle';
import * as square from './square';
import * as triangle from './triangle';
import { typeTag } from './type';

const getTotalArea = figures => reduce((figure, total) => {
    let area;
    switch (typeTag(figure)) {
        case 'square':
            area = square.getArea(figure);
            break;
        case 'circle':
            area = circle.getArea(figure);
            break;
        case 'triangle':
            area = triangle.getArea(figure);
            break;
    };
    return area + total;
}, 0, figures);


// С наличием автоматического механизма диспетчеризации (не важно реализован он в самом языке или нами самостоятельно) код сокращается до следующего:
import * as circle from './circle';
import * as square from './square';
import { reduce, l } from 'js-pairs-data';
import { getArea } from './figures';

const getTotalArea = figures => reduce((figure, total) => getArea(figure) + total, 0, figures);

const figures = l(circle.make(2), square.make(3));
getTotalArea(figures);
// => 12.57 + 9
// => 21,57

/**
 В примере выше функция getArea сама по себе не занимается вычислением площади. Это вычисление реализовано для каждой фигуры совершенно независимо. Все, что делает getArea, это перенаправляет запрос на расчет площади в соответствующую функцию.

 Алгоритм диспетчеризации в примере выше следующий:
 1. getArea извлекает тип (его название) из фигуры.
 2. getArea обращается к глобальному хранилищу (виртуальная таблица) для поиска нужной реализации настоящей функции вычисления площади.
 3. Если реализация найдена, то getArea ее вызывает с нужными аргументами и возвращает результат наружу.

 Важное следствие этого алгоритма в том, что для работы автоматической диспетчеризации необходимо, чтобы реальные функции getArea были занесены в виртуальную таблицу, иначе до них невозможно будет достучаться.

 # Виртуальная таблица
 Выполняет две задачи, которые мы рассмотрим ниже.


 # Регистрация
 Первая — это регистрация функций тех типов, по которым мы планируем делать диспетчеризацию:
 */
export const definer = type => (methodName, f) => { /** ... */ };

// Тогда модуль, реализующий наш тип, будет выглядеть так:

// FILE: circle.js
import { definer } from './generic';
import { attach, contents } from './type';

const defmethod = definer('Circle');

export const make = radius => attach('Circle', radius)

// Так как для определения круга не нужно ничего кроме радиуса, сам круг и есть радиус,
// Код снаружи об этом не знает!
export const getRadius = circle => contents(circle);

export const getArea = circle => (getRadius(circle) ** 2) * Math.PI;
defmethod('getArea', getArea);

export const getPerimeter = circle => 2 * getRadius(circle) * Math.PI;
defmethod('getPerimeter', getPerimeter);


/**
 Как видно из примера выше, по большей части Circle является типичной абстракцией, за исключением пары моментов:
 1. Внутри создается привязка к типу. Соответственно все селекторы должны сначала извлечь данные и потом уже работать.
 2. С помощью definer происходит регистрация нужных (радиус специфичен для круга, по нему диспетчеризация не нужна) функций в нашей виртуальной таблице.

 Наш модуль generic ничего не знает про Circle, да и вообще ничего не знает про тех, кто его использует. В общем случае, для регистрации функции ему нужно знать три значения: имя типа, имя функции и само тело функции, или, другими словами, мы имеем такой интерфейс: register('TypeName', 'funcName', funcBody). А код регистрации выглядел бы так:
 */

register('Circle', 'getArea', getArea);
register('Circle', 'getPerimeter', getPerimeter);

/**
 Обратите внимание на то, что мы находимся внутри модуля Circle и нам приходится в каждом вызове register передавать его название. Это единственная причина, по которой существует функция defmethod. То есть мы сначала специфицируем имя типа для которого будем заполнять функции, а потом делаем это без повторений.

 С точки зрения теории мы использовали так называемое частичное применение функции:
 */
const defmethod = partial(register, 'Circle');

// Что эквивалентно:
const defmethod = (funcName, funcBody) => register('Circle', funcName, funcBody);

/**
 Ну и самое главное, а где же происходит регистрация? Куда записываются все эти данные о типах? Ответ достаточно простой. Фактически в наш прекрасный чистый код мы вводим внешнее изменяемое состояние и заполняем его функцией с побочными эффектами (definer). Если открыть модуль generic то можно увидеть:
 */

let methods = l();

/**
 В свою очередь, все функции, которым нужен доступ к таблице, получают его посредством замыкания. Причем только definer изменяет ее, а все остальные - читают.
 Получается, что methods наполняется в тот момент, когда загружаются типы (выполняется import), использующие модуль generic для регистрации своих функций. Например:
 */

// Первый встреченный импорт модуля `circle` приведет к тому, что внутри него выполнятся все определения.
import * as circle from './circle';


/**
 # Поиск

 Вторая задача это, собственно, поиск этих функций:
 */

// извлечение типа объекта происходит внутри с помощью typeTag
export const getMethod = (obj, funcName) => { /** ... */ };

// Для поиска подходящей функции достаточно знать два параметра: имя типа и имя функции. Если функция найдена, то getMethod возвращает ее вызывающему коду, который, в свою очередь, уже делает вызов найденной функции.

// figures.js
import { getMethod } from './generic';
import { contents } from './type';

export const getArea = figure => {
    const realGetArea = getMethod(figure, 'getArea');
    // В случае с кругом эквивалентно:
    // circle.getArea(figure)
    return realGetArea(figure);
}



/***@@@
 card.js
 Реализуйте и экспортируйте обобщенную функцию damage.

 generic.js
 Реализуйте функцию getMethod, которая производит поиск конкретной реализации функции для переданного типа.

 simpleCard.js
 Реализуйте интерфейс типа simpleCard.

 Подсказки
 В percentCard.js можно подсмотреть пример использования.
 Обратите внимание в модуле generic.js на следующую строчку: let methods = l();. Именно здесь определяется та самая виртуальная таблица, механизм работы с которой подробно описан в текстовой части этого урока.
 */

// FILE: /app/card.js:
import { contents } from '@hexlet/tagged-types';
import { getMethod } from './generic';

export const getName = self => getMethod(self, 'getName')(contents(self));

export const damage = (self, health) => getMethod(self, 'damage')(contents(self), health);


// FILE: /app/generic.js
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import {
    l, cons as consList, isEmpty, head, tail,
} from 'hexlet-pairs-data';
import { attach, typeTag, contents } from '@hexlet/tagged-types';

let methods = l();

export const getMethod = (obj, methodName) => {
    const currentType = typeTag(obj);
    const iter = (elements) => {
        if (isEmpty(elements)) {
            return null;
        }
        const element = head(elements);
        if (currentType === typeTag(element)) {
            const method = contents(element);
            if (methodName === car(method)) {
                return cdr(method);
            }
        }

        return iter(tail(elements));
    };

    return iter(methods);
};

export const definer = type => (methodName, f) => {
    methods = consList(attach(type, cons(methodName, f)), methods);
};


// FILE: /app/simpleCard.js
import { cons, car, cdr, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line
import { attach } from '@hexlet/tagged-types';
import { definer } from './generic';

const defmethod = definer('SimpleCard');

const make = (name, damagePoints) => attach('SimpleCard', cons(name, damagePoints));

export default make;

defmethod('getName', self => car(self));

defmethod('damage', self => cdr(self));


// FILE: /app/solution.js:
import { cons, car, toString as pairToString } from 'hexlet-pairs'; // eslint-disable-line no-unused-vars
import { // eslint-disable-next-line no-unused-vars
    cons as consList, l, random, head, reverse, toString as listToString,
} from 'hexlet-pairs-data';
import { getName, damage } from './card';

const run = (player1, player2, cards, customRandom) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            return consList(cons(car(head(log)), `${name1} был убит`), log);
        }
        const card = customRandom(cards);
        const cardName = getName(card);
        const points = damage(card, health2);
        const newHealth = health2 - points;

        const message = `Игрок '${name1}' применил '${cardName}'
      против '${name2}' и нанес урон '${points}'`;
        let stats;
        if (order === 1) {
            stats = cons(cons(health1, newHealth), message);
        } else if (order === 2) {
            stats = cons(cons(newHealth, health1), message);
        }
        const newLog = consList(stats, log);
        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = cons(cons(startHealth, startHealth), 'Начинаем бой!');
    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default (cards, customRandom = random) => (
    (name1, name2) => run(name1, name2, cards, customRandom)
);

/**
 # Рекомендуем к прочтению
 https://habrahabr.ru/company/hexlet/blog/303754/
 */

/***@@@
 simpleCard.js
 Реализуйте интерфейс типа simpleCard.

 solution.js
 Допишите логику работы функции run.

 Подсказки
 При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs и использовать её для отладки решений. Эта функция возвращает строковое представление пары
 При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений. Эта функция возвращает строковое представление списка
 Для разрешения противоречий в случае импорта нескольких функций с одинаковыми именами используйте псевдонимы (aliases)
 */


// FILE: /app/simpleCard.js:
const make = (name, damagePoints) => (message) => {
    switch (message) {
        case 'getName':
            return name;
        case 'damage':
            return damagePoints;
        default:
            return 'undefined method';
    }
};

export default make;


// FILE: /app/solution.js:
import { cons, car } from 'hexlet-pairs';
import {
    cons as consList, l, random, head, reverse,
} from 'hexlet-pairs-data'; // eslint-enable

const run = (player1, player2, cards, customRandom) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            return consList(cons(car(head(log)), `${name1} был убит`), log);
        }

        const card = customRandom(cards);
        const cardName = card('getName');
        const damage = card('damage', health2);
        const newHealth = health2 - damage;

        const message = `Игрок '${name1}' применил '${cardName}' против '${name2}' и нанес урон '${damage}'`;
        let stats;
        if (order === 1) {
            stats = cons(cons(health1, newHealth), message);
        } else if (order === 2) {
            stats = cons(cons(newHealth, health1), message);
        }
        const newLog = consList(stats, log);
        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = cons(cons(startHealth, startHealth), 'Начинаем бой!');
    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default (cards, customRandom = random) => (name1, name2) => (
    run(name1, name2, cards, customRandom)
);



// >>>>>> Нативные объекты <<<<<<

// # Объекты в JS:
const str = 'hello, world';

// property
str.length; // 12

// method
str.toUpperCase(); // HELLO, WORLD

// actually, just property
str.toUpperCase; // [Function: toUpperCase]


// # Тип данных объект:
сonst card = {
    name: 'percent card',
    key: 'value',
};

card.key; // value
card.wrongKey; // unfined

// map syntax
card['key']; // value
card['wrongKey']; // undefined


// # Константа:
сonst card = {
    name: 'percent card',
    key: 'value',
};

card.wrongKey; // unfined
card.wrongKey = 'something';
card.wrongKey; // something

// ТуpeError: Assignment to constant variable
card = {};


// # Объект с Функциями:
сonst card = {
    name: 'percent card',
    damage: health => Math.round(health * (80 / 100)),
};

card.name; // percent card
card.damage(10); // 8


// # Cоздание объекта:

// FILE: /percentCard.js:
export const make = (name, percent) => {
    return {
        name: name,
        damage: health => Math.round(health * (percent / 100)),
    }
};


// # Динамическая диспетчиризация:

const card = percentCard.make('percent card', 60)
// const card = simpleCard.make('simple card', 3)
card.name; // percent card
card.damage(10); // 6


// # Изменение объекта:

// Обычно, изменение объекта происходит так:
const obj = { key: 'value' };
obj.key = 'another value';

// Но что делать, если свойство заранее неизвестно? Тогда можно воспользоваться таким способом:

const name = 'key';
const obj = { key: 'value' };
obj[name] = 'another value';

/**
 Вычислимые свойства встречаются достаточно часто на этапе создания объекта, по этой причине появился специальный синтаксис, позволяющий задавать подобные свойства в литерале. Дополнительный бонус в том, что при таком подходе в коде пропадают лишние мутации и код становится более функциональным:
 */
const name = 'key2';
const obj = { key: 'value', [name]: 'another value' };
// => { key: 'value', key2: 'another value' }

/**
 Единственное отличие от стандартного синтаксиса в том, что ключ это переменная (а не имя) взятая в квадратные скобки.
 Еще одна интересная возможность объектов в JS - сокращенный синтаксис создания объектов при использовании переменных или констант. Обычное создание выглядит так:
 */
const name = 'Mike';
const user = { name: name };

// В примере выше, имя свойства совпадает с именем переменной, в которой хранится нужное значение. JS позволяет написать этот код лаконичнее. Можно просто опустить часть name:. И получится:
const name = 'Mike';
const user = { name };

// Тоже самое работает и для нескольких переменных:
const name = 'Mike';
const surname = 'Smith';

const user = { name, surname };

// Можно даже мешать разные стили в рамках одного объекта:
const name = 'Mike';
const user = { name, surname: 'Smith' };

/**
 const name = 'age';
 const user = { [name]: 19 };
 console.log(user);
 > => {age: 19}
 */

/***@@@
 simpleCard.js
 Реализуйте интерфейс simpleCard, основываясь на реализации percentCard.

 solution.js
 Реализуйте функцию run, используя тип данных object для хранения элементов внутри списка log.
 */


// FILE: /app/simpleCard.js:
const make = (name, damagePoints) => ({
    name,
    damage: () => damagePoints,
});

export default make;

// FILE: /app/percentCard.js:
const make = (name, percent) => ({
    name,
    damage: health => Math.round(health * (percent / 100)),
});

export default make;

// FILE: /app/solution.js:
import { cons as consList, l, random, head, reverse, toString as listToString } from 'hexlet-pairs-data'; // eslint-disable-line

const run = (player1, player2, cards, customRandom) => {
    const iter = (health1, name1, health2, name2, order, log) => {
        if (health1 <= 0) {
            const prevLog = head(log);
            const newLog = {
                message: `${name1} был убит`,
                health1: prevLog.health1,
                health2: prevLog.health2,
            };
            return consList(newLog, log);
        }
        const card = customRandom(cards);
        const cardName = card.name;
        const points = card.damage(health2);
        const newHealth = health2 - points;

        const message = `Игрок '${name1}' применил '${cardName}'
      против '${name2}' и нанес урон '${points}'`;
        const stats = { message };
        if (order === 1) {
            stats.health1 = health1;
            stats.health2 = newHealth;
        } else if (order === 2) {
            stats.health1 = newHealth;
            stats.health2 = health1;
        }
        const newLog = consList(stats, log);
        return iter(newHealth, name2, health1, name1, order === 1 ? 2 : 1, newLog);
    };

    const startHealth = 10;
    const logItem = {
        health1: startHealth,
        health2: startHealth,
        message: 'Начинаем бой!',
    };
    return reverse(iter(startHealth, player1, startHealth, player2, 1, l(logItem)));
};

export default (cards, customRandom = random) => (
    (name1, name2) => run(name1, name2, cards, customRandom)
);



// >>>>>> Классы <<<<<<

// CamelCase
export default class PercentCard {
    constructor(name, percent) {
        this.name = name;
        this.percent = percent;
    }

    damage(health) {
        return Math.round(health * (this.percent / 100));
    }
}


// # this как пара:
import { cons, car, cdr } from 'hexlet-pairs';

export const make = (name, percent) => cons(name, percent);

export const getName = (self) => car(self);

export const damage = (self, health) => Math.round(health * (cdr(self) / 100));

// using
const card = make('name', 80);
getName(card); // name

// # this как объект:

export const make = (name, percent) => {
    return { name: name, percent: percent };
};

export const getName = (self) => self.name;

export const damage = (self, health) => Math.round(health * (self.percent / 100));

// using

const card = make('name', 80);
getName(card); // name


// # Экземляр класса (инстанс)
typeof PercentCard; // function

const card = new PercentCard('card name', 90);


card.name; // card name
card.percent; // 90
card.damage(10); // 9

card.wrongKey; // undefined


/***@@@
 SimpleCard.js
 Реализуйте класс SimpleCard по аналогии с PercentCard.
 */

// FILE: /app/PercentCard.js:
export default class PercentCard {
    constructor(name, percent) {
        this.name = name;
        this.percent = percent;
    }

    damage(health) {
        return Math.round(health * (this.percent / 100));
    }
}

// FILE: /app/SimpleCard.js:
export default class SimpleCard {
    constructor(name, damagePoints) {
        this.name = name;
        this.damagePoints = damagePoints;
    }

    damage() {
        return this.damagePoints;
    }
}




// >>>>>> Полиморфизм <<<<<<<

/**
 Виды:
 > Ad-Hoс(Специальный)
 > Параметрический
 > Подтипов (Включения)



 # Параметрический Полиморфизм:
 Вызов ОДНОГО и того же кода для ВСЕХ допустимых типов (полиморфных аргументов)
 */
const numbers1 = l(3, 4, 5, 8);
const numbers2 = l(3, 2, 9);
append(numbers1, numbers2); // (3, 4, 5, 8, 3, 2, 9)

const strings1 = l('cat', 'dog');
const strings2 = l('table', 'milk', 'phone');
append(strings1, strings2); // (cat, dog, table, milk, phone)


// # Ad-Hoс:
// В зависимости от типов аргументов применяется разная разная реализация какой-либо операции
1 + 1; // 2
'cat' + 'dog'; // catdog

console.log(1034.98);
console.log('hello');


// # Ad-Hoс:
// Вызов РАЗНОГО кода для Разных иерархий типов:
const obj = new simpleCard(); // or PercentCard()
obj.damage(health);


/***@@@
 В HTML некоторые элементы хранят ссылку в атрибуте href, а некоторые — в src. Например:

 <img src="/logo.jpg">
 <link href="/style.css">
 <a href="/">

 Абстракция Tags содержит интерфейс для представления тега HTML:
 */
const hr = make('hr');
const a = make('a', { href: '/' });

getName(a); // => a
getAttribute('href', a); // => /
getAttribute('notexist', a); // => undefined

/**
 make — принимает на вход два параметра: название тега и объект, в котором содержатся атрибуты и их значения.
 getName — принимает на вход тег, полученный вызовом make, и возвращает его имя.
 getAttribute — принимает на вход имя атрибута и тег, полученный вызовом make. Возвращает значение атрибута.


 extract.js
 Реализуйте и экспортируйте по умолчанию функцию extract, которая принимает на вход список тегов (только <a>, <link> и <img>) и возвращает список ссылок, извлеченных из этих тегов.
 */

const tags = l(
    make('a', { href: '/about' }),
    make('img', { src: '/avatar.jpeg' }),
    make('link', { href: '/favicon.ico' }),
);

extract(tags); // => ('/about', '/avatar.jpeg', '/favicon.ico')

/**
 Подсказки
 Воспользуйтесь функцией map для обхода коллекции.
 В коде не должно быть условных конструкций и, в целом, любых логических выражений. Используйте полиморфизм на основе ключей в объекте.
 Проанализируйте код файла tags.js, чтобы окончательно разобраться с устройством абстракции для тегов.
 При необходимости вы можете самостоятельно импортировать функцию toString из библиотеки hexlet-pairs-data и использовать её для отладки решений.
 */

// FILE: /app/extract.js:
import { map } from 'hexlet-pairs-data';
import { getAttribute, getName } from './tags';

const mapping = {
    img: t => getAttribute('src', t),
    a: t => getAttribute('href', t),
    link: t => getAttribute('href', t),
};

export default tags => map(tag => mapping[getName(tag)](tag), tags);





// ############################### JS: Коллекции ###############################


/**
 Domain-specific language (DSL)
 Язык специализированный для конкретной области применения

 # Внешний:
 - Язык запросов (SQL, XPath)
 - Языки разметки (HTML, Markdown)
 - Регулярные выражения

 # Внутренний:
 - Fluent Interface
 */

import Hexletlinq from 'hexlet-linq';

const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'sportage', year: 2012 },
];

const coll = Hexlet.from(cars);

const result = coll.orderBy(car => car.year, 'desc')
    .where(car => car.brand === 'kia')
    .select(car => car.model)
    .toArray();

// ['sorento', 'sportage']



// >>>>>> Массив <<<<<<

// инициализируем демонстрационный массив
const planets = ['Mercury', 'Venus', 'Earth', 'Mars'];
// [] - cинтаксический сахар для new Array. <-> new Array ('Mercury', 'Venus', 'Earth', 'Mars');
type of planets; // object


/**
 # Очередь
 Очередь является упорядоченным набором данных, организованным по принципу FIFO ('first in - first out'), т.е. добавление элементов всегда происходит в конец очереди, а извлечение (удаление) элементов - из её начала:

 push добавляет один или несколько элементов в конец массива и возвращает длину изменённого (мутированного) массива
 (если точнее, то метод возвращает обновлённое свойство length массива, являющееся значением самого последнего индекса, увеличенным на единицу)
 */

planets.push('Jupiter'); // возвращаемое значение: 5
planets.push('Saturn', 'Uranus'); // возвращаемое значение: 7
console.log(planets); // [ 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus' ]

// shift удаляет первый элемент массива и возвращает его значение
planets.shift(); // удалили элемент из начала массива, возвращаемое значение: 'Mercury'
planets.shift(); // ещё раз удалили элемент из начала массива, возвращаемое значение: 'Venus'
console.log(planets); // [ 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus' ]

/**
 # Стек
 Стек является упорядоченным набором данных, организованным по принципу LIFO ('last in - first out'), т.е. добавление и удаление элементов всегда происходит из конца такой коллекции:

 Добавим элемент в конец массива уже известным нам способом
 */

planets.push('Neptune'); // возвращаемое значение: 6
console.log(planets); // [ 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune' ]

// pop удаляет последний элемент массива и возвращает его значение
planets.pop(); // возвращаемое значение: 'Neptune'
planets.pop(); // возвращаемое значение: 'Uranus'
console.log(planets); // [ 'Earth', 'Mars', 'Jupiter', 'Saturn' ]


// reduceRight - зеркальное отражение reduce, осуществляет свёртку, обрабатывая элементы справа налево
const planets = ['Меркурий', 'Венера', 'Земля', 'Марс'];
const closer = planets.reduceRight((acc, planet) => `${acc} ${planet}`, 'всё ближе к Солнцу:'); // 'всё ближе к Солнцу: Марс   Земля Венера Меркурий'
const further = planets.reduce((acc, planet) => `${acc} ${planet}`, 'всё дальше от Солнца:'); // 'всё дальше от Солнца: Меркурий   Венера Земля Марс'


// за "превращение" строки в массив, а так же за обратное действие отвечают, соответственно, split и join
const planets = 'Mercury,Venus,Earth,Mars';
console.log(planets.split(',')); // [ 'Mercury', 'Venus', 'Earth', 'Mars' ]
console.log(planets.split(',').join('-')); // 'Mercury-Venus-Earth-Mars'

// поиск в массиве и проверка соблюдения условий элементами массива (find, findIndex, indexOf, lastIndexOf, some, every, includes...)
// includes определяет наличие элемента в массиве, возвращая true/false
const planets = ['Mercury', 'Venus', 'Earth', 'Mars'];
planets.includes('Earth'); // true
planets.includes('Earth', 3); // ищет, начиная с 3-й индексной позиции, поэтому false
planets.includes('Saturn'); // false

// Сортировка массива (sort, reverse...) и др. более или менее распространённые операции с массивами.

// Удаление (! никогда так не делать)
const arr = [1, 'string', {}];
delete arr[1];
arr.length; // 3
arr[1]; // undefined
console.log(arr); // [1,,{}]

// Итерация (Императивная)
const iterable = [10, 20, 30];
for (let value of iterable) {
    console.log(value);
}

/**
 К последнему утверждению следует добавить, что, как правило, существуют сторонние библиотеки, позволяющие не "изобретая велосипед" пользоваться множеством готовых функций "на все случаи жизни". Одной из наиболее актуальных на текущей момент javascript-библиотек является lodash, в которой реализованы различные функции по работе с массивами, коллекциями, строками и другими объектами языка. Не менее важно, что эта библиотека предоставляет множество иммутабельных функций высшего порядка, поддерживающих функциональный стиль программирования. Подробнее ознакомиться со всеми возможностями lodash можно на сайте библиотеки https://lodash.com/docs/, а здесь мы в качестве примера приведём весьма часто используюмую на практике функцию flatten, которая содержимое вложенных элементов-массивов исходного массива делает элементами самого исходного массива (т.е. как бы "выравнивает" его). :) Звучит непонятно, но давайте просто посмотрим на код:
 */


// обратите внимание, что далее рассматриваемые функции являются иммутабельными,
// поэтому они, не изменяя передаваемый им в качестве аргумента массив 'arr', будут возвращать новый массив
const arr = [1, 2, [1.1, 1.2, [2.1, [3.1, 3.2]]], 3];

// '_' - переменная, задаваемая при подключении lodash, через которую мы можем обращаться к разным функциям библиотеки
const flattenArr = _.flatten(arr);
console.log(flattenArr); // [1, 2, 1.1, 1.2, [2.1, [3.1, 3.2]], 3]

// как видно из предыдущего примера, нам удалось 'выровнять' все элементы на один уровень ниже лежащих массивов.
// Однако элементы более глубоко лежащих массивов остались невыровненными.
// Для полного выравнивания существует метод 'flattenDeep'
const flattenDeepArr = _.flattenDeep(arr);
console.log(flattenDeepArr); // [1, 2, 1.1, 1.2, 2.1, 3.1, 3.2, 3]

// с помощью 'flattenDepth(array, depth)' можно управлять уровнем 'глубины выравнивания',
// который указывается во втором параметре depth
console.log( _.flattenDepth(arr, 1)); // [1, 2, 1.1, 1.2, [2.1, [3.1, 3.2]], 3]
console.log( _.flattenDepth(arr, 2)); // [1, 2, 1.1, 1.2, 2.1, [3.1, 3.2], 3]
console.log( _.flattenDepth(arr, 3)); // [1, 2, 1.1, 1.2, 2.1, 3.1, 3.2, 3]



/**@@@
 arrays.js
 Реализуйте и экспортируйте по умолчанию функцию getIndexOfWarmestDay, которая находит самый тёплый день (тот, в котором была зарегистрирована максимальная температура) и возвращает индекс этого дня в исходном массиве.

 Примеры
 */

const data = [
    [-5, 7, 1],
    [3, 2, 3],
    [-1, -1, 10],
];

getIndexOfWarmestDay(data); // 2



const getIndexOfWarmestDay = (data) => {
    let index = null;
    let max = Number.NEGATIVE_INFINITY;

    for (let i = 0; i < data.length; i += 1) {
        const temperatures = data[i];

        for (const value of temperatures) {
            if (value >= max) {
                index = i;
                max = value;
            }
        }
    }

    return index;
};

export default getIndexOfWarmestDay;

/**@@@
 Реализуйте и экспортируйте по умолчанию функцию countUniqChars, которая получает на вход строку и считает, сколько символов (уникальных символов) использовано в этой строке. Например, в строке 'yy' всего один уникальный символ — y. А в строке '111yya!' — четыре уникальных символа: 1, y, a и !.
 */

const countUniqChars = text => {
    return new Set([...text]).size;
};

export default countUniqChars;


/**@@@
 Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов, имеющая треугольную форму. В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел. Строки треугольника симметричны относительно вертикальной оси.

 0:      1
 1:     1 1
 2:    1 2 1
 3:   1 3 3 1
 4:  1 4 6 4 1
 */

const generate = (rowNumber) => {
    let currentRow = [1];
    for (let i = 0; i < rowNumber; i += 1) {
        const newRow = [];

        for (let j = 0; j <= rowNumber; j += 1) {
            const first = currentRow[j - 1] || 0;
            const second = currentRow[j] || 0;
            newRow[j] = first + second;
        }

        currentRow = newRow;
    }

    return currentRow;
};

export default generate;


/**
 В данном упражнении необходимо реализовать стековую машину, то есть алгоритм, проводящий вычисления по обратной польской записи.

 Обратная польская нотация или постфиксная нотация — форма записи математических и логических выражений, в которой операнды расположены перед знаками операций. Выражение читается слева направо. Когда в выражении встречается знак операции, выполняется соответствующая операция над двумя ближайшими операндами, находящимися слева от знака операции. Результат операции заменяет в выражении последовательность её операндов и знак, после чего выражение вычисляется дальше по тому же правилу. Таким образом, результатом вычисления всего выражения становится результат последней вычисленной операции.

 Например, выражение (1 + 2) * 4 + 3 в постфиксной нотации будет выглядеть так: 1 2 + 4 * 3 +, а результат вычисления: 15. Другой пример - выражение: 7 - 2 * 3, в постфиксной нотации: 7 2 3 * -, результат: 1.

 solution.js
 Реализуйте функцию calcInPolishNotation, которая принимает массив, каждый элемент которого содержит число или знак операции (+, -, *, /). Функция должна вернуть результат вычисления по обратной польской записи. Экспортируйте функцию по умолачнию.
 */

calcInPolishNotation([1, 2, '+', 4, '*', 3, '+']); // 15
calcInPolishNotation([7, 2, 3, '*', '-']); // 1

const calcInPolishNotation = (array) => {
    const stack = [];
    const operators = ['*', '/', '+', '-'];

    for (let i = 0; i < array.length; i += 1) {
        const value = array[i];

        if (!operators.includes(value)) {
            stack.push(value);
            continue;
        }

        const b = stack.pop();
        const a = stack.pop();
        let result;

        switch (value) {
            case '*':
                result = a * b;
                break;
            case '/':
                result = a / b;
                break;
            case '+':
                result = a + b;
                break;
            case '-':
                result = a - b;
                break;
            default:
                break;
        }

        stack.push(result);
    }

    return stack.pop();
};

export default calcInPolishNotation;




/**
 # Мутабельность VS Иммутабельность
 Модификация массива (мутация объекта в императивном стиле), когда есть возможность писать код в функциональном, иммутабельном, стиле - очень часто является не самым удачным решением, потому что это ведёт к изменению состояния программы, излишне усложняя её. Поэтому, при изучении методов всегда обращайте внимание, изменяют ли они исходный массив или нет. Например, большинство функций высшего порядка, будучи применёнными к массиву, результатом возвращают новый массив, оставляя исходный нетронутым. А вот sort, как сказано в документации, сортирует элементы массива на месте, возвращая необратимым образом модифицированный исходный массив (поэтому такую сортировку лучше сделать на копии массива, полученной с помощью slice). Возьмём для примера типичную ситуацию, когда необходимо добавить новый элемент в массив, и рассмотрим как справиться с этой задачей на примeре мутабельного метода push и иммутабельного concat:
 */

// # push
// push мутирует массив, добавляя один (или более) элементов в его конец,
// и возвращает новую длину массива
const colours = ['red', 'orange', 'yellow'];
colours.push('green'); // возвращаемое значение: 4
console.log(colours); // теперь colours - [ 'red', 'orange', 'yellow', 'green' ]


// # concat
// concat возвращает новый массив, содержащий элементы исходного массива + элементы,
// переданные в качестве аргументов
const colours = ['red', 'orange', 'yellow'];
const myFavColours = colours.concat('green');

console.log(colours);
// colours остался неизменен - [ 'red', 'orange', 'yellow' ]

console.log(myFavColours);
// новый массив myFavColours - [ 'red', 'orange', 'yellow', 'green' ]

// аргументом можно передать и массив значений
console.log(myFavColours.concat(myFavColours));
// [ 'red', 'orange', 'yellow', 'green', 'red', 'orange', 'yellow', 'green' ]



// # Функции высшего порядка:
сonst numbers = [1, 4, 9];

const roots = numbers.map(Math.sqrt);
// numbers.map(value => Math.sqrt(value));
console.log(roots); // [1, 2, 3]

const filtered = numbers.filter(n => n > 3);
console.log(roots); // [4, 9]

const sum = numbers.reduce(
    (acc, value, index, arr) => acc + value, 0
);
console.log(sum); // 14


/***@@@
 uniq.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход массив и возвращает новый массив, полученный из исходного удалением повторяющихся элементов.
 */

uniq([2, 1, 2, 3]); // [2, 1, 3]

// Взаимный порядок оставшихся элементов в новом массиве должен сохраняться.
uniq([2, 1, 2, 3]); // [2, 1, 3], a не [1, 2, 3] или не [3, 1, 2]

/**
 Подсказки
 - Для формирования новой коллекции (другой конфигурации) из старой подходит reduce.
 - Метод arr.includes(value) проверяет, входит ли элемент в коллекцию.
 - Метод arr.concat(value) объединяет исходный массив (на котором вызван метод) с другими массивами и/или значениями (переданными в качестве аргументов). Метод иммутабелен, возвращает новый массив. Примеры и подробности использования см. в документации: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat
 */

// FILE: /app/uniq.js:
export default coll => coll.reduce(
    (acc, value) => (
        acc.includes(value) ? acc : acc.concat(value)
    ),
    [],
);

// FILE: /app/__tests__/uniq.test.js:
import uniq from '../uniq';

test('uniq', () => {
    expect(uniq([])).toEqual([]);
    expect(uniq([2, 1])).toEqual([2, 1]);
    expect(uniq([2, 1, 2, 3])).toEqual([2, 1, 3]);
    expect(uniq([-2, 20, 0, 4, 20, 0])).toEqual([-2, 20, 0, 4]);
});




// >>>>>> Map <<<<<<

/**
 Ассоциативный массив - абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида "(ключ, значение)" и поддерживающий операции добавления пары, а так же поиска и удаления пары по ключу.

 # Javascript объект:
 */
сonst pirson = {
    firstName: 'Alan',
    lastName: 'Kay',
}

person.firstName; // Alan
person.lastName; // Kay

const propName = 'lastName';
person[propName]; // Kay

person[propName] = 'King';
person[propName]; // King

// Итерации:
Object.keys(person).forEach(propName => console.log(person[propName]));
Object.values(person).forEach(value => console.log(value);


// # Недостатки как Map:
// > Дополнительные свойства:
сonst obj = {};
console.log(obj.valueOf);
// [Function: valueOf]

// > Ключи только строки и символы:
const obj = { 3: 'value' };
// { '3': 'value' }

// > Определение размера:
Object.keys(obj).length;


// # Создание объекта типа Map:
const map = new Map(); // создание пустого объекта
// new Map([key, value], [key2, value2])
map.set('key','value');
map.set(10, 'another value');
map.set('key', 'value').set('anotherKey', 'anotherValue'); // Map поддерживает fluent интерфейс. Функция set возвращает сам Map. Таким образом можно строить цепочки

map.size; // 4

map.get('key'); // value
map.get(10); // another value'

/**
 Для удаления из Map служит функция delete, которая принимает на вход имя ключа. Функция clear поступает более радикально: удаляет все элементы из Map-объекта. Крайне не рекомендую строить свои алгоритмы таким образом, чтобы пришлось мутировать объекты удалением ключей. Такой код сложен в отладке и понимании.
 */

// При этом сам map является обычным объектом:
map instanceof Object // true
map instanceof Map // true

/**
 Но пользоваться им как обычным объектом категорически нельзя, последствия непредсказуемы, и вы точно получите не то, что ожидаете. Ниже будут описаны функции, которые вам понадобятся при работе с Map, все манипуляции должны происходить именно с ними.

 Иногда бывает нужно создать Map для уже существующих данных. Такой способ работы также предусмотрен через конструктор. Правда в этом случае придется подготовить данные определенным способом:
 */

// # Цикл for...of
const person = new Map([['name', 'John'], ['surname', 'Doe'], ['age', 50]]);

// создание итератора по ключам
// имя константы может быть любым, мы выбрали 'keys'
const keys = person.keys();

// перебор ключей
for (const key of keys) {
    console.log(key);
}

// name
// surname
// age

// создание итератора по значениям
const values = person.values();

// перебор значений
for (const value of values) {
    console.log(value);
}

// John
// Doe
// 50


// создание итератора по записям
const entries = person.entries();

// перебор записей
for (const entry of entries) {
    console.log(entry);
}

// [ 'name', 'John' ]
// [ 'surname', 'Doe' ]
// [ 'age', 50 ]


// # Map как коллекция:

/**
 У Map-объектов также есть метод forEach, который позволяет удобно сделать перебор ключей и значений. Этот метод вызывается на объекте и принимает на вход callback-функцию. На каждой итерации эта callback-функция принимает ключ и значение очередной записи объекта, поэтому надо предусмотреть для них в сигнатуре функции соответствующие параметры (в примере ниже, это параметры value и key):
 */
map.keys();
map.values();
map.etries(); // [[key, value], [key2, value2]];

map.forEach((key, value) => console.log(key, value));

/**
 В качестве ключей для Map-объектов могут быть значения любых типов в js, даже другие объекты типа Map

 # Отличие от объекта
 Может возникнуть вопрос, зачем нужен Map если есть объект? И, в реальности, действительно так. Map используется редко. Основная причина его использования в JS заключается в том, что обычный объект имеет множество служебных свойств, которые содержат важную информацию и функции. Если эти функции случайно перезапишут, то программа может просто сломаться.
 */

/***@@@
 wordsCount.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход два параметра: список слов и список стоп-слов. Задача функции вернуть объект типа Map, содержащий в себе частоту переданных слов. То есть, ключами являются сами слова, а значениями число повторений.

 - Слова могут быть в разных регистрах, а подсчет должен работать без учета регистра. Соответственно в результирующем наборе слова должны быть представлены в нижнем регистре.
 - Порядок слов в выходе должен совпадать с порядком появления новых слов во входном наборе.
 - stopWords – это список стоп-слов, которые не должны попадать в результирующую структуру. Стоп-слова указываются в нижнем регистре.
 */
const stopWords = ['and', 'or', 'a', 'the', ''];
const words = ['HellO', 'h', 'And', 'heLlo', '', 'AND', 'DOG', 'oR', 'cat', 'HELLO', 'caT'];
wordsCount(words, stopWords); // [['hello', 3], ['h', 1], ['dog', 1], ['cat', 2]]

/**
 Подсказки
 - Воспользуйтесь тройкой map/filter/reduce.
 - Функция has типа Map проверяет наличие ключа в мапе
 - Проверка должна быть регистро-независимой
 */

// FILE: /app/wordsCount.js:
export default (words, stopWords) => words
    .map(word => word.toLowerCase())
    .filter(word => !stopWords.includes(word))
    .reduce((acc, word) => {
        const count = acc.get(word) || 0;

        return acc.set(word, count + 1);
    }, new Map());




// >>>>>> Set <<<<<<

// Задача по стоп-словам:
сonst stopWords = ['one', 'two', 'four'];
const words = [
    'one', 'five', 'six', 'seven',
    'two', 'four', 'nine',
];

const result = words.filter(word => !stopWords.includes(word));
concole.log(result); // ['five', 'six', 'seven', 'nine']

/**
 includes - проверяет наличие значения полным перебором массива
 ПРОБЛЕМЫ будут при больших объемах данных и длинном процессинге:

 #1: Решение с использованием Map:
 */

сonst stopWords = { // or new Map()
    one: true,
    two: true,
    four: true
};

const words = [
    'one', 'five', 'six', 'seven',
    'two', 'four', 'nine',
];

const result = words.filter(word => !stopWords.[word]);


// #2: Решение с использованием Set (cамый правильный, поскольку поиск без перебора):
сonst stopWords = new Set(['one', 'two', 'four']);
const words = [
    'one', 'five', 'six', 'seven',
    'two', 'four', 'nine',
];

const result = words.filter(word => !stopWords.has(word));


// # Интерфейс Set:
const set = new Set();
set.add(5);
set.add('some text');

set.size; // 2

set.has(5); // true
set.has('some text'); // true

set.delete(5);
set.has(5); // false


// # Обход:
const set = new Set([1, 2, 10, 10]);

Array.from(set); // [1, 2, 10] оставит только уникальные элементы

set.keys();
set.values();

set.forEach(value => console.log(value));


/***@@@
 difference.js
 Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход два множества и возвращает множество, составленное из таких элементов, которые есть в первом множестве, но нет во втором.
 */

difference(new Set([2, 1]), new Set([2, 3])); // → [1]

// FILE: /app/difference.js:
export default (set1, set2) =>
    new Set(Array.from(set1).filter(value => !set2.has(value)));



// >>>>>> Fluent interface <<<<<<

// TDD:
const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2010 },
];

const coll = new Enumerable(cars);

const result = coll.orderBy(car => car.year)
    .where(car => car.brand === 'kia')
    .where(car => car.year > 2011);

assert.deepEqual(result.toArray(), [cars[2], cars[4]]);

// Fluent interface - cпособ реализации объектно-ориентированного API, нацеленный на повышение читабельности исходного кода программы

$(this).find('img').stop().animate({opacity: 0.8}, 300).end();

// # Реализация:

class Enumerable {
    constructor (collection) {
        this.collection = collection;
    }

    where (fn) {
        this.collection = this.collection.filter(fn);

        return this;
    }

    toArray() {
        return this.collection;
    }
}


/***@@@
 Enumerable.js
 Select
 Реализуйте метод select, который отображает (принцип работы как у функции map) коллекцию, другими словами, извлекает из элементов коллекции нужные данные и возвращает объект с новой (отображенной) коллекцией из этих данных.
 */

const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2010 },
    { brand: 'kia', model: 'sportage', year: 2012 },
];
coll = new Enumerable(cars);

// [car] => [model]
const result = coll.select(car => car.model);

assert.deepEqual(result.toArray(), ['m5', 'm4', 'sorento', 'rio', 'sportage']);

/**
 OrderBy
 Реализуйте метод orderBy, который сортирует коллекцию на основе переданных данных.

 Принимаемые параметры:

 Функция, возвращающая значение, по которому будет происходить сортировка.
 Направление сортировки: asc - по возрастанию, desc - по убыванию (по умолчанию - asc).
 */
const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2010 },
    { brand: 'kia', model: 'sportage', year: 2012 },
];
coll = new Enumerable(cars);

const result = coll.orderBy(car => car.year, 'desc')
    .where(car => car.brand === 'bmw')
    .select(car => car.model);

assert.deepEqual(result.toArray(), ['m5', 'm4']);

/**
 Подсказки
 Для выполнения сортировки воспользуйтесь встроенной функцией: sort. https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 */

// FILE: /app/Enumerable.js:
class Enumerable {
    constructor(collection) {
        this.collection = collection;
    }

    select(fn) {
        this.collection = this.collection.map(fn);

        return this;
    }

    orderBy(fn, direction = 'asc') {
        const compareResult = direction === 'asc' ? 1 : -1;
        const comparator = (a, b) => {
            const a1 = fn(a);
            const b1 = fn(b);

            if (a1 > b1) {
                return compareResult;
            }
            if (a1 < b1) {
                return -compareResult;
            }

            return 0;
        };

        this.collection.sort(comparator);

        return this;
    }

    where(fn) {
        this.collection = this.collection.filter(fn);
        return this;
    }

    toArray() {
        return this.collection.slice();
    }
}

export default Enumerable;




// >>>>>> Неизменяемость <<<<<<

/**
 Императивный подход -> Возвращается измененная структура данных
 Функциональный подход -> Возвращается новая структура, являющаяся преобразованием старой
 */

сlass Enumerable {
    constructor(collection) {
        this.collection = collection;
    }

    where(fn) {
        const filtered = this.collection.filter(fn);

        return new Enumerable(filtered);
    }
}

// In-Place замена
const arr = [5, 1, 3];
arr.sort();
console.log(arr); // [1, 3, 5]

const arr2 = [5, 1, 3];
arr2.slice().sort(); // обход изменения исходного массива через slice()

console.log(arr2); // [5, 1, 3]


/***@@@
 Enumerable.js
 Реализуйте функции select, orderBy используя подход без мутации состояния.
 */

// FILE: /app/Enumerable.js:
class Enumerable {
    constructor(collection) {
        this.collection = collection;
    }

    select(fn) {
        const mapped = this.collection.map(fn);

        return new Enumerable(mapped);
    }

    orderBy(fn, direction = 'asc') {
        const comparator = (a, b) => {
            const a1 = fn(a);
            const b1 = fn(b);

            const compareResult = direction === 'asc' ? 1 : -1;

            if (a1 > b1) {
                return compareResult;
            } else if (a1 < b1) {
                return -compareResult;
            }

            return 0;
        };

        const clone = this.collection.slice();
        clone.sort(comparator);

        return new Enumerable(clone);
    }

    where(fn) {
        const filtered = this.collection.filter(fn);
        return new Enumerable(filtered);
    }

    toArray() {
        return this.collection;
    }
}

export default Enumerable;




// >>>>>> Ленивые вычисления <<<<<<

/**
 # Lazy Evaluation
 Ленивые вычисления (отложенные) - применяемая в некоторых языках программирования стратегия вычисления, согласно которой вычисления следует откладывать до тех пор, пока не понадобится их результат
 */

// # Ленивость в JS
true || console.log('message'); // true
false && console.log('message'); // false

// # Ленивые коллекции
сonst numbers = Lazy.generate(Math.random) // библиотека с Git Hub
    .map(e => Math.floor(e * 1000) + 1)
    .uniq()
    .take(300);

numbers.each(e => console.log(e)); // выполнение здесь

/**
 Ленивые коллекции позволяют работать с:
 - Бесконечные списки
 - Эффективная обработка при проходе
 */

// LINQ
constructor(collection, operations) {
    this.collection = collectionl;
    this.operations = operations || [];
}

select (fn) {
    const newOps = this.operations.slice();
    newOps.push(coll => coll.map(fn)); // откложенные вычисления

    return new Enumerable(this.collection.slice(), newOps); // в newOps - новые операции
}

// # Cравнение объектов:
[] === []; // false
['cat', 'dog'] === ['cat', 'dog']; // false

const a = {}; // в a ссылка на объект
const b = {};

a === b; // false

// Тесты:
asset.equal(a, b); // false
assert.deepEqual(a, b); // true


// # Передача по ссылке:
const numbers = [10, 8, 1, 7, 4];
const mySort = coll => coll.sort(); // side effect
mySort(numbers); // [1, 10, 4, 7, 8]

// side-effect
console.log(numbers); // [1, 10, 4, 7, 8]


// # Общий пример:
const f = (a, b, c) => {
    a = a * 10;
    b.item = 'changed';
    c = { item: 'changed' };
};

const num = 10;
const obj1 = { item: 'unchanged' };
const obj2 = { item: 'unchanged' };

f(num, obj1, obj2);

console.log(num); // 10
console.log(obj1.item); // changed
console.log(obj2.item); // unchanged


/***@@@
 Enumerable.js
 Реализуйте ленивую версию Enumerable. Интерфейс включает в себя следующие методы: select, where, orderBy, toArray.

 Подсказки
 - Так как коллекция ленивая, не нужно выполнять вычислений до вызова toArray, вместо этого необходимо формировать коллекцию из отложенных вычислений.
 */


// FILE: /app/Enumerable.js:
class Enumerable {
    constructor(collection, operations) {
        this.collection = collection;
        this.operations = operations || [];
    }

    build(fn) {
        return new Enumerable(this.collection.slice(), this.operations.concat(fn));
    }

    select(fn) {
        return this.build(coll => coll.map(fn));
    }

    orderBy(fn, direction = 'asc') {
        const compareResult = direction === 'asc' ? 1 : -1;
        const comparator = (a, b) => {
            const a1 = fn(a);
            const b1 = fn(b);

            if (a1 > b1) {
                return compareResult;
            } else if (a1 < b1) {
                return -compareResult;
            }

            return 0;
        };

        return this.build(coll => coll.sort(comparator));
    }

    where(fn) {
        return this.build(coll => coll.filter(fn));
    }

    toArray() {
        return this.operations.reduce((acc, func) => func(acc), this.collection);
    }
}

export default Enumerable;




// >>>>>> getter и мемоизация <<<<<<

// ...
coll = new Enumerable(cars);

const result = coll.where(car => car.brand === 'kia')
    .where(car => car.year > 2011);

result.length; // ???

// # Обновление во время вычисления
toArray() {
    const result = 'some code here...';
    this.length = result.length;
    return result;
}

// # Getter:
class Enumerable {
    get length() { // не имеет права принимать параметры
        return 'some code here...';
    }
}

const result = coll
    .where(car => car.brand === 'kia')
    .where(car => car.year > 2011);

result.length; // использование => 2


// # Повторные вычисления:
result.length;
result.toArray();

/**
 # Мемоизация
 Сохранение результатов выполнения функций для предотвращения повторных действий.
 Мемоизация выполняется всегда по одному и тому же шаблону. Создаётся переменная, которая заполняется, если она была пустая, а затем используется для отдачи значения без выполнения вычислений. Её можно сделать с помощью одних лишь функций, на замыканиях (а значит придётся генерировать функцию). Ниже пример с мемоизацией факториала:
 */

// #1:
methodName() {
    if (!this.memo) { // если свойство memo не установлено
        this.memo = 'some code here...'; // то устанавливаем его значение
    }

    return this.memo;
}

methodName(); // вычисление => memo
methodName(); // => memo


// Это просто функция вычисляющая факториал без мемоизации
const factorial = (num) => {
    if (num === 0) {
        return 1;
    }
    return num * factorial(num - 1);
}

// #2:
// Эта функция выполняет мемоизацию факториала
const generateFactorialWithMemo = () => {
    // Здесь будут храниться вычисленные значения
    // Так как функция факториала применяется к разным аргументам, то для хранения результатов
    // понадобится объект. В более простых случаях достаточно обычного значения (как в практике к этому уроку)
    let memo = {};

    // Эта функция возвращается наружу и именно она будет заниматься вычислением факториала
    return (num) => {
        // Если значение не мемоизированно, то мемоизируем
        if (!memo[num]) {
            memo[num] = factorial(num);
        }

        // Возвращаем значение из мемо
        return memo[num];
    };
};

const f = generateFactorialWithMemo();
// Значение вычисляется
f(3); // => 6

// Значение не вычисляется
f(3); // => 6

/**
 Отличительная черта мемоизации, которая отделяет её от кеширования — отсутствие устаревания. Данные внутри мемо устареть не могут по определению — ведь, если наша функция чистая, то для одного входа она всегда даёт один и тот же выход. А мемоизируют только чистые функции, иначе всегда есть риск сохранить результат, который впоследствии может поменяться.
 */


/***@@@
 Enumerable.js
 Реализуйте метод toArray, возвращающий массив обработанных элементов коллекции. Мемоизируйте этот массив во внутреннем свойстве memo.
 */

const coll = new Enumerable([1, 2, 3, 4, 5, 6]);
const filteredColl = coll.where(n => n > 3);

// В этот момент запускаются отложенные операции и результат возвращается.
filteredColl.toArray(); // [4, 5, 6]

// Повторный запуск извлекает массив из `memo`. Вычисления больше не производятся.
filteredColl.toArray(); // [4, 5, 6]


/**
 Реализуйте свойство length, которое возвращает количество элементов в коллекции. Так как для вычисления её длины, нужно получить результирующий массив (применив все отложенные операции), логично реализовать это свойство как getter, который вызывает внутри себя toArray.
 */

const coll = new Enumerable([1, 2, 3, 4, 5, 6]);
filteredColl = coll.where(n => n > 3);

// В этот момент запускаются отложенные операции и результат возвращается.
filteredColl.length; // 3

// Так как toArray мемоизирован, то повторный вызов не приводит к вычислениям, массив берется из memo
filteredColl.length; // 3


// FILE: /app/Enumerable.js:
class Enumerable {
    constructor(collection, operations) {
        this.collection = collection;
        this.operations = operations || [];
    }

    build(fn) {
        return new Enumerable(this.collection.slice(), this.operations.concat(fn));
    }

    select(fn) {
        return this.build(coll => coll.map(fn));
    }

    orderBy(fn, direction = 'asc') {
        const comparator = (a, b) => {
            const a1 = fn(a);
            const b1 = fn(b);

            const compareResult = direction === 'asc' ? 1 : -1;

            if (a1 > b1) {
                return compareResult;
            }

            if (a1 < b1) {
                return -compareResult;
            }

            return 0;
        };

        return this.build(coll => coll.sort(comparator));
    }

    where(fn) {
        return this.build(coll => coll.filter(fn));
    }

    getProcessedCollection() {
        if (!this.memo) {
            this.memo = this.operations.reduce((acc, func) => func(acc), this.collection);
        }

        return this.memo;
    }

    get length() {
        return this.getProcessedCollection().length;
    }

    toArray() {
        return this.getProcessedCollection().slice();
    }
}

export default Enumerable;




// >>>>>> Операция rest <<<<<<

// Разоблачение списков:
const numbers = l(1, 10, 23, 234);

export const l = (...elements) =>
    // elements = [1, 10, 23, 234]
    elements.reverse().reduce((acc, item) => cons(item, acc), null);


// # Общая форма:
const fn = (a, b, ...theArgs) => {
    console.log(a);
    console.log(b);
    console.log(theArgs);
}

fn('first');
// first
// undefined
// []


/***@@@
 Enumerable.js
 Реализуйте метод where, основываясь на следующем интерфейсе:

 Функция может принимать любое количество параметров, каждый из которых может быть либо функцией, либо объектом. Для функций должна осуществляться простая фильтрация, для объектов нужно проверять соответствие элемента коллекции значениям по тем же ключам, что и в переданном объекте.
 */

const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2010 },
    { brand: 'kia', model: 'sportage', year: 2012 },
];

coll = new Enumerable(cars);

const result = coll
    .where(car => car.brand === 'kia')
    .where(car => car.year > 2011);

result.toArray();
// [
//   { brand: 'kia', model: 'sorento', year: 2014 },
//   { brand: 'kia', model: 'sportage', year: 2012 },
// ]

const result2 = coll.where({ brand: 'bmw' });
result2.toArray();
// [
//   { brand: 'bmw', model: 'm5', year: 2014 },
//   { brand: 'bmw', model: 'm4', year: 2013 },
// ]

const result3 = coll.where({ brand: 'kia', model: 'sorento' });
result3.toArray();
// [
//   { brand: 'kia', model: 'sorento', year: 2014 },
// ]

const result3 = coll.where({ brand: 'kia' }, {  model: 'sorento' });
result3.toArray();
// [
//   { brand: 'kia', model: 'sorento', year: 2014 },
// ]

const result4 = coll.where({ brand: 'kia' }, car => car.year < 2013);
result4.toArray();
// [
//   { brand: 'kia', model: 'rio', year: 2010 },
//   { brand: 'kia', model: 'sportage', year: 2012 },
// ]

/**
 Подсказки
 - Извлечь ключи из объекта можно функцией Object.keys.
 - Проверка на функцию: typeof <value> === 'function'.
 - Метод every проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Подробнее в документации.
 */

// FILE: /app/Enumerable.js:
class Enumerable {
    constructor(collection, operations) {
        this.collection = collection;
        this.operations = operations || [];
    }

    build(fn) {
        return new Enumerable(this.collection.slice(), this.operations.concat(fn));
    }

    where(...predicates) {
        const fns = predicates.map((predicate) => {
            if (typeof predicate === 'function') {
                return coll => coll.filter(predicate);
            }

            const keys = Object.keys(predicate);

            return coll => coll.filter(element =>
                keys.every(key => predicate[key] === element[key]));
        });

        return this.build(fns);
    }

    getProcessedCollection() {
        if (!this.memo) {
            this.memo = this.operations.reduce((acc, func) => func(acc), this.collection);
        }

        return this.memo;
    }

    get length() {
        return this.getProcessedCollection().length;
    }

    toArray() {
        return this.getProcessedCollection().slice();
    }
}

export default Enumerable;




// >>>>>>> Операция spread <<<<<<

// # Базовое использование:
// const numbers = l(1, 10, 23, 234);
const numbers = l(...[1, 10, 23, 234]);

myFunction(...iterableObj);


// # Аргументы:
const fn = (v, w, x, y, z) => {}
const args = [0, 1];

fn(-1, ...args, 2, ...[3]);

// # Пример:
сonst arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];
arr1.push(...arr2);

// [0, 1, 2, 3, 4, 5]
console.log(arr1);


// # Immutable way
[...iterableObj, 4, 5, 6];

const parts = ['shoulders', 'knees'];
const lyrics = ['head', ...parts, 'and', 'toes'];

// ['head', 'shoulders', 'knees', 'and', 'toes']
console.log(lyrics);


// # Immutable Reduce:

// Reverse:
const arr = [1, 2, 3, 4, 5];
arr.reduce((acc, value) => [value, ...acc], []);
// [5, 4, 3, 2, 1]

// Repeat:
const arr = [1, 2, 3, 4, 5];
arr.reduce((acc, value) => [...acc, value, value]);
// [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]


/***@@@
 objectify.js
 Реализуйте и экспортируйте по умолчанию функцию, которая работает следующим образом:

 Принимает на вход список (в виде обычного js массива с объектами внутри) и функцию-селектор, выбирающую из каждого объекта определенное значение.
 Возвращает объект, в котором ключ - это результат применения функции селектора к каждому объекту в массиве, а значение - это сам объект.
 Обратите внимание на то, что эта функция высшего порядка является универсальной и работает с любыми наборами данных.
 */

const cars = [
    { brand: 'bmw', model: 'm3', year: 2013 },
    { brand: 'opel', model: 'astra', year: 2014 },
    { brand: 'hyundai', model: 'accent', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2013 },
    { brand: 'kia', model: 'sportage', year: 2015 },
];

console.log(objectify(cars, car => car.model));

// {
//   accent: { brand: 'hyundai', model: 'accent', year: 2014 },
//   astra: { brand: 'opel', model: 'astra', year: 2014 },
//   m3: { brand: 'bmw', model: 'm3', year: 2013 },
//   rio: { brand: 'kia', model: 'rio', year: 2013 },
//   sportage: { brand: 'kia', model: 'sportage', year: 2015 },
// };

/**
 Подсказки
 { ...acc, [propertyName]: value }
 Решите эту задачу используя reduce
 Порядок ключей в объекте при выводе - не важен
 */

// FILE: /app/objectify.js:
export default (coll, select) => coll.reduce((acc, item) => ({ ...acc, [select(item)]: item }), {});




// >>>>>> Дестракчеринг <<<<<<

// Определение функции:
const animals = [
    { age: 5, type: 'cat' },
    { age: 10, type: 'dog' },
];

const result = animals.filter(({ age }) => age > 7);

// [ { age: 10, type: 'dog'}]
console.log(result);

// # Извлечение:
const animals = ['Dog Name', 'Cat Name'];
const [myDog, myCat] = animals;

// # Rest
const x = [1, 2, 3, 4, 5];
const [a, b, ...rest] = x;
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [3, 4, 5]

// # Объекты:
const {a, b} = { a: 1, b: 2 }; //  должны совпадать
console.log(a); // 1
console.log(b); // 2


// # Значение по умолчанию:
сonst [a = 5, b = 7] = [1];
console.log(a); // 1
console.log(b); // 7

// # Обмен переменных местами:
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1


// # Определение функций:
const animals = [
    { age: 5, type: 'cat' },
    { age: 10, type: 'dog' },
];


// # Составной объект:
const metadata = {
    title: 'Scratchpad',
    translations: [
        { locale: 'de', title: 'JavaScript-Umgebung' }
    ],
    url: '/en-US/docs/Tools/Scratchpad'
};

const {
    title: englishTitle,
    translations: [
        {
            title: localTitle
        }
    ]
} = metadata;

console.log(englishTitle); // Scratchpad
console.log(blocalTitle); // JavaScript-Umgebung


/***@@@
 getCarsCountByYear.js
 Это упражнение рассчитано на максимальное использование знаний последних уроков. К сожалению, невозможно тестами убедиться в том, что ваше решение будет содержать деструктивное присваивание или rest оператор, поэтому вам нужно самостоятельно прикладывать усилия для их использования.

 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход список машин (в виде обычного js массива с объектами), а возвращает объект, в котором свойство - это год выпуска, а значение - это количество машин для соответствующего года.

 Порядок свойств в результирующем объекте не важен.
 */
const cars = [
    { brand: 'bmw', model: 'm5', year: 2014 },
    { brand: 'bmw', model: 'm4', year: 2013 },
    { brand: 'kia', model: 'sorento', year: 2014 },
    { brand: 'kia', model: 'rio', year: 2010 },
    { brand: 'kia', model: 'sportage', year: 2012 },
];

console.log(getCarsCountByYear(cars));
//  {
//    2010: 1,
//    2012: 1,
//    2013: 1,
//    2014: 2,
//  };

/**
 Решите эту задачу, используя итеративный процесс. Он хорош тем, что позволяeт задействовать сразу все, что нужно.

 Подсказки
 Вам понадобятся:
 */
const [first, ...rest] = arr
const { propertyName } = obj
{ ...acc, [propertyName]: value }

// FILE: /app/
import { has } from 'lodash';

export default (cars) => {
    const iter = (items, acc) => {
        if (items.length === 0) {
            return acc;
        }

        const [{ year }, ...rest] = items;
        const newValue = has(acc, year) ? acc[year] + 1 : 1;

        return iter(rest, { ...acc, [year]: newValue });
    };

    return iter(cars, {});
};




// ############################### JS: Деревья ###############################

/**
 Дерево — одна из самых распространённых структур данных в информатике и естественный способ моделирования некоторых предметных областей. С деревьями (как структурой данных) встречаются так или иначе все люди, даже те, кто далёк не только от программирования, но и от компьютеров в целом. Самым очевидным примером служит генеалогическое древо, а из более специализированного — файловое дерево. Ну и, конечно, HTML (а так же json, xml и многое другое), он также имеет древовидную структуру. Любая иерархия является деревом по определению.
 */


// >>>>>> Определения <<<<<<

/**
 Ключевая черта древовидной структуры в том, что она рекурсивна. Другими словами, дерево состоит из поддеревьев, которые в свою очередь состоят из поддеревьев, которые в свою очередь... В конце концов, в самом низу, находятся листья — и вот они уже не имеют потомков и никуда не ведут.

 Дерево состоит из узлов (вершин или нод, так как по-английски узел — это node) и рёбер между ними. Рёбра в реальности не существуют, они нужны лишь для того, чтобы визуализировать связь и, по необходимости, описать её. Узлы делятся на два типа: внутренние (те, у которых есть потомки) и листовые узлы (те, у которых нет потомков). В случае файловой системы листовые узлы представлены файлами, а внутренние — директориями.

 В деревьях у каждой вершины есть родитель (или предок). Единственным исключением является корневой узел — у него нет родителей, и именно с него начинается дерево. Количество потомков у любой внутренней вершины, в общем случае, может быть любым. Кроме того, в деревьях выделяют понятие глубины (depth), определяющей то, сколько шагов нужно пройти по вершинам от корневой, чтобы достичь текущей (той, на которую смотрим). Вершины на одной глубине с общим родителем называют братскими или сестринскими.

 # Определение

 Количество способов, которыми можно описать деревья, бесконечно много. Здесь мы рассмотрим только те, которые основаны на повторении структуры дерева в той структуре данных, которая его описывает. Самый примитивный вариант — это вложенные массивы:
 */

[[1, 4], 2, [3, 8]];
//     *
//    /|\
//   * 2 *
//  /|   |\
// 1 4   3 8

[3, 2, [3, 8], [[8], 3]];
[1, null, [[3]], [5, 'string', [undefined, [3], { key: 'value' }]]];

/**
 В примерах выше корень — это сам массив, а все его элементы — это дети. Если ребёнок не является массивом, то он рассматривается как листовой узел, иначе — как внутренний узел. Внутренний узел, в свою очередь, состоит из детей. Такая структура имеет ограничение. Внутренние узлы не могут хранить данных, но, в целом, такая схема может использоваться и встречаться в жизни.

 Можно пойти дальше и добиться большей гибкости. Представим каждый элемент дерева массивом, в котором первый элемент — это значение, хранящееся в узле, а второй элемент — массив детей. Если второй элемент отсутствует, то считаем, что текущий узел — листовой.
 */
[[3], [4], [[10], [[3], [2], [8], [[2], [[3], [4]]]]]]

/**
 Такой вариант многословнее, но позволяет хранить данные (произвольные) в любом узле, даже не листовом. Теперь, надеюсь, вам понятен принцип организации, и вы можете самостоятельно попрактиковаться в придумывании способов упаковки деревьев в массив. Кстати, интересная деталь. Исходный код высокоуровневых языков тоже имеет рекурсивную структуру. Посмотрите на код:
 */

f1(3 * f2(f3() + 5));

// Аргументы функции — выражения, а значит могут быть вызовами функций, что порождает рекурсию. Если код выше переписать в стиле lisp языков, то получится самое настоящее дерево, состоящее из списков:
(f1 (* 3 (f2 (+ 5 (f3))))

/**
 Соглашение здесь такое: первым элементом списка является функция (любые операции рассматриваются как функции), а всё остальное — её аргументы.

 Ещё один способ определения основан на ассоциативных массивах, а конкретно в javascript — на объектах:
 */
{
    value: 5,
        children: [
    { value: 10 },
    { value: 100 },
    { value: 'nested', children: [/** ... */] }
]
}


/**
 По большому счёту, что массив, что объект сами по себе всегда могут рассматриваться как дерево, безотносительно своей внутренней структуры и наличию вложенных элементов. Такова их природа. Структура присутствует там, где нужно хранить именно древовидные данные, например, файловую систему. Начну с того, что открою секрет, большинство файловых систем не просто имеют древовидную структуру, но и на уровне реализации представлены деревьями как структурами данных.

 По ходу курса мы будем работать с одной и той же структурой, создавая поверх неё различные вспомогательные функции для поиска и модификации содержимого. Ниже показан код (dsl), который создаёт необходимый объект-дерево:
 */

const tree = mkdir('etc', [
    mkdir('consul', [
        mkfile('config.json', { size: 1200 }),
    ]),
], { key: 'value' });

// В результате выполнения кода получается следующий результат:
{
    name: 'etc',
        type: 'directory',
    meta: {
    key: 'value',
},
    children: [
        {
            name: 'consul',
            type: 'directory',
            meta: {},
            children: [
                {
                    name: 'config.json',
                    type: 'file',
                    meta: {
                        size: 1200
                    }
                }
            ],
        },
    ],
};

// Представление директории:
{
    name: /** ... */,
    type: 'directory',
        meta: {},
    children: [/** ... */],
}


// Представление файла:
{
    name: /** ... */,
    type: 'file',
        meta: {},
}


/**
 Некоторые утверждения относительно дерева выше:
 - Файлы — листовые узлы;
 - Директории — внутренние. Могут содержать как файлы, так и директории внутри свойства children;
 - meta — объект с произвольными данными, например, размером, датой создания и так далее;
 - Директорию от файла отличает, в первую очередь, тип, заданный соответствующим свойством.
 Про последнее скажу пару слов. То самое понимание ООП, о котором так много говорят, как раз заключается в том, что код рассматривается с точки зрения типов, и вы их можете увидеть. Важно выделять их явно, а не анализировать по косвенным признакам — например, определение того, что за нода перед нами (какой у неё тип!), нужно делать через проверку type, а не через проверку наличия свойства children.
 */




// >>>>>> Traversal <<<<<<

/**
 Пошаговый перебор элементов дерева по связям между узлами-предками и узлами-потомками называется обходом дерева. Подразумевается, что в процессе обхода каждый узел будет затронут только один раз. По большому счёту, всё так же, как и в обходе любой коллекции, используя цикл или рекурсию. Только в случае деревьев способов обхода больше, чем просто слева направо и справа налево. В данном курсе используется один порядок обхода — обход в глубину, так как он естественным образом получается при рекурсивном обходе. Об остальных способах можно прочитать на википедии либо в рекомендованных книгах Хекслета.

 # Обход в глубину (Depth-first search)
 Один из методов обхода дерева (графа в общем случае). Стратегия этого поиска состоит в том, чтобы идти вглубь одного поддерева настолько, насколько это возможно. Этот алгоритм естественным образом ложится на рекурсивное решение и получается сам собой.

 Рассмотрим данный алгоритм на примере следующего дерева:

 //     * A
 //    /|\
 // B * C * D
 //  /|   |\
 // E F   G J

 Каждую нелистовую вершину я обозначил звёздочкой. Обход начинается с корневого узла.

 1. Проверяем, есть ли у вершины A дети. Если есть, то запускаем обход рекурсивно для каждого ребёнка независимо;
 2. Внутри первого рекурсивного вызова оказывается следующее поддерево:

 // B *
 //  /|
 // E F

 Повторяем логику первого шага. Проваливаемся на уровень ниже.

 1. Внутри оказывается листовой элемент E. Функция убеждается, что у узла нет дочерних элементов, выполняет необходимую работу и возвращает результат наверх.
 2. Снова оказываемся в ситуации:

 // B *
 //  /|
 // E F


 В этом месте, как мы помним, рекурсивный вызов запускался на каждом из детей. Так как первый ребёнок уже был посещён, второй рекурсивный вызов заходит в узел F и выполняет там свою работу. После этого происходит возврат выше, и всё повторяется до тех пор, пока не дойдёт до корня.
 */

const dfs = (tree) => {
    const [name, children] = tree;
    console.log(name);

    if (!children) {
        return;
    }

    return children.map(dfs);
};

const tree = ['A', [
    ['B', [['E'], ['F']]],
    ['C'],
    ['D', [['G'], ['J']]],
]];

dfs(tree);

/**
 В примере выбрана схема дерева на массивах. Первый элемент массива это значение узла, второй (если есть) — это дети. По пунктам:
 1. Извлекаем из дерева (или поддерева) значение и детей;
 2. Печатаем значение;
 3. Если нет детей, то выходим. Если есть — вызываем рекурсивно функцию dfs для каждого ребёнка.

 Всё, что будет дальше делаться по ходу курса, неизменно базируется на этом алгоритме. Попробуйте открыть редактор на своём компьютере и самостоятельно реализовать эту функцию без подглядывания. Так вы убедитесь в том, что поняли происходящее.
 */

/***@@@
 downcaseFileNames.js
 Реализуйте функцию, которая принимает на вход директорию, приводит имена всех файлов в этой и во всех вложенных директориях к нижнему регистру. Результат в виде обработанной директории возвращается наружу.

 Экспортируйте по умолчанию функцию.
 */

const tree = mkdir('/', [
    mkdir('eTc', [
        mkdir('NgiNx'),
        mkdir('CONSUL', [
            mkfile('config.json'),
        ]),
    ]),
    mkfile('hOsts'),
]);

downcaseFileNames(tree);
// {
//   name: '/',
//   type: 'directory',
//   meta: {},
//   children: [
//     {
//       name: 'eTc',
//       type: 'directory',
//       meta: {},
//       children: [
//         {
//           name: 'NgiNx',
//           type: 'directory',
//           meta: {},
//           children: [],
//         },
//         {
//           name: 'CONSUL',
//           type: 'directory',
//           meta: {},
//           children: [{ name: 'config.json', type: 'file', meta: {} }],
//         },
//       ],
//     },
//     { name: 'hosts', type: 'file', meta: {}, },
//   ],
// }


// FILE: /app/downcaseFileNames.js:
const downcaseFileNames = (node) => {
    if (node.type === 'directory') {
        return { ...node, children: node.children.map(downcaseFileNames) };
    }

    return { ...node, name: node.name.toLowerCase() };
};

export default downcaseFileNames;




// >>>>>> Map <<<<<<

/**
 Пример предыдущего урока крайне просто обобщить до функции высшего порядка map. Напомню, что map — отображение. Если раньше мы отображали плоские списки, то теперь отобразим вложенную структуру. С точки зрения семантики ничего не меняется. map каждому узлу ставит в соответствие новый узел, так что структура всего дерева остаётся прежней, а вот данные внутри узла меняются.
 */

const dfs = (tree) => {
    const [name, children] = tree;
    const newName = name.toLowerCase();

    if (!children) {
        return [newName];
    }

    return [newName, children.map(dfs)];
};

const tree = ['A', [
    ['B', [['E'], ['F']]],
    ['C'],
    ['D', [['G'], ['J']]],
]];

JSON.stringify(dfs(tree));

/**
 Преобразование включает в себя следующие шаги:

 1. Переименовать функцию в map;
 2. Добавить в сигнатуру функции передачу функции обработчика;
 3. Пропустить ноду через эту функцию;
 */

// В коде используются два разных map. Один самописный, другой на массиве.
const map = (f, tree) => {
    const [, children] = tree;
    const [newName] = f(tree);

    if (!children) {
        return [newName];
    }

    return [newName, children.map(c => map(f, c))];
};

const tree = ['A', [
    ['B', [['E'], ['F']]],
    ['C'],
    ['D', [['G'], ['J']]],
]];

JSON.stringify(map(([name]) => [name.toLowerCase()], tree));

/**
 При дестракчеринге можно игнорировать отдельные элементы массива (выбирать конкретные значения с учётом порядка). В примере выше мы никак не использовали константу name, то есть в этом случае нам нужно только второе значение массива, поэтому выражение const [name, children] = tree; можно переписать так: const [, children] = tree;, не создавая тем самым лишнюю константу.

 Дерево до отображения:

 //   A *
 //    /|\
 // B * C * D
 //  /|   |\
 // E F   G J


 Дерево после отображения:

 //   a *
 //    /|\
 // b * c * d
 //  /|   |\
 // e f   g j


 Обратите внимание на интересную деталь: в функцию обработчик нужно отдавать всю ноду, а не только имя. Связано это с тем, что преобразование может использовать любую часть узла, в том числе информацию о его детях. С другой стороны, поскольку у нас map, то количество возвращаемых узлов и структура дерева должны быть сохранены. Поэтому после обработки мы извлекаем имя из получившегося результата и собираем ноду с этим именем плюс рекурсивно обработанные дети.

 Если структура дерева изменится, то эту функцию придётся переписать, но общая схема останется прежней.
 */

/***@@@
 map.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход функцию-обработчик и дерево, а возвращает отображенное дерево.
 */
const tree = mkdir('/', [
    mkdir('eTc', [
        mkdir('NgiNx'),
        mkdir('CONSUL', [
            mkfile('config.json'),
        ]),
    ]),
    mkfile('hOsts'),
]);

map(n => ({ ...n, name: n.name.toUpperCase() }), tree);
// {
//   name: '/',
//   type: 'directory',
//   meta: {},
//   children: [
//     {
//       name: 'ETC',
//       type: 'directory',
//       meta: {},
//       children: [
//         {
//           name: 'NGINX',
//           type: 'directory',
//           meta: {},
//           children: [],
//         },
//         {
//           name: 'CONSUL',
//           type: 'directory',
//           meta: {},
//           children: [{ name: 'CONFIG.JSON', type: 'file', meta: {} }],
//         },
//       ],
//     },
//     { name: 'HOSTS', type: 'file', meta: {} },
//   ],
// }


// FILE: /app/map.js:
const map = (f, node) => {
    const updatedNode = f(node);

    return node.type === 'directory'
        ? { ...updatedNode, children: node.children.map(n => map(f, n)) } : updatedNode;
};

export default map;



// >>>>>> Filter <<<<<<

/**
 В отличие от map, filter для деревьев, в том виде, в котором он используется для коллекций, практически непригоден. Посудите сами. Предположим, мы хотим выполнить поиск по файловой системе файлов, подходящих под шаблон *.log. Задача сразу разбивается на две подзадачи. Фильтрация, оставляющая листовые узлы, и последующая фильтрация по шаблону. Очевидно, что после первого фильтра мы уже хотим работать со списком, но никак не с деревом. Более того, как будет выглядеть дерево в котором только одни файлы, и какой в нём практический смысл? Как ни крути, большинство фильтров древовидных структур, должны на выходе давать плоские списки.

 Но всё же иногда filter может использоваться, к тому же, для полноты картины, стоит пройти все шаги. Для начала необходимо определиться с тем, что нужно вернуть в ситуации, если нода не удовлетворяет предикату. Логично использовать null.
 */

const filter = (f, tree) => {
    if (!f(tree)) {
        return null;
    }

    const [name, children] = tree;
    console.log(name);

    if (!children) {
        return tree;
    }

    return [name, children.map(c => filter(f, c)).filter(v => v)];
};

const tree = ['a', [
    ['B', [['e'], ['F']]],
    ['C'],
    ['d', [['G'], ['j']]],
]];

const result = filter(([name]) => name === name.toLowerCase(), tree);

JSON.stringify(result);

//   a *
//    /|\
// B * C * d
//  /|   |\
// e  F  G j

/**
 Глядя на реализацию фильтра, видно, что если нода не удовлетворяет предикату, то её дети не рассматриваются вообще. В примере выше это нода B. Соответственно её дети e и F даже не анализируются и отфильтровываются вместе с B.

 Интересно выглядит и вот эта запись children.map(c => filter(f, c)).filter(v => v). Дело в том, что наш фильтр не работает со списком, а работает с конкретным корневым узлом. Соответственно, если мы обрабатываем детей, то в результате фильтрации количество детей не уменьшается. На их месте появляется null. Поэтому обход детей совершается, используя map на массиве children с последующим filter. Тогда все null элементы отфильтруются.

 Посмотрите, какой результат получился бы, если не использовать фильтрацию на значение null:
 */
const filter = (f, tree) => {
    if (!f(tree)) {
        return null;
    }

    const [name, children] = tree;
    console.log(name);

    if (!children) {
        return tree;
    }

    return [name, children.map(c => filter(f, c))];
};

const tree = ['a', [
    ['B', [['e'], ['F']]],
    ['C'],
    ['d', [['G'], ['j']]],
]];

const result = filter(([name]) => name === name.toLowerCase(), tree);

JSON.stringify(result);

// a
// b
// n
//'["a",[null,null,["d",[null,["j"]]]]]'


/**
 Сравните с результатом из прошлого примера.

 Элементы null отфильтрованы:

 => '["a",[["d",[["j"]]]]]'
 Элементы null НЕ отфильтрованы:

 => '["a",[null,null,["d",[null,["j"]]]]]'
 */

/***@@@
 filter.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход предикат и дерево, а возвращает отфильтрованное дерево по предикату.
 */

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('nginx', [
            mkdir('conf.d'),
        ]),
        mkdir('consul', [
            mkfile('config.json'),
        ]),
    ]),
    mkfile('hosts'),
]);

filter(n => n.type === 'directory', tree);
// {
//   name: '/',
//   type: 'directory',
//   meta: {},
//   children: [
//     {
//       name: 'etc',
//       type: 'directory',
//       meta: {},
//       children: [
//         {
//           name: 'nginx',
//           type: 'directory',
//           meta: {},
//           children: [{
//             name: 'conf.d',
//             type: 'directory',
//             meta: {},
//             children: [],
//           }],
//         },
//         {
//           name: 'consul',
//           type: 'directory',
//           meta: {},
//           children: [],
//         },
//       ],
//     },
//   ],
// }


// FILE: /app/filter.js:
const filter = (f, node) => {
    if (!f(node)) {
        return null;
    }

    if (node.type !== 'directory') {
        return node;
    }

    const children = node.children.map(n => filter(f, n)).filter(v => v);

    return { ...node, children };
};

export default filter;




// >>>>>> Reduce <<<<<<

/**
 reduce, пожалуй, самая интересная и полезная функция для работы с деревьями. Агрегация данных — операция, встречающаяся крайне часто. Подсчитать число файлов в папке, общий размер всех файлов в папке, получить список всех файлов в папке, найти все файлы по шаблону, всё это удобнее сделать с помощью reduce.

 Главная особенность reduce в наличии аккумулятора, который протаскивается сквозь все вызовы до самой глубины, а затем поднимается наверх и, в конце концов, возвращается наружу.
 */
const reduce = (f, tree, acc) => {
    const [, children] = tree;
    const newAcc = f(acc, tree);

    if (!children) {
        return newAcc;
    }

    return children.reduce((iAcc, n) => reduce(f, n, iAcc), newAcc);
};

const tree = ['A', [
    ['B', [['E'], ['F']]],
    ['C'],
    ['D', [['G'], ['J']]],
]];

reduce((acc, n) => acc + 1, tree, 0); // 8

/**
 Выше пример теста, в котором используется reduce для подсчёта количества узлов в дереве. С помощью reduce, задача выполняется в одну строку.

 Так же как и в остальных функциях высшего порядка, в функцию обработчик передаётся нода целиком, а не только имя. Самое интересное происходит при обработке детей. Вызов reduce на каждом ребёнке должен происходить с аккумулятором, протаскиваемым сквозь обработку каждого ребёнка. Из-за этого получается что снаружи есть reduce перебирающий children, в то время как каждый ребёнок принимает на вход текущий acc внешнего reduce и запускает внутренний с этим аккумулятором.
 */


/***@@@
 reduce.js
 Реализуйте и экспортируйте по умолчанию функцию-редьюсер обрабатывающую файловые деревья.
 */

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('nginx'),
        mkdir('consul', [
            mkfile('config.json'),
        ]),
    ]),
    mkfile('hosts'),
]);
reduce((acc, n) => acc + 1, tree, 0); // => 6


// FILE: /app/reduce.js:
const reduce = (f, node, acc) => {
    const newAcc = f(acc, node);

    if (node.type === 'file') {
        return newAcc;
    }

    return node.children.reduce((iAcc, n) => reduce(f, n, iAcc), newAcc);
};

export default reduce;




// >>>>>> Поиск <<<<<<

/**
 Поиск по файловой системе — операция, выполняющаяся крайне часто. Она открывает большой простор для интересных задачек. Разберём одну из них с несколькими вариациями. Предположим, что мы хотим вывести список всех пустых директорий. Используя reduce, выполнить данную задачу тривиально. Возьмём следующую файловую структуру:
 */

import { mkdir, mkfile } from 'hexlet-immutable-fs-trees';

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('apache'),
        mkdir('nginx', [
            mkfile('nginx.conf'),
        ]),
        mkdir('consul', [
            mkfile('config.json'),
            mkdir('data'),
        ]),
    ]),
    mkfile('hosts'),
    mkfile('resolve'),
]);

/**
 В этой структуре две пустых директории: /etc/apache и /etc/consul/data. Алгоритм поиска примитивный:
 1. Инициализируем reduce массивом;
 2. Если тип ноды directory и у неё нет детей — добавляем в массив;
 */

import { reduce } from 'hexlet-immutable-fs-trees';

const dirs = reduce((acc, n) => {
    if (n.type === 'directory' && n.children.length === 0) {
        return [...acc, n.name];
    }
    return acc;
}, tree, []);

/**
 В этом примере раскрывается вся прелесть функций высшего порядка. От нас полностью скрыт механизм обхода дерева, более того, можно даже не знать, что мы работаем с деревом.

 Попробуем усложнить задачу. Найдём все пустые директории, но с максимальной глубиной поиска 2 уровень. То есть пустая директория /etc/apache подходит под это условие, а вот /etc/consul/data — нет. Навскидку можно сразу назвать следующие способы решения:

 1. Так как наша реализация reduce не предоставляет информацию о том, на какой глубине текущая нода, то можно выполнить обход вручную, передавая два аккумулятора: один с итоговым массивом, второй с уровнем вложенности;
 2. Можно расширить само описание дерева, добавив туда информацию об уровне вложенности. С одной стороны, такой способ не потребует изменения прикладного кода, так как достаточно изменить реализацию интерфейсных функций mkdir и mkfile. С другой, в такой схеме глубина всех нод будет посчитана относительно корня, что неудобно;
 3. Можно написать reduce которому можно сказать насколько глубоко идти. А затем решить задачу с его использованием.

 Попробуем решить эту задачу, используя первый способ.
 */
const findEmptyDirsDepth = (root, depth = 1) => {
    const iter = (n, currentDepth, acc) => {
        if (n.type === 'file' || currentDepth > depth) {
            return acc;
        }

        if (n.children.length === 0) {
            return [...acc, n.name];
        }

        return n.children.reduce((cAcc, nn) => iter(nn, currentDepth + 1, cAcc), acc);
    };

    return iter(root, 0, []);
};

const dirs = findEmptyDirsDepth(tree, 2);
console.log(dirs); // => ['apache']

/**
 Несколько важных моментов:

 1. Теперь нужно отслеживать текущую глубину, поэтому она передаётся в iter, с каждой итерацией увеличиваясь на единицу;
 2. Если зашли глубже, чем надо, то возвращаем результат.
 В остальном код такой же, как и в обычном reduce.
 */

/***@@@
 findFilesByName.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход файловое дерево и подстроку, а возвращает список файлов, имена которых содержат эту подстроку.
 */

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('apache'),
        mkdir('nginx', [
            mkfile('nginx.conf', { size: 800 }),
        ]),
        mkdir('consul', [
            mkfile('config.json', { size: 1200 }),
            mkfile('data', { size: 8200 }),
            mkfile('raft', { size: 80 }),
        ]),
    ]),
    mkfile('hosts', { size: 3500 }),
    mkfile('resolve', { size: 1000 }),
]);

findFilesByName(tree, 'co');
// => ['/etc/nginx/nginx.conf', '/etc/consul/config.json']

/**
 Обратите внимание на то, что возвращается не просто имя файла, а полный путь до файла, начиная от корня.

 Подсказки
 - Для построения путей используйте функцию path.join https://nodejs.org/api/path.html#path_path_join_paths.
 - Проверку вхождения строк можно делать с помощью функции str.includes(substr).
 */

// FILE: /app/findFilesByName.js:
import path from 'path';

const findFilesByName = (root, substr) => {
    const iter = (n, ancestry, acc) => {
        const newAncestry = path.join(ancestry, n.name);

        if (n.type === 'file') {
            return n.name.includes(substr) ? [...acc, newAncestry] : acc;
        }

        return n.children.reduce((cAcc, nn) => iter(nn, newAncestry, cAcc), acc);
    };

    return iter(root, '', []);
};

export default findFilesByName;



// >>>>>> Агрегация <<<<<<

/**
 Попрактикуемся ещё с одним вариантом агрегации данных на файловых системах. Напишем функцию, которая принимает на вход директорию и возвращает список директорий первого уровня вложенности и количество файлов в них включая все поддиректории. Эта функция затем может использоваться в утилите командной строки выполняющей соответствующую задачу.

 Как видно из постановки, задачу нельзя решить используя reduce в чистом виде, так как нам не нужен обход всех нод, с другой стороны для подсчёта количества файлов обход нужен. Следовательно наша задача распадается уже на две подзадачи: извлечение детей-директорий текущего корня и вызов подсчёта файлов внутри каждого ребёнка.

 Начнём с подсчёта количества файлов. Эта задача содержит один примитивный reduce:
 */

import { reduce } from 'hexlet-immutable-fs-trees';

const calculateFilesCount = tree =>
    reduce((acc, node) => (node.type === 'file' ? acc + 1 : acc), tree, 0);


// Совершенно типичный reduce который увеличивает аккумулятор на единицу если тип ноды file. Следующий шаг заключается в том чтобы извлечь всех детей из исходного узла и к каждому из них применить подсчёт.


import { mkdir, mkfile } from 'hexlet-immutable-fs-trees';

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('apache'),
        mkdir('nginx', [
            mkfile('nginx.conf'),
        ]),
    ]),
    mkdir('consul', [
        mkfile('config.json'),
        mkfile('file.tmp'),
        mkdir('data'),
    ]),
    mkfile('hosts'),
    mkfile('resolve'),
]);

const result = tree.children
    .filter(n => n.type === 'directory')
    .map(n => [n.name, calculateFilesCount(n)]);

console.log(result);
// => [['etc', 1], ['consul', 2]]

// То есть мы обратились к детям напрямую сначала отфильтровав их, а затем и выполнив отображение на необходимый массив, содержащий для каждой директории имя и количество файлов в нем.


/***@@@
 Во многих операционных системах (Linux, MacOS) существует утилита du. Она умеет считать место в указанных файлах и директориях. Например так:

 tmp$ du -sh *
 0B    com.docker.vmnetd.socket
 10M    credo
 4.0K    debug.mjs
 0B    filesystemui.socket
 4.0K    index.php
 37M    node_modules
 88K    package-lock.json
 22M    taxdome

 Перед тем как делать упражнение, обязательно попробуйте поиграйте с этой утилитой в терминале, посмотрите ее опции через man du.

 du.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход директорию, а возвращает список узлов вложенных (директорий и файлов) в указанную директорию на один уровень и место которое они занимают. Размер файла задается в метаданных. Размер директории складывается из сумм всех размеров файлов находящихся внутри во всех подпапках. Сами папки размера не имеют.

 - Обратите внимание на структуру результирующего массива. Каждый элемент - массив с двумя значениями, именем директории и размером файлов внутри.
 - Результат отсортирован по размеру в обратном порядке. То есть сверху самые тяжелые, внизу самые легкие
 */

const tree = mkdir('/', [
    mkdir('etc', [
        mkdir('apache'),
        mkdir('nginx', [
            mkfile('nginx.conf', { size: 800 }),
        ]),
        mkdir('consul', [
            mkfile('config.json', { size: 1200 }),
            mkfile('data', { size: 8200 }),
            mkfile('raft', { size: 80 }),
        ]),
    ]),
    mkfile('hosts', { size: 3500 }),
    mkfile('resolve', { size: 1000 }),
]);

du(tree);
// [
//   ['etc', 10280],
//   ['hosts', 3500],
//   ['resolve', 1000],
// ]


// FILE: /app/du.js:
import { reduce } from 'hexlet-immutable-fs-trees';


const calculatefilesSize = node => reduce((acc, n) => {
    if (n.type === 'directory') {
        return acc;
    }

    return acc + n.meta.size;
}, node, 0);

const du = (node) => {
    const result = node.children.map(n => [n.name, calculatefilesSize(n)]);
    // Обычный дестракчеринг. JS позволяет пропускать имена если они не используются
    result.sort(([, size1], [, size2]) => size2 - size1);

    return result;
};

export default du;



/***@@@
 Управление зависимостями - это очень важная задача при разработке программного обеспечения. Обычно в приложениях задействовано множество сторонних компонентов, которые, в свою очередь, тоже могут полагаться на сторонние компоненты. Одной из задач менеджера зависимостей является подключение зависимостей в правильном порядке. Библиотеки, от которых зависят другие, должны подключаться раньше. Определение этой последовательности сводится к задаче сортировки графа.

 sortDeps.js
 Реализуйте и экспортируйте по умолчанию функцию sortDeps, которая принимает на вход список зависимостей и возвращает список (массив) отсортированных узлов.

 Пример:
 */
const deps1 = {
    mongo: [],
    tzinfo: ['thread_safe'],
    uglifier: ['execjs'],
    execjs: ['thread_safe', 'json'],
    redis: [],
};

console.log(sortDeps(deps1));
// => ['mongo', 'thread_safe', 'tzinfo', 'json', 'execjs', 'uglifier', 'redis'];

/**
 Независимые библиотеки и цепочки библиотек должны быть в порядке, соответствующему порядку элементов в графе зависимостей.

 Подсказки
 Об алгоритме: топологическая сортировка https://ru.wikipedia.org/Топологическая_сортировка
 */

// FILE: /app/sortDeps.js:
export default (deps) => {
    const add = (acc, node) => {
        const subDeps = deps[node] || [];
        const subAcc = subDeps.reduce(add, []);

        return { ...acc, ...subAcc, [node]: true };
    };

    const set = Object.keys(deps).reduce(add, {});

    return Object.keys(set);
};


/***@@@
 convert.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход массив определённой структуры и возвращает объект, полученный из этого массива.

 Массив устроен таким образом, что с помощью него можно представлять ассоциативные массивы. Каждое значение внутри него — это массив из двух элементов, где первый элемент — ключ, а второй — значение. В свою очередь, если значение тоже является массивом, то считается, что это вложенное представление ассоциативного массива. Другими словами, любой массив внутри исходного массива всегда рассматривается как данные, которые нужно конвертировать в объект.
 */

convert([]); // => {}
convert([['key', 'value']]); // { key: 'value' }
convert([['key', 'value'], ['key2', 'value2']]); // { key: 'value', key2: 'value2' }

convert([
    ['key', [['key2', 'anotherValue']]],
    ['key2', 'value2']
]);
// { key: { key2: 'anotherValue' }, key2: 'value2' }


// FILE: /app/convert.js:
const convert = items => items.reduce(
    (acc, [key, value]) => ({ ...acc, [key]: value instanceof Array ? convert(value) : value }),
    {},
);

export default convert;


/***@@@
 flatten.js
 Реализуйте и экспортируйте по умолчанию функцию flatten, которая делает плоским вложенный массив.
 */
const list = [1, 2, [3, 5], [[4, 3], 2]];

// [1, 2, 3, 5, 4, 3, 2]
flatten(list);
/**
 Подсказки
 Array.isArray - проверяет является ли элемент массивом.
 */

// FILE: /app/flatten.js:
const flatten = list => list.reduce((acc, element) => {
    return (!Array.isArray(element) ? [...acc, element] : [...acc, ...flatten(element)]);
}, []);

export default flatten;



/***@@@
 Реализуйте и экспортируйте по умолчанию функцию itinerary, которая выстраивает маршрут между городами.

 Функция принимает 3 аргумента:

 дерево городов
 город старта
 город окончания маршрута
 и возвращает массив городов, выстроенный в том же порядке, в котором они находятся на пути следования по маршруту.

 Примеры
 */

const tree = ['Moscow', [
    ['Smolensk'],
    ['Yaroslavl'],
    ['Voronezh', [
        ['Liski'],
        ['Boguchar'],
        ['Kursk', [
            ['Belgorod', [
                ['Borisovka'],
            ]],
            ['Kurchatov'],
        ]],
    ]],
    ['Ivanovo', [
        ['Kostroma'], ['Kineshma'],
    ]],
    ['Vladimir'],
    ['Tver', [
        ['Klin'], ['Dubna'], ['Rzhev'],
    ]],
]];

itinerary(tree, 'Dubna', 'Kostroma');
// => ['Dubna', 'Tver', 'Moscow', 'Ivanovo', 'Kostroma']

itinerary(tree, 'Borisovka', 'Kurchatov');
// => ['Borisovka', 'Belgorod', 'Kursk', 'Kurchatov']

/**
 Подсказки
 Используйте функции из библиотеки lodash https://lodash.com/docs/
 */


// FILE: /app/itinerary.js:

import _ from 'lodash';

const makeRoute = (tree, route = []) => {
    const [city, rest] = tree;
    const newRoute = route.concat(city);

    if (!rest) {
        return newRoute.join('/');
    }

    return rest.map(el => makeRoute(el, newRoute));
};

const makeListRoutes = tree => (tree.reduce(
    (acc, node) => (node instanceof Array
        ? [...acc, ...makeListRoutes(node)]
        : acc.concat(node)), [],
));

const getRoute = (routes, city) => routes.find(el => _.last(el) === city);

const getPartsOfRoute = (route1, route2) => {
    const commonRoute = route1.filter((el, i) => el === route2[i]);
    const turn = _.last(commonRoute);

    const startRoute = route1.filter((el, i) => el !== route2[i]);
    const finishRoute = route2.filter((el, i) => el !== route1[i]);

    return [startRoute, turn, finishRoute];
};

const itinerary = (tree, start, finish) => {
    const routes = makeRoute(tree);
    const listRoutes = makeListRoutes(routes).map(el => el.split('/'));

    const route1 = getRoute(listRoutes, start);
    const route2 = getRoute(listRoutes, finish);

    const [initialRoute, turn, finalRoute] = getPartsOfRoute(route1, route2);

    return initialRoute.reverse().concat(turn, finalRoute);
};

export default itinerary;





// ############################### JS: Прототипы ###############################

/**
 - В языке нет классов
 - Класс это функция
 - Функция это объект
 - this не текущий объект
 */




// >>>>>>> Проект HTML Builder <<<<<<
// # Тест:
import assert from 'assert';
import buildHtml from './solution';

const data = /**...*/;
const actual = buildHtml(data);
const expected = `<html><head>
  <title>hello, world</title></head><body>
  <h1 class="header">Html builder example</h1></body></html>`;

assert.equal(actual, expected);

// # Обобщенное представление:
/*
  <p class="text-center">text</p>
  ['p', {'class': 'text-center'}, 'text'];

  <p><Tag><Tag></p>
  ['p', {}, [<Tag>, <Tag>]];

  [<tagName>, <attributes>, <body>, <children>]
*/

// # Оптимизированное представление:
/*
[<tagName>, <attributes>, <body>, <children>]

[<tagName>]
[<tagName>, <attributes>]
[<tagName>, <body>]
[<tagName>, <attributes>, <body>]
[<tagName>, <attributes>]
[<tagName>, <attributes>, <children>]
*/

// # Определение типа:
['h1', {/**...*/}]; // attributes
['p', '...']; // body
['div', [/**...*/]] // children

    [] instanceof Array; // true
{} instanceof Object; // true
[] instanceof Object; // true


'hello' instanceof String; // false
(new String('hello')) instanceof String; // true;
typeof 'hello' === 'string'; // true

// Результат:
const data = ['html', [
    ['head', [
        ['title', 'hello, world'],
    ]],
    ['body', { 'class': 'container' }, [
        ['h1', {'class' : 'header' }, 'html builder'],
    ]],
]];

/**
 Формат, подобный тому что мы реализуем, крайне популярен в лисп подобных языках. Это связано с тем, что в Лиспах наиболее естественный способ представления данных — списковые структуры. Один из самых популярных шаблонизаторов на языке Clojure — hiccup. Типичный пример HTML на нём выглядит так:

 user=> (html [:div#foo.bar.baz "bang"])
 "<div id=\"foo\" class=\"bar baz\">bang</div>"
 или так:

 [:input { :type      "text"
          :allow-full-screen true
          :id        "comment"
          :class     ["input_active" "input_error"]
          :style     { :background-color "#EEE"
                       :margin-left      42 }
          :on-change (fn [e]
                       (js/alert (.. e -target -value))) }]

 Хотя, с непривычки, такое представление может напугать, в реальности программисты не испытывают проблем с таким способом работы, более того, HTML как данные, открывает широкие возможности по автоматической обработке и рефакторингу (переработке).

 Этот шаблонизатор встроен в rum, библиотеку для комфортной работы с React в ClojureScript.

 Лайвкодинг по проектированию данной библиотеки: https://www.youtube.com/watch?v=us8AMJKEzZg&ab_channel=Hexlet
 */

/***@@@
 solution.js
 Реализуйте и экспортируйте по умолчанию функцию buildHtml, которая возвращает строковое представление html.

 import buildHtml from './solution';

 const data = ['html', [
 ['meta', [
 ['title', 'hello, hexlet!'],
 ]],
 ['body', { class: 'container' }, [
 ['h1', { class: 'header' }, 'html builder example'],
 ['div', [
 ['span', 'span text2'],
 ['span', 'span text3'],
 ]],
 ]],
 ]];

 buildHtml(data);
 <html>
 <meta><title>hello, hexlet!</title></meta>
 <body class="container">
 <h1 class="header">html builder example</h1>
 <div>
 <span>span text2</span>
 <span>span text3</span>
 </div>
 </body>
 </html>

 Подсказки
 Для объединения массива в строку, используйте метод join(separator).
 Эту задачу можно решить практически без единой условной конструкции используя полиморфизм на основе объекта (ключ, значения).
 Решение учителя может повергнуть вас в шок. Оно не содержит ничего нового по сравнению с тем что вы проходили, но по максимуму использует пройденные идеи, функции высшего порядка, неизменяемость, полиморфизм. Потратьте время, разберитесь с ним.
 */

// FILE: /app/solution.js
const propertyActions = [
    {
        name: 'body',
        check: arg => typeof arg === 'string',
    },
    {
        name: 'children',
        check: arg => arg instanceof Array,
    },
    {
        name: 'attributes',
        check: arg => arg instanceof Object,
    },
];

const getPropertyAction = arg => propertyActions.find(({ check }) => check(arg));

const buildAttrString = attrs =>
    Object.keys(attrs).map(key => ` ${key}="${attrs[key]}"`).join('');

const buildHtml = (data) => {
    const [first, ...rest] = data;
    const root = {
        name: first,
        attributes: {},
        body: '',
        children: [],
    };

    const tag = rest.reduce((acc, arg) => {
        const { name } = getPropertyAction(arg);

        return { ...acc, [name]: arg };
    }, root);

    return [`<${tag.name}${buildAttrString(tag.attributes)}>`,
        `${tag.body}${tag.children.map(buildHtml).join('')}`,
        `</${tag.name}>`,
    ].join('');
};

export default buildHtml;



// >>>>>> Абстрактное синтаксическое дерево <<<<<<

/**
 Дерево использующееся в парсерах для промежуточного представления исходных данных (например, программы)

 # JS API
 */
let x; // =>

{
    "type": "VariableDeclaration",
    "declarations": [
    {
        "type": "VariableDeclaration",
        "id": {
            "type": "Identfier",
            "name": "x"
        },
        "init": null
    }
],
    "kind": "let"
}

/**
 Преимущества:
 - Проще представлять новые представления
 - Проще анализировать
 - Разделяй и властвуй

 > ast
 { name: 'html',
  attributes: {},
  body: '',
  children:
    [ { name: 'meta', attributes: {},
        body: '', children: [Object] },
        name: 'body', attributes: {},
        body: '', children: [Object] } ] }

 > ast.children[0].children
 [ { name: 'title',
    attributes: {},
    body: 'hello, hexlet',
    children: [] } ]

 # HtmlBuilder API
 */

import { render, parse } from './solution';

const actual = render(parse(data));


/***@@@
 Текущая версия htmlBuilder должна уметь работать с одиночными тегами. Список тегов, которые являются одиночными, находится в singleTagsList.

 Пример:
 */
// <br>
['br'];

// <img src="/path">
['img', { src: '/path' }];

/**
 solution.js
 Реализуйте и экспортируйте функции parse и render.

 Функция render принимает на вход ast и возвращает строковое представление.
 Функция parse принимает на вход исходную структуру и возвращает представление в виде ast.
 */

// FILE: /app/solution.js:
const data = ['html', [
    ['meta', { id: 'uniq-key' }, [
        ['title', 'hello, hexlet!'],
    ]],
    ['body', [
        ['br'],
    ]],
]];

const ast = parse(data);

{ name: 'html', attributes: {}, body: '', children: [
    { name: 'meta', attributes: { id: 'uniq-key' }, body: '', children: [
            { name: 'title', attributes: {}, body: 'hello, hexlet!', children: [] },
        ]},
    { name: 'body', attributes: {}, body: '', children: [
            { name: 'br', attributes: {}, body: '', children: [] },
        ]},
]}


// FILE: /app/solution.js:
import { identity } from 'lodash';

const singleTagsList = new Set(['hr', 'img', 'br']);

export const render = (data) => {
    const {
        name,
        attributes,
        body,
        children,
    } = data;

    const attrsLine = Object.keys(attributes).map(key => ` ${key}="${attributes[key]}"`).join('');
    const content = children.length > 0 ? children.map(render).join('') : body;

    if (singleTagsList.has(name)) { // одиночный тег
        return `<${name}${attrsLine}>`;
    }

    return `<${name}${attrsLine}>${content}</${name}>`; // парный тег
};

const propertyActions = [
    {
        name: 'body',
        check: arg => typeof arg === 'string',
        process: identity,
    },
    {
        name: 'children',
        check: arg => arg instanceof Array,
        process: (children, f) => children.map(f),
    },
    {
        name: 'attributes',
        check: arg => arg instanceof Object,
        process: identity,
    },
];

const getPropertyAction = arg => propertyActions.find(({ check }) => check(arg));

export const parse = (data) => {
    const [first, ...rest] = data;
    const root = {
        name: first,
        attributes: {},
        body: '',
        children: [],
    };
    return rest.reduce((acc, arg) => {
        const { name, process } = getPropertyAction(arg);

        return { ...acc, [name]: process(arg, parse) };
    }, root);
};




// >>>>>>> Полиморфизм подтипов <<<<<<<

/**
 # Типы
 - SingleTag
 - PairedTag
 */

const tag = new ...;
tag.tpString();


// # AST
const data = ['div', [
    ['hr']
]];
const ast = parse(data);

ast instanceof PairedTag; // true
ast.children[0] instanceof SingleTag; // true

ast.toString(); // <div><hr></div>


// # Конструктор:
buildNode(name, attributes, body, children);

const expected = buildNode('html', {}, '', [
    buildNode('meta', {}, '', [
        buildNode('title', {}, 'hello, world'),
    ]),
    buildNode('body',  {}. '', [
        buildNode('h1', { 'class': 'header' }, body),
        buildNode('div', {}, '', [
            buildNode('span', {}, 'span text'),
            buildNode('hr'),
        ]),
    ])
]);

// # Полиморфизм (подтипов)
const tag1 = buildNode('h1', { 'class': 'header' }, 'body');
console.log(tag1.toString()); // <h1 class="header">body</h1>

const tag2 = buildNode('img', { 'src': '/path/to/img.jpg' });
console.log(tag2.toString()); // <img src="/path/to/image.jpg">


/***@@@
 buildNode.js
 Реализуйте и экспортируйте функцию по умолчанию, задача которой, создавать объект подходящего типа. Типы: SingleTag и PairedTag.
 Список имен тегов, которые относятся к SingleTag: hr, br, img.

 PairedTag.js
 Реализуйте тип PairedTag со следующим интерфейсом:

 Конструктор, который принимает на вход: name, attributes, body, children.
 Метод toString, который возвращает текстовое представление узла (html) на всю глубину.

 SingleTag.js
 Реализуйте тип SingleTag со следующим интерфейсом:

 Конструктор, который принимает на вход: name, attributes
 Метод toString, который возвращает текстовое представление узла (html) на всю глубину.
 Обратите внимание на то что у SingleTag нет body и children
 */

// FILE: /app/buildNode.js:
import PairedTag from './PairedTag';
import SingleTag from './SingleTag';

const singleTagsList = new Set(['hr', 'br', 'img']);

export default (name, ...args) => {
    const C = singleTagsList.has(name) ? SingleTag : PairedTag;

    return new C(name, ...args);
};

// FILE: /app/PairedTag.js:
export default class {
    constructor(name, attributes = {}, body = '', children = []) {
        this.name = name;
        this.attributes = attributes;
        this.body = body;
        this.children = children;
    }

    toString() {
        const value = this.children.length > 0 ? this.children.join('') : this.body;

        return `<${this.name}${this.getAttributesAsLine()}>${value}</${this.name}>`;
    }

    getAttributesAsLine() {
        return Object.entries(this.attributes)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
    }
}

// FILE: /app/SingleTag.js:
export default class {
    constructor(name, attributes = {}) {
        this.name = name;
        this.attributes = attributes;
    }

    toString() {
        return `<${this.name}${this.getAttributesAsLine()}>`;
    }

    getAttributesAsLine() {
        return Object.entries(this.attributes)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
    }
}



// >>>>>> Иерархия типов <<<<<<

/**
 # Принцип Лисков (SOLID):
 Пусть q(x) является свойством, верным относительно объектов x некоторого типа Т.
 Тогда q(y) так же должно быть верным для объектов y типа S, где S является подтипом типа Т

 # По фаулеру:
 Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

 - Предусловия не могут быть усилены в подклассе.
 - Посусловия не могут быть ослаблены в подклассе.

 # Зачем?
 - Системы типов не могут гарантировать корректность иерархии.
 - Некорректное использование наследования может приводить к ошибкам.
 - Снижается модульность (текут абстракции).

 # Реальность:
 - Множественные надтипы - боль.
 - Очень легко ошибиться.
 - Композиция вместо наследования.
 */



// >>>>>> Подтип <<<<<<

/**
 # Наследование:
 - Способ строить иерархии типов.
 - Не зависит от существования классов.
 - Чаще используются для сокращения дублирования.

 # Надтип:
 */
class Node {
    constructor(name) {
        this.name = name;
    }

    getName() {
        return this.name;
    }
}

// # Подтипы:
import Node from './Node';

class PairedTag extends Node {
    constructor (name, body = '') {
        super(name); // вызываем конструктор базового класса
        this.body = body;
    }

    toString() {
        return `<${this.getName()}>${this.body}</${$this.getName()}>`;
    }
}


// # Использование:
const tag = new Pairedtag('h1', 'text');
console.log(tag.getName()); // h1
console.log(tag.toString()); // <h1>text</h1>

tag.name = 'h2';
console.log(tag.toString()); // <h2>text</h2>


/***@@@
 Node.js
 Реализуйте базовый класс Node таким чтобы он содержал в себе общую логику

 PairedTag.js, SingleTag.js
 Реализуйте типы тегов как подтипы типа Node.
 */

// FILE: /app/Node.js:
export default class {
    constructor(name, attributes = {}) {
        this.name = name;
        this.attributes = attributes;
    }

    getAttributesAsLine() {
        return Object.keys(this.attributes)
            .reduce((acc, key) => `${acc} ${key}="${this.attributes[key]}"`, '');
    }
}

// FILE: /app/PairedTag.js:
import Node from './Node';

export default class extends Node {
    constructor(name, attributes, body = '', children = []) {
        super(name, attributes);
        this.body = body;
        this.children = children;
    }

    toString() {
        const value = this.children.length > 0
            ? this.children.join('')
            : this.body;

        return `<${this.name}${this.getAttributesAsLine()}>${value}</${this.name}>`;
    }
}

// FILE: /app/SingleTag.js:
import Node from './Node';

export default class extends Node {
    toString() {
        return `<${this.name}${this.getAttributesAsLine()}>`;
    }
}




// >>>>>> Функции как объекты <<<<<<

const f = name => `hello, ${name}`;
typeof f; // function
f instanceof Object; // true
f.length; // количество аргументов, которая принимает функция => 1
f.toString(); // возвращает тело функции => name => `hello, ${name}`
f.wrongProperty; // undefined

// # Класс это функция
class Node {
    constructor (name) {
        this.name = name;
    }
}

console.log(typeof Node); // function


// # Конструктор (до ES6):
function Node(name) { // принято называть с большой буквы
    this.name = name;
}

node = new Node('table');
node.name; // table

// Arrow function:
new ((name) => { this.name = name; })
// Type Error: (name) => { this.name = name; })
// is not constructor


// # function !== this
function Node(name) { // принято называть с большой буквы
    this.name = name;
}

const obj = new Node('table');
obj.Name; // table

Node.name; // возвращает имя функции => Node
Node.length; // 1
obj.length; // свойство не определено => undefined

// # Контекст (this):
function Node(name) {
    this.name = name;
}

function New(Constructor, args) {
    const obj = {};
    Constructor.apply(obj, args); // obj - контекст, args - аргументы

    return obj;
}

const node = New(Node, ['table']);
node.name; // table



// # apply vs call:
const sum = (a, b) => a + b;

sum.apply(null, [5, 9]); // 14
sum.call(null, 5, 9); // 14

Math.sqrt.apply(null, [16]); // 4
Math.pow.apply(null, [2, 3]); // 8

Math.sqrt.call(null, 16) // 4
Math.pow.call(null, 2, 3); // 8


/***@@@
 magic.js
 Реализуйте и экспортируйте по умолчанию функцию, которая работает следующим образом:

 Принимает на вход любое число аргументов и возвращает функцию, которая, в свою очередь, принимает на вход любое количество аргументов и так до бесконечности (привет, рекурсия ;)).
 Результат вызова этой функции при проверке на равенство должен быть равен сумме всех аргументов всех подфункций.
 */
magic() == 0; // true
magic(5, 2, -8) == -1; // true
magic(1, 2)(3, 4, 5)(6)(7, 10) == 38; // true
magic(4, 8, 1, -1, -8)(3)(-3)(7, 2) == 13; // true

/**
 Подсказки
 Объекты в js по умолчанию имеют метод valueOf, который вызывается автоматически в тех местах, где требуется преобразование к числовому значению (контекст арифметических операций и операций нестрогого сравнения). В ситуации выше, во время сравнения, js вызовет valueOf для нашей функции. Этим можно воспользоваться для того, чтобы возвращать сумму через valueOf.
 */

const obj = {}
obj + 3; // '[object Object]3'
obj.valueOf = () => 3;
obj + 7; // 10

// FILE: /app/magic.js:
const f = (...numbers) => {
    const sum = numbers.reduce((acc, x) => x + acc, 0);
    const inner = (...rest) => f(sum, ...rest);
    inner.valueOf = () => sum;

    return inner;
};

export default f;


// FILE: /app/magic.test.js:
import magic from '../magic';

test('magic', () => {
    expect(magic() + 0).toBe(0);
    expect(magic() + 1).toBe(1);

    magic(4, 5);

    expect(magic(5, 2, -8) + 2).toBe(1);
    expect(magic(1, 2)(3, 4, 5)(6)(7, 10) - 8).toBe(30);
    expect(magic(4, 8, 1, -1, -8)(3)(-3)(7, 2) + 7).toBe(20);

    magic(1, 3, 4);
    expect(magic(5) + 1).toBe(6);
});




// >>>>>> Позднее связывание <<<<<<

const makeNode = name => {
    return {
        name, // name: name
        getName() { // getName: function getName{...}
            return this.name;
        },
    }
};

const obj = makeNode('table');
// # this:
obj.name; // table
obj.getName(); // table

// Контекст:
const func = obj.getName;
func(); // вызываем функцию вне контекста
// TypeError: Cannot read property
// 'name' of undefined

// # Позднее связывание:
function f(name) {
    this.name = name;
}

const obj1 = { setName: f }; // объекты передаются по ссылке
const obj2 = { setName: f };

obj1.setName === obj2.setName; // одна и та же функция => true

obj1.setName('martin');
obj2.setName('mike');

// { setName: [Function f], name: 'martin'}
// { setName: [Function f], name: 'mike'}

// # Стрелочные функции:
// this в стрелочной функции относится к внешнему окружению функции:
const makeNode = (name) => {

    return {
        name,
        getName: () => { // раннее связывание
            return this.name;
        },
    }
};

const node = makeNode('table');
node.getName();
// TypeError: Cannot read property 'name'
// of undefined at Object.getName

// # Почти класс:
function Node(name) {
    this.name = name;
    this.getNAme = function getName() { // позднее связывание
        return this.name;
    }
}

node = new Node('div');
node.getName(); // div


// # Наследование:
function PairedNode(name, body) {
    Node.apply(this, [name]); // super
    this.body = body;
}

node = new PairedNode('div', 'body');
// PairedNode { name: 'div',
// getName: [Function: getName],
// body: 'body' }

node.getName(); // div
node.body; // body


/**
 # Дополнительные материалы
 Объяснение раннего и позднего связывания https://softwareengineering.stackexchange.com/questions/200115/what-is-early-and-late-binding
 */

/***@@@
 В этом упражнении реализация наших типов (Node и ее подтипов) будет опираться на следующие свойства js:

 Функция это объект
 Позднее связывание
 Побочные эффекты (apply) **
 Node.js
 Реализуйте базовый тип Node используя подход описанный в видео.

 PairedTag.js, SingleTag.js
 Реализуйте типы тегов как подтипы типа Node.

 Подсказки
 При определении функции внутри конструктора есть одна деталь. Функция создается каждый раз заново, а это ведет к двум проблемам:

 1. Лишний расход памяти. Ведь достаточно создать одну функцию и использовать ее повторно.
 2. Сравнение объектов даже в случае deepEqual будет давать false. Ведь функция это объект, а объекты друг другу не равны (даже если структура одинаковая), если это не один и тот же объект. А это сильно затрудняет проверки на равенство деревьев (или поддеревьев), а также делает крайне сложным тестирование.
 По этим причинам функцию нужно описывать вне конструктора (выше в файле), а внутри присваивать ее соответствующему свойству.

 **
 Побочным эффектом называют любые действия, изменяющие среду выполнения. К ним относятся любые файловые операции, такие как запись в файл, отправка или приём данных по сети, даже вывод в консоль или чтение файла. Кроме того, побочными эффектами считаются обращения к глобальным переменным (как на чтение, так и запись) и изменение входных аргументов в случае, когда они передаются по ссылке. Вызов функции с побочными эффектами также считается побочным эффектом.

 */

// FILE: /app/Node.js:
function getAttributesAsLine() {
    return Object.keys(this.attributes).reduce(
        (acc, key) => `${acc} ${key}="${this.attributes[key]}"`,
        '',
    );
}

export default function Node(name, attributes = {}) {
    this.name = name;
    this.attributes = attributes;

    this.getAttributesAsLine = getAttributesAsLine;
}

// FILE: /app/PairedTag.js:
import Node from './Node';

function toString() {
    const value = this.children.length > 0
        ? this.children.join('') : this.body;

    return `<${this.name}${this.getAttributesAsLine()}>${value}</${this.name}>`;
}

export default function PairedTag(name, attributes = {}, body = '', children = []) {
    Node.apply(this, [name, attributes]);
    this.body = body;
    this.children = children;
    this.toString = toString;
}

// FILE: /app/SingleTag.js:
import Node from './Node';

function toString() {
    return `<${this.name}${this.getAttributesAsLine()}>`;
}

export default function SingleTag(name, attributes = {}) {
    Node.apply(this, [name, attributes]);
    this.toString = toString;
}




// >>>>>> Прототипы <<<<<<
/**
 Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.
 */

// # Наследство:
const obj = { key: 'value' };
obj.toString(); // текстовое представление => [object Object]

obj.valueOf(); // значение объекта => { key: 'value' }

Object.getOwnPropertyNames(obj); // возвращает все ключи, которые определены => ['key']


// # Прототип:
const obj = { key: 'value' };

// [[Prototype]] - закрытое свойство внутри объекта
const proto = Object.getPrototypeOf(obj);

Object.getOwnPropertyNames(proto); // =>
// [ 'contructor', 'toString',
// 'toLocaleString', 'valueOf',
// 'hasOwnProperty', 'isPrototypeOf',
// 'propertyIsEnumetable', '__defineGetter__',
// '__lokupGetter__', '__defineSetter__',
// '__lokupSetter__', '__proto__' ]


// # операция [[Get]]:
obj.name; // or obj['name']

/**
 1. Есть ли у текущего объекта свойство name?
 2. Есть ли у прототипа свойства name?
 3. Если прототип null, возвращаем undefined.
 */

const get = (obj, property) => { // имитация Get
    if (obj.hasOwnProperty(property)) { // есть ли у объекта собственное свойство
        return obj[property];
    } else if (Object.getPrototypeOf(obj) === null) { // У вверхнего прототипа протототип null
        return undefined;
    } else {
        return get(Object.getPrototypeOf(obj), property) // рекурсивно перебираем прототипы
    }
}

// # Создание объектов:
const obj = new Object(); // {}
typeof Object; // function
const proto = Object.getPrototypeOf(obj); // извлекаем прототип
proto === Object.prototype; // в proto cсылка на объект Object.prototype => true
obj.prototype; // обращение через объект не работает => undefined


// # Cоздание прототипа:
function F() // {}
F.prototype; // {}

Object.getOwnPropertyNames(F);
// [ 'length', 'name', 'argument',
// 'caller', 'prototype' ]

Object.getOwnPropertyNames(F.prototype);
// [ 'constructor' ]

const obj = new F();
obj.constructor === F; // ссылка => true
obj.name; // undefined

// ! Cвойство самой функции никак не связано с объектом, а с прототипом связано.

// # Изменение прототипа:
function F() {}
const obj1 = new F();
F.prototype.color = 'green';
const obj2 = new F();

console.log(obj1.color); // green
console.log(obj2.color); // green


// # Определение класса (до ES6):
function Node(name) { // описываем конструктор
    this.name = name;
}

Node.prototype.getName = function getName() {
    return this.name; // позднее связывание
}

const obj = new Node('span');
obj.getName(); // span


// # Перекрытие:
function F() {}
F.prototype.color = 'green';

const obj1 = new F();
const obj2 = new F();
obj2.color = 'red';

console.log(obj1.color); // green
console.log(obj2.color); // red

console.log(F.prototype.color) // green


/***@@@
 PairedTag.js, SingleTag.js
 Реализуйте типы тегов как подтипы типа Node. Добавьте необходимые функции в прототипы типов.
 */

// FILE: /app/Node.js:
function getAttributesAsLine() {
    const attrs = Object.entries(this.attributes).map(([key, value]) => `${key}="${value}"`);
    return attrs.length > 0 ? ` ${attrs.join(' ')}` : '';
}

export default function Node(name, attributes = {}) {
    this.name = name;
    this.attributes = attributes;
    this.getAttributesAsLine = getAttributesAsLine;
}

// FILE: /app/PairedTag.js:
import Node from './Node';

export default function PairedTag(name, attributes, body = '', children = []) {
    Node.apply(this, [name, attributes]);
    this.body = body;
    this.children = children;
}

PairedTag.prototype.toString = function toString() {
    const value = this.children.length > 0 ? this.children.join('') : this.body;

    return `<${this.name}${this.getAttributesAsLine()}>${value}</${this.name}>`;
};

// FILE: /app/SingleTag.js:
import Node from './Node';

export default function SingleTag(name, attributes) {
    Node.apply(this, [name, attributes]);
}

SingleTag.prototype.toString = function toString() {
    return `<${this.name}${this.getAttributesAsLine()}>`;
};




// >>>>>> Цепочки прототипов <<<<<<

// # Прототип моего прототипа:
function F() {}
const obj = new F();

const proto1 = Object.getPrototypeOf(obj);
proto1 === F.prototype; // true

const proto2 = Object.getPrototypeOf(proto1); // прототип прототипа
proto2 === Object.prototype; // true

// Object -> F.prototype -> Object.prototype -> null


// # Построение цепочки:
function A() {}
function B() {}

// wrong way:
B.prototype = A.prototype;

B.prototype.color = 'green';
A.prototype.color; // green !!!

const obj = new B();

Object.getPrototypeOf(obj) === A.prototype; // true


// right way:
B.prototype = Object.create(A.prototype);

B.prototype.color = 'green';
A.prototype.color; // undefined

const obj = new B();

const proto1 = Object.getPrototypeOf(obj);
// B.prototype

const proto2 = Object.getPrototypeOf(proto1);
// A.prototype

// # Объект на основе прототипа:
Object.create = function create(protoObj) {
    function F() {}; // фейковый конструктор без side effects
    F.prototype = protoObj;

    return new F();
}

function A() {}
function B() {}

B.prototype = Object.create(A.prototype);

// wrong way
B.prototype = new A(); // из-за side effects


// # Линковка:
function F() {}

const obj1 = new F();
const obj2 = new F();

const proto1 = Object.getPrototypeOf(obj1);
const proto2 = Object.getPrototypeOf(obj2);

proto1 === proto2; // true

/**
 - В js нет классов, но есть конструкторы
 - Цепочка прототипов - основа наследования в js
 - new не создает "инстанс" класса/функции
 - new создает обычный объект и линкует его с прототипом функции
 - instanceof проверяет наличие прототипа в цепочке
 - Прототип объекта Object.prototype равен тull

 */

/**
 # Дополнительные материалы
 Прототипы
 */

/***@@@
 Node.js
 Реализуйте тип Node.js используя прототип.

 PairedTag.js, SingleTag.js
 Реализуйте прототипное наследование от типа Node.
 */

// FILE: /app/Node.js:
export default function Node(name, attributes = {}) {
    this.name = name;
    this.attributes = attributes;
}

Node.prototype.getAttributesAsLine = function getAttributesAsLine() {
    return Object.keys(this.attributes).reduce((acc, key) => `${acc} ${key}="${this.attributes[key]}"`, '');
};

// FILE: /app/PairedTag.js:
import Node from './Node';

export default function PairedTag(name, attributes, body = '', children = []) {
    Node.apply(this, [name, attributes]);
    this.body = body;
    this.children = children;
}

PairedTag.prototype = Object.create(Node.prototype);

PairedTag.prototype.toString = function toString() {
    const value = this.children.length > 0 ? this.children.map(child => child.toString()).join('') : this.body;
    return `<${this.name}${this.getAttributesAsLine()}>${value}</${this.name}>`;
};


// FILE: /app/SingleTag.js:
import Node from './Node';

export default function SingleTag(name, attributes) {
    Node.apply(this, [name, attributes]);
}

SingleTag.prototype = Object.create(Node.prototype);

SingleTag.prototype.toString = function toString() {
    return `<${this.name}${this.getAttributesAsLine()}>`;
};

/***@@@
 solution.js
 Добавьте в Object.prototype функцию hash, которая позволяет извлекать вложенные значения из объекта.
 */
const obj = {
    person: {
        name: 'joe',
        history: {
            hometown: 'bratislava',
            bio: {
                funFact: 'I like fishing.',
            },
        },
    },
};

obj.hash('car'); // undefined
obj.hash('person.history.bio'); // { funFact: 'I like fishing.' }
obj.hash('person.history.homeStreet'); // undefined
obj.hash('person.animal.pet.needNoseAntEater'); // undefined


// FILE: /app/
Object.prototype.hash = function hash(path) {
    const keys = path.split('.');

    return keys.reduce((acc, item) =>
        (acc === undefined ? acc : acc[item]), this);
};



/***@@@
 solution.js
 Добавьте в Function.prototype функцию wrap, которая работает согласно примеру:
 */
function speak(name) {
    return `Hello ${name}`;
}

const newSpeak = speak.wrap((original, yourName, myName) => {
    const greeting = original(yourName);
    return `${greeting}, my name is ${myName}`;
});

newSpeak('Mary', 'Kate'); // Hello Mary, my name is Kate


// FILE: /app/solution.js:
Function.prototype.wrap = function wrap(func) {
    return (...args) => func(this, ...args);
};




// ############################### Обработка ошибок ############################



// >>>>>> Деревья <<<<<<

/**
 |- home /
 |- config
 |-  etc/
 */

tree = new Tree('/');
const child = tree.addChild('home')
    .addChild('config', 'data');
tree.addChild('etc');

assert.ok(tree.hasChildren());
assert.ok(tree.hasChildren('home'));

// # Дизайн:
const node = tree.getChild('home')
    .getChild('config');

assert.equal(node.getKey(), 'config');
assert.equal(node.getMeta(), 'data');

// # Реализация:
class Tree {
    constructor(key, meta, parent) {
        this.parent = parent;
        this.key = key;
        this.meta = meta;
        this.children = new Map();
    }

    addChild(key, meta) {
        const child = new Tree(key, meta, this);
        this.children.set(key, child);

        return child;
    }
}

// # Ошибки:
tree = new Tree('animals');
tree.addChild('cats');
const dogs = tree.getChild('dogs');


// # Поиск в глубину:
const path = '/etc/nginx/conf.d/hexlet.conf';

const keys = ['etc', 'nginx', 'conf.d'];
const subtree = tree.getDeepChild(keys);
assert.equal(subtree.getParent().getkey(), 'nginx');

const keys = ['etc', 'init', 'nginx.conf'];
const subtree = tree.getDeepChild(keys);
assert.equal(subtree, undefinded);


/***@@@
 Реализуйте недостающие части интерфейса типа Tree.
 hasChildren()
 hasChild(key)
 getParent()
 removeChild(key)
 getDeepChild(keys). Функция возвращает undefined если узел не найден или был передан пустой массив.
 getChildren()
 */

tree = new Tree('/');
tree.addChild('var')
    .addChild('lib')
    .addChild('run');
tree.addChild('etc');
tree.addChild('home');

// example: getDeepChild
const subtree = tree.getDeepChild(['var', 'lib']);
subtree.getKey(); // lib

tree.getDeepChild(['var', 'nobody']); // undefined

const parent = subtree.getParent();
parent.getKey(); // var

tree.removeChild('home'); // true
tree.removeChild('nonexistentNode'); // false

/**
 Подсказки
 метод getChildren возвращает массив нод
 */

// FILE: /app/Tree.js:
class Tree {
    constructor(key, meta, parent) {
        this.parent = parent;
        this.key = key;
        this.meta = meta;
        this.children = new Map();
    }

    getKey() {
        return this.key;
    }

    getMeta() {
        return this.meta;
    }

    addChild(key, meta) {
        const child = new Tree(key, meta, this);
        this.children.set(key, child);

        return child;
    }

    getChild(key) {
        return this.children.get(key);
    }

    hasChild(key) {
        return this.children.has(key);
    }

    getParent() {
        return this.parent;
    }

    removeChild(key) {
        return this.children.delete(key);
    }

    hasChildren() {
        return this.children.size > 0;
    }

    getDeepChild(keys) {
        const [key, ...rest] = keys;
        const node = this.getChild(key);

        if (!node || rest.length === 0) {
            return node;
        }

        return node.getDeepChild(rest);
    }

    getChildren() {
        return [...this.children.values()];
    }
}

export default Tree;




// >>>>>> Файловая система <<<<<<

// # TDD:
const files = new HexletFs();

assert.ok(!files.isDirectory('/etc'));

files.mkdirSync('/etc');
assert.ok(files.isDirectory('/etc'));

files.mkdirSync('/etc/nginx');
assert.ok(files.isDirectory('/etc/nginx'));


// # hexlet-trees:
// FILE: HexletFs.js:
export default class {
    constructor() {
        this.tree = new Tree('/');
    }
}

// mkdir
subtree.addChild(name, { type: 'dir' });


// # Порядок действий:
const path = '/etc/nginx/conf.d';

/**
 1. Разбиваем путь на массив имен
 2. Используя getDeepChild извлекаем предпоследний элемент
 3. Добавляем новый элемент в дерево.
 */

// # Особенности работы путей:
assert.ok(!files.isDirectory('/var//'));

files.mkDirSync('/var/');
assert.ok(files.isDirectory('/var'));
assert.ok(files.isDirectory('/var////'));

files.mkdirSync('/var//log//////');
assert.ok(files.isDirectory('/var/log'));
assert.ok(files.isDirectory('/var///log'));


// # touch:
assert.ok(!file.isFile('/file.txt'));

files.touchSync('/file.txt');
assert.ok(files.isFile('/file.txt'));

files.mkdirSync('/etc');
files.touchSync('/etc/bashrc');
assert.ok(files.isFile('/etc/bashrc'));


/***@@@
 Файловая система должна корректно обрабатывать пустые пути, делая внутри нормализацию. То есть, если ей передать путь ///etc/config//my///, то он транслируется в /etc/config/my.

 HexletFs.js
 Реализуйте следующие части интерфейса типа HexletFs.

 isDirectory(path)
 isFile(path)
 mkdirSync(path) - поведение этой функции должно соответствовать поведению утилиты mkdir в баше. Для ее работы должны существовать все родительские директории. Она не создает директории рекурсивно.
 touchSync(path) - создает пустой файл. На самом деле, в реальной файловой системе, команда touch меняет время последнего обращения к файлу, а побочным эффектом этой команды является создание файла в случае его отсутствия. По этой причине данной командой часто пользуются для создания файлов.
 Пример:
 */

files.isDirectory('/etc'); // false

files.mkdirSync('/etc');
files.isDirectory('/etc'); // true

files.mkdirSync('/etc/nginx');
files.isDirectory('/etc/nginx'); // true

files.isFile('/file.txt'); // false

files.touchSync('/file.txt');
files.isFile('/file.txt'); // true

/**
 Подсказки
 Реализуйте функцию getPathParts, которая разбивает путь на массив имен. Без этой функции не будет работать метод findNode, осуществляющий глубокий поиск файла (каталога) внутри текущего каталога.
 Для работы с путями используйте возможности встроенного в Node.js модуля Path. Конкретно вам понадобятся parse и sep
 */

import path from 'path';
import Tree from 'hexlet-trees';

const getPathParts = filepath => filepath.split(path.sep).filter(part => part !== '');

export default class {
    constructor() {
        this.tree = new Tree('/', { type: 'dir' });
    }

    touchSync(filepath) {
        const { dir, base } = path.parse(filepath);

        if (!this.isDirectory(dir)) {
            return false;
        }

        const current = this.findNode(dir);

        return current.addChild(base, { type: 'file' });
    }

    isFile(filepath) {
        const current = this.findNode(filepath);

        return !!current && current.getMeta().type === 'file';
    }

    mkdirSync(filepath) {
        const { dir, base } = path.parse(filepath);

        if (!this.isDirectory(dir)) {
            return false;
        }

        const parent = this.findNode(dir);

        return parent.addChild(base, { type: 'dir' });
    }

    isDirectory(filepath) {
        const current = this.findNode(filepath);

        return !!current && current.getMeta().type === 'dir';
    }

    findNode(filepath) {
        const parts = getPathParts(filepath);

        return parts.length === 0 ? this.tree : this.tree.getDeepChild(parts);
    }
}




// >>>>>> Информация о файле <<<<<<

// # Информация о файле:
// isFile(path)
const parts = getPathParts(path);
const current = this.getDeepChild(parts);

return current & current.getMeta().type === 'file';

// isDirectory, isSocket, isSymbolicLink


// # Объект со статистикой:
// state.isFile()
// stats.isDirectory()

// util.inspect(stats) =>
{
    dev: 2114,
        ino: 48064969,
    mode: 33188,
    nlink: 1,
    uid: 85,
    gid: 100,
    size: 527,
    blocks: 8,
    atime: 'Mon, 10 Oct 2011 23:24:11 GMT',
    birthtime: 'Mon, 10 Oct 2011 23:24:11 GMT',
    // ...
}

// # Интерфейс:
files.mkdirSync('/etc');
files.statSync('/etc').isDirectory(); // true
files.isDirectory('/etc'); // true

files.touchSync('/file.txt');
files.statSync('/file.txt').isFile(); // true
files.isFile('/file.txt'); // true


// # Полиморфизм:
// touchSync(path)
return parent.addChild(name, new File(name));
// file.getStats().isFile();

// mkdirSync(path)
return parent.addChild(name, new Dir(name));
// file.getStats().isDirectory();

statSync(path) {
    const keys = getPathParts(path);
    const current = this.tree.getDeepChild(keys);

    return current.getMeta().getStats();
}



/***@@@
 Задача состоит в том, чтобы реализовать тип Stats и его формирование посредством динамической диспетчеризации благодаря подтипам Node.

 Stats.js
 Реализуйте тип Stats со следующим интерфейсом:

 constructor
 isFile()
 isDirectory()
 Node.js
 Реализуйте надтип Node, интерфейсом которого являются функции:

 getStats()
 getName()
 Dir.js, File.js
 Реализуйте подтипы Dir и File (надтип Node). Варианты использования этих типов можно увидеть в файле HexletFs.js.
 */

// FILE: /app/Dir.js:
import Node from './Node';

export default class extends Node {
    isDirectory() {
        return true;
    }

    isFile() {
        return false;
    }
}

// FILE: /app/File.js:
import Node from './Node';

export default class extends Node {
    constructor(name, body) {
        super(name);
        this.body = body;
    }

    getBody() {
        return this.body;
    }

    isDirectory() {
        return false;
    }

    isFile() {
        return true;
    }
}

// FILE: /app/Node.js:
import Stats from './Stats';

export default class {
    constructor(name) {
        this.name = name;
    }

    getStats() {
        return new Stats(this.isFile(), this.isDirectory());
    }

    getName() {
        return this.name;
    }
}

// FILE: /app/Stats.js:
export default class {
    constructor(file, directory) {
        this.file = file;
        this.directory = directory;
    }

    isFile() {
        return this.file;
    }

    isDirectory() {
        return this.directory;
    }
}

/**
 # Дополнительные материалы
 Stats в стандартной библиотеке Node.js https://nodejs.org/api/fs.html#fs_class_fs_stats
 */




// >>>>>> Обработка ошибок <<<<<<

// # Ошибка:
'Blue Whale'.indexOf('Blue'); // 0
'Blue Whale'.indexOf('Blute'); // -1

const pos = 'Blue Whale'.indexOf('Whale');

if (pos !== -1) {
    // ...
}


// # Возможные ошибки:
files.rmdirSync(path);

/***
 * Директория не существует
 * Передан файл
 * Директория не существует

 * Передана не строка


 # Типы ошибок:
 - Эксплуатационные ошибки:
 Ошибки времени выполнения возникающие в корректных программах

 - Ошибки программирования
 Баги в программе


 # Обработка ошибок:
 - Значительная часть кода
 - Сложно предусмотреть заранее
 - Сильная система типов может помочь
 - Необходимы тесты
 */

// # StatSync:
statSync(path) {
    const parts = getPathParts(path);
    const current = this.tree.getDeepChild(parts);

    if (!current) {
        return false;
    }

    return current.getMeta().getStats();
}



/***@@@
 HexletFs.js
 Реализуйте следующие возможности файловой системы HexletFs:

 mkdirpSync(path)
 Создает директории рекурсивно (в отличие от mkdir).

 Если в пути встречается файл, то возвращает false, т.к. нельзя создать директорию внутри файла.
 Если все отработало корректно, то возвращается true
 readdirSync(path)
 Возвращает список файлов (и папок) указанной директории.

 Если директории не существует, то возвращает false
 Если передан файл, то возвращает false
 */


// FILE: //app/
import path from 'path';
import Tree from 'hexlet-trees';
import { Dir, File } from 'hexlet-fs';


const getPathParts = filepath => filepath.split(path.sep).filter(part => part !== '');

export default class {
    constructor() {
        this.tree = new Tree('/', new Dir('/'));
    }

    statSync(filepath) {
        const current = this.findNode(filepath);

        if (!current) {
            return null;
        }

        return current.getMeta().getStats();
    }

    mkdirSync(filepath) {
        const current = this.findNode(filepath);

        if (current) {
            return false;
        }

        const { base, dir } = path.parse(filepath);
        const parent = this.findNode(dir);

        if (!parent || parent.getMeta().isFile()) {
            return false;
        }

        parent.addChild(base, new Dir(base));

        return true;
    }

    mkdirpSync(filepath) {
        const result = getPathParts(filepath).reduce((subtree, part) => {
            if (!subtree) {
                return false;
            }
            const current = subtree.getChild(part);
            if (!current) {
                return subtree.addChild(part, new Dir(part));
            }
            if (current.getMeta().isFile()) {
                return false;
            }

            return current;
        }, this.tree);

        return !!result;
    }

    readdirSync(filepath) {
        const current = this.findNode(filepath);
        if (!current || current.getMeta().isFile()) {
            return false;
        }
        return current.getChildren()
            .map(child => child.getKey());
    }

    touchSync(filepath) {
        const { base, dir } = path.parse(filepath);
        const parent = this.findNode(dir);

        if (!parent) {
            return false;
        }

        if (parent.getMeta().isFile()) {
            return false;
        }

        parent.addChild(base, new File(base, ''));

        return true;
    }

    rmdirSync(filepath) {
        const { base } = path.parse(filepath);
        const current = this.findNode(filepath);

        if (!current) {
            return false;
        }

        if (current.getMeta().isFile() || current.hasChildren()) {
            return false;
        }

        current.getParent().removeChild(base);

        return true;
    }

    findNode(filepath) {
        const parts = getPathParts(filepath);

        return parts.length === 0 ? this.tree : this.tree.getDeepChild(parts);
    }
}




// >>>>>> Коды ошибок <<<<<<

// # Как возвращать?
const result = files.rmdir(path);

if ([/** errors list */].includes(result)) { // код ошибки может совпадать с результатом
                                             // error
} else {
    // success
}

// # C style:
#include <stdio.h>
#include <errno.h>

extern int errno;

int main () {
    FILE * fp;
    fp = fopen("filedoesnotexist.txt", "rb");
    if (fp === NULL) { // Value of errno is: 2
        fprint (stderr, "Value of errno: %d'n", errno);
    } else {
        fclose(fp);
    }

    return 0;
}

// # Golang style:
package main
import (
    "fmt"
"io"
"io/ioutil"
)

func main() {
    dat, err := ioutil.ReadFile("/tmp/dat") // чтение файла
    if e != nil {
        fmt.Println(err.Error())
    }
    fmt.Print(string(dat))
}


// # Destructuring:
const [data, err] = files.readFileSync('/unknow');

if (err === null) {
    // do something with data
} else {
    // fandle error
}

// return [null, errors.code.ENOENT];

/***@@@
 Ошибок, связанных с файловой системой, очень много, и для их ручной генерации существуют удобные библиотеки. Например, errno. Пример использования:
 */

import errors from 'errno';

errors.code.ENOTEMPTY;
// → {
//     "errno": 53,
//     "code": "ENOTEMPTY",
//     "description": "directory not empty"
//   }


/**
 Список ошибок можно подсмотреть тут: https://github.com/rvagg/node-errno/blob/master/errno.js

 HexletFs.js
 Реализуйте следующие возможности файловой системы HexletFs:

 unlinkSync(path)
 Удаляет файл (в реальной фс все чуть сложнее, см. hard link).

 Возможные ошибки:

 ENOENT - файл не найден
 EPERM - операция не разрешена. Такая ошибка возникает в случае, если path это директория
 writeFileSync(path, content)
 Записывает content в файл по пути path.

 Возможные ошибки:

 ENOENT - родительская директория, в которой нужно создать файл, не существует
 EISDIR - path является директорией
 ENOTDIR - родительский элемент не является директорией
 readFileSync(path)
 Читает содержимое файла по пути path.

 ENOENT - файл не найден
 EISDIR - path является директорией
 Подсказки
 Тип File содержит метод getBody, который возвращает содержимое файла.
 */

// FILE: /app/HexletFs.js:
import path from 'path';
import errors from 'errno';
import Tree from 'hexlet-trees';
import { Dir, File } from 'hexlet-fs';

const getPathParts = filepath => filepath.split(path.sep).filter(part => part !== '');

export default class {
    constructor() {
        this.tree = new Tree('/', new Dir('/'));
    }

    statSync(filepath) {
        const current = this.findNode(filepath);

        if (!current) {
            return [null, errors.code.ENOENT];
        }

        return [current.getMeta().getStats(), null];
    }

    unlinkSync(filepath) {
        const current = this.findNode(filepath);

        if (!current) {
            return [null, errors.code.ENOENT];
        }

        if (current.getMeta().isDirectory()) {
            return [null, errors.code.EPERM];
        }

        return [current.getParent().removeChild(current.getKey()), null];
    }

    writeFileSync(filepath, body) {
        const { base, dir } = path.parse(filepath);
        const parent = this.findNode(dir);

        if (!parent) {
            return [null, errors.code.ENOENT];
        }

        if (parent.getMeta().isFile()) {
            return [null, errors.code.ENOTDIR];
        }

        const current = parent.getChild(base);

        if (current && current.getMeta().isDirectory()) {
            return [null, errors.code.EISDIR];
        }

        return [parent.addChild(base, new File(base, body)), null];
    }

    readFileSync(filepath) {
        const current = this.findNode(filepath);

        if (!current) {
            return [null, errors.code.ENOENT];
        }

        if (current.getMeta().isDirectory()) {
            return [null, errors.code.EISDIR];
        }

        return [current.getMeta().getBody(), null];
    }

    mkdirpSync(filepath) {
        const result = getPathParts(filepath).reduce((subtree, part) => {
            if (!subtree) {
                return false;
            }

            const current = subtree.getChild(part);

            if (!current) {
                return subtree.addChild(part, new Dir(part));
            }

            if (current.getMeta().isFile()) {
                return false;
            }

            return current;
        }, this.tree);

        return !!result;
    }

    touchSync(filepath) {
        const { base, dir } = path.parse(filepath);
        const parent = this.findNode(dir);

        if (!parent) {
            return [null, errors.code.ENOENT];
        }

        if (parent.getMeta().isFile()) {
            return [null, errors.code.ENOTDIR];
        }

        return [parent.addChild(base, new File(base, '')), null];
    }

    readdirSync(filepath) {
        const dir = this.findNode(filepath);

        if (!dir) {
            return [null, errors.code.ENOENT];
        }

        if (dir.getMeta().isFile()) {
            return [null, errors.code.ENOTDIR];
        }

        return [dir.getChildren().map(child => child.getKey()), null];
    }

    findNode(filepath) {
        const parts = getPathParts(filepath);

        return parts.length === 0 ? this.tree : this.tree.getDeepChild(parts);
    }
}




// >>>>>> Исключения <<<<<<

// # Глубоко в стеке:
const [data, err] = files.readFileSync(path);

if (err) {
    return err;
} else {
    // process
}

/**
 # Исключительная ситуация:
 * Критическая ошибка, после которой невозможно восставновление (до какой-то точки стека)
 * Всегда приводит к раскрутке стека вызовов.
 */

// # Синтаксис:
сonst g = () => undefinedFunc();
const f = () => g();

try {
    f();
} catch (e) {
    console.log(e);
}

// ReferenceError: undefinedFunc is not defined
// at g (main.js:60:17)
// at f (main.js:61:17)
// at Object.<anonymous> (main.js:64:3)

// # Возбуждение исключения:
// const obj = new Error(message);
// throw obj;

statSync(path) {
    const parts = getPathParts(path);
    const current = this.tree.getDeepChild(parts);

    if (!current) {
        const error = errors.code.ENOENT;
        throw new HexletFsError(error, path);
    }

    return current.getMeta().getStats();
}

/**
 # Эмпирическое правило:
 You throw an exception when your method is unable to do what it promises to - Jeff Richter
 "Нужно бросать эсключение, тогда, когда функция не способна выполнить то, что обещает"
 */


/***@@@
 Реализуйте функцию copySync(src, dest), которая копирует файл из src в dest.

 Если dest это путь до папки, то имя файла берется из src
 Если dest это путь до файла (существующего или нет), то его содержимое становится равным src
 Возможные ошибки:

 EISDIR - возникает в случае, если src это директория, а не файл
 ENOENT - возникает в случае, если src не существует, а так же возникает в случае, если не существует директорий по пути dest (копирование не создает директорий)
 */

// FILE: /app/
import path from 'path';
import errors from 'errno'; // eslint-disable-line
import Tree from 'hexlet-trees'; // eslint-disable-line
import { Dir, File } from 'hexlet-fs'; // eslint-disable-line

import HexletFsError from './HexletFsError';

const getPathParts = filepath =>
    filepath.split(path.sep).filter(part => part !== '');

export default class {
    constructor() {
        this.tree = new Tree('/', new Dir('/'));
    }

    statSync(filepath) {
        const current = this.findNode(filepath);
        if (!current) {
            throw new HexletFsError(errors.code.ENOENT, filepath);
        }
        return current.getMeta().getStats();
    }

    copySync(src, dest) {
        const data = this.readFileSync(src);
        const destNode = this.findNode(dest);
        if (destNode && destNode.getMeta().isDirectory()) {
            const { base } = path.parse(src);
            const fullDest = path.join(dest, base);
            return this.writeFileSync(fullDest, data);
        }
        return this.writeFileSync(dest, data);
    }

    writeFileSync(filepath, body) {
        const { dir, base } = path.parse(filepath);
        const parent = this.findNode(dir);
        if (!parent || parent.getMeta().isFile()) {
            throw new HexletFsError(errors.code.ENOENT, filepath);
        }
        const current = parent.getChild(base);
        if (current && current.getMeta().isDirectory()) {
            throw new HexletFsError(errors.code.EISDIR, filepath);
        }
        parent.addChild(base, new File(base, body));
    }

    touchSync(filepath) {
        const { dir, base } = path.parse(filepath);
        const parent = this.findNode(dir);
        if (!parent) {
            throw new HexletFsError(errors.code.ENOENT, filepath);
        }
        if (parent.getMeta().isFile()) {
            throw new HexletFsError(errors.code.ENOTDIR, filepath);
        }
        return parent.addChild(base, new File(base, ''));
    }

    mkdirpSync(filepath) {
        getPathParts(filepath).reduce((subtree, part) => {
            const current = subtree.getChild(part);
            if (!current) {
                return subtree.addChild(part, new Dir(part));
            }
            if (current.getMeta().isFile()) {
                throw new HexletFsError(errors.code.ENOTDIR, filepath);
            }

            return current;
        }, this.tree);
    }

    readFileSync(filepath) {
        const current = this.findNode(filepath);
        if (!current) {
            throw new HexletFsError(errors.code.ENOENT, filepath);
        }
        if (current.getMeta().isDirectory()) {
            throw new HexletFsError(errors.code.EISDIR, filepath);
        }
        return current.getMeta().getBody();
    }

    findNode(filepath) {
        const parts = getPathParts(filepath);
        return parts.length === 0 ? this.tree : this.tree.getDeepChild(parts);
    }
}

// FILE: /app/HexletFsError.js:
export default class extends Error {
    constructor({ code, errno, description }, path) {
        super(`${code}: ${description}, ${path}`);

        this.name = this.constructor.name;
        this.stack = (new Error()).stack;
        this.code = code;
        this.errno = errno;
        this.path = path;
    }
}





// ############################### JS: Асинхронное программирование ###############################


// >>>>>>>> Введение <<<<<<

/**
 JavaScript – язык, созданный для выполнения на клиентской стороне. Это сильно повлияло не только на устройство самого языка, но и на то, как устроены его среды исполнения: браузеры, Node.js и другие. Браузер заточен под так называемую событийную модель, когда код не исполняется непрерывно, а ожидает пользовательских событий: нажатий на кнопки, кликов мышкой или скроллинга. Каждое из этих (и десятка других) событий запускает нужный обработчик, причём к нему предъявляются особые требования: он не должен блокировать работу, так как на одно событие может выполняться много задач (практически параллельно), и при этом пользователь должен иметь возможность продолжать взаимодействовать с интерфейсом.

 По этим причинам все движки (исполнители js-кода) построены по асинхронной модели. Любые операции ввода/вывода (например, выполнение Ajax-запросов) выполняются асинхронно. Асинхронный код устроен совершенно отлично от синхронного и требует времени на привыкание. Кроме того, он сложен, у него другой способ обработки ошибок и, в целом, другие подходы при написании. Добавляя одни возможности, он создаёт множество проблем в других местах: то, что легко делалось в синхронном коде, становится крайне сложным в асинхронном.

 Асинхронное программирование в JavaScript прошло несколько стадий: от колбеков, через промисы и до концепции async/await. Все эти подходы по-своему важны и рассматриваются в данном курсе.
 */




// >>>>>> Стек вызовов (Call Stack) <<<<<<

/**
 Перед тем, как погружаться в асинхронное программирование, разберём один важный момент, связанный с исполнением кода. Тот код, который мы писали ранее, называется синхронным, так как он последовательно выполняется прямо здесь и сейчас.
 */
const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // => [4, 8, 2]
const predicate = v => v > 2
const data3 = data2.filter(predicate); // => [4, 8]

/**
 Каждая строчка в коде выше выполняется только тогда, когда выполнится предыдущая. Причём выполнение каждой конкретной строчки может быть сколь угодно сложным. Если посмотреть на вторую строку, то видно, что вызывается функция map, которая внутри себя вызывает функцию Math.sqrt. В реальных приложениях глубина такого погружения может быть просто огромной, на сотни функций внутрь. Такая цепочка функций, вызывающих друг друга, называется стеком вызовов (call stack). Почему именно стеком? Потому что именно так происходит процесс исполнения кода. Каждый внутренний вызов добавляет текущую функцию внутрь стека — и так до самой глубокой функции. Затем, когда происходит возврат, начинается раскрутка стека — из него по очереди (в обратном порядке, ведь это стек) извлекаются функции и продолжают своё выполнение с того места, где внутренняя функция вернула результат.

 Рассмотрим ещё один пример:
 */

const multiply = (a, b) => a * b;

const square = n => multiply(n, n);

const printSquare = (n) => {
    const squared = square(n)
    console.log(squared);
};

printSquared(5);

/**
 Вот, какой стек построит интерпретатор:
 const multiply = (a, b) => a * b;
 const square = n => multiply(n, n);

 const printSquare = (n) => {
  const squared = square(n)
  console.log(squared);
};

 printSquared(5);

 Стек вызовов:
 multiply(n, n)
 square(n)
 printSquare(5)
 main()

 Мы, как разработчики, видим стек вызовов каждый день в выводе ошибок. Backtrace (обратная трассировка) — ни что иное, как стек вызовов, записанный в обратном порядке. Для демонстрации я допустил ошибку в третьей строке нашего кода:
 */

const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // => [4, 8, 2]
const predicate = v => unkonwn > 2;
const data3 = data2.filter(predicate); // => [4, 8]

// Запуск (код расположен в файле index.js) и вывод:
$ nodejs index.js

index.js:3
const predicate = v => unkonwn > 2;
^
/**
 ReferenceError: unkonwn is not defined
 at predicate (index.js:3:32)
 at Array.filter (<anonymous>)
 at Object.<anonymous> (index.js:4:21)


 Важно понимать, что стек вызовов растёт только тогда, когда вызовы идут в глубину. Это видно по выводу: в бектрейсе не фигурирует первая и вторая строчки, в нём описана последовательность, начиная от вызова фильтра и дальше.

 Механизм исключений в js, как и в других языках, полностью опирается на наличие стека вызовов. Более того, он создан для того, чтобы удобно "раскручивать" этот стек. Любое возникающее исключение поднимается вверху по стеку вызовов, до тех пор пока не наткнется на конструкцию try/catch либо до тех пор пока стек вызовов не закончится.
 */

const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // => [4, 8, 2]
const predicate = v => unkonwn > 2;

try {
    const data3 = data2.filter(predicate); // => [4, 8]
} catch (e) {
    console.log('Catch it');
    console.log(e.stack);
}


/**
 И хотя функция predicate, содержащая ошибку, находится вне блока try/catch, он всё равно поймает ошибку внутри этой функции, так как predicate вызывается внутри по цепочке.

 $ node index.js
 Catch it
 ReferenceError: unkonwn is not defined
 at predicate (index.js:3:32)
 at Array.filter (<anonymous>)


 Существуют специальные инструменты, которые позволяют визуализировать стек вызовов. Обычно их используют во время профайлинга — процесса поиска узких мест для ускорения приложения.

 # Дополнительные материалы
 Стек https://ru.wikipedia.org/wiki/Стек
 Стек вызовов https://ru.wikipedia.org/wiki/Стек_вызовов


 В каком случае стек вызовов растет?
 > Во время вызова функции

 В каком случае стек вызовов уменьшается?
 > При возврате из функции

 Какая информация содержится в стеке вызовов?
 > Имя функции
 > Номер строчки, на которой находится функция
 > Имя файла в котором была определена функция
 */



// >>>>>> Асинхронный код <<<<<<

/**
 Примеры в этом уроке даются на основе работы с файловой системой, потому что именно они лучше всего раскрывают суть асинхронного программирования. Принципы работы асинхронного кода абсолютно идентичны и для фронтенда, и для бекенда.

 В синхронном коде выполнение функций происходит в том же месте, где они были вызваны, и в тот момент, когда происходит вызов. В асинхронном коде всё по-другому. Вызов функции не означает, что она отработает прямо здесь и сейчас. Более того, мы не знаем, когда она отработает. Разберём пример с копированием файла через чтение и повторную запись в другой файл:
 */

import fs from 'fs';

const content = fs.readFileSync('./myfile', 'utf-8');
fs.writeFileSync('./myfile-copy', content);

/**
 Пример кода написан для Node.js: здесь используется модуль fs и его синхронные функции для чтения и записи файла (их особенность в том, что имена оканчиваются на Sync). Такой код работает как ожидается: сначала читается содержимое файла в константу content, затем оно же записывается в другой файл. Каждая строчка приводит к блокировке, то есть выполнение программы ждёт, пока операционная система прочитает файл (а это делает именно она) и отдаст его содержимое программе, и только затем выполняется следующая строчка. Соответственно, там, где происходит запись, программа ожидает, пока операционная система запишет файл на диск (это не совсем правда, но данная тема выходит за рамки урока, подробнее в книгах по операционным системам), и только затем продолжает работу.

 В принципе, здесь можно было бы и остановится — зачем что-то делать с этим кодом? Дело в том, что любые файловые операции занимают много времени (они в тысячи раз медленнее, чем вызов обычной функции), в течение которого процесс ничего не делает: он висит в ожидании ответа от ядра о результате операции. Поэтому синхронный подход в случае файловых операций очень неэффективно утилизирует ресурсы. Асинхронный же код продолжает выполняться во время любых файловых операций. Другими словами, код никогда не блокируется на IO операциях, но может узнать об их завершении. Правильно написанные асинхронные программы (в тех ситуациях, где это нужно) значительно эффективнее синхронных. Иногда это настолько критично, что синхронная версия просто не справится с задачей.

 Небольшая ремарка. IO — это ввод/вывод. К нему относится не только работа с файлами, но и любое сетевое взаимодействие (которое, в конечном итоге, сводится к работе с файлами). Даже печать на экран — это тоже запись в файл.

 Теперь попробуем прийти к асинхронному коду через понимание принципов его работы. Представим, что функция readFile в примере ниже асинхронная. Это значит, что она читает файл не прямо в том месте, где её вызвали, а где-то в другом месте на фоне:
 */

import fs from 'fs';

// пустая функция, чуть позже разберём её смысл,
// но асинхронная версия readFile требует передачи функции третьим параметром
const noop = () => {};
const content = fs.readFile('./myfile', 'utf-8', noop);
console.log(content);

// Возможно ли появление такого асинхронного кода? Ответ сразу — нет. Неважно, какую конкретно задачу выполняет эта функция, важно лишь одно — она не выполняет её сразу, а значит у неё невозможен возврат. Если запустить подобный код, то мы увидим такой вывод:

$ node index.js
undefined

/**
 Это фундаментальная особенность асинхронных функций, которую нужно запомнить раз и навсегда. Приходится подчёркивать этот момент, потому что новички постоянно спотыкаются на нём, пытаясь работать с асинхронными функциями как с синхронными.

 Тогда возникает вопрос: как получить результат выполнения этой функции? А вот для этого используется ещё одна функция, которая передаётся в асинхронную. В этом качестве она называется функцией обратного вызова или просто коллбек (callback). Эта функция будет вызвана в тот момент, когда операция закончится (возможно, с ошибкой). Она имеет следующую сигнатуру: callback(error, result). Первым параметром в неё передаётся ошибка, если всё было плохо, вторым — результат операции, если всё было хорошо. Про ошибки мы поговорим чуть позже, а сейчас разберём общие принципы работы.
 */

import fs from 'fs';

const callback = (_error, data) => console.log(data);
fs.readFile('./myfile', 'utf-8', callback);

// Запуск и вывод:
$ node index.js
content of file

// Как только операция завершилась, интерпретатор Node.js внутри себя вызвал колбек, передав ему параметром содержимое файла. Осталось убедиться в том, что этот код действительно асинхронный:

import fs from 'fs';

const callback = (_error, data) => console.log(data);
console.log('before read');
fs.readFile('./myfile', 'utf-8', callback);
console.log('after read?');

// Запуск и вывод:
$ node index.js
before read
after read?
    content of file

/**
 Несмотря на то, что after read? выводится последней инструкцией, реальный вывод отличается от порядка инструкций в коде. Асинхронная функция хоть и запустилась на выполнение сразу, но колбек вызывается только в тот момент, когда в текущем стеке вызовов не останется ни одной функции. В нашем случае это означает, что она запускается только после отработки всего файла. И этот запуск породит свой собственный стек вызовов.

 В асинхронном коде каждый колбек асинхронной функции порождает свой собственный стек вызовов, который, в свою очередь, может выполнять новые асинхронные вызовы и так далее до бесконечности.

 Node.js дожидается завершения всех асинхронных вызовов, которые были сделаны в процессе работы программы:
 */

import fs from 'fs';

fs.readFile('./myfile', 'utf-8', (_error, data) => console.log('First!'));
fs.readFile('./myfile', 'utf-8', (_error, data) => console.log('Second!'));

/**
 В примере выше мы видим запуск двух асинхронных операций. Теперь мы знаем, что второе чтение файла запустится практически одновременно с первым, так как операции асинхронные и их выполнение не блокирует поток выполнения программы. Попробуйте ответить на вопрос, в каком порядке появится результат?

 Запуск и вывод:
 */
$ node index.js
Second!
    First!
    $ node index.js
First!
    Second!

/**
 Как видите, на этот вопрос нельзя дать однозначный ответ. Асинхронные операции могут выполниться в любом порядке, если они запускаются одновременно. И единственный способ упорядочить их — делать последовательный запуск, и об этом мы поговорим далее.

 Асинхронное программирование значительно сложнее синхронного. Видеть линейный код (последовательно записанный) и думать о нём нелинейно — очень тяжело. Дальше вы увидите, что с ростом числа асинхронных функций в рамках одной программы сложность увеличивается экспоненциально, и в какой-то момент перестаёшь понимать, что происходит. Для борьбы с ней придумано множество выходов, некоторые из которых оказались очень удачными и рассматриваются в более поздних уроках курса.

 # Дополнительные материалы
 синхронная функция readFileSync из модуля fs https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options
 асинхронная функция readFile из модуля fs https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback
 */


/***@@@
 printer.js
 Реализуйте асинхронную функцию, которая читает данные файла по указанному пути и печатает их на экран.
 */
import print from './printer';
print('./myfile');


// FILE: /app/printer.js:
import fs from 'fs';

export default filepath =>
    fs.readFile(
        filepath,
        'utf-8',
        (error, data) => console.log(data),
    );





// >>>>>> Возврат в асинхронном коде <<<<<<

/**
 Остановимся чуть подробнее на возврате значений из асинхронных функций. В прошлом уроке мы выяснили, что асинхронные функции никогда не возвращают результат:
 */
import fs from 'fs';

const noop = () => {};
const content = fs.readFile('./myfile', 'utf-8', noop);
console.log(content); // undefined

// И единственный способ получить результат — описать логику в коллбеке. Тогда возникает вопрос: а что, если сделать return внутри коллбека? К чему это приведёт?

import fs from 'fs';

const noop = () => {};
const content = fs.readFile('./myfile', 'utf-8', (_error, data) => {
    // что-нибудь делаем
    return data;
});
console.log(content); // undefined

// В результате ничего не меняется, так как этот возврат никем не используется. Это не означает, что сама инструкция return бесполезна в асинхронном коде. Напротив, она часто бывает полезна, но лишь как способ прервать выполнение кода, а не вернуть результат.

import fs from 'fs';

const noop = () => {};
const content = fs.readFile('./myfile', 'utf-8', (_error, data) => {
    if (data === '') {
        return;
    }
    // делаем что-нибудь с данными
});
console.log(content); // undefined

/**
 Этот паттерн называется guard expression.

 Всё тоже самое распространяется и на асинхронные функции, которые мы пишем сами. Асинхронной является любая функция, внутри которой есть хоть одна асинхронная операция. Без исключения. Даже если помимо асинхронной операции, она выполняет и синхронные, например, производит манипуляции с текстом. В свою очередь, каждая асинхронная функция обязана принимать на вход колбек, так как это единственный способ упорядочивать события и отслеживать завершение.

 Напишем асинхронную функцию-обёртку для чтения файла, которая, кроме самого чтения, выполняет небольшую чистку, удаляя начальные и концевые пробелы из содержимого. Сразу вспоминаем, что, раз наша функция асинхронная, то она обязана принимать на вход функцию-колбек, которая будет вызвана по окончании операции. Эта функция должна иметь общепринятую сигнатуру, то есть принимать первым параметром ошибку и вторым — сами данные. Возврата данных через return в нашей асинхронной функции быть не может.
 */
import fs from 'fs';

const readFileWithTrim = (filepath, cb) => {
    fs.readFile(filepath, 'utf-8', (_error, data) => {
        cb(null, data.trim());
    })
}

readFileWithTrim('./', (_error, data) => console.log(data));

/**
 Этот процесс рекурсивен по своей природе, любая функция, которая внутри работает с асинхронной функцией, становится асинхронной и начинает принимать на вход колбек. Почему так происходит? Почему нельзя просто выполнить асинхронную операцию внутри, никак не сообщая об этом наружу? Дело в том, что в такой ситуации вы не можете ни воспользоваться результатом работы асинхронной функции (ведь данные приходят в колбек в другом стеке вызовов), ни узнать о том, закончилась ли операция вообще и закончилась ли она успешно. Всё это рассмотрим в следующих уроках.
 */


/***@@@
 writer.js
 Реализуйте асинхронную функцию, которая записывает данные по указанному пути и оповещает о завершении работы через переданный колбек.
 */
import write from './writer';

write('./myfile', 'data', () => {
    console.log('success');
});


// FILE: /app/writer.js:
import fs from 'fs';

export default (filepath, data, cb) => {
    fs.writeFile(filepath, data, cb);
};




// >>>>>> Упорядочивание асинхроннных операций <<<<<<

/**
 Асинхронное программирование помогает эффективно использовать вычислительные ресурсы. Но создаёт сложности там, где изначально было просто. В первую очередь это касается порядка выполнения (flow). Предположим, что перед нами стоит задача прочитать содержимое двух файлов и записать в третий (объединение файлов).
 */

import fs from 'fs';

fs.readFile('./first', 'utf-8', '?');
fs.readFile('./second', 'utf-8', '?');
fs.writeFile('./new-file', content, '?');

/**
 Вся задача сводится к последовательному выполнению трёх операций, так как записать новый файл мы можем лишь тогда, когда прочитаем данные первых двух. Упорядочить подобный код можно лишь одним способом: каждая последующая операция должна запускаться внутри колбека предыдущей. Тогда мы построим нужную цепочку вызовов:
 */

import fs from 'fs';

fs.readFile('./first', 'utf-8', (_error1, data1) => {
    fs.readFile('./second', 'utf-8', (_error2, data2) => {
        fs.writeFile('./new-file', `${data1}${data2}`);
    });
});

/**
 В реальных программах количество операций может быть значительно больше: например, десятки — и тогда у вас получится лесенка из 10-ти вложенных вызовов. Подобное свойство асинхронного кода нередко называют Callback Hell ("ад колбеков") из-за большого числа вложенных коллбеков, которые очень затрудняют анализ программы. Кто-то даже сделал сайт http://callbackhell.com/ , на котором разбирается эта проблема и приводится вот такой код:
 */

import fs from 'fs';

// В этом коде происходит обработка ошибок, которую мы рассмотрим в следующем уроке
fs.readdir(source, (err, files) => {
    if (err) {
        console.log('Error finding files: ' + err)
    } else {
        files.forEach((filename, fileIndex) => {
            console.log(filename);
            gm(source + filename).size((err, values) => {
                if (err) {
                    console.log('Error identifying file size: ' + err)
                } else {
                    console.log(filename + ' : ' + values)
                    aspect = (values.width / values.height)
                    widths.forEach((width, widthIndex) => {
                        height = Math.round(width / aspect)
                        console.log('resizing ' + filename + 'to ' + height + 'x' + height)
                        this.resize(width, height).write(dest + 'w' + width + '_' + filename, (err) => {
                            if (err) console.log('Error writing file: ' + err)
                        })
                    }.bind(this))
                }
            })
        })
    }
})

// В некоторых случаях заранее неизвестно, сколько надо будет выполнить операций. Например, может понадобиться прочитать содержимое директории и посмотреть, кто владелец каждого файла (его uid). Если бы код был синхронный, то наше решение выглядело бы так:

import path from 'path';
import fs from 'fs';

const getFileOwners = (dirpath) => {
    // Читаем содержимое директории
    const files = fs.readdirSync(dirpath);
    // Получаем информацию по каждому файлу и формируем результат
    return files
        .map(fname => [fname, fs.statSync(path.join(dirpath, fname))])
        .map(([fname, stat]) => ({ filename: fname, owner: stat.uid }));
};
// [ { filename: 'Makefile', owner: 65534 },
//       { filename: '__tests__', owner: 65534 },
//       { filename: 'babel.config.js', owner: 65534 },
//       { filename: 'info.js', owner: 65534 },
//       { filename: 'package.json', owner: 65534 } ]

/**
 Последовательный код прост и понятен, каждая следующая строчка выполняется после того, как закончится предыдущая, а в map каждый элемент обрабатывается гарантированно последовательно.

 С асинхронным кодом возникают вопросы. И если чтение директории — операция, которую мы сделаем в любом случае, то как описать анализ файлов, ведь их может быть любое количество. К сожалению, без использования готовых абстракций, упрощающих данную задачу, мы получим много сложного кода. Настолько сложного, что в реальной жизни так лучше никогда не делать, этот код приводится только в образовательных целях.
 */

import path from 'path';
import fs from 'fs';

const getFileOwners = (dirpath, cb) => {
    fs.readdir(dirpath, (_error1, filenames) => {
        const readFileStat = (items, result = []) => {
            if (items.length === 0) {
                // Обработку ошибок пока не рассматриваем
                cb(null, result);
                return;
            }
            const [first, ...rest] = items;
            const filepath = path.join(dirpath, first);
            fs.stat(filepath, (_error2, stat) => {
                readFileStat(rest, [...result, { filename: first, owner: stat.uid }]);
            });
        };
        readFileStat(filenames);
    });
};

/**
 Общий принцип такой: формируется специальная функция (readFileStat), которая рекурсивно вызывается, передавая себя в функцию stat. С каждым новым вызовом она отрабатывает один файл и уменьшает массив items, в котором содержатся ещё необработанные файлы. Вторым параметром она аккумулирует (собирает) получившийся результат, который в конце передаётся в коллбек cb (переданный вторым аргументом функции getFileOwners). Пример выше реализует итеративный процесс, построенный на рекурсивных функциях. Чтобы лучше понять код выше, попробуйте скопировать его к себе на компьютер и позапускайте с разными аргументами, предварительно расставив отладочный вывод внутри неё.

 # Дополнительные материалы
 Итеративный процесс https://ru.hexlet.io/courses/introduction_to_programming/lessons/iterative/theory_unit


 Выберите верные утверждения
 > Асинхронный код нельзя писать как синхронный. Функции должны быть вложены в колбеки друг друга, только тогда появляется контроль выполнения асинхронных операций.
 > Асинхронный код не блокирует операции ввода и вывода. Это позволяет выполнять полезный код, пока идут эти операции.
 */

/***@@@
 info.js
 Реализуйте и экспортируйте асинхронную функцию compareFileSizes, которая сравнивает размеры двух файлов. Если первый больше второго, то она возвращает единицу, если размеры равны, то возвращает ноль, иначе — -1.
 */
import { compareFileSizes } from './info';

compareFileSizes('file1', 'file2', (_err, result) => console.log(result));

/**
 Подсказка
 Для реализации этого задания, нужно воспользоваться функцией fs.stat, которая использовалась в примерах теории
 Math.sign возвращает знак числа, указывающий на то, является ли число отрицательным, положительным или нулём.
 */


// FILE: /app/info.js:
import fs from 'fs';

export const compareFileSizes = (filepath1, filepath2, cb) => {
    fs.stat(filepath1, (_error1, { size: size1 }) => {
        fs.stat(filepath2, (_error2, { size: size2 }) => {
            cb(null, Math.sign(size1 - size2));
        });
    });
};




// >>>>>> Обработка ошибок <<<<<<

/**
 Чтение и запись файлов, получение данных по сети, выполнение HTTP запросов — всё это операции ввода/вывода. Через них программа взаимодействует с внешней средой. Внешняя среда — штука сложная, с большим количеством разнообразных правил, которые необходимо соблюдать. Например, для успешного чтения файла программа должна иметь к нему доступ. Для записи — свободное место на диске. Для выполнения запросов по сети нужно соединение с сетью. Подобных условий десятки, а то и сотни. Невыполнение хотя бы одного из них приводит к ошибке. Посмотрите на этот впечатляющий список возможных ошибок. В нём несколько сотен всевозможных ошибок!

 В JavaScript обработка ошибок работает через механизм исключений. Одни функции их возбуждают, другие обрабатывают через try..catch. Так было в синхронном коде. В асинхронном стандартный механизм уже не работает.

 Подумайте над тем как отработает код ниже:
 */

import fs from 'fs';

try {
    // Пытаемся читать директорию, а это ошибка
    fs.readFile('./file', 'utf-8', () => {
        callUndefinedFunction();
    });
} catch (e) {
    console.log('error!')
}

/**
 Так как try/catch работает только с кодом из текущего стека вызовов, то он не сможет перехватить то что вызвалось в другом стеке. Поэтому мы не увидим сообщения error!, хотя сама ошибка на экране появится:
 */

callUndefinedFunction();
^

ReferenceError: callUndefinedFunction is not defined
at ReadFileContext.fs.readFile [as callback] (/private/var/tmp/index.js:6:5)

/**
 Из вывода видно, что колбек вызвался в своем стеке вызовов, начавшимся внутри функции readFile. Фактически это означает, что использовать try/catch в асинхронном коде с колбеками — бесполезно, эта конструкция здесь просто неприменима.

 Подумайте над тем, что выведет на экран этот код:
 */

import fs from 'fs';

try {
    // Пытаемся читать директорию, а это ошибка
    fs.readFile('./directory', 'utf-8', () => {
        console.log('finished!');
    });
} catch (e) {
    console.log('error!');
}

/**
 Правильный ответ: finished!. Это кажется странным, учитывая что ошибка возникла внутри функции readFile, а не в колбеке. Это происходит потому, что содержимое функции readFile не принадлежит текущему стеку вызовов.

 Асинхронные функции всегда имеют дело с внешней средой (операционной системой). Это значит, что любая асинхронная функция, потенциально может завершиться с ошибкой. Причем не важно возвращает ли она какие-то данные или нет, ошибка может возникнуть всегда. Именно по этой причине колбеки всех асинхронных функций первым параметром принимают ошибку err и, соответственно, проверять её наличие придётся руками. Если пришёл null, то ошибки нет, если не null — есть. Это очень важное соглашение, которого придерживаются не только разработчики стандартной библиотеки, но и все разработчики сторонних решений.
 */

fs.readFile('./directory', 'utf-8', (err, data) => {
    // Любые ошибки чтения файла: доступ, отсутствие файла, директория вместо файла
    // null неявно приводится к false, поэтому достаточно такой проверки,
    // любой другой ответ трактуется как true
    if (err) {
        console.log('error!');
        return; // guard expression
    }

    console.log('finished!')
});

// В цепочке вызовов придётся делать проверку на каждом уровне:

import fs from 'fs';

fs.readFile('./first', 'utf-8', (error1, data1) => {
    if (error1) {
        console.log('error in first file')
        return;
    }
    fs.readFile('./second', 'utf-8', (error2, data2) => {
        if (error2) {
            console.log('error in second file')
            return;
        }
        fs.writeFile('./new-file', `${data1}${data2}`, (error3, data3) => {
            if (error3) {
                console.log('error during writing')
                return;
            }
            console.log('finished!');
        });
    });
});

/**
 Тот же самый код, помещённый внутрь функции, выглядит немного по-другому. Как только происходит ошибка, мы вызываем основной колбек и отдаём туда ошибку. Если ошибка не возникла, то мы всё равно вызываем исходный колбек и передаём туда null. Вызывать его обязательно, иначе внешний код не дождётся окончания операции. Следующие вызовы больше не выполняются:
 */

import fs from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
    fs.readFile(inputPath1, 'utf-8', (error1, data1) => {
        if (error1) {
            cb(error1);
            return;
        }
        fs.readFile(inputPath2, 'utf-8', (error2, data2) => {
            if (error2) {
                cb(error2);
                return;
            }
            fs.writeFile(outputPath, `${data1}${data2}`, (error3) => {
                if (error3) {
                    cb(error3);
                    return;
                }
                cb(null); // не забываем последний успешный вызов
            });
        });
    });
}

// Последний вызов можно сократить. Если в самом конце не было ошибки, то вызов cb(error3) отработает так же, как и cb(null), а значит, весь код последнего колбека можно свести к вызову cb(error3):

fs.writeFile(outputPath, `${data1}${data2}`, cb);
// что равносильно fs.writeFile(outputPath, `${data1}${data2}`, error3 => cb(error3));

/**
 Почему отлаживать асинхронный код сложнее чем синхронный?
 > В бектрейсе показывается только текущий стек вызовов. Поэтому сложно сказать какой путь проделала программа, перед тем как попала в текущий стек.
 > Труднее воспроизводить ошибочные ситуации из-за отсутствия гарантия порядка выполнения
 */


/***@@@
 file.js
 Реализуйте и экспортируйте функцию move, которая асинхронно копирует файл из одного места в другое. Ее параметры:

 Путь до файла исходника
 Путь по которому нужно копировать файл
 Колбек, у которого единственный аргумент — ошибка.
 Алгоритм работы функции следующий:

 Читаем исходный файл
 Создаём новый файл и записываем туда данные исходного файла (это важно сделать до попытки удаления исходного файла!)
 Удаляем исходный файл
 Реальная функция move устроена не так. Если исходник и приемник находятся на одном устройстве, то копирования не происходит, меняются лишь указатели в фс
 */

import { move } from './file';

move('/opt/myfile', '/tmp/newfile', (error) => {
    if (error) {
        console.log('oops');
        return;
    }
    console.log('yes!')
});

/**
 Другие примеры смотрите в тестах

 Подсказки
 fs.unlink - удаление файла
 fs.readFile - чтение файла
 fs.writeFile - запись в файл
 */

//
import fs from 'fs';

export const move = (from, to, cb) => {
    fs.readFile(from, 'utf-8', (error1, data) => {
        if (error1) {
            cb(error1);
            return;
        }
        fs.writeFile(to, data, (error2) => {
            if (error2) {
                cb(error2);
                return;
            }
            fs.unlink(from, cb);
        });
    });
};




// >>>>>> Параллельное выполнение операций <<<<<<

/**
 Ситуация с асинхронным кодом становится резко сложнее, если мы попытаемся выполнить несколько вызовов одновременно и затем воспользоваться их результатом. Попробуем переписать нашу задачу по объединению файлов. Напомню её текст:

 Предположим, что перед нами стоит задача прочитать содержимое двух файлов и записать в третий (объединение файлов).

 Из постановки видно, что оба исходных файла можно прочитать одновременно и затем, когда они оба будут прочитаны, записать новый файл.
 */

fs.readFile('./first', 'utf-8', (error1, data1) => {
    // ?
});

fs.readFile('./second', 'utf-8', (error2, data2) => {
    // ?
});

/**
 Так как наш код асинхронный, результат работы каждой функции можно получить лишь внутри колбеков. Причём, порядок запуска колбеков мы не можем знать — всё зависит от того, какой файл прочитается быстрее. Для отслеживания состояния выполнения этих операций придётся ввести глобальное состояние (относительно этих операций), через которое мы будем отслеживать завершённость и в котором сохраним данные. И только, когда все операции завершились — запишем новый файл. Кроме того, нам нужно чётко разделять данные первого и второго файлов, так как запись в новый файл (в отличие от чтения) должна происходить в определённом порядке.
 */

const state = {
    count: 0,
    results: [];
}

fs.readFile('./first', 'utf-8', (error1, data1) => {
    state.count += 1;
    state.results[0] = data1;
});

fs.readFile('./second', 'utf-8', (error2, data2) => {
    state.count += 1;
    state.results[1] = data2;
});

// Когда обе операции завершатся, состояние заполнится данными, а значение count станет 2. Именно на это условие мы и завяжем наш код:

import fs from 'fs';

const state = {
    count: 0,
    results: [],
}

const tryWriteNewFile = (error) => {
    if (error) {
        return; // guard expression
    }
    if (state.count !== 2) {
        return; // guard expression
    }

    fs.writeFile('./new-file', state.results.join(''), (error) => {
        if (error) {
            return;
        }
        console.log('finished!');
    });
}

console.log('first reading was started');
fs.readFile('./first', 'utf-8', (error1, data1) => {
    console.log('first callback');
    state.count += 1;
    state.results[0] = data1;
    tryWriteNewFile(error1);
});

console.log('second reading was started');
fs.readFile('./second', 'utf-8', (error2, data2) => {
    console.log('second callback');
    state.count += 1;
    state.results[1] = data2;
    tryWriteNewFile(error2);
});

// Один запуск
// $ node index.js
// first reading was started
// second reading was started
// second callback
// first callback
// finished!

// Другой запуск
// $ node index.js
// first reading was started
// second reading was started
// first callback
// second callback
// finished!

/**
 Теперь файлы читаются параллельно и мы, наконец-то, увидели на практике преимущество одновременного выполнения асинхронных операций. Скорость выполнения этой программы значительно выше синхронного варианта! Причём, чем больше размер файлов, тем больше разница. Однако, стоит заметить, что, хотя загрузка файлов происходит параллельно, работа самого js, обрабатывающего результат — строго последовательна. Колбеки начинают запускаться только после того, как опустеет текущий стек вызовов, и в том порядке, в котором завершились асинхронные операции (параллельный запуск не означает, что операции заканчиваются и начинаются одновременно).

 Каждый раз писать подобный код очень утомительно, поэтому лучше воспользоваться библиотекой под названием async http://caolan.github.io/async/, которая предоставляет набор готовых абстракций для работы в асинхронном стиле. Она содержит десятки функций для большого числа задач, связанных с упорядочиванием асинхронных операций. Ниже пример решения нашей задачи с использованием этой библиотеки:
 */

import { map } from 'async';
import fs from 'fs';

map(['./first', './second'], fs.readFile, (err1, results) => {
    if (err1) {
        return;
    }

    fs.writeFile('./new-file', results.join(''), (err2) => {
        if (err2) {
            return;
        }
        console.log('finished!');
    });
});

/**
 Согласитесь, что это значительно лучше ;) Но, как увидите позже, можно пойти ещё дальше.

 Дополнительные материалы
 async — библиотека для работы в асинхронном стиле http://caolan.github.io/async/
 */

/***@@@
 info.js
 Реализуйте и экспортируйте асинхронную функцию getDirectorySize, которая считает размер переданной директории (не включая поддиректории). Анализ размера файла должен происходить паралелльно, для этого воспользуйтесь библиотекой async
 */

import { getDirectorySize } from './info';

getDirectorySize('/usr/local/bin', (err, size) => {
    console.log(size);
});

/**
 Подсказка
 fs.readdir - чтение содержимого директории
 path.join - конструирует пути
 async.map
 fs.stat - информация о файле
 _.sumBy - нахождение суммы в массиве
 */

// FILE: /app/info.js:
import path from 'path';
import fs from 'fs';
import _ from 'lodash';
import async from 'async';

export const getDirectorySize = (dirpath, cb) => {
    fs.readdir(dirpath, (error1, filenames) => {
        if (error1) {
            cb(error1);
            return;
        }
        const filepaths = filenames.map(name => path.join(dirpath, name));
        async.map(filepaths, fs.stat, (error2, stats) => {
            const sum = _.sumBy(stats.filter(stat => stat.isFile()), 'size');
            cb(error2, sum);
        });
    });
};



// >>>>>> Таймеры <<<<<<

/**
 Отдельное место в асинхронном мире занимают таймеры. Они позволяют отложить выполнение какой-либо функции "на потом". Наиболее важная функция для работы с таймерами — setTimeout(f, delay)
 */
const f = () => console.log('hey!');
setTimeout(f, 1000);
/**
 В коде выше функция f выполнится не раньше, чем через секунду. Об этом нам говорит второй параметр, в который передаётся время, указанное в миллисекундах, после которого запустится функция, указанная первым параметром. По историческим причинам у таймеров есть минимальная задержка, которую они соблюдают всегда, и она равна четырём миллисекундам. Другими словами, нет разницы между вызовами setTimeout(f, 1), setTimeout(f, 3) и setTimeout(f, 4) — во всех этих случаях минимальная задержка равна 4.

 Для чего нужны таймеры? У них много разных применений. Если говорить про браузер, то это могут быть автоматически скрываемые элементы: например, нотификации. Другой пример — это регулярный (например, раз в 5 секунд) Ajax-запрос для получения новых данных. На сервере таймеры используются реже, но тоже встречаются: с помощью них можно разбить объёмную синхронную операцию на несколько кусков, давая возможность выполниться другому коду.

 В операционных системах такое поведение называется кооперативной многозадачностью. Она позволяет создавать ощущение параллельного выполнения кода, даже если этого не приосходит.

 Функция, переданная в таймер, выполняется не в текущем стеке вызовов, а значит к таймерам применимы все те особенности и подходы, о которых мы говорили ранее. Ошибки, возникающие в таймерах, невозможно отследить с помощью try/catch, для этого нужно использовать колбеки.
 */

const f = () => console.log('hey!');
console.log('before timeout');
setTimeout(f, 1000);
console.log('after timeout');

// скрипт не заканчивается, а дожидается выполнения таймеров

// Запуск:
$ node index.js

before timeout
after timeout
hey!

/**
 Попробуйте ответить на такой вопрос. Могут ли таймеры гарантировать точный запуск через указанный промежуток времени? На самом деле не могут. Все зависит от того, что выполняется прямо сейчас. Проверкой таймеров занимается рантайм в тот момент, когда в текущем стеке вызовов не осталось кода. Если запустить тяжелое вычисление, которое не прекращается долго, то все колбеки, все таймеры, будут ждать пока вычисление закончится. Фактически это означает, что в таймерах задается минимальное время, после которого их можно запускать.

 Эта особенность имеет два важных следствия:

 * Старайтесь мминимизировать время выполнения долгих вычислений. Например их можно разбивать на шаги.
 * Не рассчитывайте на точность времени вызова. Оно всегда будет отличаться в большую сторону.
 Таймеры можно не только создавать, но и отменять. Вызов setTimeout возвращает специальное значение — идентификатор таймера. Если передать его в функцию clearTimeout, то таймер отменится:
 */

const f = () => console.log('hey!');
console.log('before timeout');
// В браузере идентификатор таймера это числовое значение
// В node.js это объект
const timerId = setTimeout(f, 1000);
console.log('after timeout');
clearTimeout(timerId);

// Запуск:
$ node index.js

before timeout
after timeout

// Частая ошибка новичков в том, что они передают в таймер не саму функцию, а делают её вызов. Обычно она встречается тогда, когда в функцию нужно передать некоторые заранее определённые аргументы:

const f = message => console.log(message);
console.log('before timeout');
setTimeout(f('hey!'), 1000);
console.log('after timeout');


$ node index.js

before timeout
hey!
    timers.js:390
throw new ERR_INVALID_CALLBACK();
^

TypeError [ERR_INVALID_CALLBACK]: Callback must be a function

/**
 До последнего лога дело не дошло, потому что скрипт упал на вызове setTimeout, так как он ожидал на вход функцию, а пришла не функция (вызов в примере вернул значение undefined).


 Запомнить данные внутри функции можно тремя способами:

 # Дополнительные параметры в setTimeout:
 Все аргументы, переданные в setTimeout после второго аргумента (времени), автоматически становятся аргументами функции, которую вызовет таймер.
 */
const f = (a, b) => console.log(a + b);
setTimeout(f, 1000, 5, 8);
// =>  13

/**
 # Функция-обёртка

 Наиболее распространённый способ — создание функции-обёртки. Такой способ лучше предыдущего из-за его прозрачности: сразу видно, что происходит.
 */
const f = (a, b) => console.log(a + b);
setTimeout(() => f(5, 8), 1000);
// =>  13

/**
 # bind

 Последний способ — использовать функцию bind. Основное предназначение этой функции — смена контекста функции. Но как побочный эффект она может использоваться для частичного применения:
 */

const f = (a, b) => console.log(a + b);
// Первый параметр null потому что контекст не меняется
setTimeout(f.bind(null, 5, 8), 1000);
// =>  13

/**
 Вызов этой функции возвращает новую функцию с применёнными аргументами.

 Важно понимать, что таймер не делает операцию (та, что выполняется при вызове функции, переданной в setTimeout) асинхронной — таймер лишь откладывает время её выполнения. Если сама операция синхронная, то после запуска она заблокирует основной поток выполнения программы, и все остальные будут ждать её завершения.

 # setInterval:

 Функция setInterval имеет точно такую же сигнатуру, как и setTimeout. Смысл аргументов — тот же самый. Разница в том, что setInterval автоматически запускает функцию не один раз, а до тех пор, пока её явно не остановят через clearInterval. Время между запусками равно переданному второму параметру.
 */

const id = setInterval(() => console.log(new Date()), 5000);
setTimeout(() => clearInterval(id), 16000);

// $ node index.js
// 2019-06-05T19:05:28.149Z
// 2019-06-05T19:05:33.172Z
// 2019-06-05T19:05:38.177Z

// Таймер можно остановить изнутри, передав в колбек его id.
let counter = 0;
const id = setInterval(() => {
    counter += 1;

    if (counter == 4) {
        return;
    }

    console.log(new Date());
}, 5000);


/**
 Дополнительные материалы
 setTimeout https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout
 setInterval https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval
 */

/***@@@
 watcher.js
 Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая следит за изменением файла. Если файл был изменён со времени предыдущей проверки, то необходимо вызвать колбек. Параметры функции:

 * Путь до файла, который нужно отслеживать
 * Период отслеживания
 * Колбек, который принимает на вход только ошибку
 */
import watch from './watcher';

const id = watch(filepath, 500, (err) => {
    console.log('Wow!');
});

setTimeout(() => fs.appendFileSync(filepath, 'ehu'), 700);

/**@@@
 Реализуйте эту логику используя функцию setInterval. Функция должна возвращать наружу идентификатор таймера. Если во время анализа файла (через fs.stat) произошла ошибка, то нужно остановить таймер и вызвать колбек, передав туда ошибку.

 Подсказки
 stats.mtimeMs — время последнего изменения
 Date.now() — текущая дата
 */

// FILE: /app/watcher.js:
import fs from 'fs';

const check = (timerId, filepath, period, cb) => {
    fs.stat(filepath, (err, stat) => {
        if (err) {
            clearInterval(timerId);
            cb(err);

            return;
        }

        if ((Date.now() - stat.mtimeMs) < period) {
            cb(null);
        }
    });
};

export default (filepath, period, cb) => {
    const timerId = setInterval(() => check(timerId, filepath, period, cb), period);

    return timerId;
};




// >>>>>> Event Loop <<<<<

/**
 Для лучшего понимания асинхронности неплохо разобраться с тем, как устроен рантайм (браузер или Node.js) JavaScript. JavaScript изначально появился в браузерах, и к нему предъявлялись особые требования, из-за которых он кардинально отличается от остальных языков программирования. Браузер работает по так называемой событийной модели. Он загружает страницу и ждёт действий от пользователя: клики, набор текста или движение мышкой. А код, загруженный на страницу, реагирует на эти события.

 Такая организация взаимодействия невозможна в синхронном коде, у которого есть понятия "запуск" и "завершение" работы. Код в браузере не может завершиться совсем, он проходит стадию инициализации, а затем ждёт событий для реакции на них. Технически это выглядит, как колбек, который соединён с определённым типом события. Когда событие срабатывает, то колбек вызывается.

 Организация асинхронного взаимодействия требует наличия событийного цикла (Event Loop). Он может быть реализован как на уровне языка в виде библиотеки, так и на уровне рантайма, как в случае с JavaScript. Упрощённо цикл событий можно представить себе так:
 */
// Ждем событие
while (queue.waitForMessage()) {
    // Обрабатываем
    queue.processNextMessage();
}
// Возвращаемся к первому шагу


/**
 Как только появляется новое событие, оно начинает обрабатываться (тем самым обработчиком, который мы повесили на это событие). Время обработки события может быть довольно большим, но это не значит, что в этот момент браузер зависает и не даёт пользователю работать. Нет, напротив, благодаря тому, что код асинхронный, события могут (и будут) накапливаться в очереди (queue). Именно поэтому в коде выше сообщение проверяется в переменной с именем queue.

 Событийный цикл всегда работает в однопоточном режиме (понимание этой темы кроется в операционных системах). Это значит, что события обрабатываются строго последовательно. Причём, запуск одного события может приводить к выполнению довольно тяжёлого кода, который работает достаточно долго. Такое периодически встречается, когда страницы сайта вдруг начинают подвисать. Проверьте себя, как вы поняли предыдущие темы. В какой момент начнёт обрабатываться следующее событие?

 Правильный ответ: В тот момент, когда текущий стек вызовов опустеет. Пока текущий стек не пуст, все остальные ждут его завершения. Исключение составляют Workers https://developer.mozilla.org/ru/docs/DOM/Using_web_workers, но это отдельная тема.

 # Дополнительные материалы
 Как на самом деле работает асинхронность? https://www.youtube.com/watch?v=8cV4ZvHXQL4
 */


/***@@@
 Это задание напрямую не связано с теорией урока, но позволяет еще больше прокачаться в работе с асинхронным кодом.

 В библиотеке async https://caolan.github.io/async/v3/docs.html#waterfall есть функция waterfall, которая позволяет строить цепочки асинхронных функций без необходимости вкладывать их друг в друга. Подробнее о том как она работает, посмотрите в документации. Попробуйте решить данное упражнение с применением этой функции.

 file.js
 Реализуйте и экспортируйте асинхронную функцию unionFiles, которую мы рассматривали в предыдущих уроках. Вот её обычное решение на колбеках:
 */

import fs from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
    fs.readFile(inputPath1, 'utf-8', (error1, data1) => {
        if (error1) {
            cb(error1);
            return;
        }
        fs.readFile(inputPath2, 'utf-8', (error2, data2) => {
            if (error2) {
                cb(error2);
                return;
            }
            fs.writeFile(outputPath, `${data1}${data2}`, (error3) => {
                if (error3) {
                    cb(error3);
                    return;
                }
                cb(null); // не забываем последний успешный вызов
            });
        });
    });
}

// Попробуйте написать её, используя указанную выше функцию waterfall.


// FILE: /app/file.js:
import fs from 'fs';
import { waterfall } from 'async';

export const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
    waterfall([
        callback => fs.readFile(inputPath1, callback),
        (data1, callback) => fs.readFile(inputPath2, (err, data2) => callback(err, data1, data2)),
        (data1, data2, callback) => fs.writeFile(outputPath, `${data1}${data2}`, callback),
    ], cb);
};


// FILE: /app/__tests__/test.js:
import path from 'path';
import os from 'os';
import fs from 'fs';
import { unionFiles } from '../file';

let output;
let filepath1;
let filepath2;

beforeAll(() => {
    const tmpDir = fs.mkdtempSync(`${os.tmpdir()}/`);
    output = path.join(tmpDir, 'output');
    filepath1 = path.join(tmpDir, 'source1');
    fs.writeFileSync(filepath1, 'data1');
    filepath2 = path.join(tmpDir, 'source12');
    fs.writeFileSync(filepath2, 'data2');
});

test('unionFiles 1', (done) => {
    unionFiles('/undefined', filepath2, output, (err) => {
        expect(err).not.toBeNull();
        done();
    });
});

test('unionFiles 2', (done) => {
    unionFiles(filepath1, '/undefined', output, (err) => {
        expect(err).not.toBeNull();
        done();
    });
});

test('unionFiles 3', (done) => {
    unionFiles(filepath1, filepath2, '/a/b/c/', (err) => {
        expect(err).not.toBeNull();
        done();
    });
});

test('unionFiles 4', (done) => {
    unionFiles(filepath1, filepath2, output, (err) => {
        expect(err).toBeNull();

        fs.readFile(output, 'utf-8', (err2, data2) => {
            expect(err2).toBeNull();
            expect(data2).toBe('data1data2');
            done();
        });
    });
});




// >>>>>> Промисы (Promise) <<<<<<

/**
 Писать асинхронный код — не самое приятное удовольствие в жизни, и вообще непонятно, как можно создавать достаточно большие асинхронные программы на колбеках. Оказывается, их можно создавать вполне успешно, если использовать не колбеки, а другие механизмы, позволяющие писать асинхронный код без "лесенки". К таким механизмам относятся промисы (Promise). Промисы входят в стандарт EcmaScript и реализованы практически во всех рантаймах. Node.js постепенно интегрирует их во все свои модули: например, в модуле fs промисы доступны как свойство promises. У промисов довольно много особенностей, и к ним нужно привыкнуть. Промисы это удобная абстракция для написания асинхронного кода.
 */

import { promises as fs } from 'fs';

export const copy = (src, dest) => {
    return fs.readFile(src, 'utf-8')
        .then(content => fs.writeFile(dest, content));
};

// Тот же код но короче
// const copy = (src, dest) =>
//   fs.readFile(src, 'utf-8').then(content => fs.writeFile(dest, content));

/**
 Первое, на что стоит обратить внимание, промисы не добавляют нового синтаксиса, вся работа с ними сводится к вызову функций. Технически промис — это объект, который возвращается из функции, выполняющей асинхронную операцию:
 */

const promise = fs.readFile(src, 'utf-8');

// Очень важно понимать, что промис — это не результат асинхронной операции. Это объект, который отслеживает выполнение операции. Операция по-прежнему асинхронна и выполнится когда-нибудь потом.

const promise = fs.readFile(src, 'utf-8');
console.log(promise);
// Promise { <pending> }

/**
 Теперь самое интересное: как получить результат выполнения асинхронной операции? Снаружи — никак, это просто невозможно. Но промис можно "продолжить", используя метод then, в который нужно передать функцию обработчик — такой же колбек, который мы использовали ранее. Отличие этого колбека в том, что он принимает на вход только данные, а не ошибки. Обработка ошибок в промисах рассматривается в следующем уроке.
 */

fs.readFile(src, 'utf-8').then(content => console.log(content));
// Или проще, ведь функции — уже функции, их не надо оборачивать в функции
// fs.readFile(src, 'utf-8').then(console.log);

/**
 В свою очередь then тоже возвращает промис. Причём ему неважно, какая операция выполнялась внутри колбека — асинхронная или нет. То, что вернётся из этого колбека, пойдёт значением в следующий then. Эта идея крайне важна, поэтому я её особо подчеркну. То, что возвращается из колбека в then, не является результатом возврата самой функции then. Эта функция всегда возвращает промис, внутри которого оказывается результат из колбека.
 */

const promise = fs.readFile(src, 'utf-8') // результат цепочки ВСЕГДА промис
    .then(() => 'go to the next then') // игнорируем результат операции
    .then(console.log); // в этот колбек, роль которого играет лог, передается значение с предыдущего then
// => go to the next then

/**
 Вопрос на самопроверку. Что выведется на экран, если добавить к промису выше then(console.log)?

 Если в коде начали применяться промисы, то весь асинхронный код должен строиться с их использованием. Иногда бывает такое, что нужная библиотека умеет работать только с колбеками, и тогда её оборачивают в промис. То, как это сделать, мы рассмотрим позже, когда научимся использовать промисы.

 В нашем первом примере демонстрировался код, в котором из then возвращается промис.
 */

fs.readFile(src, 'utf-8').then(content => fs.writeFile(dest, content));

// В этом случае промис ведёт себя немного отлично от возврата обычного значения. Дальнейшая цепочка начинает строиться от того промиса, который вернулся из колбека.

fs.readFile(src, 'utf-8')
    .then(content => fs.writeFile(dest, content));
// Следующий then берется от writeFile. То есть этот код равносилен fs.writeFile(dest, content).then(...)
.then(() => console.log('writing has been finished!'));

/**
 Благодаря такому поведению можно строить цепочки вызовов, в которых каждая следующая операция ждёт окончания предыдущей. С другой стороны, любая функция, которая использует внутри себя промис, автоматически становится промисом и обязана вернуть промис наружу. Именно поэтому в нашей функции copy есть возврат. Только в этом случае вызывающий код сможет встроить эту функцию и контролировать ход выполнения асинхронной операции.
 */

export const copy = (src, dest) => {
    return fs.readFile(src, 'utf-8')
        .then(content => fs.writeFile(dest, content));
};

/**
 Если бы возврата не было, то было бы непонятно, как получить результат копирования или хотя бы дождаться его завершения.

 Дополнительные материалы
 promisejs.org https://www.promisejs.org/
 */


/***@@@
 file.js
 Реализуйте и экспортируйте асинхронную функцию reverse, которая меняет строчки в файле в обратом порядке
 */

import { reverse } from './file';

// До
// one
// two
reverse(filepath);

// После
// two
// one

// FILE: /app/__tests__/test.js:
import { promises as fs, readFileSync } from 'fs';
import { reverse } from '../file';

const reverseLines = data => data.split('\n').reverse().join('\n');

test('reverse 1', () => {
    const content = 'one\ntwo';
    const filepath = '/tmp/example';
    const promise = fs.writeFile(filepath, content)
        .then(() => reverse(filepath))
        .then(() => readFileSync(filepath, 'utf-8'));
    return expect(promise).resolves.toBe(reverseLines(content));
});

// FILE: /app/file.js:
import { promises as fs } from 'fs';

export const reverse = filepath => fs.readFile(filepath, 'utf-8')
    .then(data => fs.writeFile(filepath, data.split('\n').reverse().join('\n')));




// >>>>>> Обработка ошибок в промисах <<<<<<

/**
 Ошибки внутри промисов обрабатываются крайне просто. Для перехвата достаточно вызвать метод catch и передать туда колбек, принимающий на вход саму ошибку:
 */

import { promises as fs } from 'fs';

const promise = fs.readFile('unkownfile');
promise.catch(e => console.log('error!!!', e));
// => error!!! { [Error: ENOENT: no such file or directory, open 'unkownfile']
// errno: -2, code: 'ENOENT', syscall: 'open', path: 'unkownfile' }

// catch, в свою очередь, возвращает promise, что позволяет коду восстанавливать работу после ошибок и продолжать цепочку. Вполне нормально писать код в стиле цепочки, в которой чередуются then и catch:


import { promises as fs } from 'fs';

const promise = fs.readFile('unkownfile')
    .catch(console.log)
    .then( () => fs.readFile('anotherUnknownFile'))
    .catch(console.log);

/**
 В большинстве ситуаций не имеет значения, на какой из операций упало. Любое падение должно прерывать текущее выполнение и уходить в блок обработки ошибки. Именно так работает код с try/catch, и такое же поведение эмулируется промисами. Дело в том, что, если возникла ошибка, то она передаётся по цепочке первому встреченному catch, а все встреченные на пути then игнорируются. Поэтому код выше можно упростить так:
 */

import { promises as fs } from 'fs';

const promise = fs.readFile('unkownfile')
    .then(() => fs.readFile('anotherUnknownFile'))
    .catch(console.log);

/**
 Семантически эти версии кода не эквивалентны. В первом случае вторая опера��ия чтения начнёт выполняться обязательно, независимо от того, как закончилась предыдущая. В последнем — если упадёт первое чтение файла, то второе не будет выполнено.

 Иногда ошибку нужно генерировать самостоятельно. Самый простой способ сделать это — бросить исключение. К этому тоже надо привыкнуть. try/catch использовать нельзя (потому что бесполезно), а вот бросать исключения можно. Промис сам их преобразует, как надо, и отправит по цепочке в поиске вызова catch:
 */

import { promises as fs } from 'fs';

const promise = fs.readFile('unkownfile')
    .then((data) => {
        // делаем что нибудь
        throw new Error('boom!');
    })
    .then(() => {
        // Этот then не будет вызван, из—за исключения на предыдущем шаге
    })
    .catch(console.log);

// Другой способ вернуть результат вызова функции — Promise.reject, внутрь которой передаётся сама ошибка:

import { promises as fs } from 'fs';

const promise = fs.readFile('unkownfile')
    .then((data) => {
        // делаем что нибудь
        return Promise.reject(new Error('boom!'));
    })
    .catch(console.log);

// Помимо чисто технических моментов в обработке ошибок есть и архитектурно-организационные. Если вам приходится реализовывать асинхронные функции, которыми будут пользоваться другие люди, то никогда не подавляйте ошибок:

import { promises as fs } from 'fs';

const readFileEasily = (filepath) => fs.readFile(filepath).catch(console.log);

// Перехватив ошибку, вы не оставляете шансов узнать о ней вызывающему коду. Тот, кто использует эту функцию, не сможет отреагировать на ошибочную ситуацию. Если обработка ошибки всё же нужна — обрабатывайте, но не забывайте генерировать её снова:

import { promises as fs } from 'fs';

const readFileEasily = (filepath) => fs.readFile(filepath)
    .catch((e) => {
        console.log(e); // В библиотеках так делать нельзя, только в своем коде
        throw e;
    });

// Теперь вызывающий код может обработать ошибку:
readFileEasily('path/to/file').catch(/** ... */);


/**
 Что происходит после того как отработал catch?
 > Промис продолжает выполнять то что было добавлено в then уже после catch
 */

/***@@@
 file.js
 Реализуйте и экспортируйте асинхронную функцию touch, которая создает файл если его не существует.
 */

import { touch } from './file';

touch('/myfile').then(() => console.log('created!'));

/**
 Подсказка
 fs.access - проверка сущестования файла
 */

// FILE: /app/tests.js:
import { promises as fs } from 'fs';

export const touch = filepath => fs.access(filepath)
    .catch(() => fs.writeFile(filepath));


// FILE: /app/__tests__/test.js:
import os from 'os';
import { promises as fs } from 'fs';
import _ from 'lodash';
import { touch } from '../file';

test('touch 1', () => {
    const filepath = `${os.tmpdir()}/example`;
    const promise = fs.unlink(filepath)
        .catch(_.noop)
        .then(() => touch(filepath))
        .then(() => fs.access(filepath, 'utf-8'));
    return expect(promise).resolves.toBe();
});

test('touch 2', () => {
    const filepath = `${os.tmpdir()}/example`;
    const promise = fs.unlink(filepath)
        .catch(_.noop)
        .then(() => fs.writeFile(filepath, 'content'))
        .then(() => touch(filepath))
        .then(() => fs.readFile(filepath, 'utf-8'));
    return expect(promise).resolves.toBe('content');
});




// >>>>>> Цепочка промисов <<<<<<

/**
 Даже при использовании промисов не всегда понятно, как структурировать асинхронный код. В этом уроке мы разберём некоторые полезные практики, делающие его проще для написания и анализа. Возьмём уже знакомую нам задачку по объединению двух файлов.
 */

import fs from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
    fs.readFile(inputPath1, 'utf-8', (error1, data1) => {
        if (error1) {
            cb(error1);
            return;
        }

        fs.readFile(inputPath2, 'utf-8', (error2, data2) => {
            if (error2) {
                cb(error2);
                return;
            }

            fs.writeFile(outputPath, `${data1}${data2}`, cb);
        });
    });
}


// Запомните этот код — таким вы больше никогда его не увидите ;) Сейчас мы проведём серию рефакторингов и получим в результате код, который является каноническим при работе с промисами. Итак, первая версия:

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    // Промисы всегда должны возвращаться и строиться в цепочку!
    return fs.readFile(inputPath1, 'utf-8')
        .then((data1) => {
            return fs.readFile(inputPath2, 'utf-8')
                .then((data2) => fs.writeFile(outputPath, `${data1}${data2}`));
        });
};

/**
 Хорошая новость — код стал понятнее и уменьшился в объёме. К тому же, из него целиком ушла обработка ошибок, так как промисы обрабатывают их автоматически и, если вызывающий код захочет их перехватывать, то сделает это самостоятельно через метод catch. Но есть и плохая новость — код всё ещё структурирован, как колбеки, "лесенкой". В этом коде не учитывается свойство промисов, связанное с возвратом из then. Напомню, что, если из колбека возвращается промис, то дальнейшая цепочка then/catch продолжается от него.
 */

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    return fs.readFile(inputPath1, 'utf-8')
        .then(data1 => fs.readFile(inputPath2, 'utf-8'))
        // then ниже берется от промиса readFile
        .then(data2 => fs.writeFile(outputPath, `${data1}${data2}`));
};

/**
 Эта версия совсем плоская, именно к такому коду нужно стремиться в промисах. Но она таит в себе одну проблему. Если где-то в цепочке ниже нужны данные, которые были получены сверху, то придется протаскивать их сквозь всю цепочку. В примере выше это результат чтения первого файла. Переменная data1 недоступна в том месте, где происходит запись в файл. Основной выход из данной ситуации — создание переменных, через которые данные будут прокинуты дальше:
 */

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    let data1;

    return fs.readFile(inputPath1, 'utf-8')
        .then(content => {
            data1 = content;
        })
        .then(() => fs.readFile(inputPath2, 'utf-8'))
        .then(data2 => fs.writeFile(outputPath, `${data1}${data2}`));
};

/**
 Уже не так красиво, но всё ещё плоско. Преимущество такого подхода становится всё более и более очевидным с увеличением количества промисов. Тем более, далеко не всегда нужно передавать данные дальше.

 Выберите правильные ответы
 > Нужно стремиться делать цепочки промисов максимально плоскими. Иначе получатся те же колбеки, но через then.
 > Промисы стоит использовать только с асинхронным кодом
 */

/***@@@
 file.js
 Реализуйте и экспортируйте асинхронную функцию getTypes, которая анализирует список переданных путей и возвращает массив (в промисе), с описанием того, что находится по каждому из путей:
 */

import { getTypes } from './file';

getTypes(['/etc', '/etc/hosts', '/undefined']).then(console.log);
// ['directory', 'file', null]

/**
 Эта функция должна отрабатывать успешно в любом случае. Если во время выполнения асинхронной операции возникла ошибка, то значением для этого пути будет null. Для простоты считаем, что в эту функцию всегда передается как минимум один путь для обработки (иначе придется задействовать механизм, который проходится в курсах далее).

 Подсказки
 fs.stat - информация о файле или директории. Для проверки на директорию используйте метод isDirectory.
 Методы then и catch не меняют сам промис, а возвращают новый
 */

// FILE: /app/__tests__/file.js:
import { getTypes } from '../file';

test('getTypes 1', () => {
    const actual = getTypes(['undefined']);
    return expect(actual).resolves.toEqual([null]);
});

test('getTypes 2', () => {
    const actual = getTypes(['/etc']);
    return expect(actual).resolves.toEqual(['directory']);
});

test('getTypes 3', () => {
    const actual = getTypes(['/etc/hosts']);
    return expect(actual).resolves.toEqual(['file']);
});

test('getTypes 4', () => {
    const actual = getTypes(['/etc/hosts', '/undefined', '/etc/bashrc', '/etc']);
    return expect(actual).resolves.toEqual(['file', null, null, 'directory']);
});

test('getTypes 5', () => {
    const actual = getTypes(['/undefined', '/etc/hosts', '/et', '/etc/bashrc']);
    return expect(actual).resolves.toEqual([null, 'file', null, null]);
});


// FILE: /app/file.js:
import { promises as fs } from 'fs';

const getTypeName = stat => (stat.isDirectory() ? 'directory' : 'file');

export const getTypes = (paths) => {
    const [first, ...rest] = paths;
    const result = [];

    let promise = fs.stat(first)
        .then(data => result.push(getTypeName(data)))
        .catch(() => result.push(null));

    rest.forEach((path) => {
        promise = promise.then(() => fs.stat(path))
            .then(data => result.push(getTypeName(data)))
            .catch(() => result.push(null));
    });

    return promise.then(() => result);
};




// >>>>>> Promise.all <<<<<<

/**
 Промисы, как и колбеки, позволяют выполнять асинхронные операции параллельно. Причём умеют делать это в автоматическом режиме, без ручного отслеживания окончания одной из операций. Для этого достаточно собрать массив из промисов и передать их в функцию Promise.all. В результате вернётся обычный промис, на основе которого можно строить дальнейшую цепочку. Данными в первом then будет массив с данными всех выполненных операций.
 */

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    const promise1 = fs.readFile(inputPath1, 'utf-8');
    const promise2 = fs.readFile(inputPath2, 'utf-8');
    // На вход идет МАССИВ из промисов
    const promise = Promise.all([promise1, promise2]);
    // Обязательно делать возврат!
    return promise.then(([data1, data2]) => fs.writeFile(outputPath, `${data1}${data2}`))
};


/**
 Промисы, как и колбеки, позволяют выполнять асинхронные операции параллельно. Причём умеют делать это в автоматическом режиме, без ручного отслеживания окончания одной из операций. Для этого достаточно собрать массив из промисов и передать их в функцию Promise.all. В результате вернётся обычный промис, на основе которого можно строить дальнейшую цепочку. Данными в первом then будет массив с данными всех выполненных операций.
 */

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    const promise1 = fs.readFile(inputPath1, 'utf-8');
    const promise2 = fs.readFile(inputPath2, 'utf-8');
    // На вход идет МАССИВ из промисов
    const promise = Promise.all([promise1, promise2]);
    // Обязательно делать возврат!
    return promise.then(([data1, data2]) => fs.writeFile(outputPath, `${data1}${data2}`))
};

/**
 Получился эффективный код, который ещё и легко понять. К тому же здесь нет дополнительных переменных. Promise.all хоть и возвращает данные в том же порядке, в котором в него были переданы промисы, он не гарантирует последовательность выполнения операций. Не рассчитывайте на это никогда, все операции запускаются одновременно, и какая из них выполнится раньше или позже — неизвестно.

 Функции Promise.all не важно каким образом была получена коллекция промисов. Единственное что ей нужно – получить на вход массив этих промисов. Поэтому Promise.all легко комбинируется с любыми функциями, возвращающими коллекции. В примере ниже дается массив путей до файлов, которые нужно прочитать и вывести на экран их содержимое. Первым делом в коде формируется массив из промисов, затем он передается в Promise.all и, наконец, содержимое файлов выводится на экран:
 */

// promises – массив промисов
const promises = filepaths.map(filepath => fs.readFile(filepath, 'utf-8'));
const promise = Promise.all(promises);

// Выводим на экран содержимое каждого файла
promise.then(contents => contents.map(console.log));

// map проходится по каждому файлу, и отдает его в нашу функцию, которая выполняет вызов fs.readFile. Каждый такой вызов возвращает промис. Если попробовать распечатать этот массив, то он будет выглядеть так:

const promises = filepaths.map(filepath => fs.readFile(filepath, 'utf-8'));
console.log(promises);

/*
[
  Promise { <pending> },
  Promise { <pending> },
  Promise { <pending> },
  Promise { <pending> },
  ...
]
*/

/**
 Ещё одна особенность Promise.all связана с ошибками. Если хотя бы одна операция вернёт ошибку, то весь промис будет отмечен, как выполненный с ошибкой, а значит управление попадёт в ближайший catch. Чтобы этого избежать, можно передавать в Promise.all не просто промисы, а промисы с повешенными на них обработчиками ошибок catch, из которых уже возвращаются данные с пометкой об успешности.
 */

const promises = filepaths.map(filepath => fs.readFile(filepath, 'utf-8')
    .then(v => ({ result: 'success', value: v }))
    .catch(e => ({ result: 'error', error: e })));
const promise = Promise.all(promises);

/**
 # Дополнительные материалы
 Promise.all https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
 */

/***@@@
 file.js
 Реализуйте и экспортируйте асинхронную функцию getDirectorySize, которая считает размер переданной директории (не включая поддиректории).

 import { getDirectorySize } from './file';

 getDirectorySize('/usr/local/bin').then(console.log);
 Подсказка
 fs.readdir - чтение содержимого директории
 path.join - конструирует пути
 fs.stat - информация о файле
 _.sumBy - нахождение суммы в массиве
 */

// FILE: /app/__tests__/file.js:
import { getDirectorySize } from '../file';

test('getDirectorySize 1', () => {
    const promise = getDirectorySize('/undefined');
    return expect(promise).rejects.toThrow();
});

test('getDirectorySize 2', () => {
    const promise = getDirectorySize('/opt');
    return expect(promise).resolves.toBe(0);
});

test('getDirectorySize 3', () => {
    const promise = getDirectorySize('/usr/local/bin');
    return expect(promise).resolves.toBe(1224);
});

// FILE: /app/file.js:
import path from 'path';
import _ from 'lodash';
import { promises as fs } from 'fs';

export const getDirectorySize = (dirpath) => {
    const promise = fs.readdir(dirpath).then((filenames) => {
        const filepaths = filenames.map(name => path.join(dirpath, name));
        const promises = filepaths.map(fs.stat);

        return Promise.all(promises);
    });

    return promise.then(stats => _.sumBy(stats, 'size'));
};




// >>>>>> new Promise <<<<<<

/**
 Если в проекте появились промисы, то, по-хорошему, весь код должен работать только через них. К сожалению, далеко не все библиотеки имеют интерфейс с промисами и работают по-старинке, на колбеках. В таких случаях нужно "обернуть" или, как говорят, "промисифицировать". Создание промиса происходит с помощью конструктора Promise:
 */

import fs from 'fs';

const promise = new Promise((resolve, reject) => {
    fs.readFile('/etc/passwd', (err, data) => {
        if (err) {
            reject(err);
        }
        resolve(data);
    });
});

/**
 Промис ожидает на вход функцию, которая будет вызвана в момент создания. Именно внутри этой функции и нужно выполнять асинхронную операцию (на колбеках), которую мы хотим превратить в промис. Промис прокидывает в эту функцию два колбека:

 - resolve — должна быть вызвана в случае успешного завершения асинхронной операции. Ей на вход отдаётся результат этой операции.
 - reject — должна быть вызвана в случае ошибки. На вход, соответственно, отдаётся ошибка.

 Эти функции принимают на вход ровно один аргумент, который затем передаётся либо в then (как данные), либо в catch (как ошибка). Причём достаточно, чтобы вызывалась хотя бы одна из этих функций. Вполне возможно, что понадобится создать промис, который всегда завершается успешно — и это легко сделать, никогда не вызывая reject.

 В конечном итоге конструкция new Promise() возвращает самый настоящий промис, с которым можно работать уже привычным для нас способом:
 */

promise
    .then(console.log)
    .catch(console.log)

/**
 А что, если нужно обернуть две асинхронных операции, или три, или даже больше? Придётся оборачивать каждую из них независимо. Другими словами, одна асинхронная операция — один конструктор new Promise. Кстати, эту задачу можно автоматизировать, и в ноду встроена специальная функция, которая делает промисы из асинхронных функций:
 */

import util from 'util';
import fs from 'fs';

const stat = util.promisify(fs.stat);
stat('.').then((stats) => {
    // Do something with `stats`
}).catch((error) => {
    // Handle the error.
});

/**
 Во фронтенде такое тоже возможно, достаточно "загуглить" пакет, предоставляющий функцию promisify.

 В реальной жизни, встречаются задачи, когда асинхронного кода нет, но нужен промис чтобы построить цепочку. Такой промис можно создать самостоятельно:
 */

const promise = new Promise(resolve => resolve());
// promise.then ...

// Тоже самое для промиса, который завершается неуспешно:
const promise = new Promise((resolve, reject) => reject());
// promise.catch ...


// Для этих задач добавили специальные сокращения, с которыми код становится чище:
const promise1 = Promise.resolve();
// promise1.then

const promise2 = Promise.reject();
// promise2.catch ...


/**
 С технической точки зрения, промис — это объект, имеющий три состояния (см. конечные автоматы и автоматное программирование): pending, fulfilled и rejected. Промис начинается в состоянии pending, а затем, с помощью функций ("событий", как говорят в теории автоматов) resolve и reject переводится в одно из конечных (терминальных) состояний fulfilled или rejected. Перейдя однажды в эти состояния, промис уже не может откатиться назад или уйти в другое терминальное состояние. То есть после вызова resolve, нет способа привести промис в состояние rejected, вызывая функцию reject.

 # Дополнительные материалы
 util.promisify https://nodejs.org/api/util.html#util_util_promisify_original

 Что возвращает вызов метода Promise.resolve()?
 > Промис, который вызовет then если его добавить

 Что возвращает вызов метода Promise.reject()?
 > Промис, который вызовет catch если его добавить
 */


/***@@@
 timer.js
 Реализуйте таймер в виде промиса.
 Экспортируйте функцию по умолчанию.
 */
import wait from './timer';

wait(100).then(() => console.log('time is over!'));

// FILE:/app/__tests__/test.js:
import wait from '../timer';

test('wait', () => {
    const before = new Date();
    const startTime = before.getTime();
    const duration = 150;

    return wait(duration).then(() => {
        const after = new Date();
        const endTime = after.getTime();
        const difference = endTime - startTime;
        expect(difference).toBeGreaterThanOrEqual(duration);
        expect(difference).toBeLessThan(duration + 30);
    });
});


// FILE: /app/test.js:
export default ms => new Promise(resolve => setTimeout(resolve, ms));




// >>>>>> Async/Await <<<<<<

/**
 Несмотря на все удобства, промисы не являются вершиной эволюции. Вспомним минусы, которые они добавляют:

 Своя собственная обработка ошибок, которая идёт в обход try/catch. Это значит, что в коде будут появляться оба способа обработки, комбинирующихся в причудливых формах.
 Иногда бывает нужно передавать данные вниз по цепочке с самых верхних уровней, и с промисами делать это неудобно. Придётся создавать переменные вне промиса.
 С промисами по-прежнему легко начать создавать вложенность, если специально за этим не следить.

 Все эти сложности убираются механизмом async/await, делающим код с промисами ещё более похожим на синхронный! Вспомним нашу задачу по объединению двух файлов. Вот её код:
 */

import { promises as fs } from 'fs';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
    let data1;

    return fs.readFile(inputPath1, 'utf-8')
        .then(content => {
            data1 = content;
        })
        .then(() => fs.readFile(inputPath2, 'utf-8'))
        .then(data2 => fs.writeFile(outputPath, `${data1}${data2}`));
};

// А теперь посмотрим на этот же код с использованием async/await. Подчеркну, что async/await работает с промисами:

import { promises as fs } from 'fs';

const unionFiles = async (inputPath1, inputPath2, outputPath) => {
    const data1 = await fs.readFile(inputPath1, 'utf-8');
    const data2 = await fs.readFile(inputPath2, 'utf-8');
    await fs.writeFile(outputPath, `${data1}${data2}`);
};


/**
 Эта версия практически не отличается от её синхронной версии. Код настолько простой, что даже не верится, что он асинхронный. Разберём его по порядку.

 Первое, что мы видим, — это ключевое слово async перед определением функции. Оно означает, что данная функция всегда возвращает промис: const promise = unionFiles(...). Причём, теперь не обязательно возвращать результат из этой функции, она всё равно станет промисом.

 Внутри функции используется ключевое слово await, которое ставится перед вызовом функций, которые, в свою очередь, тоже возвращают промисы. Если результат этого вызова присваивается переменной или константе, то в них записывается результат вызова. Если присвоения нет, как в последнем вызове await, то происходит ожидание выполнения операции без использования её результата.

 А что с обработкой ошибок? Теперь достаточно поставить обычные try/catch и ошибки будут отловлены!
 */

import { promises as fs } from 'fs';

const unionFiles = async (inputPath1, inputPath2, outputPath) => {
    try {
        const data1 = await fs.readFile(inputPath1, 'utf-8');
        const data2 = await fs.readFile(inputPath2, 'utf-8');

        await fs.writeFile(outputPath, `${data1}${data2}`);
    } catch (e) {
        console.log(e);
        throw e; // снова бросаем, потому что вызывающий код должен иметь возможность отловить ошибку
    }
};

// Однако, при параллельном выполнении промисов не обойтись без функции Promise.all:
const unionFiles = async (inputPath1, inputPath2, outputPath) => {
    const promise1 = fs.readFile(inputPath1, 'utf-8');
    const promise2 = fs.readFile(inputPath2, 'utf-8');

    // сразу можно разложить данные с помощью дестракчеринга
    const [data1, data2] = await Promise.all([promise1, promise2]);

    await fs.writeFile(outputPath, `${data1}${data2}`);
};


// Подводя итог, механизм async/await делает код максимально плоским и похожим на синхронный. Благодаря нему появляется возможность использовать try/catch и с ним легко манипулировать данными полученными в результате асинхронных операций.

// Код на колбеках
import fs from 'fs';

fs.readFile('./first', 'utf-8', (error1, data1) => {
    if (error1) {
        console.log('boom!');
        return;
    }

    fs.readFile('./second', 'utf-8', (error2, data2) => {
        if (error2) {
            console.log('boom!');
            return;
        }

        fs.writeFile('./new-file', `${data1}${data2}`, (error3) => {
            if (error3) {
                console.log('boom!');
            }
        });
    });
});

// Код на промисах
import { promises as fs } from 'fs';

let data1;
fs.readFile('./first', 'utf-8')
    .then((d1) => {
        data1 = d1;

        return fs.readFile('./second', 'utf-8');
    })
    .then((data2) => fs.writeFile('./new-file', `${data1}${data2}`))
    .catch(() => console.log('boom!'));

// Код на async/await
import { promises as fs } from 'fs';

const data1 = await fs.readFile('./first', 'utf-8');
const data2 = await fs.readFile('./second', 'utf-8');
await fs.writeFile('./new-file', `${data1}${data2}`);


/**
 Дополнительные материалы
 Пример реального кода из проектов Хекслета https://github.com/Hexlet/hexlet-exercise-kit/blob/master/import-documentation/src/index.js
 */

/***@@@
 file.js
 Реализуйте и экспортируйте асинхронную функцию exchange, которая обменивает содержимое двух файлов.
 */
import { exchange } from './file';

exchange('/myfile1', '/myfile2');


// FILE: /app/__tests__/file.js:
import os from 'os';
import { promises as fs } from 'fs';
import { exchange } from '../file';

test('exchange 1', async () => {
    const firstPath = `${os.tmpdir()}/first`;
    const secondPath = `${os.tmpdir()}/second`;
    const firstContent = 'content1';
    const secondContent = 'content2';
    await fs.writeFile(firstPath, firstContent);
    await fs.writeFile(secondPath, secondContent);
    await exchange(firstPath, secondPath);

    const result1 = await fs.readFile(firstPath, 'utf-8');
    expect(result1).toBe(secondContent);
    const result2 = await fs.readFile(secondPath, 'utf-8');
    expect(result2).toBe(firstContent);
});

// FILE: /app/file.js:
import { promises as fs } from 'fs';

export const exchange = async (filepath1, filepath2) => {
    const data1 = await fs.readFile(filepath1);
    const data2 = await fs.readFile(filepath2);

    await fs.writeFile(filepath1, data2);
    await fs.writeFile(filepath2, data1);
};


/***@@@
 promisify.js

 Реализуйте и экспортируйте по умолчанию функцию, которая "промисифицирует" асинхронные функции с колбеками.
 */

import promisify from '../promisify';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

const filepath = '/tmp/myfile';

writeFile(filepath, 'content')
    .then(() => readFile(filepath));
.then(console.log);

/**
 Реализация этой функции опирается на тот факт, что колбек в асинхронных функциях всегда передается последним параметром.

 Подсказка
 Вам понадобятся rest и spread операторы
 */

// FILE: /app/__tests/promisify.js:
import path from 'path';
import fs from 'fs';
import os from 'os';
import promisify from '../promisify';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const access = promisify(fs.access);
const mkdtemp = promisify(fs.mkdtemp);

test('promisify', async () => {
    const directory = await mkdtemp(path.join(os.tmpdir(), 'foo-'));
    const filepath = path.join(directory, 'file');
    await writeFile(filepath, 'content');
    await access(filepath);
    await readFile(filepath);
});


// FILE: /app/promisify.js:
export default asyncFn => (...args) => {
    const promise = new Promise((resolve, reject) => {
        asyncFn(...args, (err, data) => (err ? reject(err) : resolve(data)));
    });

    return promise;
};

/***@@@
 ls.js
 Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход путь и возвращает информацию о файлах и директориях расположенных по этому пути. Данные возвращаются в виде массива объектов, где каждый элемент это информация о конкретном файле: его путь и описание доступов (stat.mode). Объекты в массиве должны быть отсортированы по имени файла.
 */

import ls from '../ls';

await ls('/var');
// [
//   { filepath: '/var/local', mode: 17917 },
//   { filepath: '/var/lock', mode: 17407 },
//   { filepath: '/var/log', mode: 16877 },
// ];

await ls('/etc/passwd');
// [{ filepath: '/etc/passwd', mode: 33188 }];

/**
 Эта функция должна уметь обрабатывать не только директории, но и файлы. В таком случае отдается массив с одним объектом - информацией по текущему файлу.

 Подсказка
 readdir() - чтение директории
 stat() - информация о файле. isFile() - является ли файлом, mode - описание доступа.
 */

// FILE: /app/
import ls from '../ls';

test('ls dir', async () => {
    const expected = [
        { filepath: '/var/backups', mode: 16877 },
        { filepath: '/var/cache', mode: 16877 },
        { filepath: '/var/lib', mode: 16877 },
        { filepath: '/var/local', mode: 17917 },
        { filepath: '/var/lock', mode: 17407 },
        { filepath: '/var/log', mode: 16877 },
        { filepath: '/var/mail', mode: 17917 },
        { filepath: '/var/opt', mode: 16877 },
        { filepath: '/var/run', mode: 16877 },
        { filepath: '/var/spool', mode: 16877 },
        { filepath: '/var/tmp', mode: 17407 },
    ];
    const actual = await ls('/var');
    expect(actual).toEqual(expected);
});

test('ls file', async () => {
    const expected = [
        { filepath: '/etc/passwd', mode: 33188 },
    ];
    const actual = await ls('/etc/passwd');
    expect(actual).toEqual(expected);
});

// FILE: /app/
import _ from 'lodash';
import path from 'path';
import { promises as fs } from 'fs';

export default async (pathForInspect) => {
    const absolutePath = path.resolve(__dirname, pathForInspect);
    const stat = await fs.stat(absolutePath);

    if (stat.isFile()) { // guard expression
        return [{ filepath: absolutePath, mode: stat.mode }];
    }

    const filenames = await fs.readdir(absolutePath);
    const filepaths = filenames.sort().map(n => path.join(absolutePath, n));
    const stats = await Promise.all(filepaths.map(fs.stat));
    return _.zipWith(filepaths, stats, (filepath, { mode }) => ({ filepath, mode }));
};




// ################## JS: Автоматное программирование ##################

/**
 Конечный автомат — удобная модель представления процессов, обладающих несколькими явными состояниями. Этот курс посвящен автоматам и конечным автоматам, а также соответствующим шаблонам проектирования (State, State Machine).

 «Компьютер — это конечный автомат. Потоковое программирование нужно тем, кто не умеет программировать конечные автоматы». Алан Кокс, прим. Википедия

 Как вы уже заметили, одну и ту же программу можно написать множеством различных способов. Если не брать во внимание случаи, когда программа написана просто плохо, то остаются подходы, которые имеют как преимущества, так и недостатки относительно друг друга. Иными словами, вся наша жизнь состоит из компромиссов.

 # Парадигма программирования
 Это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию)

 Подходы к написанию программ принято называть парадигмами. И эти парадигмы резко отличаются от того, чем они являются в науке.

 Своим современным значением в научно-технической области термин «парадигма» обязан, по-видимому, Томасу Куну и его книге «Структура научных революций». Кун называл парадигмами устоявшиеся системы научных взглядов, в рамках которых ведутся исследования. Согласно Куну, в процессе развития научной дисциплины может произойти замена одной парадигмы на другую (как, например, геоцентрическая небесная механика Птолемея сменилась гелиоцентрической системой Коперника), при этом старая парадигма ещё продолжает некоторое время существовать и даже развиваться благодаря тому, что многие её сторонники оказываются по тем или иным причинам неспособны перестроиться для работы в другой парадигме.

 Термин «парадигма программирования» впервые применил в 1978 году Роберт Флойд в своей лекции лауреата премии Тьюринга.

 Флойд отмечает, что в программировании можно наблюдать явление, подобное парадигмам Куна, но, в отличие от них, парадигмы программирования не являются взаимоисключающими:

 Если прогресс искусства программирования в целом требует постоянного изобретения и усовершенствования парадигм, то совершенствование искусства отдельного программиста требует, чтобы он расширял свой репертуар парадигм.

 Таким образом, по мнению Роберта Флойда, в отличие от парадигм в научном мире, описанных Куном, парадигмы программирования могут сочетаться, обогащая инструментарий программиста.

 А по нашему мнению, каждая новая парадигма в арсенале разработчика делает его профессионалом качественно нового уровня.

 Например, владение декларативной парадигмой помогает программисту применять в нужных местах функции высшего порядка, элементы логического программирования, а так же помогает избегать ненужных мутаций состояния. И всё это с лёгкостью можно использовать почти в любом современном императивном языке.

 # Примеры парадигм
 Императивное программирование
 Функциональное программирование
 Логическое программирование
 Программирование, управляемое данными (ООП)
 Событийно-ориентированное программирование
 Автоматное программирование
 Actor-based программирование

 Этот курс посвящён одной из самых важных парадигм программирования. Эта парадигма не требует поддержки со стороны языка и применима в бесчисленном количестве ситуаций для управления системами со сложным поведением. То есть поведением, в котором результат операции зависит не только от входных данных, но и от предыдущего состояния системы.

 # Автоматное программирование

 Этот курс посвящён одной из самых важных парадигм программирования. Эта парадигма не требует поддержки со стороны языка и применима в бесчисленном количестве ситуаций для управления системами со сложным поведением. То есть поведением, в котором результат операции зависит не только от входных данных, но и от предыдущего состояния системы.

 Автоматное программирование
 Парадигма программирования, основанная на применении конечных автоматов для описания поведения программ

 Автоматное программирование имеет под собой серьёзную математическую базу. Сразу предупрежу, что в этом курсе математики не будет. Основная задача курса — дать интуитивное понимание автоматов и научиться их видеть и применять в реальной жизни.

 Те, кто хотят узнать про эту тему чуть глубже и стать немного ближе к чистому Computer Science, я рекомендую почитать про машину Тьюринга.
 */




// >>>>>> Лёгкость и виды сложности <<<<<<

/**
 # Необходимая сложность
 Определяется сложностью решаемой проблемы/предметной области.

 Если перед вами стоит задача реализовать программу, которая выполняет 20 действий, то вы не можете (с точки зрения программирования, а не бизнеса) реализовать меньше и при этом выполнить задачу. Если у вас есть 5 бизнес-правил, касающихся оформления заказа (например, у вас должно быть достаточно денег на счету), то вам нужно будет их все реализовать.

 Очень важно уметь выделять главное и видеть, где у вас та самая, необходимая, сложность.

 # Случайная сложность
 Определяется проблемами, которые создают сами программисты. Например, используют неправильные инструменты для данной задачи.

 Именно этот тип сложности является опасным и ведущим к краху. Неправильные процессы, подходы, библиотеки, языки — всё это, как минимум, вас сильно замедляет, удорожает разработку. И, в конце концов, может стать причиной неудачи проекта.

 От этой сложности нужно избавляться всеми способами. Главное, что я хотел бы донести до вас в этом уроке: понимание того, где у вас случайная сложность, приходит только с обогащением вас как профессионала. Многие разработчики смотрят на это так: я выучу ещё 10 новых библиотек и пару новых языков и стану круче. Да, вы станете чуть лучше, но это будет совсем чуть-чуть. Потому что эти библиотеки и языки будут использовать подходы, к которым вы привыкли, и вам будет легко, а значит роста почти не будет. Единственный способ расти по-настоящему быстро и качественно — это изучать то, что даётся тяжело: языки с новыми парадигмами, другие области программирования, такие как мобильные приложения, фронтэнд вместо бэкэнда и наоборот.

 Автоматное программирование, как раз, относится к одному из таких пунктов. Эта парадигма изменит вас (если вы позволите этому случиться) невероятно сильно и даст возможность лучше определять и искоренять случайную сложность в вашем коде.

 P.S. Основные языки для роста: haskell, clojure, prolog, erlang, kotlin, c.
 */



// >>>>>> Конечный автомат <<<<<<

/**
 По большей части автоматное программирование связано с понятием "конечный автомат". Не вдаваясь в математические дебри, конечный автомат можно определить следующим образом:

 Модель, с помощью которой удобно представлять процесс, имеющий конечное число дискретных управляющих состояний.

 В первую очередь необходимо обратить внимание на то, что finite-state machine появляется только там, где есть процесс. Возьмём пример с Хекслета. Сущность "курс" участвует в процессе публикации на сайте. Сначала курс не виден, но потом мы его публикуем, и он становится доступным на сайте. При этом, у нас есть возможность произвести обратное действие. Этот же курс участвует и в другом процессе, который можно назвать "завершённость". Наши курсы могут появляться на сайте до того, как мы их запишем до конца. В какой-то момент курс наполняется всеми уроками, и мы переводим конечный автомат в положение "завершён". Получается, что одна и та же сущность участвует, как минимум, в двух процессах. И каждый обладает своим собственным конечным автоматом.

 Второе, что мы видим в этом определении: слово "состояние". Состояние — основа любого конечного автомата, и по жизни мы периодически пользуемся этим понятием. Тот смысл, который закладывается в него на интуитивном уровне, идентичен смыслу, который закладывается в него при работе с конечными автоматами. Например, человек бывает сытым или голодным, спящим, болеющим и даже, прости господи, мертвым. А вода бывает жидкой, твёрдой (лёд) и газообразной. Это всё состояния разных процессов.

 В определении уточняется, что состояния должны быть дискретными. Другими словами, мы должны иметь возможность проводить чёткие различия между разными состояниями процесса. Процесс нагрева воды нельзя представить как конечный автомат, если мы не выделим в нём конкретные точки (состояния): например, тёплая вода (50 градусов), горячая вода (80 градусов) и холодная вода (10 градусов).

 И последнее. Что значит "управляющие состояния"? Понятие состояния не является чужеродным для мира программирования. В одной из первых лекций я рассказывал о том, что состояние программы это, грубо говоря, слепок её памяти. Другими словами, значение всех переменных в конкретный момент времени. Это действительно так, но можно пойти ещё дальше и заметить, что состояние можно поделить на два типа. Первый тип — это состояние, отвечающее за все возможные пути движения данных сквозь программу. Второй — это данные сами по себе или так называемое вычислительное состояние.

 Если взять тот же пример с курсом, то мы увидим, что в нём, с одной стороны, присутствует управляющее состояние, отвечающее за видимость курса на сайте, с другой стороны, курс наполнен количественными переменными состояниями, такими как количество уроков, ссылки на видео, тексты и квизы.


 Управляющие состояния
 > Их число не очень велико
 > Каждое из них имеет вполне определённый смысл и качественно отличается от других
 > Они определяют действия, которые совершает сущность

 Вычислительные состояния
 > Их число либо бесконечно, либо конечно, но очень велико
 > Большинство из них не имеет смысла и отличается от остальных лишь количественно
 > Они непосредственно определяют лишь результаты действий

 Что может быть описано конечным автоматом?

 Состояние заказа
 Светофор
 Активация симки
 Запуск практики на Хекслете
 Пользовательские интерфейсы (UI)
 Лично мне кажется, что проще перечислить то, что не описывается конечным автоматом, чем наоборот.


 # Вывод
 Реальный мир полон процессов, которые описываются конечными автоматами. Другими словами, конечные автоматы всегда присутствуют независимо от того, знаем мы про них или нет.

 Акцентирую на этом ваше внимание. В моей практике часто встречается убеждение у уже опытных программистов, что конечные автоматы усложняют жизнь и/или они нужны только для написания компиляторов. Это большое заблуждение, вызванное отсутствием должной базовой подготовки. Если в вашей программе есть сущность со сложным поведением, то по определению самым простым способом описания её процессов является конечный автомат.

 Распознать сущность со сложным поведением в исходном коде программы можно следующим образом: при традиционной реализации таких сущностей используются логические переменные, называемые флагами, и многочисленные запутанные конструкции ветвления, условиями в которых выступают различные комбинации значений флагов. Такой способ описания логики сложного поведения плохо структурирован, труден для понимания и модификации, подвержен ошибкам.

 Одна из центральных идей автоматного программирования состоит в отделении описания логики поведения (при каких условиях необходимо выполнить те или иные действия) от описания его семантики (собственно смысла каждого из действий). Кроме того, описание логики при автоматном подходе жестко структурировано. Эти свойства делают автоматное описание сложного поведения наглядным и ясным.
 */




// >>>>>> Лексический анализ <<<<<<

/**
 Перед тем, как окунуться в высокоприкладное автоматное программирование, попробуем немного использовать его в более классической теме, а именно в лексическом анализе.

 Лексический анализ — процесс распознавания и выделения лексем из входного потока символов.

 Перейдём сразу к примеру. Необходимо во входящем тексте сделать заглавной первую букву каждого слова. Задача тривиально решается путём применения цепочки split/map(capitalize)/join. Но герои всегда идут в обход, поэтому мы попробуем решить эту задачу так, как сделал бы это настоящий лексер. Главное условие состоит в том, что данные в лексер попадают посимвольно. В нашей задаче мы будем это имитировать простым перебором строки.

 Эту задачу я уже использовал в "Основах программирования". И вот, как её решает "обычный программист":
 */

export default (str) => {
    let result = '';
    for (let i = 0; i < str.length; i += 1) {
        const symbol = str[i];
        const shouldBeBig = symbol !== ' ' && (i === 0 || str[i - 1] === ' ');
        result += shouldBeBig ? symbol.toUpperCase() : symbol;
    }

    return result;
};

/**
 А вот, как её решил бы "автоматный программист":

 Сначала определяем значимые состояния управления. Для текущей задачи это будут "внутри слова" и "снаружи слова". Почему именно так? Первое, на что нужно ориентироваться при выделении состояний, это переходы. Именно во время переходов из одного состояния в другое происходят необходимые действия. Перевод буквы в верхний регистр осуществляется во время перехода между состояниями "вне слова" и "в слове".
 */

export default (str) => {
    let result = '';
    let state = 'outside'; // outside, inside

    for (let i = 0; i < str.length; i += 1) {
        const symbol = str[i];

        switch (state) {
            case 'inside':
                if (symbol === ' ') {
                    state = 'outside';
                }

                result += symbol;
                break;
            case 'outside':
                if (symbol !== ' ') {
                    state = 'inside';
                    result += symbol.toUpperCase();
                } else {
                    result += symbol;
                }
                break;
        }
    }

    return result;
};

/**
 Первое, на что можно обратить внимание, это размер. Действительно, ввод нового понятия приводит к увеличению программы. И в данном случае может показаться, что оно того не стоит. Возможно, для такой задачи это правда, но с ростом количества состояний и переходов (рост обычно не линейный, и программа резко скатывается в "невозможно разобраться") подход без автоматов сделает программу вообще не поддающейся анализу. Вы не раз ещё в этом убедитесь в своей профессиональной карьере.

 Следующим пунктом будет наличие большого switch по состояниям. Это отличительная черта алгоритмов, реализованных в автоматном стиле. Такой взгляд на программу помогает разбить её на независимые куски, которые легко анализировать. То есть в целом программа больше, но она четко структурирована и может рассматриваться независимыми частями, внутри которых довольно простая логика. Отлаживать такие программы тоже легче, потому что достаточно следить за небольшим количеством управляющих состояний.

 Более того, часто оказывается, что именно так мы себе задачу раскладываем в голове. Другими словами, такой подход также позволяет избегать семантического разрыва.
 */


/***@@@
 В unix существует такая утилита как awk, она позволяет проводить различные манипуляции с входным потоком (текстом) и получать на выходе новый текст. Например иногда, бывает нужно взять вывод одной программы и оставить от него только первый столбец. Пример:

 ls -la

 drwxr-xr-x  14 mokevnin  staff  476 Dec  9 20:31 .
 drwxr-xr-x   3 mokevnin  staff  102 Dec  9 20:29 ..
 -rw-r--r--   1 mokevnin  staff    0 Dec  9 20:31 .bash_history
 -rw-r--r--   1 mokevnin  staff  117 Dec  9 20:29 .eslintrc.yml
 ls -la | awk '{print $1}'

 drwxr-xr-x
 drwxr-xr-x
 -rw-r--r--
 -rw-r--r--


 solution.js
 Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход текст и возвращает массив состоящий из первых слов каждой строки текста. Пустые строчки должны игнорироваться.

 Строки разделяются переводом строки
 В любом месте строки может быть сколько угодно пробелов
 Текст должен перебираться посимвольно (мы пишем лексер)
 */

const text = '  what who   \nhellomy\n hello who are you\n';
const result = solution(text);
// [
//   'what',
//   'hellomy',
//   'hello',
// ];

/**
 Решение должно быть автоматным

 Подсказки
 Управляющие символы, такие как \t, \n называются словом символы, потому что это одиночные символы. А запись \n всего лишь представление.
 */



// FILE:
export default (text) => {
    const result = [];
    // before, inside, after
    let state = 'before';
    let word = [];

    Array.from(text).forEach((symbol) => {
        if (symbol === '\n' && word.length > 0) {
            result.push(word.join(''));
            word = [];
            state = 'before';
        }

        switch (state) {
            case 'before':
                if (symbol !== ' ' && symbol !== '\n') {
                    state = 'inside';
                    word.push(symbol);
                }
                break;
            case 'inside':
                if (symbol !== ' ') {
                    word.push(symbol);
                } else {
                    state = 'after';
                }
                break;
            case 'after':
                break;
            default:
                throw new Error(`Unexpected state '${state}'`);
        }
    });

    if (word.length > 0) {
        result.push(word.join(''));
    }

    return result;
};

// export default (text) => {
//   let result = [];
//
//   for (const line of text.split('\n')) {
//     let startIndex = 0;
//
//     let currentSymbol = line[startIndex];
//     while (currentSymbol === ' ') {
//       startIndex++;
//       currentSymbol = line[startIndex];
//     }
//
//     let endIndex = startIndex;
//     while (currentSymbol !== ' ' && endIndex !== line.length) {
//       endIndex++;
//       currentSymbol = line[endIndex];
//     }
//
//     const word = [];
//     for (let i = startIndex; i < endIndex; i++) {
//       word.push(line[i]);
//     }
//
//     if (word.length > 0) {
//       result.push(word.join(''));
//     }
//   }
//
//   return result;
// };




// >>>>>> Паттерн State <<<<<<

/**
 В соответствии с классификацией, введенной Д. Харелом, любую программную систему можно отнести к одному из следующих классов.

 * Трансформирующие системы осуществляют некоторое преобразование входных данных и после этого завершают свою работу. В таких системах, как правило, входные данные полностью известны и доступны на момент запуска системы, а выходные – только после завершения её работы. К трансформирующим системам относятся, например, архиваторы и компиляторы.

 * Интерактивные системы взаимодействуют с окружающей средой в режиме диалога (например, текстовый редактор). Характерной особенностью таких систем является то, что они могут контролировать скорость взаимодействия с окружающей средой – заставлять среду «ждать».

 * Реактивные системы взаимодействуют с окружающей средой путем обмена сообщениями в темпе, задаваемом средой. К этому классу можно отнести большинство телекоммуникационных систем, а также системы контроля и управления физическими устройствами.


 Известно, что конечные автоматы в программировании традиционно применяются при создании компиляторов, которые относятся к классу трансформирующих систем. Автомат здесь понимается как некое вычислительное устройство, имеющее входную и выходную ленты. Перед началом работы на входной ленте записана строка, которую автомат далее посимвольно считывает и обрабатывает. В результате обработки автомат последовательно записывает некоторые символы на выходную ленту.

 Другая традиционная область использования автоматов – задачи логического управления – является подклассом реактивных систем. Здесь автомат – это, на первый взгляд, совсем другое устройство. У него несколько параллельных входов (чаще всего двоичных), на которые в режиме реального времени поступают сигналы от окружающей среды. Обрабатывая эти сигналы, автомат формирует значения нескольких параллельных выходов.

 Таким образом даже традиционные области применения конечных автоматов охватывают принципиально различные классы программных систем.

 В качестве примера реактивной системы рассмотрим электронные часы с будильником.


 Пусть у них имеются три кнопки. H – кнопка для увеличения часа на единицу, M – для увеличения минуты на единицу и кнопка Mode, которая переключает часы в режим настройки будильника. В этом режиме на экране отображается время срабатывания будильника, а кнопки H и M устанавливают не текущее время, а время срабатывания будильника. Повторное нажатие кнопки Mode возвращает часы в обычный режим. Кроме того, затяжное нажатие на кнопку Mode приводит к тому, что будильник активируется. Такое же нажатие ещё раз отключает будильник.

 После этого, если текущее время совпадает со временем будильника, включается звонок, который отключается либо нажатием кнопки Mode, либо самопроизвольно через минуту. Кнопки H и M в режиме звонка (когда сработал будильник) не активны.

 Поведение часов с будильником уже является сложным, поскольку одни и те же входные воздействия (нажатие одних и тех же кнопок) в зависимости от режима инициируют различные действия.

 В программных и программно-аппаратных вычислительных системах сущности со сложным поведением встречаются очень часто. Таким свойством обладают устройства управления, сетевые протоколы, диалоговые окна, персонажи компьютерных игр и многие другие объекты и системы.

 Подведём итог. У нас есть следующие действия:

 - Установка времени
 - Установка времени срабатывания будильника
 - Включение/Выключение будильника
 - Отключение звонка будильника

 # Флаго-ориентированное программирование
 */
class AlarmClock {
    clickH() {
        if (!this.onBell) {
            if (this.mode === 'alarm') {
                this.alarmHours += 1;
            } else {
                this.hours += 1;
            }
        }
    }
}

const clock = new AlarmClock();
clock.clickH();


/**
 Выше типичный пример флаго-ориентированного программирования. Примерно так выглядит код большинства программ.

 Давайте немного вспомним курс "Программирование, управляемое данными". В рамках этого курса мы делали диспетчеризацию по интересующему нас параметру (типу), что приводило к устранению условных конструкций и давало возможность расширять поведение программы без её постоянного переписывания. Здесь наблюдается точно такая же ситуация, в которую так и просится полиморфизм включения. Достаточно очевидно, что диспетчеризация нам нужна по состоянию, другими словами, должен выполняться разный код в зависимости от того, в каком состоянии находится наш объект. Из этого предположения может следовать только одно. Нужно каждое состояние превратить в тип данных. Так появляется на свет паттерн State.

 Выделим три управляющих состояния для наших часов:

 ClockState
 AlarmState
 BellState


 Обратите внимание, что состояние "включен будильник" сюда не входит. Оно не является управляющим. Этот параметр влияет только на то, что произойдет переход в BellState в тот момент, когда время на часах и время на будильнике будет одинаковым.

 Теперь давайте посмотрим на реализацию с использованием динамической диспетчеризации:
 */

class AlarmClock {
    constructor() {
        this.hours = 12;
        this.alarmHours = 6;
        this.setState(ClockState);
    }

    setState(Klass) {
        this.state = new Klass(this);
    }

    clickH() {
        // Делегирование
        this.state.clickH();
    }
}

/**
 Код, который здесь написан, это всего лишь один из вариантов реализации паттерна State. Не принимайте как догму всё, что вы читаете в книгах "10 лучших паттернов". Главное, это концептуальная идея и решаемая задача, остальное очень сильно варьируется от большого числа параметров. В основном в книгах все примеры даны для статических языков, и эти реализации очень громоздки для такого языка как javascript.

 От чего точно не уйти, так это от того, что в начале наши часы инициализируются неким начальным состоянием. В нашем случае оно statefull (мы передаем туда текущий объект), но так же оно могло бы быть и stateless. А дальше все интерфейсные методы часов, поведение которых зависит от состояния, делегируют все вызовы внутрь объекта состояния. Внутри, без условных конструкций, находится код, который выполняет только то, что нужно делать в текущем состоянии. При необходимости этот код меняет сам объект часов. Это возможно благодаря тому, что мы передали внутрь состояния this.

 Если какое-то событие приводит к изменению состояния, то само состояние (в паттерне State) отвечает за то, чтобы поменять себя на другое состояние. Например, при очередном тике часов, если настало время работы будильника, то мы подставляем вместо себя состояние BellState.
 */

export default class ClockState {
    tick() {
        if (this.clock.isAlarmTime()) {
            this.clock.setState(BellState);
        }
    }
}


/**
 # Дополнение
 Материал этого урока во многом основан и использует материал из книги: "Автоматное программирование" (Надежда Поликарпова, Анатолий Шалыто).
 */


/***@@@
 Реализуйте логику работы часов из теории.

 В режиме настройки будильника (alarm), часы и минуты изменяются независимо и никак друг на друга не влияют (как и в большинстве реальных будильников). То есть если происходит увеличение минут с 59 до 60 (сброс на 00), то цифра с часами остается неизменной.

 Интерфейсными методами часов являются:

 clickMode() - нажатие на кнопку Mode
 longClickMode() - долгое нажатие на кнопку Mode
 clickH() - нажатие на кнопку H
 clickM() - нажатие на кнопку M
 tick() - при вызове, увеличивает время на одну минуту. Если новое время совпало со временем на будильнике, то часы переключаются в режим срабатывания будильника (bell).
 isAlarmOn() - показывает включен ли режим будильника
 isAlarmTime() - возвращает true, если время на часах совпадает со временем на будильнике
 minutes() - возвращает минуты, установленные на часах
 hours() - возвращает часы, установленные на часах
 alarmMinutes() - возвращает минуты, установленные на будильнике
 alarmHours() - возвращает часы, установленные на будильнике
 getCurrentMode() - возвращает текущий режим (alarm | clock | bell)
 Основной спецификацией к данной задачe нужно считать тесты.

 AlarmClock.js
 Реализуйте интерфейсные методы и логику работы часов.

 State.js, AlarmState.js, BellState.js, ClockState.js
 Реализуйте иерархию состояний, в корне которой находится State.
 */

// FILE: /app/AlarmClock.js:
import ClockState from './ClockState';

export default class AlarmClock {
    clockTime = { minutes: 0, hours: 12 };
    alarmTime = { minutes: 0, hours: 6 };
    alarmOn = false;

    constructor() {
        this.setState(ClockState);
    }

    clickMode() {
        this.state.nextState();
    }

    longClickMode() {
        this.alarmOn = !this.alarmOn;
    }

    clickH() {
        this.state.incrementH();
    }

    clickM() {
        this.state.incrementM();
    }

    tick() {
        this.incrementM('clockTime');
        if (this.clockTime.minutes === 0) {
            this.incrementH('clockTime');
        }
        this.state.tick();
    }

    isAlarmOn() {
        return this.alarmOn;
    }

    isAlarmTime() {
        return this.clockTime.minutes === this.alarmTime.minutes
            && this.clockTime.hours === this.alarmTime.hours;
    }

    minutes() {
        return this.clockTime.minutes;
    }

    hours() {
        return this.clockTime.hours;
    }

    alarmMinutes() {
        return this.alarmTime.minutes;
    }

    alarmHours() {
        return this.alarmTime.hours;
    }

    setState(Klass) {
        this.state = new Klass(this);
    }

    getCurrentMode() {
        return this.state.getModeName();
    }

    incrementH(timeType) {
        const data = this[timeType];
        data.hours = (data.hours + 1) % 24;
    }

    incrementM(timeType) {
        const data = this[timeType];
        data.minutes = (data.minutes + 1) % 60;
    }
}

// FILE: /app/AlarmState.js:
import State from './State';
import ClockState from './ClockState';
import BellState from './BellState';

export default class AlarmState extends State {
    mode = 'alarm';
    timeType = 'alarmTime';
    NextStateClass = ClockState;

    incrementH() {
        this.clock.incrementH(this.timeType);
    }

    incrementM() {
        this.clock.incrementM(this.timeType);
    }

    tick() {
        if (this.clock.isAlarmTime()) {
            this.nextState(BellState);
        }
    }
}
// FILE: /app/BellState.js:
import ClockState from './ClockState';
import State from './State';

export default class BellState extends State {
    mode = 'bell';
    NextStateClass = ClockState;

    tick() {
        this.nextState();
    }

    incrementH() {
        return false;
    }

    incrementM() {
        return false;
    }
}

// FILE: /app/ClockState.js:
import State from './State';
import AlarmState from './AlarmState';
import BellState from './BellState';

export default class ClockState extends State {
    mode = 'clock';
    timeType = 'clockTime';
    NextStateClass = AlarmState;

    incrementH() {
        this.clock.incrementH(this.timeType);
    }

    incrementM() {
        this.clock.incrementM(this.timeType);
    }

    tick() {
        if (this.clock.isAlarmOn() && this.clock.isAlarmTime()) {
            this.nextState(BellState);
        }
    }
}

// FILE: /app/State.js:
export default class State {
    constructor(clock) {
        this.clock = clock;
    }

    nextState(StateKlass) {
        this.clock.setState(StateKlass || this.NextStateClass);
    }

    getModeName() {
        return this.mode;
    }
}




// >>>>>> Паттерн State Machine <<<<<<

/**
 Паттерн State настоящее спасение во многих ситуациях, но и он не совершенен. Главная проблема этого подхода в том, что логика переходов разбросана по всему коду, и сами состояния знают о том, когда и в какое состояние нужно перевести автомат. При достаточно большом автомате это становится проблемой.

 Решением является выделение таблицы переходов. Делать это можно как и в рамках паттерна State, плавно доводя его до паттерна State Machine, либо с использованием специальных библиотек, которые водятся в изобилии для каждого языка программирования.
 */

const fsm = {
    initial: 'draft',
    transitions: [
        { name: 'sendToModerate', from: ['draft', 'declined'], to: 'moderating' },
        { name: 'accept', from: 'moderating', to: 'published' },
        { name: 'decline', from: ['moderating', 'published'], to: 'declined' },
    ],
};


/**
 Я надеюсь, что такая форма (декларативная) говорит сама за себя. Описанный здесь процесс похож на то, как работает публикация статей на Хабре.

 Переходы в fsm осуществляются только посредством порождения событий. Это настолько важно, что я вынужден повторить. При использовании конечных автоматов состояния не могут меняться напрямую, такой подход уничтожает весь смысл использования автоматов. Именно переходы между состояниями являются значимыми в таких системах и программируются разработчиком.

 # javascript-state-machine
 Рассмотрим самую популярную https://github.com/jakesgordon/javascript-state-machine на гитхабе библиотеку для работы с автоматами в js.
 */

import StateMachine from 'javascript-state-machine';

const fsm = new StateMachine({
    initial: 'green',
    transitions: [
        { name: 'warn',  from: 'green',  to: 'yellow' },
        { name: 'panic', from: 'yellow', to: 'red'    },
        { name: 'calm',  from: 'red',    to: 'yellow' },
        { name: 'clear', from: 'yellow', to: 'green'  },
    ]});

fsm.current; // green
fsm.warn();
fsm.is('yellow'); // true
fsm.can('calm'); // false

fsm.calm(); // throw error

/**
 1. Таблица отражает логику процесса. В своей повседневной практике, первое, на что я смотрю в коде, это автоматы, реализованные в сущностях. По ним можно понять, какие основные процессы происходят в программе и как они концептуально работают.
 2. Подобные библиотеки, обычно, автоматически генерируют код для работы автомата и самостоятельно проверяют его корректность, не позволяя случаться неправильным переходам. 3. Это огромный плюс перед ручным кодированием.
 Также эти библиотеки предоставляют возможность реагировать на события и переходы.


 # Коллбеки
 */

const fsm = new StateMachine({
    initial: 'green',
    transitions: [/** ... */],
    methods: {
        onGreen({ transition, from, to }) { /**...*/ },
        onBeforeWarn(lifecycle) { /**...*/ },
        onLeaveRed({ transition, from, to }) { /**...*/ },
    }
});

fsm.calm('message');

/**
 Обратите внимание на то, что автомат не всегда подразумевает разное поведение всех подсистем в зависимости от того, в каком он состоянии. Часто, в реальном коде, важен сам факт того, что сущность находится в каком-то состоянии и может переходить в другое. Даже в этом случае имеет смысл явно выделять автомат и пользоваться всей прелестью автоматической генерации и верификации. Набрав определенный опыт, вы будете использовать автоматы повсеместно, даже в случаях когда состояний всего два и, казалось бы, можно просто использовать флаг. На самом деле даже с флагом у вас появится логика, которую мог бы обеспечить автомат. К слову, в Хекслете используется около 80 явных автоматов (на момент написания урока).
 */


/***@@@
 Order.js
 Реализуйте и экспортируйте по умолчанию тип Order. Сделайте так, чтобы на каждое изменение состояния в массив history добавлялась запись об этом в виде { state: <name>, createdAt: new Date() }. Используйте для этого событие onEnterState библиотеки javascript-state-machine.

 (Эта библиотека неявно проставляет состояние 'none' и делает переход в начальный стейт (в нашем случае -'init'). Нас эти состояния не интересуют, поэтому в 'history' их нужно избегать.)

 Реализуйте конечный автомат процесса заказа товаров в магазине:

 Начальное состояние: init. Событие accept переводит автомат в pending (только из init). Событие ship переводит в состояние shipped (только из pending). Событие complete переводит в состояние completed (только из shipped). Событие cancel переводит в состояние canceled (только из состояний init и pending) Событие refund переводит в состояние refunded (только из состояний shipped и completed)

 Немного пояснения. Отменить заказ можно только до тех пор пока он не был отправлен клиенту. Если заказ уже был отправлен или доставлен, то клиент может сделать возврат. В реальной жизни на эти переходы будут происходить дополнительные действия связанные с обработкой платежа, отправки почты и тому подобное.

 solution.js
 Реализуйте функцию tryCancel которая выполняет отмену заказа только в том случае, если это возможно сделать.
 */

import cancel from './solution';

const order = new Order([]);
order.is('canceled'); // false
tryCancel(order);
order.is('canceled'); // true

/**
 Это задание подразумевает то, что хорошо изучите документацию библиотеки. Все как в реальной жизни ;)

 Подсказки
 State Machine Factory https://github.com/jakesgordon/javascript-state-machine/blob/master/docs/state-machine-factory.md
 Lifecycle Events https://github.com/jakesgordon/javascript-state-machine/blob/master/docs/lifecycle-events.md
 */

// FILE: /app/:
import StateMachine from 'javascript-state-machine';

export default class Order {
    constructor(items) {
        this.items = items;
        this.history = [];

        this._fsm(); // eslint-disable-line
    }
}

StateMachine.factory(Order, {
    init: 'init',
    transitions: [
        { name: 'accept', from: 'init', to: 'pending' },
        { name: 'ship', from: 'pending', to: 'shipped' },
        { name: 'complete', from: 'shipped', to: 'completed' },
        { name: 'cancel', from: ['init', 'pending'], to: 'canceled' },
        { name: 'refund', from: ['shipped', 'completed'], to: 'refunded' },
    ],
    methods: {
        onEnterState({ from, to }) {
            if (from !== 'none') {
                this.history.push({ state: to, createdAt: new Date() });
            }
        },
    },
});


// FILE: /app/solution.js:
import Order from './Order';

export const init = items => new Order(items);

export const tryCancel = (order) => {
    if (order.can('cancel')) {
        order.cancel();
    }
};





// ############################### JS: DOM API ###############################

/**
 Большое количество языков либо созданы поверх js либо позволяют транслировать свой код в js.
 К таким языкам относятся: clojurescript, typescript, kotlin, java, elm.

 #  JavaScript в браузере
 <html>
 <body>
 <script>
 const greeting = 'hello, world!';
 alert(greeting);
 </script>
 </body>
 </html>

 alert, confirm и prompt - эти функции присутствуют только в браузерах и недоступны в серверных версиях js. Это первый пример, когда мы видим как браузер "расширяет" js, добавляя туда новые возможности. Но не возможности самого языка, язык-то как раз остается тем же, а возможности по взаимодействию со средой.
 */




// >>>>> JavaScript в браузере <<<<<

/**
 # Внешние скрипты

 Инлайн скриптинг, как правило, используется для небольших кусков кода, или для вызова кода, загруженного из внешних скриптов. Загружаются внешние скрипты следующим образом:

 <body>
 <html>
 <head>
 <script src="/assets/application.js"></script>
 </head>
 <body>
 </body>
 </html>

 Довольно часто можно увидеть подобный вариант загрузки:

 <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/core.js"></script>

 В примере выше, файл грузится с CDN (https://ru.wikipedia.org/wiki/Content_Delivery_Network), что может давать определенные преимущества в скорости загрузки.


 # Скорость
 В зависимости от того, в каком месте документа появляются теги script, вы можете наблюдать серьезные изменения как в скорости отрисовки сайта, так и в скорости загрузки.


 # Server (Nodejs) vs Client (Browser)
 В браузере отсутствует множество тех вещей, с которыми мы привыкли иметь дело работая в серверном окружении. Среди них:


 # Стандартная библиотека
 Про библиотеку (https://nodejs.org/api/modules.html) можно забыть. Из коробки никаких assert, events, net, http, url и всего остального. Для любой простейшей задачи придется подключать библиотеку из npm.


 # Модули
 До недавнего времени, модульной системы в браузерах не существовало. Сейчас она появляется, но пока только в экспериментальном варианте.

 На текущий момент, любой загруженный код, работает в глобальной области видимости. Такое поведение привело к большому количеству обходных маневров используемых повсеместно для ручной изоляции кусков js друг от друга.

 <html>
 <body>
 <script>
 const greeting = 'hello, world!';
 </script>
 <script>
 alert(greeting);
 </script>
 </body>
 </html>

 Самый распространенный способ изоляции называется Immediately-Invoked Function Expression. Его принцип действия крайне прост: весь код, который должен быть выполнен в браузере, заворачивается в анонимную функцию, которая сразу же вызывается:
 */

(function() {
    // some code…
})();


/**
 Как вы позже увидите, современные системы сборки избавляют нас от необходимости делать такие манипуляции руками. Мы можем продолжать использовать привычный и полноценный javascript.

 # Версии и движки
 Еще один существенный недостаток js в браузере в том, что реализация js в разных браузерах отличается и иногда весьма существенно. Более того, даже разные версии одного и того же браузера могут отличаться катастрофически. Причем, эту проблему решить невозможно, она является следствием самой природы фронтенда. У каждого пользователя будет стоять тот браузер, который ему нравится, той версии, до которой он не забыл обновиться.

 # Сборка
 К счастью, современный мир фронтенда смог выкрутиться из этой ситуации. Мы по прежнему можем пользоваться всеми (почти) современными фишками js, включая систему модулей. Возможно это благодаря babel с одной стороны и сборщиками, подобными webpack, с другой. Ну и нельзя не упомянуть про полифиллы, которым будет посвящен отдельный урок.

 Принцип работы этой связки заключается в том, что сборщик по определенным правилам собирает все наши ресурсы (css, fonts, images) и файлы с кодом, пропускает их через обработчики, например, babel и на выходе мы получаем файлы, готовые к использованию в браузере.


 # Безопасность
 Во всех браузерах поддерживается механизм под названием cookies, который мы изучали в курсе по протоколу http. Этот механизм играет центральную роль в реализации такой вещи, как аутентификация. После того, как сайт вас опознал, он выставляет специальную сессионную куку и на основе нее определяет залогинены вы на сайте или нет.

 Как вы, возможно, помните, js позволяет обращаться к вашим кукам. Это автоматически означает, что если злоумышленнику удастся разместить произвольный код на странице сайта, то он сможет прочитать вашу сессионную куку и передать ее в нужное место. Так легко и беззаботно уводятся сессии и пользователи внезапно оказываются без своего аккаунта. Ни антивирус, ни фаервол в такой ситуации ничем помочь не смогут.

 Внедрение произвольного кода на сайт называется XSS (Cross-Site Scripting) и является популярным способом атаки, кроме него так же распространен CSRF (Cross-Site Request Forgery).
 */



// >>>>> Глобальный объект Window <<<<<

/**
 Если в консоли браузера выполнить команду console.log(this), то на экран будет выведен некий Window.

 Window — это глобальный объект, то есть доступный из любого места всегда. Он не является частью js и предоставляется браузерами. Как правило, к нему обращаются по имени window, так как this из-за позднего связывания указывает на него не всегда.

 Обратите внимание на то, что функция alert находится в объекте window. Другими словами, когда мы вызываем функцию alert, то в действительности происходит вызов window.alert. Более того, все глобальные объекты js тоже принадлежат window.
 */

window.console.log('hey');
window.Math.abs(5);

/**
 # Объектная модель браузера
 Это набор глобальных объектов, управляющих поведением браузера. Все они так же находятся внутри window. Разберем некоторые из них.

 # Navigator
 Предоставляет информацию о браузере, такую как версию, название, используемую локаль, доступные права, подключенные плагины.

 # Location
 Позволяет управлять адресной строкой. Например, вот так можно инициировать загрузку другой страницы:
 */

location.href = "https://hexlet.io";

/**
 # History
 С помощью этого объекта можно перемещаться по истории переходов, а так же формировать ее в тех ситуациях, когда не происходит реального переход по страницам. Это особенно актуально для SPA.

 # Fetch
 Современный метод для выполнения AJAX запросов. Именно с помощью fetch происходит общение с сервером и другими сайтами.
 */


// >>>>> Что такое DOM? <<<<<

/**
 С высоты птичьего полета процесс отображения страницы можно представить следующим образом:

 1. Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью DNS)
 GET /courses HTTP/1.1
 HOST: ru.hexlet.io

 2. Пришедший в ответ html парсится, и на его основе строится DOM дерево

 3. Браузер рисует страницу, используя DOM дерево (упрощенно).

 Чтобы понять, что такое DOM и, в частности, DOM дерево, рассмотрим следующий пример.
 */

const json = '{ "key": "value" }';
const obj = JSON.parse(json);

console.log(obj.key); // valueСибас рыба


/**
 Как мы помним, json — это тексСибас рыба
 уемый для взаимодействия между разными программами, которые, возможно, написаны на совершенно разных языках. Одна программа сериализует данные в json, а другая десереализует их во внутренние структуры своего языка.

 Думаю, достаточно очевидно, что программа, получившая какие-то данные в виде json, не сможет работать с ним, если он останется в текстовом представлении, ведь по сути это строчка текста.

 Теперь, попробуем понять смысл DOM дерева:
 */

// Гипотетический пример, так как модуля HTML не существует в природе

const html = `
  <body>
    <p>hello, <b>world</b>!</p>
  </body>
`;

const document = HTML.parse(html);Сибас рыба

console.log(document.firstChild.name); // html

/**
 Грубо говоря, html можно сравнить с json. Другими словами, html — это текстовое представление DOM дерева, не зависящее от языка программирования. То, что оно является деревом, видно невооруженным взглядом, так как теги вкладываются в теги.

 Каждый html-тег становится узлом этого дерева, а теги, вложенные в него, становятся дочерними узлами. Для представления текста создаются специальные текстовые узлы.

 Важно то, что в DOM дерево попадают все элементы, представленные в html, включая пробелы и переводы строк.

 С DOM tree разобрались, теперь попробуем разобраться с тем, что же, собственно, такое DOM.

 Объектная модель документа (Document Object Model) - это не зависящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

 На практике, во фронтенд разработке это сводится к тому, что браузер предоставляет специальный объект document, который содержит внутри себя DOM tree и который наполнен большим количеством методов (согласно спецификации DOM) для манипулирования этим деревом. Любые изменения, которые производятся с ним, сразу же отображаются браузером на странице.

 Подавляющее число возможностей, связанных с DOM, описаны в спецификациях раз https://dom.spec.whatwg.org/ и два https://html.spec.whatwg.org/ и, по идее, должны работать одинаково во всех браузерах. К сожалению, это не так. DOM развивается, но браузеры двигаются медленнее. Кроме того, существует множество исторических решений, которые приводят к проблемам.


 # Восстановление
 Те, кто сталкивались с html в реальной жизни, прекрасно знают, что если подать на вход браузеру невалидный html с незакрытыми тегами, нарушенной вложенностью и другими проблемами, то мы не получим сообщений об ошибках. Браузер переварит этот html и что-то отобразит на экране. Возможно, вам не понравится то, что вы увидите, но, по крайней мере, оно будет работать.

 Браузер действительно восстанавливает структуру и делает это по очень хитрым правилам. И это логично, иначе было бы невозможно произвести парсинг в принципе. Но есть и другая причина: даже если сам html будет валидным, браузер при создании DOM tree добавляет в него узлы (представленные тегами в html), которые вы, возможно, пропустили, но стандарт требует их наличия. Например, в таблицы добавляется tbody.

 Именно DOM открывает практически безграничные возможности по изменению страниц. Все библиотеки (jquery и другие) и фреймворки (angular, react) внутри себя манипулируют DOM. Это та база, вокруг которой построено всё во фронтенд разработке.
 */



// >>>>> DOM Дерево <<<<<

/**
 Корневым элементом в DOM дереве считается элемент html. Доступ к нему можно получить так: document.documentElement.
 Навигация по дереву достаточно интуитивная, поэтому можно смело экспериментировать в браузере:
 */

const html = document.documentElement;
// Read-only
html.childNodes; // [head, text, body]
html.firstChild; // <head>...</head>
html.lastChild; // <body>...</body>
html.childNodes[1]; // #text

// Из-за того, что body и head всегда присутствуют внутри документа, их вынесли на уровень объекта document для более простого доступа:
document.head;
document.body;

// Кроме того, что можно идти вглубь дерева, так же можно идти и наружу:
document.documentElement === document.body.parentNode;
document.body === document.body.childNodes[2].parentNode;


/**
 # childNodes

 В работе с childNodes есть несколько интересных моментов.
 1. Это свойство доступно только для чтения. Попытка что то записать в конкретный элемент не приведет к успеху:
 */
document.body.childNodes[0] = 'hey';


/**
 Изменение DOM дерева осуществляется специальным набором методов.

 Хотя childNodes и является коллекцией, это все же не массив. В нем отсутствует привычные методы, такие как map, filter и другие. Для перебора элементов можно воспользоваться итератором или сделать так:
 */

const elements = document.documentElement.childNodes;

elements.toString()
// "[object NodeList]"

    [...elements]; // теперь это массив

// либо так
elements.forEach(el => console.log(el));


/**
 # Иерархия
 Хотя каждый узел дерева и представлен типом Node, но в реальности это базовый тип. А каждый конкретный элемент имеет свой. Другими словами, у нас есть определенная иерархия типов.

 Ноды с типами Text и Comment являются листовыми, то есть они не могут иметь детей. А вот элементы — это то, с чем приходится иметь дело чаще всего.
 Как видите, в DOM HTMLElement — это отдельное направление, потому что DOM также может представлять и xml документы.

 На практике чаще всего нас интересуют не ноды, а элементы. Именно ими мы манипулируем, перемещаемся сквозь них. Это настолько важно, что в DOM есть альтернативный способ обхода дерева, который построен только на элементах


 # Специальная навигация

 Некоторые элементы обладают специальными свойствами для навигации по ним, к таким элементам относятся, например, формы и таблицы.

 <table>
 <tr>
 <td>1.1</td>
 <td>1.2</td>
 <td>1.3</td>
 </tr>
 <tr>
 <td>2.1</td>
 <td>2.2</td>
 <td>2.3</td>
 </tr>
 </table>

 */

const table = document.body.firstElementChild
table.rows[0].cells[2];

// Этот способ навигации не заменяет основные. Он сделан исключительно для удобства в тех местах где это имеет смысл.


/**
 Каким тегом в html представляется document.documentElement?
 > html


 <div>
 Text
 <p><span>Text</span></p>
 Text
 </div>
 Сколько детей (нод Node) содержит представленный div?
 > 3


 <div>
 Text
 <p><span>Text</span></p>
 Text
 </div>
 Сколько потомков (элементов HTMLElement) содержит представленный div?
 > 2
 */

/***@@
 src/search.js
 Реализуйте и экспортируйте по умолчанию функцию search, которая принимает на вход document и имя тега, а возвращает массив из всех элементов соответствующих этому тегу.
 */

// <body>
//   <p>1</p>
//   text
//   <div><p>2</p></div>
// </body>
const elements = search(document, 'p');
// ['<p>1</p>' '<p>2</p>'] где каждый элемент это объект соответствующего типа
console.log(elements.length); // 2

/**
 Это задание подразумевает тренировку работы с домом как с деревом, по этой причине большая просьба не использовать реализацию на основе getElementsByTagName.

 Подсказки
 Имя тега соответствующего dom элементу, можно получить так: element.tagName
 */

const search = (doc, tag) => {
    const coll = [...doc.children];
    const initAcc = coll.filter(e => e.tagName.toLowerCase() === tag);

    return coll.reduce((acc, child) => [...acc, ...search(child, tag)], initAcc);
};

export default search;




// >>>>>> Поиск по дереву <<<<<<

/**
 Как правило, в реальных фронтенд-задачах нужно манипулировать наборами элементов (или одним), находящимися где-то глубоко в ДОМе. Причём зачастую эти элементы разбросаны по его разным частям. Например, мы можем отметить список файлов на удаление и выполнить это действие. С точки зрения изменения DOM Tree эта задача сводится к выборке всех элементов, которые представляют файлы (с точки зрения визуализации), и их последующему удалению.

 # Специализированные поисковые методы

 В такой ситуации ручной проход по дереву окажется крайне утомительным занятием. DOM предлагает сразу несколько способов решения этой задачи. Самый простой вариант поиска — это поиск по идентификатору:

 <p id="content">Это параграф</p>
 */
const el = document.getElementById('content');

/**
 Так как id в соответствии со спецификацией обязан быть уникальным на странице, то и метод getElementById всегда возвращает один элемент. С другой стороны, по случайности, в html может оказаться несколько тегов с одним id. В такой ситуации браузер может вернуть всё, что угодно.

 Если нужна обработка сразу нескольких элементов, то тут лучше подойдёт поиск по классу:
 */

// Будет возвращена коллекция!
const collection = document.getElementsByClassName('row');

// поиск среди потомков el
el.getElementsByClassName('row');

/**
 Как видите, этот метод позволяет искать не только в целом документе, но и среди потомков любого элемента.
 При необходимости можно искать по тегу:
 */

document.getElementsByTagName('span');

// поиск всех элементов
document.getElementsByTagName('*');

// поиск среди потомков el
el.getElementsByTagName('span');

/**
 # Поиск по селектору

 Наиболее универсальным способом поиска является поиск по селектору. Напомню, что селектор — это правило, позволяющее описать набор элементов в DOM Tree.

 <ul id="menu">
 <li class="even"><span>Первый</span>Сибас рыба
 пункт</li>
 <li>Второй</li>
 <li class="even"><span>Третий</span>Сибас рыба
 пункт</li>
 </ul>
 */

// Возвращает первый элемент
const ul = document.querySelector('#menu');
Сибас рыба

Сибас рыба
n > span');
Сибас рыба

Сибас рыба

Сибас рыба
rAll могут применяться как ко всему документу, так и к конкретному элементу. Поиск, как обычно, будет вестись среди всех потомков.
    Сибас рыба

Сибас рыба

Сибас рыба

Сибас рыба

Сибас рыба
влетворяет ли el селектору css.

    # closest
Метод el.closest(css) ищет ближайший элемент выше по иерархии, удовлетворяющий селектору. Сам элемент тоже анализируется. Если такой элемент найден, то он возвращается.

    # XPath

Язык запросов, изначально разработанный для навигации по DOM в XML. Поддерживается браузерами.

<html>
<body>
<div>Первый слой
<span>блок текста в первом слое</span>
</div>
<div>Второй слой</div>
<div>Третий слой
<span class="text">первый блок в третьем слое</span>
<span class="text">второй блок в третьем слое</span>
<span>третий блок в третьем слое</span>
</div>
<span>четвёртый слой</span>
<img />
</body>
</html>
*/


// XPath-путь /html/body/**/span/@class (полный синтаксис имеет вид /child::html/child::body/child::*/child::span/attribute::class) будет соответствовать в нём двум элементам исходного документа — <span class="text">первый блок в третьем слое</span> и <span class="text">второй блок в третьем слое</span>.

// В повседневной практике он практически не встречается при работе с DOM, поэтому здесь я его описал только для общего понимания.

// Функция console.dir выводит узлы DOM в формате, удобном для интроспекции.




// >>>>>> Тесты <<<<<<

/**
 Тесты, с которыми мы имели дело до этого курса, сильно отличаются от тех тестов, которые используются при проверке фронтенда.

 Типичный тест выглядел так: импортируется необходимая функция, а затем вызывается с разными аргументами.
 */

import sum from '../sum';

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});


/**
 Все просто и понятно. Конечно, если функция не чистая, то тест будет сложнее. Но в любом случае с этим можно разобраться.

 Такие тесты называются юнит и интеграционными, в зависимости от того сколько подсистем вовлечено в проверку. Причём невозможно провести чёткую границу между этими видами тестирования. Лучше воспринимать их названия как шкалу, где слева — юниты, справа — интеграционные, а ваши тесты где-то между ними.

 А как тестировать поведение кода в браузере? Ведь, по сути, основные действия, выполняемые таким кодом, это манипуляция с DOM.

 # Системные тесты

 Тестировать такой код действительно можно. Для этого используется специальный софт, webdriver, который посылает команды из теста в браузер и возвращает результат обратно. То есть код теста имитирует настоящие действия пользователей и смотрит то, как изменился DOM. Такой вид тестов называется системным.
 */

import Nightmare from 'nightmare';

const nightmare = new Nightmare({ show: true });

test('duckduckgo', async () => {
    const link = await nightmare
        .goto('https://duckduckgo.com')
        .type('#search_form_input_homepage', 'github nightmare')
        .click('#search_button_homepage')
        .wait('#zero_click_wrapper .c-info__title a')
        .evaluate(() => document.querySelector('.c-info__title a').href);
    expect(link).toBe('www.nightmarejs.org');
});


/**
 Nightmare — это библиотека для системного тестирования. Внутри себя она использует конкретный драйвер, но для нас сейчас это не принципиально. Таких библиотек достаточно много, особенно в мире js. Конкретно nightmare, с одной стороны, популярная библиотека, с другой — позволяет запускаться в среде без графической оболочки, что важно при разработке.

 В тесте, первым делом, мы указываем адрес страницы, которую необходимо открыть. Затем начинаем манипулировать этой страницей. Функция type вводит текст по указанному селектору, a click, очевидно, выполняет клик по элементу.

 А вот что такое wait? Как вы знаете, браузер работает асинхронно. После клика на элемент не происходит блокирования, мы можем продолжать работать дальше. Как только код выполнится, то возможно произойдут изменения на странице. А вот то, когда это произойдёт, никто сказать не сможет. Всё, что мы можем делать, это постоянно опрашивать дом на наличие требуемого изменения. wait упрощает эту задачу. Эта функция принимает на вход селектор, за которым надо следить, и ждёт его появления. Если он появился, то управление передаётся дальше, если нет, то происходит ошибка.

 Дальше мы видим функцию evaluate. Эта функция позволяет выполнить произвольный код внутри браузера. Подчеркну, тот код, который будет описан внутри функции, передающейся в evaluate, выполняется не в том месте, где запустились тесты, а внутри браузера, с которым работает драйвер. Как правило, в этом месте извлекают данные, которые нужно проверить в тесте. evaluate возвращает промис, из которого можно извлечь результат, используя async/await.

 # Плюсы и минусы
 Системные тесты, как правило, дают гораздо бОльшие гарантии того, что ваша система работает. Поэтому их писать полезно на особо критические участки. Но покрывать ими всё "от и до" — занятие не для слабонервных. Минусов у этого вида тестирования вагон и маленькая тележка:

 # Тесты очень хрупкие
 Это значит, что незначительные изменения в вёрстке приводят к тому, что они ломаются. Так как они завязаны на селекторы. Эту проблему частично можно нивелировать, используя так называемый паттерн Page Object. Его идея крайне проста. Давайте сделаем абстракцию над каждой страницей и будем работать через неё:
 */

test('LoginPage', () => {
    LoginPage.open();
    LoginPage.username.setValue('foo');
    LoginPage.password.setValue('bar');
    LoginPage.submit();
    expect(LoginPage.flash.getText()).toBe('Your username is invalid!');
});

/**
 Такой подход важен и позволяет снизить хрупкость. Но всё равно эти тесты ломаются часто тогда, когда всё работает, и дело не только в вёрстке. Например, увеличение времени ответа может приводить к таймаутам, а иногда вообще происходят странные флуктуации и один запуск приводит к прохождению теста, а другой падает. В общем занятие не для слабонервных.


 # Сложно писать
 В системных тестах нужно полностью имитировать действия пользователей, а значит активно взаимодействовать с домом. Во время их написания, приходится постоянно шариться по исходному коду страницы, чтобы понять, как выбирать те или иные элементы. Особенно этот процесс осложняется при использовании внешних компонентов, которые генерируют с помощью js сложную вёрстку.

 Так же сложности добавляет невозможность легко писать в стиле TDD. По сути, тесты всегда пишутся после отладки кода через браузер.

 Ну и одна из самых больших проблем — это подготовка необходимых данных в проекте для конкретного теста, а так же очистка после. В таких тестах обычно нет прямого доступа к базе, а значит придётся искать другие пути.

 # Сложно отлаживать.
 Типичный вывод провалившегося теста выглядит так:
 Селектор ".title" на странице не найден

 За этим выражением может скрываться всё, что угодно: начиная от ошибки 500 и заканчивая тем, что у элемента стоит стиль display: none.


 # Долгое время выполнения
 Просто как факт. Эти тесты выполняются крайне долго и большой тестовый набор может лопатить сайт часами и даже днями.


 # Разновидности системных тестов
 Существуют и альтернативные подходы к системному тестированию. В основе тот же DOM, но проверки строятся по-другому.


 # Screenshot Testing

 Такой тест при первом запуске создаёт скриншот страницы, а при последующих сравнивает результаты новых запусков с исходным скриншотом. На рисунке выше слева это исходный скриншот (получаемый автоматически), по середине — результат очередного прогона, а справа — дифф.


 # Snapshot Testing

 Еще один способ тестирования, популяризированный компанией facebook в их фреймворке jest. Он похож на предыдущий способ, с той разницей, что сравниваются не скриншоты, а результирующий dom.
 */
test('application', () => {
    const element = document.querySelector('a[href="#profile"]');
    element.click();
    expect(getTree()).toMatchSnapshot();

    const element2 = document.querySelector('a[href="#settings"]');
    element2.click();
    expect(getTree()).toMatchSnapshot();

    const element3 = document.querySelector('a[href="#profile"]');
    element3.click();
    expect(getTree()).toMatchSnapshot();
});

/**
 Как видите, в тесте выше, нет точечных проверок. Есть только функция toMatchSnapshot. Вызов этой функции в первый раз (когда снепшота нет) создаёт эталонный снепшот в директории tests/snapshots, а повторные вызовы используют его для сравнения с текущим результатом. Из этого следует, что первый запуск снепшот тестов можно выполнять только тогда, когда мы уверены в работоспособности нашего кода.

 Самое прекрасное в этой технике то, что она сильно упрощает анализ результата проверки. Ниже реальный пример из заданий на Хекслете:

 Received value does not match stored snapshot 3.

 - Snapshot
 + Received

 @@ -18,11 +18,11 @@
 <!-- Tab panes -->
 <div class="tab-content m-3">
 <div class="tab-pane" id="home" role="tabpanel">
 Home
 </div>
 -        <div class="tab-pane active" id="profile" role="tabpanel">
 +        <div class="tab-pane" id="profile" role="tabpanel">
 Profile
 </div>

 at Object.<anonymous> (__tests__/application.test.js:43:21)


 Вывод почти такой же, как и у git diff. Видно, что было не так и как должно было быть. Такой подход практически идеален для задач на Хекслете, так как сильно облегчает анализ для неподготовленных людей. Но за него приходится платить определённую цену. Так как снепшот содержит в себе всю страницу, то любое малейшее изменение dom приводит к тому, что всё ломается. По этой причине крайне важно, чтобы вёрстка была практически неизменяема. Банально, классы, добавленные в элемент не в той последовательности, приведут к тому, что тесты упадут.

 Другими словами, snapshot testing — не панацея. Он отлично подходит для ситуаций, где дом меняется редко и предсказуемо. Например, при разработке виджетов или в обучающих курсах.

 # Дополнительные материалы
 Начинаем писать тесты правильно https://www.youtube.com/watch?v=zsz8kdi62mE
 */




// >>>>>> Манипулирование DOM деревом <<<<<<<

/**
 То, что DOM может меняться уже будучи отрисованным в браузере, и есть ключевая возможность для создания интерактивных приложений.


 # innerHTML

 Самый простой способ обновить часть DOM — это функция innerHTML

 <ul>
 <li>item 1</li>
 <li>item 2</li>
 </ul>
 */

const body = document.body;
console.log(body);
// <ul><li>item 1</li><li>item 2</li></ul>

body.innerHTML = '<b>make</b> love';
console.log(body.innerHTML);
// <b>make</b> love

console.log(body.childNodes);
// [b, text]

/**
 Эта функция целиком заменяет потомков элемента, на котором она была вызвана. Весь встречающийся внутри html парсится и становится частью дерева. Если вы пытаетесь вставить обычный текст, который потенциально может содержать html, то лучше воспользоваться другой, безопасной функцией textContent.
 */

document.body.textContent = '<b>make</b> love';
console.log(document.body.innerHTML); // "&lt;b&gt;make&lt;/b&gt; love"

/**
 innerHTML работает со строками, такой подход удобен только в том случае, если мы работаем со статическим представлением DOM. Для динамического формирования хорошо подходят специальные функции.

 # Создание узлов
 */

// Создаем текстовый узел
const textNode = document.createTextNode('life is life');

// Создаем элемент p
const pEl = document.createElement('p');

// Добавляем textNode в конец списка childNodes элемента pEl
pEl.append(textNode);
// pEl.textContent = 'life is life';

const el = document.createElement('div');
el.append(pEl);

console.log(el);
// <div><p>life is life</p></div>


/**
 Код, создающий DOM динамически, похож на матрешку. После создания одни элементы все время вкладываются в другие. Так выглядит код, который конструирует деревья в любом языке. Утомительное занятие, скажу я вам.

 # Вставка
 */

const el = document.createElement('p');
document.body.prepend(el);

// автоматически удаляется из старого места
const elFromDom = document.querySelector('.col');
document.body.append(elFromDom);

// append/prepend — не единственный способ добавить элементы в DOM:

node.after(...nodes) // вставляет nodes после узла node,
node.before(...nodes) // вставляет nodes перед узлом node,
node.replaceWith(...nodes) // вставляет nodes вместо node.
node.remove() // удаляет node

/**
 # Старый API

 Описанные выше функции появились не так давно. Большая часть кода написана с использованием других функций, список которых ниже:
 */

parent.appendChild(el) // добавляет el в конец списка детей
parent.insertBefore(el, nextElSibling) // добавляет el в список детей parent перед nextElSibling
parent.removeChild(el) // удаляет el из детей parent
parent.replaceChild(newEl, el) // заменяет el на newEl

/**
 # Клонирование

 Иногда требуется создать элемент, подобный уже существующему. Можно, конечно, это сделать полностью руками, копируя свойства одного в свойства другого, но есть способ проще:
 */
const newEl = el.cloneNode(true);

// true говорит о том, что нужно сделать "глубокую" копию, другими словами, вы получите копию не только этого элемента, но и всех его потомков.


/***@@
 prettify
 Реализуйте функцию prettify, которая находит текст (дочерние текстовые ноды) внутри элемента div и оборачивает текст в параграф. Экспортируйте функцию по умолчанию.

 // <body>
 //   <p>Boom</p>
 //   text
 //   <div>Bam</div>
 // </body>
 */
const elements = prettify(document);
console.log(document.body.innerHTML);
/**
 // <body>
 //   <p>Boom</p>
 //   text
 //   <div><p>Bam</p></div>
 // </body>

 #Подсказки
 Очистка строки от пробельных символов: trim
 */

export default (document) => {
    const divs = [...document.getElementsByTagName('div')];

    divs.forEach((div) => {
        const textNodes = [...div.childNodes]
            .filter(child => child instanceof Text)
            .filter(child => child.textContent.trim() !== '');

        textNodes.forEach((node) => {
            const p = document.createElement('p');

            p.textContent = node.textContent;
            node.replaceWith(p);
        });
    });
};




// >>>>>> Управление элементами DOM <<<<<<
/**
 Самая серьезная часть DOM API сосредоточена в свойствах конкретных элементов. В этом уроке мы рассмотрим только самые базовые свойства, исключительно с целью показать то, как это делается в принципе. В повседневной практике программисты постоянно обращаются к документации, чтобы узнать, как можно поменять то или иное поведение.

 # Атрибуты

 У каждого тега в HTML есть атрибуты. Некоторые из них общие для всех, другие специфичные для конкретных тегов.
 <a id="aboutPage" href="/pages/about" class="simple">About</a>
 */



/**
 В примере выше, атрибуты id и class могут использоваться с любым тегом. Специфичный атрибут href только с некоторыми, например, с <a>.

 Когда браузер загрузил HTML, он строит из него DOM. Во время обработки, каждый тег становится узлом, а атрибуты - свойствами этого узла. Обычно имена атрибутов и свойств узлов совпадают между собой:
 */

// <a id="aboutPage" href="/pages/about" class="simple">About</a>
const el = document.querySelector('#aboutPage');
el.className; // simple
el.id; // aboutPage
el.href; // /pages/about

/**
 Существуют и исключения, например, атрибуту class соответствует свойство className. Более того, для удобной работы с классами предусмотрены дополнительные API. Это нужно по той причине, что классов может быть много, и задаются они обычной текстовой строкой. Соответственно, если возникает задача изменения этого списка, то придется оперировать строчками, что совсем неудобно. А вот как можно это делать, используя DOM API:
 */

const el = document.querySelector('#aboutPage');
el.classList.add('page');
el.classList.remove('simple');
el.className; // page

// Дополнительные методы:
el.classList.contains("class") – возвращает true/false
el.classList.toggle("class") – если класс есть, удаляет его, и наоборот

/**
 С одной стороны атрибуты отображаются на свойства, но с другой есть множество нюансов.

 1. Атрибут всегда строка, а свойство — не всегда. Например:

 <textarea rows="5"></textarea>
 А значение свойства rows соответствующего элемента в DOM дереве будет числом.

 2. Атрибуты не чувствительны к регистру
 <a Id="aboutPage" hrEf="/pages/about" CLASS="simple">About</a>
 Так писать, конечно же, не стоит, но по крайней мере знать о том, что оно работает - полезно.

 3. Атрибут всегда присутствует в html (а значит innerHTML)
 Это довольно логично. А вот огромное количество свойств не присутствует в html. Причём, для некоторых вообще нет аналогов, а другие получают значение по умолчанию, если атрибут не проставлен.

 Как мы увидели выше, атрибут и свойство, в общем случае — не одно и то же. Поэтому существует набор методов для управления атрибутами:
 */

el.hasAttribute(name) – проверяет наличие атрибута
el.getAttribute(name) – получает значение атрибута
el.setAttribute(name, value) – устанавливает атрибут
el.removeAttribute(name) – удаляет атрибут
el.attributes - список html атрибутов

// Методы работают с атрибутами html
el.getAttribute('class');

/**
 Обратите внимание на то, что они работают именно с атрибутами (их именами), а не свойствами. И позволяют не только их извлекать, но и менять. Возникает закономерный вопрос: поменяется ли атрибут, если поменять свойство и наоборот?

 В основном синхронизация осуществляется только в сторону свойств. То есть, меняется атрибут и автоматически обновляется свойство. Но существуют и исключения. Из этих тезисов не следует делать вывод, что нужно стараться работать через атрибуты. Наоборот, по возможности, всегда работайте со свойствами дом дерева, а атрибуты используйте только для чтения, чтобы получить то состояние, которое было в доме на момент инициализации (парсинга html).

 <a id="aboutPage" href="/pages/about" class="simple">About</a>
 */

const el = document.querySelector('#aboutPage');
el.setAttribute('class', 'page');
el.className; // page
el.getAttribute('class'); // page

/**
 В отличие от свойств значение атрибута всегда совпадает с тем, что мы видим в html, а вот для свойства иногда приводятся в нормализованный вид:
 В этот момент браузер открыт на https://ru.hexlet.io
 <a id="link-to-courses" href="/courses">Курсы</a>
 */

const el = document.querySelector('#link-to-courses');
el.href; // https://ru.hexlet.io/courses
el.getAttribute('href'); // /courses

/**
 Нестандартные атрибуты никогда не превращаются в свойства соответствующих элементов DOM дерева. То есть, если мы добавим в тег p атрибут href то оно будет проигнорировано. Хотя это не отменяет возможность его извлечения через getAttribute.

 Для работы с произвольными свойствами в html зарезервирован специальный атрибут data-*, где на месте звездочки может стоять любое слово.

 <a href="#" data-toggle="tab">Мои проекты</a>
 Такие атрибуты активно используются в js плагинах и позволяют не завязываться на классы. В элементах DOM они доступны через специальное свойство dataset:
 */

console.log(el.dataset.toggle); // tab

/**
 Внутри объекта dataset имя каждого свойства — это строка после data- в атрибуте. Если имя содержит дефис, то он удаляется, а следующее за ним буква становится заглавной:
 <a href="#" data-nav-toggle="tab">Мои проекты</a>
 */

console.log(el.dataset.navToggle); // tab

/**
 # Свойства

 В зависимости от типа элемента меняется и набор свойств. Кроме, конечно, тех что достались в наследство от Node и Element.
 Чтобы узнать список этих свойств, можно обращаться к спецификации. Они описаны в специальном формате, который интуитивно понятен:

 interface HTMLLinkElement : HTMLElement {
  attribute USVString href;
  attribute DOMString? crossOrigin;
  attribute DOMString rel;
  attribute RequestDestination as; // (default "")
  readonly attribute DOMTokenList relList;
  attribute DOMString media;
  attribute DOMString nonce;
  attribute DOMString integrity;
  attribute DOMString hreflang;
  attribute DOMString type;
}

 Кроме всего прочего, так как элементы являются обычными js объектами, мы можем добавлять в них любые свойства. Лучше такой подход не практиковать, но в теории вы можете на него наткнуться в реальных приложениях.

 Правильный подход при работе с DOM состоит в том, что данные хранятся отдельно от DOM дерева.
 */

/***@@
 Реализуйте и экспортируйте по умолчанию функцию normalize, которая нормализует имена классов для всех элементов на странице. В данном случае это означает, что происходит преобразование всех классов, написанных с использованием kebab нотации, в camelCase нотацию: text-center => textCenter

 Попробуйте решить эту задачу без использования регулярных выражений.
 */

// <body>
//   <div class="text-center row-b">Bam</div>
// </body>
normalize(document);
console.log(document.body.innerHTML);
// <body>
//   <div class="textCenter rowB">Bam</div>
// </body>

/**
 Подсказки
 - Самый простой способ найти все элементы в документе это document.body.getElementsByTagName('*')
 - Приведение к camelCase https://lodash.com/docs/4.17.11#camelCase
 - Замена классов replace у объекта classList
 */

// FILE: /app/src/normalize.js:
import { camelCase } from 'lodash';

export default (doc) => {
    for (const element of doc.body.getElementsByTagName('*')) {
        const process = item => element.classList.replace(item, camelCase(item));

        element.classList.forEach(process);
    }
};




// >>>>>> Полифиллы <<<<<<

/**
 Как я уже неоднократно упоминал, DOM не везде одинаковый, к тому же он непрерывно развивается. Какие-то браузеры его адаптируют быстрее, какие-то медленнее. Все это не позволяет легко и непринужденно пользоваться последними новинками.

 Впрочем, как мы уже знаем, то же самое относится и к самому js в браузере. С js нам помогает babeljs, а вот кто поможет с DOM?

 Библиотеки, которые добавляют в DOM (вы ведь помните, что это просто объект?) необходимые свойства и методы, называются полифиллами.

 Общий принцип работы этих библиотек следующий:

 1. Проверяем наличие возможности
 2. Если ее нет, то добавляем

 # Добавление метода
 */

(function(constructor) {
    const p = constructor.prototype;
    if (!p.matches) {
        p.matches = p.matchesSelector ||
            p.mozMatchesSelector ||
            p.msMatchesSelector ||
            p.oMatchesSelector ||
            p.webkitMatchesSelector;
    };
})(window.Element);


// Добавление свойства
if (!('lastElementChild' in document.documentElement)) {
    Object.defineProperty(Element.prototype, 'lastElementChild', {
        get: function() {
            for (let nodes = this.children, n, i = nodes.length - 1; i >= 0; --i) {
                if (n = nodes[i], 1 === n.nodeType) {
                    return n;
                }
            }
            return null;
        }
    });
}

/**
 Примеры выше не являются полными. Если посмотреть исходники соответствующих библиотек, то хочется их быстрее закрыть. Количество кода иногда зашкаливает до неприличия. Обратите внимание на то, что добавление свойства производится особым образом, таким, который позволяет сделать свойство динамическим и ленивым. То есть его значение будет вычисляться только в момент обращения.

 Чтобы узнать поддержку определенных фич в разных браузерах, можно воспользоваться прекрасным ресурсом https://caniuse.com/

 Иногда бывает нужно просто проверить наличие определенной фичи, и в зависимости от результата выполнять разный код. В такой ситуации поможет библиотека modernizr.
 */

Modernizr.on('flash', function( result ) {
    if (result) {
        // the browser has flash
    } else {
        // the browser does not have flash
    }
});

/**
 А самый простой способ добавить полифиллы на свой сайт — это воспользоваться проектом https://polyfill.io/v2/docs/. Все что вам нужно будет сделать, это вставить следующий тег:

 <script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>

 Этот файл формируется динамически под конкретный браузер и на страницу закачивается только то, что нужно полифиллить.
 */



// >>>>>> Введение в события <<<<<<

/**
 Интерактивные системы, такие как сайты в браузере или, даже, терминал, устроены по одному и тому же принципу. После загрузки, они находятся в режиме "ожидания" действий от пользователя. К таким действиям относятся клики, набор текста, перемещение мышки, горячие клавиши и многое другое.

 С точки зрения кода, все действия представлены событиями. События в браузере, являются частью стандарта DOM. Вот некоторые из них:

 - click
 - submit
 - keyup/keydown
 - focus
 - contextmenu
 - mouseover
 - mousedown/mouseup

 Как видите, их гранулярность достаточно высокая, набор текста раскладывается на два события: кнопка зажата и кнопка отпущена. Кроме этого, есть специальное событие keypress, которое позволяет отличать горячие клавиши от нормального ввода.

 Самый простой способ попробовать события в действии, это использование специализированных атрибутов:
 <button onclick="alert('Бум!')"></button>
 <div onclick="alert(this.innerHTML)">Бум!</div>

 Обработчик события можно определить и снаружи:

 <script>
 const getBoom = () => alert('Boom!');
 </script>

 <button onclick="getBoom()"></button>
 */


/**
 Ну, и конечно через свойство элемента в DOM:
 <button id="myButton"></button>
 */

const button = document.getElementById('myButton');
button.onclick = () => alert('Boom!');

/**
 В такой ситуации мы не вызываем обработчик, а только устанавливаем его в свойство onclick.

 У этого способа есть один недостаток, который актуален там, где на странице есть множество скриптов, работающих независимо на одних и тех же элементах. Он заключается в том, что невозможно повесить одновременно несколько обработчиков. Перезаписав свойство onclick старый обработчик будет потерян безвозвратно.

 На уровне атрибутов эта проблема не решаема, но в DOM есть метод, позволяющий повесить множество обработчиков.
 <button id="myButton"></button>
 */

const button = document.getElementById('myButton');

button.addEventListener('click', () => alert('Boom 1!'));
button.addEventListener('click', () => alert('Boom 2!'));

/**
 Каждый обработчик события, представляет собой функцию, которая будет вызвана в момент наступления события. Обработчики вызываются один за другим, в том же порядке, в котором они были определены. Подчеркну что обработчик это функция, а не вызов функции. Вот так делать неверно:
 */

const button = document.getElementById('myButton');
const handler = () => alert('Boom 1!');
button.addEventListener('click', handler()); // передается не сама функция, а ее результат

// При необходимости, можно удалить обработчик:
const button = document.getElementById('myButton');

const handler = () => alert('Boom 1!');
button.addEventListener('click', handler);
button.removeEventListener('click', handler);

/**
 Обратите внимание на то, что удаление сработает только в том случае, если вы передадите в функцию removeEventListener ту же самую функцию. Не "такую же по структуре", а именно ту же самую, другими словами такой код не удалит нужный обработчик:
 */
const button = document.getElementById('myButton');

button.addEventListener('click', () => alert('Boom 1!'));
button.removeEventListener('click', () => alert('Boom 1!'));

/**
 В процессе выполнения обработчиков могут возникать новые события, как от действий пользователя, так и программно, в самих обработчиках, а некоторые события всегда возникают целым блоком, например mouseup и click. Но это не означает что выполнение кода сразу переключается на обработку этих событий. Вместо этого, события складываются в очередь и будут выполнены строго последовательно.

 Но некоторые события, все же, берутся в обработку сразу. Это касается тех событий, которые генерируются программно, например onfocus.

 Возникает закономерный вопрос, что происходит со страницей во время выполнения обработчика? И здесь возможны варианты. Если обработчик выполняет некоторый код синхронно, например занимается вычислениями, то в этот момент, блокируется все остальное (не считая webworkers) и страница замирает (говорят фризится).

 Если такое поведение длится слишком долго, то некоторые браузеры зависают, а другие предлагают закрыть вкладку. Отсюда вывод, обработчики должны выполнять свою задачу максимально быстро. Если задача долгая и синхронная, то ее можно вынести либо в webworker, либо разбить на этапы, фактически реализовав кооперативную многозадачность (основы операционных систем, в любой книге). Самый простой способ сделать это, переодически прерывать выполнение и продолжать выполнять через setTimeout. Это позволит выполниться остальным событиям.

 А что если задача асинхронная, например выполняется запрос к серверу? В таком случае все продолжает прекрасно работать.

 Вообще говоря, из этого урока должно стать понятно, почему js именно такой, какой есть. Событийная система возможна только в асинхронном коде. По сути, при загрузке страницы происходит инициализация и установка обработчиков, а дальше, как правило, не выполняется никакой код, вся страница находится в ожидании действий от пользователя.

 # Объект события

 С каждым возникающим событием связана информация, зависящяя от типа события. Например событие click это не только факт сам по себе, но так же и координаты точки на экране, где был совершен клик. Эта информация доступна через специальный объект-событие.

 <div id="myElement">Бум!</div>
 const button = document.getElementById('myElement');
 */

button.addEventListener('click', e => alert(e.target.textContent));

/**
 По умолчанию этот объект передается всегда, в любой обработчик, как единственный параметр. Если он вам не нужен, то его можно проигнорировать.

 Базовые свойства объекта Event:
 - event.target - элемент на котором произошло событие
 - event.type - тип события

 У каждого типа событий свой набор свойств, подробнее о них смотрите в документации https://developer.mozilla.org/en/docs/Web/Events/click.


 # Действие по умолчанию

 Некоторые элементы в DOM обладают действиями по умолчанию. Например если повесить обработчик на клик по ссылке, то выполнив этот клик, мы внезапно перейдем на другую страницу, ту которая была указана в href. Здесь мы видим пример того самого действия по умолчанию, на которое никак не влияет наличие обработчиков. Чтобы отменить это действие, а такое бывает нужно часто, необходимо вызвать метод event.preventDefault() внутри обработчика.

 <a href="#" id="myElement">Бум!</a>
 */

const button = document.getElementById('myElement');

button.addEventListener('click', (e) => {
    e.preventDefault();

    alert(e.target.textContent);
});

/**
 Иногда вы можете встретить такой код:
 <a href="#" id="myElement" onclick="alert('hey'); return false;">Бум!</a>

 Возврат false внутри значения атрибута, приводит к такому же эффекту.

 Действиями по умолчанию обладают следующие элементы:
 - Клик по ссылке приводит к переходу на страницу указанную в href атрибуте.
 - Клик на кнопку с типом submit начинает отправку формы на сервер.
 - Вращение колесом мышки в textarea передвигает текст если он не помещается
 - Вызов контекстного меню с помощью правого клика мышки


 # Оживление страницы

 В промышленной разработке, как правило, в первую очередь используются уже написанные кем-то компоненты, и только в крайнем случае используются свои. Большая часть этих компонентов реализована таким образом, что может работать с любым сайтом и с минимальным уровнем конфигурирования. Вплоть до того, что вам даже не придется вызвать js для его работы.

 Существует несколько подходов, которые используются для подключения компонентов на странице:

 # Через класс

 Здесь все очень просто. Для работы компонента требуется наличие определенного класса у тега. Иногда есть класс по умолчанию, который описан в документации, но его можно и поменять.


 <select class="style-select">
 <option>1</option>
 <option>2</option>
 </select>

 <script>
 styleSelect('select.style-select');
 </script>

 # Через data-* атрибуты

 Этот подход более гибкий и, например, активно используется в Bootstrap. Вместо указания классов, каждый компонент определяет свой data-* атрибут (или набор таких атрибутов). Одно из преимуществ перед классами заключается в том, что, в отличие от класса, атрибут имеет значение и это можно использовать.

 Библиотека jquery-ujs, изначально написанная для rails (но подходит для всего), позволяет очень легко получать разные возможности в html без прямого использования js. Например мы можем захотеть сделать отправку по ссылке используя глагол POST. С этой библиотекой достаточно написать следующее:

 <a href="page/url" data-method="post">Submit</a>

 Возможно мы хотим подтверждение действия перед выполнением. Делается это крайне просто:
 <a href="page/url" data-confirm="Are you sure?">Submit</a>


 Точно так же в Bootstrap работают почти все компоненты. Например выпадающее меню:
 <div class="dropdown">
 <button class="btn btn-secondary dropdown-toggle" type="button" data-toggle="dropdown">
 Dropdown button
 </button>
 <div class="dropdown-menu">
 <a class="dropdown-item" href="#">Action</a>
 <a class="dropdown-item" href="#">Another action</a>
 <a class="dropdown-item" href="#">Something else here</a>
 </div>
 </div>
 */


/***@@
 В Bootstrap есть компонент nav. Один из вариантов этого компонента, это табы, которые переключаются, по нажатию, без перезагрузки страницы.

 <ul class="nav nav-tabs" role="tablist">
 <li class="nav-item">
 <a class="nav-link active" data-toggle="tab" href="#home3" role="tab">Home 2</a>
 </li>
 <li class="nav-item">
 <a class="nav-link" data-toggle="tab" href="#profile3" role="tab">Profile 2</a>
 </li>
 </ul>


 <!-- Tab panes -->
 <div class="tab-content m-3">
 <div class="tab-pane active" id="home3" role="tabpanel">
 Home
 </div>
 <div class="tab-pane" id="profile3" role="tabpanel">
 Profile
 </div>
 </div>

 <!-- Nav tabs -->
 <ul class="nav nav-tabs" role="tablist">
 <li class="nav-item">
 <a class="nav-link active" data-toggle="tab" href="#home" role="tab">Home</a>
 </li>
 <li class="nav-item">
 <a class="nav-link" data-toggle="tab" href="#profile" role="tab">Profile</a>
 </li>
 <li class="nav-item">
 <a class="nav-link" data-toggle="tab" href="#messages" role="tab">Messages</a>
 </li>
 <li class="nav-item">
 <a class="nav-link" data-toggle="tab" href="#settings" role="tab">Settings</a>
 </li>
 </ul>

 <!-- Tab panes -->
 <div class="tab-content m-3">
 <div class="tab-pane active" id="home" role="tabpanel">
 Home
 </div>
 <div class="tab-pane" id="profile" role="tabpanel">
 Profile
 </div>
 <div class="tab-pane" id="messages" role="tabpanel">
 Messages
 </div>
 <div class="tab-pane" id="settings" role="tabpanel">
 Settings
 </div>
 </div>

 <ul class="nav nav-tabs" role="tablist">
 <li class="nav-item">
 <a class="nav-link active" data-toggle="tab" href="#home2" role="tab">Home 2</a>
 </li>
 <li class="nav-item">
 <a class="nav-link" data-toggle="tab" href="#profile2" role="tab">Profile 2</a>
 </li>
 </ul>

 <!-- Tab panes -->
 <div class="tab-content m-3">
 <div class="tab-pane active" id="home2" role="tabpanel">
 Home
 </div>
 <div class="tab-pane" id="profile2" role="tabpanel">
 Profile
 </div>
 </div>

 </div>

 По клику на таб происходит следующее:
 - Класс active снимается с текущего элемента меню
 - У ссылки и дива с данными добавляется класс active

 Общий принцип работы в том, что каждый таб представлен ссылкой с href в виде хеша #profile, а ниже определен div с id равным profile. По клику на таб, код должен извлечь id, найти соответствующий элемент и сделать его активным, не забыв при этом снять класс active с таба который был активным до клика.

 src/application.js
 Реализуйте логику переключения табов.

 Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов nav.

 Технически, бутстрап ориентируется на наличие аттрибута data-toggle и именно по нему решает активировать ли динамическое поведение для компонента nav. Если его нет, значит данное меню не динамическое.
 */

const handle = ({ target }) => {
    const nav = target.closest('.nav');
    const current = nav.querySelector('a.active');
    current.classList.remove('active');
    const currentTabContentId = current.hash.slice(1);
    const currentTabContent = document.getElementById(currentTabContentId);
    currentTabContent.classList.remove('active');

    target.classList.add('active');
    const nextTabContentId = target.hash.slice(1);
    const nextTabContent = document.getElementById(nextTabContentId);
    nextTabContent.classList.add('active');
};

const links = document.querySelectorAll('a[data-toggle]');

links.forEach((element) => {
    element.addEventListener('click', handle);
});




// >>>>>> Перехват и всплытие <<<<<<

/**
 Предположим что у нас есть два вложенных элемента, на каждом из которых висит обработчик события click. Если выполнить щелчок по области внешнего элемента, не затрагивающей внутренний, то выполнится обработчик, привязанный к этому внешнему элементу. Если выполнить щелчок по внутреннему элементу, автоматически выполнится щелчок и по внешнему, а значит, отработают оба события.

 <div>
 <button>Send</button>
 </div>
 */

button.addEventListener('click', () => alert('Boom 1!'));
div.addEventListener('click', () => alert('Boom 2!'));

/**
 Возникает закономерный вопрос, в каком порядке выполнятся эти события после щелчка на кнопку? В общем случае, событие проходит сквозь дерево начиная от корня до самого глубокого элемента, на котором событие сработало, и затем, в обратном направлении. Путешествия события туда и обратно, называется его стадиями или фазами, ниже о них подробнее.


 # Погружение (Capturing)

 Когда событие только возникло, оно начинает двигаться по DOM-дереву, начиная от корневого узла, до самого глубокого, на котором произошло событие. Попутно выполняются все обработчики связанные с этим событием.

 | |
 ---------------| |---------------
 | div          | |              |
 |   -----------| |-----------   |
 |   | button   \ /          |   |
 |   -------------------------   |
 |        Event CAPTURING        |
 ---------------------------------

 На стадии погружения выполняются не все обработчики, а только те которые были привязаны к этой стадии. Привязка регулируется третьим параметром функции addEventListener.
 */

button.addEventListener('click', () => alert('Boom 1!'), true);
div.addEventListener('click', () => alert('Boom 2!'), true);

/**
 Значение true привязывает обработчики к стадии погружения. Получится такой вывод:
 Boom 2!
 Boom 1!

 # Всплытие (Bubbling)

 После остановки погружения на target элементе, начинается всплытие.

 / \
 ---------------| |---------------
 | div          | |              |
 |   -----------| |-----------   |
 |   | button   | |          |   |
 |   -------------------------   |
 |        Event BUBBLING         |
 ---------------------------------


 Именно эта стадия подразумевается при вызове addEventListener без указания третьего параметра.
 */

button.addEventListener('click', () => alert('Boom 1!'));
div.addEventListener('click', () => alert('Boom 2!'));

/**
 На ней выполнение обработчиков происходит изнутри наружу:
 Boom 1!
 Boom 2!


 # W3C Модель

 Согласно стандарту, большинство событий проходят обе стадии, сначала погружаясь в глубину дерева и затем поднимаясь до самого верха. Стадия погружения, при этом, используется крайне редко, большая часть обработчиков вешается на стадию всплытия.

 В предыдущем уроке, мы познакомились с объектом e.target. Это самый глубокий элемент до которого идет погружение. Target не меняется в процессе всплытия. Благодаря нему всегда можно узнать где конкретно произошло событие. Кроме него, доступен объект currentTarget - это элемент, к которому прикреплен данный обработчик. В зависимости от ситуации используется тот или иной.

 В обычной ситуации событие должно всплывать до конца, но иногда могут возникать ситуации, когда всплытие нежелательно.

 Сделать это можно двумя способами:
 */
event.stopPropagation()
event.stopImmediatePropagation()

// Первый останавливает всплытие, но дает возможность доработать всем обработчикам, которые висят на текущем элементе, второй же, не дает выполнится больше ни одному обработчику.


/***@@
 Игра в 15 или пятнашки — популярная головоломка, придуманная в 1878 году Ноем Чепмэном. Представляет собой набор одинаковых квадратных костяшек с нанесёнными числами, заключённых в квадратную коробку. Длина стороны коробки в четыре раза больше длины стороны костяшек для набора из 15 элементов, соответственно в коробке остаётся незаполненным одно квадратное поле. Цель игры — перемещая костяшки по коробке, добиться упорядочивания их по номерам, желательно сделав как можно меньше перемещений.

 | 1  | 2  | 9  | 12 |
 |----|----|----|----|
 | 4  | 3  | 8  | 10 |
 |----|----|----|----|
 | 15 | 14 | 5  | 7  |
 |----|----|----|----|
 | 11 | 13 | 6  |    |

 src/application.js

 Реализуйте эту игру внутри функции экспортируемой по-умолчанию, учитывая следующие моменты:

 - Перемещение происходит по клику. Если номер, на котором был клик, находится рядом с пустой областью, то он перемещается на эту область. Если пустой области рядом нет, то ничего не происходит.
 - При перемещении числа, из текущей ячейки удаляется класс table-active и добавляется на ту, откуда происходит перемещение (та что становится пустой).
 - В файле уже заданы values, в том порядке в котором они должны появляться в выводе. Для упрощения тестирования, этот порядок всегда один и тот же.
 - В файле index.html находится div с классом gem-puzzle, именно к нему нужно привязывать игру.

 html первой позиции должен получиться таким:

 <div class="gem-puzzle">
 <table class="table-bordered">
 <tbody>
 <tr>
 <td class="p-3">8</td>
 <td class="p-3">11</td>
 <td class="p-3">7</td>
 <td class="p-3">12</td>
 </tr>
 <tr>
 <td class="p-3">3</td>
 <td class="p-3">15</td>
 <td class="p-3">6</td>
 <td class="p-3">10</td>
 </tr>
 <tr>
 <td class="p-3">2</td>
 <td class="p-3">5</td>
 <td class="p-3">13</td>
 <td class="p-3">14</td>
 </tr>
 <tr>
 <td class="p-3">9</td>
 <td class="p-3">1</td>
 <td class="p-3">4</td>
 <td class="p-3 table-active"></td>
 </tr>
 </tbody>
 </table>
 </div>


 Теги и классы должны совпадать.

 Подсказки
 - Используйте дополнительную навигацию доступную в таблицах: rows, cells.
 - Достаточно повесить событие на всю таблицу и использовать возможности всплытия
 - У cell есть свойство cellIndex у row есть свойство rowIndex
 */

// FILE: /app/public/index.html:
/**
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

 <!-- Bootstrap CSS -->
 <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
 </head>
 <body>
 <div class="container m-3">
 <div class="gem-puzzle"></div>
 </div>
 <script src="/vendors~main.js" ></script>
 <script src="/main.js" ></script>
 </body>
 </html>
 */

// FILE: /app/src/index.js:
import app from './application';

app();


// FILE: /app/src/application.js:
const values = [8, 3, 2, 9, 11, 15, 5, 1, 7, 6, 13, 4, 12, 10, 14];

const generatePlayingField = () => {
    const tableEl = document.createElement('table');

    tableEl.className = 'table-bordered';

    for (let i = 0; i < 4; i += 1) {
        const row = tableEl.insertRow(); // добавляет новую строку в таблицу и возвращает на неё ссылку.

        for (let j = 0; j < 4; j += 1) {
            const cell = row.insertCell(); // метод вставляет ячейку в текущей строке.

            cell.className = 'p-3';

            if (i === 3 && j === 3) {
                cell.classList.add('table-active');
            } else {
                cell.textContent = values[i + (j * 4)];
            }
        }
    }

    return tableEl;
};

const getDistance = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);

export default () => {
    let currentPosition = { x: 3, y: 3 };
    const tableEl = generatePlayingField();

    tableEl.addEventListener('click', (e) => {
        const cell = e.target;
        const { cellIndex, parentElement: { rowIndex } } = cell;
        const newPosition = { y: rowIndex, x: cellIndex };
        const distance = getDistance(currentPosition, newPosition);

        if (distance !== 1) {
            return;
        }

        const point = tableEl.rows[currentPosition.y].cells[currentPosition.x];
        point.textContent = cell.textContent;
        point.classList.remove('table-active');
        cell.textContent = '';
        cell.classList.add('table-active');
        currentPosition = { x: cellIndex, y: rowIndex };
    });

    const root = document.querySelector('.gem-puzzle');
    root.append(tableEl);
};

// >>>>>> События документа <<<<<<

/**
 Кроме событий, которые возникают в ответ на действия пользователей, существует ряд событий, которые живут своей жизнью. К таким событиям относятся события на загрузку и выгрузку страницы:

 - DOMContentLoaded – DOM-дерево построено
 - load – все ресурсы загружены (картинки, стили, скрипты, ...)
 - beforeunload - уйти со страницы

 DOMContentLoaded возникает в тот момент, когда DOM дерево полностью построено и готово к работе, но, при этом, стили, скрипты и картинки могут находиться в процессе загрузки.

 Это событие происходит на document:
 */

document.addEventListener('DOMContentLoaded', () => {
    const coll = document.querySelectorAll('.help');
    [...coll].forEach(el => el.classList.add('hidden'));
});

/**
 Скорость построения DOM дерева, очень зависима от тегов <script>. По стандарту, любой <script> встреченный в HTML будет выполняться до полного построения дерева. Следовательно скорость отработки кода в этом блоке <script> будет сильно влиять на то, когда пользователь увидит сам сайт и то, когда сработает событие DOMContentLoaded.

 Поскольку DOM полностью готов только тогда, когда срабатывает событие DOMContentLoaded, многие механизмы активизируются именно на нем, например, браузерная подстановка значений в поля форм. По этой же причине, большинство сайтов, инициализируют интерфейсы также на этом событии.

 Тема оптимизации загрузки скриптов и быстрой инициализации достаточно сложна. Это связано не только с большим количеством факторов влияющих на порядок и скорость, но так же и с тем, что в разных браузерах этот механизм работает по разному. Здесь мы не будем его разбирать, это тема продвинутого уровня и по ней написано множество статей.

 Обратите внимание на красную и синюю полоску. Красная показывает момент когда сработало событие load, а синяя - DOMContentLoaded. Внизу картинки указано время срабатывания каждого события, от начала загрузки страницы.

 Из картинки видно, что браузер сначала скачивает саму страницу (ее html), а затем начинает скачивать ресурсы (картинки, стили и скрипты), причем делает это параллельно.
 */


// >>>>>> AJAX <<<<<<

/**
 Манипуляции с dom деревом помогают сделать наши сайты более живыми, но их все же недостаточно для создания автономных виджетов или полноценных (имеющих бекенд) Single Page Application (SPA).

 Рассмотрим конкретный пример. Многие сервисы дают возможность использовать разные виджеты, например, погода или курсы валют. Работает это так: вы вставляете в свой html код предоставленный сервисом. Далее этот код подгружает сам виджет и периодически обращается за необходимыми данными на сервера сервиса. Это может происходить в тот момент, когда пользователь виджета нажимает кнопки, требующие новых данных: например, показать погоду за следующую неделю.

 Кстати, подобный виджет используется на Хекслете. В уроке в правом нижнем углу есть пункт "Техподдержка", а вне уроков в углу висит синий кружочек. По нажатию появляется специальная форма обратной связи. Она предоставлена специальным сервисом, который помогает нам обрабатывать фидбек от пользователей, причем работа этой формы никак не связана с бекендом Хекслета.

 Ключевая технология в этой истории, механизм для выполнения http запросов прямо из браузера. Именно его называют AJAX, что расшифровывается как "Asynchronous JavaScript and XML". Несмотря на название, эта технология работает не только с xml.

 # XMLHttpRequest

 До появления html5, браузеры предоставляли (и сейчас предоставляют) специальный объект XMLHttpRequest:
 */

const request = new XMLHttpRequest();

request.onreadystatechange = () => {
    if (this.readyState == 4 && this.status == 200) {
        document.getElementById('demo').innerHTML = this.responseText;
    }
};

request.open('GET', '/api/v1/articles/152.json', true);
request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
request.send();

/**
 Работать с ним крайне неудобно и, по сути, все использовали обертку созданную в рамках библиотеки JQuery. Подробнее об этом будет в уроке посвященному JQuery.

 # Fetch

 С появлением стандарта HTML5, появился новый механизм для http запросов:
 */

// const promise = fetch(url[, options]);
fetch('/api/v1/articles/152.json')
    .then((response) => {
        console.log(response.status); // 200
        console.log(response.headers.get('Content-Type'));

        return response.json();
    })
    .then((article) => {
        console.log(article.title); // Как использовать fetch?
    })
    .catch(console.error);

/**
 Как видно, fetch это функция возвращающая промис, а значит работать с ней удобно и приятно. А благодаря наличию полифиллов можно не переживать о том что какой-то браузер не поддерживает этот механизм.

 Обратите внимание на то что response.json тоже возвращает промис. Кроме json данные можно получать используя функции blob, text, formData и arrayBuffer.

 Отправка формы POST запросом:
 */

const form = document.querySelector('form');

fetch('/users', {
    method: 'POST',
    body: new FormData(form),
});


// Отправка формы как json:
fetch('/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        name: 'Hubot',
        login: 'hubot',
    })
})

/**
 При всех своих преимуществах, fetch довольно низкоуровневый механизм. Например работая с json (очень частый вариант), придется самостоятельно выставлять заголовки и делать разные манипуляции с данными, которые можно было бы автоматизировать.

 На практике, это привело к созданию различных библиотек, которые работают схожим образом, но дают гораздо больше возможностей. Причем многие из этих библиотек изоморфные, то есть работают одинаково и в браузере и на сервере. Одна из самых популярных библиотек на момент создания курса - axios https://github.com/mzabriskie/axios.


 # URL

 Как мы знаем из предыдущих курсов, клеить строчки для работы с путями или урлами это плохая идея. Можно легко ошибиться и, в целом, приходится выполнять работу, которую может выполнять машина. В Node.js с этим никаких проблем, у нас есть соответствующие модули, а вот в браузере это всегда вызывало сложности. Распарсить url или собрать легко и просто не получалось.

 С одной стороны, можно всегда воспользоваться сторонними библиотеками, которых достаточно много, но с другой, в браузерах уже есть встроенный для этого механизм (как обычно добавляется полифиллами).
 */

const url = new URL('../cats', 'http://www.example.com/dogs');
console.log(url.hostname); // www.example.com
console.log(url.pathname); // /cats

url.hash = 'tabby';
console.log(url.href); // http://www.example.com/cats#tabby

url.pathname = 'démonstration.html';
console.log(url.href); // http://www.example.com/d%C3%A9monstration.html

// Что особенно приятно, fetch умеет работать с объектом URL напрямую:
const response = await fetch(new URL('http://www.example.com/démonstration.html'));

// А вот как можно работать с query параметрами:
// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get('id')); // 123
parsedUrl.searchParams.append('key', 'value')
console.log(parsedUrl); // https://some.site/?id=123&key=value

/**
 # HTTP access control (CORS)

 В отличие от бекенда, http запросы на клиенте могут использоваться злоумышленниками для кражи данных. Поэтому браузеры контролируют то, куда и как делаются запросы.

 Подробно об этом механизме можно прочитать тут https://habr.com/ru/company/ruvds/blog/421347/
 */



/***@@
 Задача этого упражнения состоит в том чтобы реализовать автокомплит по странам. На странице присутствует элемент input, с аттрибутами data-autocomplete и data-autocomplete-name, к которому нужно привязаться. Атрибут data-autocomplete содержит ссылку, по которой нужно делать запрос на данные. Атрибут data-autocomplete-name содержит имя, по которому необходимо найти на странице список ul с точно таким же аттрибутом и значением. В этом списке выводятся данные.

 src/application.js
 Реализуйте автокомплит по странам.

 Как только в поле ввода появляется хотя бы один символ, необходимо выполнить запрос на сервер с параметром term значением которого, будет строка введенная в input. Сервер возвращает массив из стран (на английском языке).

 Если этот массив не пустой, то нужно заполнить список (посмотреть его нахождение можно либо через public/index.html либо открыв исходный код страницы в веб доступе) таким образом:

 <ul data-autocomplete-name="country">
 <li>pakistan</li>
 <li>panama</li>
 <li>paraguay</li>
 </ul>
 Если с сервера пришел пустой список то нужно вывести:

 <ul data-autocomplete-name="country">
 <li>Nothing</li>
 </ul>

 Подсказки
 Для формирования правильного запроса на сервер, используйте URL https://nodejs.org/api/url.html#url_url_strings_and_url_objects
 Значение поля input необходимо брать из события так: e.target.value
 Используйте async/await
 Ваш код должен работать даже в том случае если на странице множество автокомплитов
 Используйте событие input https://developer.mozilla.org/en-US/docs/Web/Events/input
 */

// FILE: /app/public/index.html:
/**
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

 <!-- Bootstrap CSS -->
 <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
 </head>
 <body>
 <div id="container" class="container m-3">
 <div class="row">

 <div class="col-6">
 <div class="form form-inline">
 <div class="form-group">
 <label>Country</label>
 <input type="text" data-autocomplete-name="country" data-autocomplete="/countries.json" class="form-control">
 </div>
 </div>
 </div>
 <div class="col-6">
 <ul data-autocomplete-name="country">
 <li>Nothing</li>
 </ul>
 </div>
 </div>
 </div>
 <script src="/vendors~main.js" ></script>
 <script src="/main.js" ></script>
 </body>
 </html>
 */

import '@babel/polyfill';
import 'whatwg-fetch';

export default () => {
    const autocompleteElements = document.querySelectorAll('input[data-autocomplete]');

    autocompleteElements.forEach((el) => {
        const route = el.dataset.autocomplete;

        el.addEventListener('input', async (e) => {
            const dataAutocompleteName = el.dataset.autocompleteName;
            const oldList = document.querySelector(`ul[data-autocomplete-name="${dataAutocompleteName}"]`);
            const url = new URL(route, window.location.origin);
            url.searchParams.append('term', e.target.value);
            const response = await fetch(url);
            const countries = await response.json();
            const list = document.createElement('ul');
            list.dataset.autocompleteName = dataAutocompleteName;

            if (countries.length === 0) {
                countries.push('Nothing');
            }
            countries.forEach((country) => {
                const li = document.createElement('li');
                li.textContent = country;
                list.append(li);
            });

            oldList.replaceWith(list);
        });
    });
};



// >>>>>> JQuery <<<<<<

/**
 В августе 2006 года Джон Резиг выпустил библиотеку JQuery. За короткое время эта библиотека завоевала огромную популярность и стала стандартом де-факто при разработке интерактивных элементов на сайтах.
 */

// Знак $ — это функция JQuery, через которую все и делается
$(() => {
    // Эта функция выполнится на событие DOMContentLoaded
});

/**
 Во многом, это случилось, потому что JQuery появилась в нужное время в нужном месте. В те года шел переход к верстке без использования таблиц, и css использовался все активнее и разнообразнее. JQuery позволил переиспользовать те же самые селекторы для добавления поведения.

 К тому же, в JQuery был реализован CSS3 гораздо раньше, чем он появился нативно в самих браузерах. Более того, JQuery в принципе позволила практически не думать о разных браузерах, так как ее задачей было, в том числе, обеспечить работоспособность на всех платформах.
 */

// Работает так же, как и document.querySelectorAll
const spans = $('.section span');

/**
 Еще одной причиной успеха стало то, что JQuery популяризовал отделение верстки от поведения. Такую технику называют "ненавязчивый javascript". Ее идея в том, что обработчики событий описываются не в самих тегах, а отдельно:
 */

$('button').click(() => {
    alert('hey!');
});

/**
 Вместо:
 <button onclick="alert('hey!')">

 Сам JQuery при этом является прекрасным примером DSL (предменто-ориентированный язык). Как правило, код на JQuery выражает задачу в тех же терминах, в которых эта задача формулируется:
 */

$('container.main').hide();
$('#address').remove();

// Fluent interface
$('#p1').css('color', 'red').slideUp(2000).slideDown(2000);

/**
 И это еще не все. JQuery долгое время предоставляла единственный нормальный способ делать AJAX запросы и анимацию на страницах. А благодаря расширяемости, за счет плагинов, экосистема библиотеки за десяток лет стала фантастических размеров. В какой-то период времени любая библиотека для фронтенда появлялась как плагин к JQuery. Вплоть до того, что некоторые люди вообще не догадываются о существовании javascript и DOM. Они сразу начали с JQuery и видят мир только сквозь него.


 # Манипуляции

 Функция $ — это единая точка входа для всего. Если ее вызвать и передать внутрь строчку, то JQuery считает, что строка — это селектор, и нужно сделать выборку элементов DOM. Этот вызов аналогичен вызову querySelectorAll, с тем лишь отличием, что возвращается специализированная коллекция.

 Более того, JQuery, в принципе, работает с элементами как с коллекциями, даже если это один элемент. И любые изменения применяются сразу ко всем элементам коллекции без необходимости итерирования.
 */

// Selecting all <h1> tags.
const headings = $('h1');
const firstHeader = headings.get(0); // извлечение DOM элемента

// Ниже два эквивалентных примера
headings.addClass('header');
headings.each((i, header) => $(header).addClass('header'));

// В последнем примере, во время итерации, в функцию передается именно DOM нода. Чтобы сделать из нее JQuery коллекцию, придется делать оборачивание: $(domNode).

// Если был найден один заголовок
const link = $('#home');
link.html('link to home'); // val(), text()
link.attr('href', '/about'); // prop(), css()
console.log(link.attr('href')); // /about

/**
 Выше приведено несколько примеров функций, изменяющих дом элемент и его потомков. Главная особенность JQuery здесь в том, что если вызвать эти функции без параметров, то они возвращают значение, если вызвать с параметрами, то изменяют.

 # События
 */
$('button').click(() => {
    $('#w3s').attr('href', (i, origValue) => `${origValue}/jquery`);
});

// Либо так:
$('button').on('click', () => {
    $('#w3s').attr('href', (i, origValue) => `${origValue}/jquery`);
});

// # AJAX

const jqxhr = $.get('/api/v1/companies.json', (data) => {
    console.log('success');
})
    .done(() => {
        console.log('success');
    })
    .fail(() => {
        console.log('fail');
    })
    .always(() => {
        console.log('finished');
    });

/**
 Как видно из примера выше, интерфейс промисов JQuery не совпадает с принятым стандартом.

 # Анимация

 <div id="clickme">
 Click here
 </div>
 <img id="book" src="book.png" alt="" width="100" height="123">
 */

// With the element initially hidden, we can show it slowly:
$('#clickme').click(() => {
    $('#book').show('slow', () => {
        // Animation complete.
    });
});

/**
 # JQuery UI

 Это группа плагинов к JQuery, которая реализует типичную функциональность, необходимую при разработке интерактивных сайтов, например, перетаскивание, автокомплит, изменение размеров, сортировка и многое другое.


 # Перспективы

 В свое время JQuery была прекрасным выбором, но это время уходит. С момента выхода библиотеки веб ушел вперед. Стандарт DOM развился настолько, что многие вещи делать напрямую удобнее, чем через JQuery, а поддержка самого стандарта браузерами достаточно высока. В тех местах, где поддержки не хватает, всегда есть полифиллы. К тому же появились новые стандарты, в которые JQuery не вписывается. Ярким примером служат промисы и тот же AJAX.

 Все это приводит к тому, что постепенно происходит отказ от JQuery. Для любых задач на фронтенде можно найти множество популярных библиотек, которые в своей нише будут лучше, чем то, что предлагает JQuery.

 Есть еще один очень важный аспект. Хотя JQuery и позволила упростить работу с DOM (когда он был плох), этого недостаточно для создания по-настоящему сложных интерактивных сайтов. В 2015 году я делал доклад на эту тему, где подробно объяснял, почему прямое манипулирование домом (пусть даже через JQuery) — концептуально неверный путь. Такой подход срабатывает в тривиальных ситуациях, а дальше всё очень быстро усложняется.

 Поэтому современные проекты строят с использованием React, Vue, Angular и других фреймворков, а JQuery не используют совсем.

 С другой стороны, на JQuery уже столько понаписано, что его требуют знать в любой вакансии, связанной с фронтендом. Как вы могли убедиться исходя из примеров выше, ничего сложного и фантастического в JQuery нет. Более того, в первую очередь надо знать DOM, а остальное — это просто внимательное чтение документации и примеров использования.
 */

/***@@
 В Bootstrap есть компонент Carousel.

 Этот слайдер устроен также как и все остальное в бутстрапе. В верстке определяются data аттрибуты, по которым бутстрап понимает что это карусель и оживляет ее.

 На слайдере отображаются две стрелки, одна влево другая вправо. Клики по этим стрелкам приводят к перемотке слайдов по кругу. С точки зрения DOM происходит следующее:
 - Класс active снимается с текущего элемента .carousel-item
 - Активный элемент получает класс active

 application.js
 Реализуйте логику слайдера в функции экспортированной по умолчанию.

 Постройте свою логику так, чтобы она позволила использовать на одной странице любое количество компонентов carousel с любым количеством картинок внутри.
 */

import _ from 'lodash';
import $ from 'KNOWLEDGE/JS/jQuery';

export default () => {
    const carousels = $('[data-ride="carousel"]');

    carousels.each((index, carousel) => {
        const root = $(carousel);
        const slides = root.find('.carousel-item');
        const maxIndex = slides.length - 1;
        let currentIndex = _.findIndex(slides, slide => $(slide).hasClass('active'));

        const handlerGenerator = next => () => {
            const newCurrentIndex = next(currentIndex);
            slides.removeClass('active');
            slides.filter(id => id === newCurrentIndex).addClass('active');
            currentIndex = newCurrentIndex;
        };

        const prev = root.find('[data-slide="prev"]');
        prev.click(handlerGenerator(i => (i === 0 ? maxIndex : i - 1)));

        const next = root.find('[data-slide="next"]');
        next.click(handlerGenerator(i => (maxIndex === i ? 0 : i + 1)));
    });
};




// >>>>>> Состояние приложения <<<<<<

/**
 Манипулирование домом — задача простая только в самых примитивных ситуациях. Как только понадобится реализовать полноценное, пусть и небольшое, приложение, код моментально превращается в тыкву. Десятка обработчиков достаточно для того чтобы потеряться. С каждым новым событием сложность кода растет еще быстрее, а, ведь, в реальных приложениях событий сотни. Почему так происходит?

 Хотя подобная проблема касается не только фронтенда, именно в нем, она достигает своего апогея. Событийная архитектура и дом, без должного внимания, порождают запутанный код буквально сразу. Понятно что где-то здесь появляется Архитектура, но где конкретно и как, это вопрос.

 Подойдем к правильной архитектуре со стороны бекенда. Как вы уже знаете или догадываетесь, в бекенде приложения состоят минимум из двух частей - базы данных и собственно самого кода. Формы отправляемые на сервер, изменяют состояние приложения, которое хранится в базе, далее, на основе этого состояния формируется ответ в виде HTML страницы.

 По сути, в типичных веб проектах, приложение занимается двумя вещами, либо обновляет данные в базе, либо извлекает эти данные и на основе них формирует HTML. Необходимость базы данных довольно очевидна и понятна для всех, но тоже самое не очевидно во фронтенде, DOM позволяет хранить состояние внутри себя и более того, провоцирует так делать. На протяжении курса мы встречались с этой ситуацией не раз, когда нужно выполнить некоторое действие, а оно зависит от того что сейчас на экране. Для анализа приходилось лезть в DOM и смотреть что же там происходит. Первый шаг в построении правильной архитектуры, состоит в выделении состояния из дома, в некое подобие базы данных, основанной на обычном объекте js. При такой организации кода, вырисовывается следующая схема работы:

 - Возникает событие
 - Меняется состояние
 - Обновляется DOM

 <div id="result">0</div>
 <button id="increment">+</button>
 <button id="decrement">-</button>
 */

const app = () => {
    let counterValue = 0

    const result = document.getElementById('result');

    const incHandler = () => {
        counterValue += 1;
        result.textContent = counterValue;
    };

    const decHandler = () => {
        counterValue -= 1;
        result.textContent = counterValue;
    };

    const inc = document.getElementById('increment');
    inc.addEventListener('click', incHandler);

    const dec = document.getElementById('decrement');
    dec.addEventListener('click', decHandler);
};

app();


/**
 Главная особенность кода выше, в том как идет работа с состоянием. Здесь нет никаких обращений к дому для извлечения текущего значения, оно хранится в переменной и доступно для всех обработчиков. Обратите внимание на структуру кода. Состояние и навешивание колбеков находятся внутри функции. Это важно, как минимум, по двум причинам. Во-первых, такой подход позволяет использовать данный файл как модуль, импортировать из него другие функции (если они там есть) и, например, тестировать их. Если код вызывается на уровне модуля, то импорт привел бы к его немедленному исполнению. Во-вторых, состояние локально (оно определено внутри функции), а значит мы можем запустить несколько версий приложения, это особенно актуально при написании тестов. Напротив, определение состояния на уровне модуля, сделало бы его "синглотоном" (что-то существующее в единственном экземпляре), другими словами, состояние было бы всегда одним и общим для всего кода, который его использует. Не было бы возможности начать с чистого листа.

 Перед тем как смотреть более сложный пример, в котором состояние представлено объектом, давайте разберемся с тем, что включает в себя понятие состояние. Если коротко, то состояние это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере. Их количество и содержимое меняются в зависимости от того, какие кнопки мы нажимаем и что пытаемся загрузить. В общем случае, любое визуальное изменение в приложении или на странице, это всегда изменение состояния и никак иначе. Невозможна ситуация при которой на странице сайта меняется какая-то деталь, но состояние при этом остается тем же. Изменение представления возможно только на основе изменения состояния. Вы можете возразить, что анимация через CSS не меняет ничего в нашем приложении и будете правы лишь на половину. Да, анимация в css не связана с нашим приложением, но внутри браузера это состояние есть и оно меняется.

 Отличным примером неочевидного, для начинающего фронтенд специалиста, состояния, служит состояние формы. Представьте себе поле для ввода телефона, которое отслеживает ошибки при вводе и сразу их показывает. Если ошибок нет, то оно позволяет выполнить сабмит формы, иначе кнопка заблокирована. Что в данном случае является состоянием? Однозначно состояние валидности данных формы: "валидно" и "не валидно". На основе этого состояния определяется обводить красной рамкой поле для ввода или нет. Ну, и, конечно, состоянием является заблокированность кнопки.

 <form>
 <input type="text" class="phone" name="phone" value="">
 <input type="submit" class="submit" disabled value="Save">
 </form>
 */

const app = () => {
    const state = {
        registrationProcess: {
            valid: true,
            submitDisabled: true,
        }
    };

    const input = document.querySelector('.phone');
    input.addEventListener('keyup', () => {
        if (input.value === '') {
            state.registrationProcess.valid = true;
            state.registrationProcess.submitDisabled = true;
        } else if (!input.value.match(/^\d+$/)) {
            state.registrationProcess.valid = false;
            state.registrationProcess.submitDisabled = true;
        } else {
            state.registrat ionProcess.valid = true;
            state.registrationProcess.submitDisabled = false;
        }

        render(state);
    });
};

const render = (state) => {
    const input = document.querySelector('.phone');
    const submit = document.querySelector('.submit');

    submit.disabled = state.registrationProcess.submitDisabled;

    if (state.registrationProcess.valid) {
        input.style.border = null;
    } else {
        input.style.border = "thick solid red";
    }
}

app();

// Как видно из примера, состояние описывается обычным js объектом, который создается при старте приложения:
const state = {
    registrationProcess: {
        valid: true,
        submitDisabled: true,
    }
};


// Нет никаких правил по формированию его структуры, как удобно так и делайте. Главное не привязывайте структуру состояния к визуальному оформлению, оформление зависит от состояния, но никак не наоборот. Пример того как делать не стоит ниже:

const state = {
    centralBlock: {
        valid: true,
        submitDisabled: true,
    },
    sideBar: {
        formValue: 'value'
    },
};

/**
 Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придется править.

 Далее обработчики событий. Они должны иметь доступ к состоянию, так как оно меняется именно в обработчиках. Поэтому обработчики определяются в той же функции где и создается состояние (главное не делать это на уровне модуля, состояние должно быть локально относительно приложения). Кроме того, обработчики это то место, где выполняются ajax запросы. В нашем примере их нет, но на будущее не забывайте.
 */

input.addEventListener('keyup', () => {
    if (input.value === '') {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = true;
    } else if (!input.value.match(/^\d+$/)) {
        state.registrationProcess.valid = false;
        state.registrationProcess.submitDisabled = true;
    } else {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = false;
    }

    render(state);
});


/**
 Последнее, что делается в обработчиках, в нашем примере, вызывается функция render, которая принимает на вход состояние и меняет DOM на его основе. Этот момент ключевой. Изменение DOM может происходить только внутри функции render. Весь остальной код может менять только состояние.

 Теперь наше приложение разделено на три независимых части: состояние, обработчики и рендеринг. Эта модель работы на тривиальных приложениях (в пару тройку обработчиков) смотрится избыточной, но если обработчиков станет хотя бы 10, то вы увидите, что с приложением достаточно удобно работать. Виден поток данных, всегда можно отследить, что изменилось и как одни части приложения зависят от других. К тому же сокращается дублирование. Например, изменение состояния может идти из разных частей приложения, но логика отрисовки при этом остается неизменной. В такой ситуации достаточно описать новый способ изменения уже существующего состояния, а рендеринг сделает все остальное.
 */

const render = (state) => {
    const input = document.querySelector('.phone');
    const submit = document.querySelector('.submit');

    submit.disabled = state.registrationProcess.submitDisabled;
    if (state.registrationProcess.valid) {
        input.style.border = null;
    } else {
        input.style.border = "thick solid red";
    }
}

/**
 Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют, более того, это основа модульности:

 - Состояние не знает ничего про остальные части системы, оно ядро.
 - Рендеринг ничего не знает про существование обработчиков, но пользуется состоянием для отрисовки
 - Обработчики знают про состояние, так как обновляют его и инициируют рендеринг

 Этот способ разделения по прежнему обладает одним важным недостатком, который мы устраним в следующем уроке, когда поговорим про MVC.
 */


/***@@
 src/application.js
 Реализуйте фильтр ноутбуков на основе формы доступной в public/index.html. Изменение любого параметра должно сразу приводить к фильтрации. Ноутбуки подходящие под фильтр выводятся внутри <div class="result"></div> как список ul/li моделей (свойство model внутри объекта представляющего ноутбук). Полный список ноутбуков доступен в файле src/application.js.

 Условия:
 - Если фильтр пустой, то выводится все.
 - Если под фильтр ничего не подходит, то список не выводится.

 Подсказки
 Для отслеживания изменений текстовых инпутов используйте событие input. Для select - change.
 */

// FILE: /app/src/application.js:
const notebooks = [
    {
        model: 'v1', processor: 'intel', frequency: 1.7, memory: 16,
    },
    {
        model: 'd3', processor: 'intel', frequency: 3.5, memory: 8,
    },
    {
        model: 'd2', processor: 'amd', frequency: 2.5, memory: 16,
    },
];

const predicates = {
    eq: value => el => String(el) === String(value),
    gt: value => el => el >= Number(value),
    lt: value => el => el <= Number(value),
};

const filterNotebooks = (query, items) => {
    const fields = Object.keys(query);
    const activeFields = fields.filter(field => query[field]);
    const result = activeFields.reduce((acc, field) => {
        const [name, predicateName] = field.split('_');
        const match = predicates[predicateName];

        return acc.filter(item => match(query[field])(item[name]));
    }, items);

    return result;
};

const render = (state) => {
    const resultElement = document.querySelector('.result');
    const filteredNotebooks = filterNotebooks(state.filter, notebooks);
    if (filteredNotebooks.length === 0) {
        resultElement.innerHTML = '';
        return;
    }

    const html = `<ul>${filteredNotebooks.map(n => `<li>${n.model}</li>`).join('')}</ul>`;
    resultElement.innerHTML = html;
};

export default () => {
    const state = {
        filter: {
            processor_eq: null,
            memory_eq: null,
            frequency_gt: null,
            frequency_lt: null,
        },
    };

    const items = [
        { name: 'processor_eq', eventType: 'change' },
        { name: 'memory_eq', eventType: 'change' },
        { name: 'frequency_gt', eventType: 'input' },
        { name: 'frequency_lt', eventType: 'input' },
    ];

    items.forEach(({ name, eventType }) => {
        const element = document.querySelector(`[name="${name}"]`);

        element.addEventListener(eventType, ({ target }) => {
            state.filter[target.name] = target.value === '' ? null : target.value;

            render(state);
        });
    });

    render(state);
};

// FILE: /app/public/index.html:
/**
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

 <!-- Bootstrap CSS -->
 <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
 </head>
 <body>
 <div class="container m-3">
 <div class="row">
 <div class="col-6">
 <form>
 <div>
 <label>Processor</label>
 <select name="processor_eq">
 <option value="">Select</option>
 <option value="intel">Intel</option>
 <option value="amd">AMD</option>
 </select>
 </div>
 <div>
 <label>Memory</label>
 <select name="memory_eq">
 <option value="">Select</option>
 <option value="8">8</option>
 <option value="16">16</option>
 <option value="32">32</option>
 </select>
 </div>
 <div>
 <label>Frequency Min</label>
 <input type="number" name="frequency_gt" min="1" max="5" value=""></input>
 </div>
 <div>
 <label>Frequency Max</label>
 <input type="number" name="frequency_lt" min="1" max="5" value=""></input>
 </div>
 </form>
 </div>
 <div class="col-6">
 <div class="result"></div>
 </div>
 </div>
 </div>
 <script src="/vendors~main.js" ></script>
 <script src="/main.js" ></script>
 </body>
 </html>
 */



// >>>>>> MVC <<<<<<
/**
 Как я говорил в прошлом уроке, наша схема работы с состоянием имеет один существенный недостаток - за вызов отрисовки отвечают обработчики. Ниже приведен, уже знакомый нам, пример демонстрирующий вызов render.
 */

input.addEventListener('keyup', () => {
    if (input.value === '') {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = true;
    } else if (!input.value.match(/^\d+$/)) {
        state.registrationProcess.valid = false;
        state.registrationProcess.submitDisabled = true;
    } else {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = false;
    }

    render(state);
});

/**
 Какие проблемы могут возникнуть при таком подходе?

 Здесь стоит сказать, что на бекенде такой подход, как раз, оправдан. Бекенд работает в рамках другой парадигмы, а именно клиент-серверной архитектуры. Обработчик на бекенде, по своей сути, это функция которая либо меняет состояние (что не приводит ни к каким перерисовкам, так как выполняется редирект), либо извлекает данные из базы для формирования ответа, например, в виде HTML. Во фронтенде изменение данных тут же влияет на экран.

 Пример который мы видим выше очень упрощен, в нем вызывается только одна функция render принимающая на вход все состояние. Теперь представьте что у нас в приложении десятки обработчиков (что немного) и большое состояние (что типично). В такой ситуации перерисовывать все на каждое изменение довольно затратная операция. С другой стороны, можно вставить проверку внутри render на каждый кусок стейта и отслеживать изменился ли он. Такой подход очень быстро станет проблемой сам по себе. Можно легко забыть что-то проверить, можно ошибиться в проверке, можно, просто, забыть поправить проверку после изменения структуры состояния.

 Существует другой способ выполнить эту задачу. Он основан на такой концепции (говорят шаблон проектирования), как Наблюдатель (Observer). Его идея очень проста, одна часть системы наблюдает за изменением другой части системы. Если наблюдаемый изменился, то наблюдатель может сделать что-то полезное.

 В JS подобный механизм можно реализовать через Proxy https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy, но это довольно муторно. Более простым решением будет использование готовой библиотеки Watch.js https://github.com/melanke/Watch.JS/.
 */

import { watch } from 'melanke-watchjs';

const app = () => {
    const state = {
        value: "hello",
    };

    watch(state, 'value', () => alert('value changed!'));

    // После изменения атрибута возникнет алерт
    const el = document.querySelector('<selector>');
    el.addEventListener('change', () => {
        state.value = 'other value';
    });
}

// Где-то в другом файле (обычно в index.js)
app();

/**
 Watch.js позволяет "слушать" нужные части состояния и вызывать функции рендеринга при их изменении.

 <div id="result">0</div>
 <button id="increment">+</button>
 <button id="decrement">-</button>
 */

const { watch } = WatchJS;

const app = () => {
    const state = {
        value: 0
    }
    const result = document.getElementById('result');

    watch(state, 'value', () => {
        result.textContent = state.value;
    });

    const incHandler = () => {
        state.value += 1
    };

    const decHandler = () => {
        state.value -= 1
    };

    const inc = document.getElementById('increment');
    inc.addEventListener('click', incHandler);

    const dec = document.getElementById('decrement');
    dec.addEventListener('click', decHandler);
};

app();

/**
 Теперь, обработчики ничего не знают про рендеринг и отвечают только за взаимодействие с состоянием. В свою очередь рендеринг следит за состоянием и меняет дом только там где нужно и так как нужно. Этот способ организации приложения считается уже классическим и носит имя MVC (Model View Controller). Каждое слово обозначает слой приложения со своей зоной ответственности. Model - состояние приложения и бизнес-логика, View - слой отвечающий за взаимодействие с DOM, Controller - обработчики.

 Обратите внимание на то что Model, Controller или View это не файлы, не классы, ни что-либо еще конкретное. Это логические слои, которые выполняют свою задачу и определенным образом взаимодействуют друг с другом.

 Понимание MVC дает ответ на то как структурировать приложение, но самостоятельно его реализуют редко. Современные фреймворки построены на различных модификациях MVC и за нас определили правила взаимодействия. Остается только разобраться и следовать им.
 */


/***@@
 src/application.js
 Реализуйте js часть компонента list-group бутстрапа. Посмотреть пример работы можно здесь https://getbootstrap.com/docs/4.1/components/list-group/#javascript-behavior

 Задача в том чтобы добавить js код, который оживляет переключение.

 Реализуйте задание используя архитектуру MVC.
 */

// FILE: /app/src/application.js:
import { watch } from 'melanke-watchjs';

export default () => {
    const state = {
        menu: {
            currentHeaderId: 'list-home-list',
            previousHeaderId: null,
            currentTabPaneId: 'list-home',
            previousTabPaneId: null,
        },
    };

    watch(state, 'menu', () => {
        if (state.menu.currentHeaderId === state.menu.previousHeaderId) {
            return;
        }

        const currentBodyEl = document.getElementById(state.menu.currentTabPaneId);
        currentBodyEl.classList.add('active', 'show');
        const prevousBodyEl = document.getElementById(state.menu.previousTabPaneId);
        prevousBodyEl.classList.remove('active', 'show');

        const currentHeaderEl = document.getElementById(state.menu.currentHeaderId);
        currentHeaderEl.classList.add('active');
        const prevousHeaderEl = document.getElementById(state.menu.previousHeaderId);
        prevousHeaderEl.classList.remove('active');
    });

    const elements = document.querySelectorAll('[data-toggle="list"]');
    elements.forEach((element) => {
        element.addEventListener('click', (e) => {
            state.menu = {
                previousTabPaneId: state.menu.currentTabPaneId,
                currentTabPaneId: e.target.hash.slice(1),
                previousHeaderId: state.menu.currentHeaderId,
                currentHeaderId: e.target.id,
            };
        });
    });
};


// FILE: /app/src/index.js:
import app from './application';

app();


// FILE: /app/public/index.html:
/**
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

 <!-- Bootstrap CSS -->
 <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
 </head>
 <body>
 <div class="container m-3">
 <div class="row">
 <div class="col-4">
 <div class="list-group" id="list-tab" role="tablist">
 <a class="list-group-item list-group-item-action active" id="list-home-list" data-toggle="list" href="#list-home" role="tab" aria-controls="home">Home</a>
 <a class="list-group-item list-group-item-action" id="list-profile-list" data-toggle="list" href="#list-profile" role="tab" aria-controls="profile">Profile</a>
 <a class="list-group-item list-group-item-action" id="list-messages-list" data-toggle="list" href="#list-messages" role="tab" aria-controls="messages">Messages</a>
 <a class="list-group-item list-group-item-action" id="list-settings-list" data-toggle="list" href="#list-settings" role="tab" aria-controls="settings">Settings</a>
 </div>
 </div>
 <div class="col-8">
 <div class="tab-content" id="nav-tabContent">
 <div class="tab-pane fade active show" id="list-home" role="tabpanel" aria-labelledby="list-home-list">Home Content</div>
 <div class="tab-pane fade" id="list-profile" role="tabpanel" aria-labelledby="list-profile-list">Profile Content</div>
 <div class="tab-pane fade" id="list-messages" role="tabpanel" aria-labelledby="list-messages-list">Messages Content</div>
 <div class="tab-pane fade" id="list-settings" role="tabpanel" aria-labelledby="list-settings-list">Settings Content</div>
 </div>
 </div>
 </div>
 </div>
 <script src="/vendors~main.js" ></script>
 <script src="/main.js" ></script>
 </body>
 </html>
 */


/***@@@
 application.js
 Реализуйте и экспортируйте по умолчанию функцию, которая отвечает за показ модальных окон.

 <button type="button" class="btn btn-primary" data-toggle="modal" data-target="#exampleModal">
 Launch demo modal
 </button>
 <div class="modal fade" id="exampleModal">
 <div class="modal-dialog" role="document">
 <div class="modal-content">
 <div class="modal-header">
 <h5 class="modal-title" id="exampleModalLabel">Modal title 1</h5>
 <button type="button" class="close" data-dismiss="modal" aria-label="Close">
 <span aria-hidden="true">&times;</span>
 </button>
 </div>
 <div class="modal-body">
 ...
 </div>
 </div>
 </div>
 </div>

 - Модальные окна определяются по селектору data-toggle="modal".
 - Идентификатор самого окна хранится в аттрибуте data-target кнопки
 - Чтобы окно всплыло, необходимо в элемент с id из data-target добавить класс show и стиль display выставить в block
 - За скрытие модального окна отвечает крестик доступный по селектору data-dismiss="modal" внутри модального окна. Нажатие на кнопку приводит к обратному эффекту, удаляется класс show, а display выставляется в none.
 */


// FILE: /app/src/application.js:
const openHandler = (modal) => {
    modal.classList.add('show');
    modal.style.display = 'block';
};

const closeHandler = (modal) => {
    modal.classList.remove('show');
    modal.style.display = 'none';
};

export default () => {
    const buttons = document.querySelectorAll('[data-toggle="modal"]');

    buttons.forEach((element) => {
        const id = element.dataset.target;
        const modal = document.querySelector(id);

        element.addEventListener('click', openHandler.bind(null, modal));
        const closeButton = modal.querySelector('[data-dismiss="modal"]');
        closeButton.addEventListener('click', closeHandler.bind(null, modal));
    });
};

// FILE: /app/src/index.js:
import app from './application';

app();


/***@@@
 Модификация игры в пятнашки, в которой управление осуществляется с помощью стрелок.

 application.js
 Реализуйте игру в соответствие со следующими требованиями:

 Размер поля должен быть 4x4
 В начальной позиции пустым всегда является правый нижний квадрат
 Элементы формируются случайным образом по следующему алгоритму: сначала они перемешиваются используя randomize(values), а затем они наполняют таблицу. Таблица должна заполняться значениями сверху вниз, то есть пятый элемент, добавляемый в неё, находится по индексам [1, 0];
 Перемещение костяшек происходит с помощью стрелок.

 Так как тесты завязаны на верстку (Bootstrap), то к ней предъявляются особые требования. Вот как выглядит начальная позиция:

 <div class="gem-puzzle">
 <table class="table-bordered">
 <tbody>
 <tr>
 <td class="p-3">10</td>
 <td class="p-3">11</td>
 <td class="p-3">6</td>
 <td class="p-3">4</td>
 </tr>
 <tr>
 <td class="p-3">14</td>
 <td class="p-3">2</td>
 <td class="p-3">12</td>
 <td class="p-3">1</td>
 </tr>
 <tr>
 <td class="p-3">3</td>
 <td class="p-3">13</td>
 <td class="p-3">9</td>
 <td class="p-3">8</td>
 </tr>
 <tr>
 <td class="p-3">5</td>
 <td class="p-3">7</td>
 <td class="p-3">15</td>
 <td class="p-3 table-active"></td>
 </tr>
 </tbody>
 </table>
 </div>
 Класс таблицы постоянен
 У каждой ячейки проставлен класс p-3
 Пустая ячейка не содержит текста.
 У пустой ячейки добавляется класс table-active

 Подсказки
 - Нажатие на клавиши генерирует код, по которому можно понять что за клавиша была нажата
 */

// FILE: /app/src/application.js:
import _ from 'lodash';

const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

export default (randomize = _.shuffle) => {
    const defaultCellIndex = 3;
    const defaultRowIndex = 3;
    let currentPosition = { cellIndex: defaultCellIndex, rowIndex: defaultRowIndex };
    const root = document.querySelector('.gem-puzzle');
    const tableEl = document.createElement('table');
    tableEl.className = 'table-bordered';
    document.addEventListener('keyup', (e) => {
        let newPosition;
        const { cellIndex, rowIndex } = currentPosition;
        switch (e.key) {
            case 'ArrowLeft':
                newPosition = { ...currentPosition, cellIndex: cellIndex + 1 };
                break;
            case 'ArrowUp':
                newPosition = { ...currentPosition, rowIndex: rowIndex + 1 };
                break;
            case 'ArrowRight':
                newPosition = { ...currentPosition, cellIndex: cellIndex - 1 };
                break;
            case 'ArrowDown':
                newPosition = { ...currentPosition, rowIndex: rowIndex - 1 };
                break;
            default:
                return;
        }

        const row = tableEl.rows.item(newPosition.rowIndex);

        if (row) {
            const cell = row.cells.item(newPosition.cellIndex);

            if (cell) {
                const point = tableEl.rows.item(rowIndex).cells.item(cellIndex);
                point.textContent = cell.textContent;
                point.classList.remove('table-active');
                cell.textContent = '';
                cell.classList.add('table-active');
                currentPosition = newPosition;
            }
        }
    });

    root.append(tableEl);

    const randomValues = randomize(values);
    for (let i = 0; i < 4; i += 1) {
        const row = tableEl.insertRow();
        for (let j = 0; j < 4; j += 1) {
            const cell = row.insertCell();
            cell.className = 'p-3';
            if (i === defaultCellIndex && j === defaultRowIndex) {
                cell.classList.add('table-active');
            }
            cell.textContent = randomValues[i + (j * 4)];
        }
    }
};


// FILE: /app/src/index.js:
import app from './application';

app();



/***@@@
 src/application.js
 Реализуйте и экспортируйте по умолчанию функцию, которая запускает код, заполняющий элемент <progress> на один процент за 1 секунду. Через 100 секунд процесс должен остановится, так как достигнет максимума.

 Начальное состояние

 <progress value="0" max="100"></progress>
 Через одну секунду

 <progress value="1" max="100"></progress>
 Для изменения значения value используйте метод setAttribute

 Подсказки
 Реализуйте задачу используя setTimeout (с setInterval может не заработать проверка)
 Элемент Progress
 */

// FILE: /app/src/application.js:
import '@babel/polyfill';

export default () => {
    const element = document.querySelector('progress');
    let counter = 0;

    const handler = () => {
        counter += 1;
        element.setAttribute('value', counter);

        if (counter !== 100) {
            setTimeout(handler, 1000);
        }
    };

    setTimeout(handler, 1000);
};


// FILE: /app/src/index.js:
import app from './application';

app();



// ############################### JS: HTTP Server ###############################

/**
 Этот курс посвящен знакомству с принципами разработки клиент-серверных приложений. Проектом курса является сервис 'The Phonebook' (записная книжка), который представляет из себя json api.
 */



// >>>>>> Введение <<<<<<

/**
 Под веб-разработкой обычно понимают создание клиент-серверных приложений или, как мы обычно говорим, сайтов. Типичный сайт представляет из себя бэкэнд – приложение, которое крутится на сервере, и клиент. Под клиентом чаще всего подразумевается браузер. Он так же является тонким клиентом, то есть браузер, сам по себе, не содержит логики, а отправляет запросы на сервер и занимается только отрисовкой данных, пришедших с сервера. С другой стороны, современные сайты содержат богатую логику на клиенте, что, по сути, превращает работающий сайт в полноценное приложение, которое отрабатывает на компьютере пользователя.Но это уже совсем другая история ;)

 Основным способом коммуникации между браузером и бэкэндом сайта является протокол http. Он относится к классу текстовых протоколов, которые можно легко читать и понимать, что происходит. Это довольно удобно, к тому же http работает достаточно просто, и хорошее понимание его работы делает из вас гораздо более ценного специалиста.

 В этом курсе мы научимся делать бэкэнд сайта, который представляет из себя сервис для ведения телефонной книги.
 */

(master) js-phonebook$ bin/phonebook
hexlet-phonebook server was started on localhost:4000 +0ms

$ curl localhost:4000
Welcome to The Phonebook
Records count: 1000

/**
 В процессе разработки изучим множество тем и подходов, связанных с написанием подобных приложений. Основные темы:

 - Базовые сведения об операционных системах
 - Основы сетей и TCP/IP
 - Понятие HTTP сессии. Понимание модели запрос/ответ.
 - Форматы данных, JSON.
 - Работа с инструментами для выполнения запросов telnet/curl
 - Обработка ошибок. Логгирование.

 Кроме перечисленного выше, познакомимся со множеством модулей nodejs и полезными пакетами для более удобной разработки.
 * http, fs, querystring, url
 * debug, nodemon
 */



// >>>>>> Реализация сервера <<<<<<

/**
 Перед тем, как бросаться в омут и смотреть на реализацию бэкэнда, нам придётся поговорить о теоретической базе, скрывающейся за несколькими строчками кода. Небольшого введения должно хватить для старта, но в будущем нужно будет браться за соответствующие книги и углубляться в тему. Конечно же, это верно для тех, кто хочет стать хорошим разработчиком. Пугаться этих книжек не стоит, даже наоборот, после них вы можете почувствовать кураж, потому что огромное число вещей, которые для вас сейчас представляются черным ящиком, на поверку окажутся достаточно простыми концепциями с понятным устройством внутри.


 # Операционная система (ОС)

 Основой основ для программиста можно считать ОС. Да, у нас есть ещё железо и архитектуру ЭВМ никто не отменял, но прикладному разработчику достаточно иметь общее понимание того, как работает железо, а вот от ОС не уйти совсем.

 # Процесс
 Базовой единицей исполнения в ОС является процесс. Каждый раз, когда вы запускаете какую-либо программу, то запускается минимум один процесс. Кстати, может быть и больше, отсюда следует что программа != процесс. Список запущенных процессов можно посмотреть так:
 */

$ ps xf

PID TTY      STAT   TIME COMMAND
29 pts/1    S      0:00 bash
30 pts/1    S+     0:00  \_ top
22 pts/0    S      0:00 bash
32 pts/0    R+     0:00  \_ ps xf

/**
 Каждая строчка на рисунке выше – это информация о каком-либо процессе. Как видно, ОС содержит в себе различную информацию о каждом из процессов. На текущий момент нас интересует только один параметр, который называется PID. PID, как ни странно, расшифровывается как process identifier и фактически представляет из себя целое число, однозначно определяющее то, о каком процессе идет речь.

 # Сети
 Основным (высокоуровневым) способом коммуникации между машинами является семейство протоколов TCP/IP. Большинство людей, которые пользуются интернетом или сетями в целом так или иначе слышали выражение ip адрес. Этот адрес (для версии IPv4) может выглядеть так: 10.0.152.23. Он указывает на какое-то устройство в сети, которое не обязательно представлено компьютером в привычном понимании этого слова.


 # Интерфейсы

 По правде говоря, этот адрес связан даже не с самим устройством, а с конкретным интерфейсом устройства. Например, каждая сетевая карта будет представлена в системе как отдельный интерфейс. Кроме того, интерфейсы бывают виртуальными, то есть у них отсутствует физический элемент. Зачем это нужно? Самый тривиальный пример это так называемая обратная петля (loopback). Интерфейс, который присутствует по умолчанию в большинстве ОС. Любой трафик, посланный в этот интерфейс, тут же принимается им же.

 Этот интерфейс позволяет обращаться к серверному приложению, расположенному на той же машине, без активного подключения к сети. Такая возможность особенно полезна для тестирования служб и их разработки. Адрес этого интерфейса всегда 127.0.0.1. Так же к нему можно обращаться по имени localhost.


 # Domain Name System

 DNS - система доменных имён, благодаря которой нам необходимо запоминать только буквенные имена сайтов без необходимости знать конкретный ip адрес машины, на которую надо пойти. Общий принцип работы довольно прост. Каждый раз, когда в браузер вводится имя сайта, он обращается к специальным серверам и спрашивает их: 'Какой ip адрес у hexlet.io?'. Дальше происходит немного магии* и, в конце концов, эта система возвращает (если найдёт) этот адрес. Затем браузер устанавливает tcp соединение и начинает свою работу.


 # Порты

 Когда происходит общение удаленных машин друг с другом по tcp, то в реальности между собой общаются процессы ОС, а не компьютеры в целом. Отсюда возникает вопрос: каким образом, зная только ip адрес, постучаться на чужую машину в интересующую нас программу. Конкретно в этом курсе нас интересует веб-сервер. Короткий ответ: никак. И действительно, одного ip адреса недостаточно.

 В tcp существует такое понятие, как порт. Это целое число, означающее точку входа в процесс запущенной программы. То есть при получении данных по tcp ОС смотрит то, для какого порта они предназначены. Затем она находит процесс, соответствующий этому порту, и передает данные в него. Важным следствием этого подхода становится тот факт, что невозможно занять уже занятый порт. Иначе это ввело бы неоднозначность. И действительно, при старте сервера, который пытается слушать занятый другой программой порт, будет получена такая ошибка:
 */

Error: listen EADDRINUSE :::4000

// Мы можем даже посмотреть на того, кто занял этот порт:

$ lsof -i :4000

COMMAND   PID     USER TYPE NODE NAME
node    40726 mokevnin IPv6 TCP  *:terabase (LISTEN)

/**
 Суммируя вышесказанное, делаем вывод, что любое серверное приложение при старте должно начать слушать определенный порт для возможности получать данные по сети.

 Если вернуться к браузеру, то может возникнуть вопрос: почему мы не указываем порт, когда загружаем сайты, откуда браузер знает, куда стучаться на сервер? Ответ на этот вопрос крайне прост: браузер действительно знает порт, на который нужно идти. И по умолчанию это порт с номером 80.

 # Веб-сервер
 Начнём с иллюстрации:
 */

// server.js
import http from 'http';

const server = http.createServer((request, response) => {
    // content-length формируется автоматически!
    response.write('hello, world!');
    response.end();
});

const port = 4000;
server.listen(port, () => {
    console.log('Server has been started');
});

/**
 1. Импортируется модуль http. Он встроен в nodejs и позволяет создать веб-сервер (и не только).
 2. Создаётся веб-сервер. В функцию createServer передается обработчик запросов. Он будет вызываться на каждый входящий запрос.
 3. Сервер вешается на порт.

 Обработки запроса в данном примере как таковой нет. Сервер будет отвечать по http фразой hello, world! на любой входящий запрос. Делается это с помощью объекта response, который представляет собой http-ответ. В примере выше мы используем две функции интерфейса response. Функцию write, которая позволяет передать текст в теле http ответа, и функцию end, которая означает, что мы закончили формирование ответа. Обратите внимание: нам не пришлось руками выставлять заголовок content-length, модуль http самостоятельно вычисляет размер тела и подставляет необходимый заголовок.

 Для запуска нашего сервера необходимо набрать команду:
 */

$ babel-node server.js # blocking

/**
 Запуск приводит к блокировке. Сервер запущен и работает. Чтобы его остановить, надо нажать комбинацию ctrl+c.

 Теперь можно выполнить запрос к серверу:
 */

$ telnet localhost 4000

GET / HTTP/1.1
host: hexlet.io

/**
 Проделав данную процедуру, можно будет сказать, что вы запустили свой первый сайт на nodejs ;)

 Но дальше нас поджидает сюрприз. Если попробовать поменять код сервера, и писать в ответ my first web server, то без перезапуска сервера ничего не изменится. После того, как сервер запущен, он больше не перечитывает файлы с диска и не изменяет своего состояния. Такое поведение не является особенностью модуля http, так устроен сам язык. Поэтому не забывайте перезапускать сервер, после внесения изменений.

 # Дополнительные материалы
 Что такое DNS https://guides.hexlet.io/dns/
 */


/***@@@
 server.js
 Реализуйте http-сервер, который является интерфейсом доступа к телефонному справочнику.
 Справочник представлен текстовым файлом phonebook.txt. Его формат:
 1 | Carleton Sporer | 197.328.3450
 2 | Ashton Bogisich | 244.742.7016
 3 | Valentin Auer | 964.685.7490
 4 | Buddy Kuvalis | 356.157.9872

 Каждая строчка представляет собой отдельную запись о человеке. Она содержит три значения, разделенных символом | 1 - это id, 2 - имя, 3 - телефон.

 При запросе на / сервер должен отдавать следующее тело:

 Welcome to The Phonebook
 Records count: <количество строк в файле phonebook.txt>
 Flow

 Кроме запуска тестов, обязательно попробуйте "поиграть" с написанным сервером. Для этого воспользуйтесь командой make start, которая запускает ваш сервер. После этого вы можете делать к нему запросы, используя telnet или, например, curl: curl localhost:8080. Не забывайте перезапускать сервер при изменении исходного кода. Для остановки сервера воспользуйтесь комбинацией ctrl+c.
 */

// FILE: /app/server.js:
import fs from 'fs';
import path from 'path';
import http from 'http';

export default (port, callback) => {
    fs.readFile(path.resolve(__dirname, 'phonebook.txt'), (err, data) => {
        if (err) {
            throw err;
        }

        const users = data.toString().trim().split('\n');
        const s = http.createServer((request, response) => {
            const messages = [
                'Welcome to The Phonebook',
                `Records count: ${users.length}`,
            ];

            response.end(messages.join('\n'));
        });

        s.listen(port, callback);
    });
};


// FILE /app/bin/phonebook.js:
#!/usr/bin/env babel-node

import solution from '../server';

const port = 8080;

solution(port, () => {
    // eslint-disable-next-line no-console
    console.log('server started!');
});


// FILE: /app/phonebook.txt:
1 | Chelsie Eichmann | 1-466-807-1978
2 | Miss Ewald Dickinson | 699-653-9379
3 | Mauricio Cassin | (683) 115-8139
4 | Liam Wiegand | 1-327-988-3382
5 | Lonny McGlynn | (935) 384-0149




// >>>>>> cURL <<<<<<

/**
 Разрабатывая сайты и, в особенности, веб-сервисы, приходится постоянно выполнять http-запросы, проверяя не только тело ответа, но и заголовки.

 Самый надёжный и деревянный способ делать запросы, без которого иногда не обойтись — это telnet. Мы его подробно разбирали в курсе http. Но пользоваться им в повседневной практике неудобно, вбивать запросы долго и муторно. К счастью, есть способ легче — это cURL.

 cURL — кроссплатформенная служебная программа командной строки,
 позволяющая взаимодействовать с множеством различных серверов
 по множеству различных протоколов с синтаксисом URL.
 Самый простой способ сделать запрос с помощью curl выглядит так:
 */

$ curl example.com

/**
 По умолчанию запрос делается по протоколу http, а в stdout выводится тело ответа.

 Часто бывает нужно увидеть только заголовки ответа, без самого тела. Для этого достаточно добавить флаг --head. Этот флаг меняет тип запроса с GET на HEAD.
 */

$ curl --head example.com

HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Fri, 07 Sep 2018 13:42:46 GMT
Etag: "1541025663+ident"
Expires: Fri, 14 Sep 2018 13:42:46 GMT
Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
Server: ECS (lga/1378)
X-Cache: HIT
Content-Length: 606

// При необходимости увидеть и запрос и ответ целиком, можно воспользоваться флагом -v, который включает verbose режим.
$ curl -v example.com

// Как видно, этот вывод содержит в себе вообще всё.




// >>>>>> Перезагрузка <<<<<<

/**
 Необходимость перезапускать сервер после каждого изменения кода может сильно расшатать нервную систему. Во-первых, это долго, такой подход мешает быстро и эффективно работать. Иногда говорят, что становится длинным цикл обратной связи. А если приложение тяжелое, то время старта может быть неприлично большим. Желание разбить клавиатуру будет появляться всё чаще и чаще.

 К счастью, делать этого не придётся. В nodejs, как, впрочем, и во всех остальных экосистемах, существуют библиотеки, решающие эту задачу достаточно хорошо. Но перед тем, как смотреть конкретные библиотеки, давайте проанализируем подходы, применяемые для этого.


 # Опрос файловой системы (ФС)
 Идея решения тривиальна. Нам понадобится отдельная программа, которая с небольшой периодичностью опрашивает файлы в указанной папке и проверяет, изменились ли они со времени последнего рестарта. Если да, то производится перезапуск веб-сервера, если нет, то опрос продолжается.

 У этого подхода два недостатка:

 - Наличие задержки. Даже если файлов немного, такой подход не позволяет реагировать на изменения сразу.
 - Большая задержка и серьезная нагрузка при большом количестве файлов.


 # Подписка на события ФС
 Недостаток у этого способа только один, его сложно назвать фатальным. Этот способ работает не везде. А в остальном, такой подход очень эффективен и быстр.

 # Nodemon
 nodemon – это программа для рестарта при изменениях фс.

 Установка:
 */

$ npm install -g nodemon

// Запуск
$ nodemon ./server.js
    [nodemon] 1.10.2
    [nodemon] to restart at any time, enter `rs`
    [nodemon] watching: *.*
[nodemon] starting `node ./server.js`

// По умолчанию nodemon смотрит файлы в текущей рабочей директории. Это поведение можно поменять так: nodemon --watch app --watch libs app/server.js.

// # babel
nodemon --exec babel-node -- path/to/script.js

/**
 # Дополнительные материалы
 Inotify https://ru.wikipedia.org/wiki/Inotify
 */



// >>>>>> Запрос <<<<<<

/**
 После того, как клиент делает запрос на сервер, nodejs формирует объект request и передает его в наш обработчик. Request является инстансом IncomingMessage и содержит всю возможную информацию о соединении. Нас интересует только небольшая часть этих данных.
 */

// http://localhost:4000/search?q=php
console.log(request);
{
    url: '/search?q=php',
        method: 'GET',
    headers: {
    host: 'localhost:4000',
        connection: 'close',
},
    /** ... */
}

/**
 Важно упомянуть, что все заголовки в объекте headers представлены в нижнем регистре, причём не важно, в каком виде они были посланы на сервер. Это сильно упрощает дальнейшую работу с заголовками. Если некоторые заголовки повторяются, их значения будут перезаписаны или объединены в строчки разделённые точкой запятой, в зависимости от заголовка. В некоторых случаях это может быть нежелательным, поэтому всегда можно получить сырые заголовки, используя объект rawHeaders.

 С одной стороны видно, что здесь есть все параметры запроса, с другой – есть маленькие неудобства. Выражаются они в том, что http не предоставляет возможность получить query params в виде объекта js, но, как мы знаем, можно воспользоваться модулем url и распарсить параметры.

 Существует и другой способ работы с сервером ноды:
 */
const server = http.createServer();
server.on('request', (request, response) => {
    // the same kind of magic happens here!
});
server.listen(port);

/**
 Как и многое другое в node.js, сервер является EventEmitter. Событие request соответствует входящему запросу.

 # Request EventEmitter
 Объект Request так же является EventEmitter. Изучим подробнее генерируемые им события.
 */

/**
 # end
 Событие end генерируется в тот момент, когда запрос целиком получен. Обычно обработчик, именно на это событие, содержит логику обработки запроса.
 */
request.on('end', () => {
    const message = 'Welcome to The Phonebook';
    response.end(message);
});

/**
 # error

 В случае ошибок это будет событие error. Если это событие не будет прослушано, то возникшая ошибка превращается в исключение, что приведёт к падению программы. Таким образом, будет хорошей практикой всегда слушать это событие и, как минимум, логгировать его, а ещё лучше отвечать вызывающей стороне правильным кодом ошибки.
 */

request.on('error', err => {
    // This prints the error message and stack trace to `stderr`.
    console.error(err.stack);
})

/**
 # data

 Событие, которое вызывается при получении данных. Будет рассматриваться в соответствующем уроке.

 В случае, если данные не принимаются и это событие не слушается, необходимо обязательно делать вызов функции resume на объекте request, иначе запрос не начнёт обрабатываться.

 # Response
 В общем виде запись ответа в response выглядит так:
 */
response.write('hello world');
response.end();

// или так:
response.end('hello world');

/**
 То есть в зависимости от ситуации можно передавать данные либо сразу в end, либо, если они большие, отдавать порциями через write.

 По умолчанию код ответа всегда 200. Конечно не каждому запросу гарантируется такой ответ, в некоторых случаях нужно отправлять совсем другой код. Самый простой способ сделать это - напрямую поменять свойство statusCode.
 */

response.statusCode = 404; // Tell the client that the resource wasn't found.

// Установка заголовков делается уже через специальный метод:
response.setHeader('Content-Type', 'application/json');
response.setHeader('X-Powered-By', 'bacon');

/**
 Важно не забывать установить все заголовки до того, как начнёт отправляться тело. Это логично, ведь заголовки в http идут перед телом, а поменять порядок после отправки уже нельзя.

 # Всё вместе
 */

import http from 'http';

http.createServer((request, response) => {
    request
        .on('error', err => {
            console.error(err);
        })
        .on('end', () => {
            response.on('error', err => {
                console.error(err);
            });

            response.statusCode = 200;
            response.setHeader('Content-Type', 'application/json');

            const message = 'Welcome to The Phonebook';
            response.write(message);
            response.end();
        });

    request.resume(); // !!!
}).listen(8080);


/***@@@
 index.js
 Реализуйте логику парсинга файла phonebook.txt в следующий формат:
 {
  <id>: {
    name: <name>,
    phone: <phone>,
  },
  <id>: {
    name: <name>,
    phone: <phone>,
  },
}

 Где <id> - это идентификатор конкретной записи, а <name> и <phone> – это имя и телефон соответствующей записи.

 server.js
 Сервер позволяет выполнять запросы на поиск всех записей, соответствующих критерию поиска. Критерием является часть имени/фамилии, по которой производится сопоставление.

 В запросе к серверу по ссылке /search необходимо передать один параметр: q, значением которого, будет подстрока. В случае, если найдены сопоставления, то сервер возвращает данные в следующем формате (для подстроки miss):

 Miss Arlo Barrows, 328-949-3924
 Miss Bernadette Conn, 249.059.5515
 Miss Savannah Dicki, 157.463.3368
 Miss Rudy Brown, 779-703-0150


 Обратите внимание, что регистр при сопоставлении не учитывается.

 В случае если запрос к серверу выполняется без параметров или соответствий не найдено, он должен вернуть пустую строку.
 */

$ curl localhost:8080/search

$ curl localhost:8080/search?q=mrs

    /**
     Mrs. Rosalia Wisoky, (865) 611-8960
     Mrs. Earl Gaylord, 944-345-3158
     Mrs. Roslyn Moen, 526.643.3627
     Mrs. Giovani Rempel, 842-246-9417

     Flow
     Кроме запуска тестов, обязательно попробуйте "поиграть" с написанным сервером. Для этого воспользуйтесь командой make start, которая запускает ваш сервер. После этого вы можете делать к нему запросы, используя, например, curl: curl localhost:8080. В данном уроке сервер перезапускается автоматически.
     */

    // FILE: /app/bin/phonebook.js:
    #!/usr/bin/env babel-node

import makeServer from '..';

const port = 8080;
makeServer(port);


// FILE: /app/Makefile:
start:
    nodemon --exec babel-node -- bin/phonebook.js

test:
    npm test -s


// FILE: /app/index.js:
import fs from 'fs';
import path from 'path';

import makeServer from './server';

export default (port, callback = () => {}) => {
    fs.readFile(path.resolve(__dirname, 'phonebook.txt'), (err, data) => {
        if (err) {
            throw err;
        }

        const users = data.toString()
            .trim()
            .split('\n')
            .reduce((acc, value) => {
                const [id, name, phone] = value.split('|').map(item => item.trim());
                return { ...acc, [id]: { name, phone } };
            }, {});

        const server = makeServer(users);
        server.listen(port, () => callback(server));
    });
};


// FILE: /app/server.js:
import http from 'http';
import url from 'url';
import querystring from 'querystring';

export default usersById => http.createServer((request, response) => {
    request.on('end', () => {
        if (request.url === '/') {
            const messages = [
                'Welcome to The Phonebook',
                `Records count: ${Object.keys(usersById).length}`,
            ];

            response.end(messages.join('\n'));
        } else if (request.url.startsWith('/search')) {
            const { query } = url.parse(request.url);
            const { q } = querystring.parse(query);
            const normalizedSearch = q ? q.trim().toLowerCase() : null;

            if (q) {
                const result = Object.values(usersById)
                    .filter(user => user.name.toLowerCase().includes(normalizedSearch))
                    .map(user => `${user.name}, ${user.phone}`)
                    .join('\n');
                response.end(result);
            } else {
                response.end();
            }
        }
    });

    request.resume();
});




// >>>>>> JSON <<<<<<

/**
 Попробуем задать себе вопрос: кто является пользователем нашего проекта The Phonebook?

 # Пользователи
 В этом случае наш проект должен представлять из себя классический сайт, с удобным интерфейсом, работающий под разными устройствами и браузерами. Этим мы обязательно займёмся, но в другой раз.

 # Другие сервисы
 В такой ситуации требования резко изменяются. Роботам без разницы то, как выглядят данные, им ничего, кроме самих данных, собственно, и не нужно. Сервисы такого плана предоставляют так называемый api (эй-пи-ай), что расшифровывается как application programming interface. В случае с http это набор урлов, по которым мы можем получить необходимые данные либо изменить их. Главное требование к api состоит в том, чтобы данные отдавались в машиночитаемом представлении, в идеале не зависящем от конкретного языка или платформы.

 Разберёмся в том, что это означает. Если мы возьмём html, то про него можно сказать следующее:
 - Задает структуру представления информации;
 - Совсем немного определяет семантику (html5, scheme);
 - Может содержать ошибки, что допускается браузерами, но совершенно не подходит для программного интерфейса;
 - Меняется хаотично, а нам не хотелось бы, чтобы сервис падал, потому что верстальщик поправил теги на странице;
 - Содержит только то, что нужно для вывода, а программный интерфейс часто требует дополнительных данных.
 Как видно, html не подходит на роль формата обмена между сервисами, но зато подходит json.

 # Media Type
 При передаче контента по интернету мы должны явно специфицировать, какого типа этот контент. Достигается это использованием заголовка content-type. А вот значение, которое можно туда подставить, не является произвольным. Существует такое понятие, как media type (раньше – MIME type), которое представляет из себя строковой идентификатор. Для json он выглядит так: application/json.

 # HTTP
 */

(request, response) => {
    const result = /** ... */;

    response.setHeader(
        'Content-Type', 'application/json'
    );
    response.write(JSON.stringify(result));
    response.end();
}

/**
 Как видно из примера выше, кроме сериализации данных в json мы так же установили заголовок, указывающий на то, какого типа наш контент. Для этого пришлось воспользоваться интерфейсной функцией объекта response - setHeader.

 # Curl
 При выполнении запроса к серверу мы должны указывать тип формата, в котором хотим получить ответ. С помощью curl это делается так:
 */
curl -H "Accept: application/json" localhost:4000/users


/***@@@
 server.js
 Реализуйте обработчик адреса /users.json. Он должен отдавать данные в следующем формате:
 */
{
    "meta": { "page": 5, "perPage": 2, "totalPages": 500  },
    "data": [
    { "name": "Mrs. Marlee Lesch", "phone": "(412) 979-7311" },
    { "name": "Mrs. Mabelle Cormier", "phone": "307.095.4754" }
]
}

/**
 Этот вызов должен поддерживать пагинацию (pagination, постраничный вывод) результата. За это отвечают два параметра запроса:

 page - текущая запрошенная страница. По умолчанию 1.
 perPage - количество возвращенных данных на страницу. По умолчанию 10.
 Пример:
 */
$ curl localhost:8080/users.json?page=2&perPage=3
    {
        meta: { page: 2, perPage: 3, totalPages: 334 },
        data: [
            { name: "Liam Wiegand", phone: "1-327-988-3382" },
            { name: "Lonny McGlynn", phone: "(935) 384-0149" },
            { name: "Dr. Faustino Bailey", phone: "746-901-8330" }
        ]
    };


// FILE: /app/index.js:
import fs from 'fs';
import path from 'path';

import makeServer from './server';

export default (port, callback = () => {}) => {
    fs.readFile(path.resolve(__dirname, 'phonebook.txt'), (err, data) => {
        if (err) {
            throw err;
        }

        const users = data.toString()
            .trim()
            .split('\n')
            .reduce((acc, value) => {
                const [id, name, phone] = value.split('|').map(item => item.trim());
                return { ...acc, [id]: { name, phone } };
            }, {});

        const server = makeServer(users);
        server.listen(port, callback.bind(null, server));
    });
};


// FILE: /app/server.js:
import http from 'http';
import url from 'url';
import querystring from 'querystring';

export default usersById => http.createServer((request, response) => {
    request.on('error', (err) => {
        console.error(err.stack);
    });

    request.on('end', () => {
        if (request.url === '/') {
            const messages = [
                'Welcome to The Phonebook',
                `Records count: ${Object.keys(usersById).length}`,
            ];

            response.end(messages.join('\n'));
        } else if (request.url.startsWith('/search.json')) {
            response.setHeader('Content-Type', 'application/json');
            const { query } = url.parse(request.url);
            const { q } = querystring.parse(query);
            const normalizedSearch = q ? q.trim().toLowerCase() : '';

            const result = Object.values(usersById)
                .filter(user => user.name.toLowerCase().includes(normalizedSearch));

            response.end(JSON.stringify(result));
        } else if (request.url.startsWith('/users.json')) {
            response.setHeader('Content-Type', 'application/json');

            const { query } = url.parse(request.url);
            const { page = 1, perPage = 10 } = querystring.parse(query || '');
            const parsedPage = Number(page);
            const parsedPerPage = Number(perPage);
            const users = Object.values(usersById);

            const usersSubset = users.slice((parsedPage * parsedPerPage) - parsedPerPage, parsedPage * parsedPerPage);
            const totalPages = Math.ceil(users.length / perPage);

            response.end(JSON.stringify({ meta: { page: parsedPage, perPage: parsedPerPage, totalPages }, data: usersSubset }));
        }
    });
    request.resume();
});




// >>>>>> Маршрутизация (Роутинг) <<<<<<

/**
 В веб-разработке, процесс, который отвечает за определение обработчика для конкретной запрашиваемой страницы, называется маршрутизация. Чаще говорят "роутинг". Посмотрим на пример:
 */

https://ru.hexlet.io/code_reviews/4172
    https://ru.hexlet.io/courses/programming-basics
        https://ru.hexlet.io/account/profile/edit

            /**
             Каждый адрес из примера выше представляет из себя конкретный маршрут (роут). Причём, их можно разделить на типы: статические и динамические.

             # Статические маршруты
             Характеризуются тем, что адрес совпадает с самим маршрутом. Например, account/profile/edit. Несмотря на то, что адрес один, у разных пользователей он будет отображать разные данные, зависящие от того, кто сейчас авторизован.

             # Динамические маршруты
             А что, если у нас есть адреса, которые обозначают одно и тоже, но содержат параметр. Типичный пример /users/5. Без особого труда можно понять, что по этой ссылке мы получим информацию о пользователе с номером 5. Но тогда возникает вопрос: если у нас в базе тысячи пользователей, нам придётся определять тысячи маршрутов?

             К счастью, нет, здесь нам на помощь приходят регулярные выражения. Создаётся один маршрут, который выглядит примерно так: ^/users/(?<id>\w+). А дальше нужно просто сопоставить это регулярное выражение со строкой запроса. Другими словами, мы определили один единственный маршрут, который покрывает подобные ссылки:

             /users/4
             /users/1234
             /users/3

             После этого момента становится понятно, что процесс роутинга – это чуть сложнее, чем просто большой if/switch. В будущем мы начнём работать с фреймворками, в которых роутинг является одной из основных подсистем. Это справедливо для всех web-фреймворков на всех языках.

             Как правило, фреймворки предоставляют более высокоуровневый способ работы с роутами. То есть, вы пишите не сырые регулярные выражения, а строки с плейсхолдерами: /users/:id.

             В нашем сервере мы реализовали следующий способ работы роутера. Отдельно описывается объект, содержащий правила роутинга (как ключи) и обработчики маршрутов (как значения):
             */

            const routes = {
                'GET': {
                    '/': (req, res, matches) => {
                        /** ... */
                    },

                    '/search.json': (req, res, matches) => {
                        /** ... */
                    },
                },
            }

/**
 Обратите внимание на важную деталь. Глагол http тоже является частью роутинга. GET запрос на /users – это не тоже самое, что и POST запрос туда же. Это связано с большим количеством причин, одной из которых является семантика http. А вот параметры запроса не являются частью процесса маршрутизации (при таком роутинге, как выше). Они уже используются внутри обработчиков на ваше усмотрение.

 Так же имеет значение порядок, в котором заданы маршруты. Поэтому первыми должны идти статические и наиболее конкретизированные маршруты, а в конце более общие. Это правило справедливо в том случае, если есть пересечения.

 Ещё остаётся работа с ошибками, такими как "страница не найдена". Здесь уже возможны варианты. Некоторые фреймворки обрабатывают эту ситуацию отдельно, проверяя, что ни один маршрут не совпал с запрошенным адресом и выполняя специальный обработчик для этой ситуации. В других достаточно определить в самом конце, маршрут *, в который попадет всё, что не попало в другие места. И из обработчика этого роута можно делать всё, что нужно для правильного отображения ошибки.

 Пример простого способа обрабатывать маршруты:
 */

export default http.createServer((request, response) => {
    const routes = router[request.method];
    // Обходим маршруты с помощью find, чтобы остановиться после того, как маршрут найден
    const result = Object.keys(routes).find(str => {
        // извлекаем из адреса часть без query params
        const { pathname } = url.parse(request.url);
        if (!pathname) {
            return false;
        }

        const regexp = new RegExp(`^${str}$`);
        // Проверяем совпадение с маршрутом (записанным в виде регулярного выражения)
        const matches = pathname.match(regexp);
        // Маршрут не найден, двигаемся дальше
        if (!matches) {
            return false;
        }

        // Выполнение обработчика
        routes[str](request, response, matches);

        return true;
    });

    // Особая обработка ситуации когда не было найдено соответствующего маршрута
    if (!result) {
        response.writeHead(404);
        response.end();
    }
});

/**
 # Соглашения

 В web-разработке существует понятие CRUD, которое расшифровывается как CREATE, READ, UPDATE, DELETE. И самое простое и базовое, что делают разработчики - это круды. Например, любой административный интерфейс (админка сайта) это большой набор разных крудов для всевозможных сущностей: круд постов в блог, круд товаров и так далее.

 Существуют соглашения о том, как грамотно делать круды с точки зрения маршрутизации. Они включают в себя особенности семантики http.
 */

GET /users # список
POST /users # создание

GET /users/10 # просмотр
PATCH /users/10 # обновление
DELETE /users/10 # удаление

GET /users/10/photos # список фотографий


/***@@@
 solution.js
 Реализуйте маршрут /users/(\\w+).json, по которому будет доступна информация о конкретной записи из справочника. Данные отдаются в формате json, поэтому обязательно нужно выставить правильный media type.
 */

$ curl localhost:4000/users/5.json
{"data":{"name":"Lonny McGlynn","phone":"(935) 384-0149"}}

// Если такой записи не существует, необходимо вернуть код ответа 404 и пустое тело.

// FILE: /app/index.js:
import fs from 'fs';
import path from 'path';

import makeServer from './server';

export default (port, callback = () => {}) => {
    fs.readFile(path.resolve(__dirname, 'phonebook.txt'), (err, data) => {
        if (err) {
            throw err;
        }

        const users = data.toString()
            .trim()
            .split('\n')
            .reduce((acc, value) => {
                const [id, name, phone] = value.split('|').map(item => item.trim());
                acc[id] = { name, phone };
                return acc;
            }, {});

        const server = makeServer(users);
        server.listen(port, callback.bind(null, server));
    });
};


// FILE: /app/server.js:
import http from 'http';
import url from 'url';
import querystring from 'querystring';

const getParams = (address) => {
    const { query } = url.parse(address);
    return querystring.parse(decodeURI(query || ''));
};

const router = {
    GET: {
        '/users/(\\w+).json': (req, res, matches, users) => {
            const id = matches[1];
            res.setHeader('Content-Type', 'application/json');
            const user = users[id];

            if (!user) {
                res.writeHead(404);
                res.end();
                return;
            }

            res.end(JSON.stringify({ data: user }));
        },
        '/': (req, res, matches, users) => {
            const messages = [
                'Welcome to The Phonebook',
                `Records count: ${Object.keys(users).length}`,
            ];
            res.end(messages.join('\n'));
        },
        '/search.json': (req, res, matches, users) => {
            res.setHeader('Content-Type', 'application/json');

            const { q = '' } = getParams(req.url);
            const normalizedSearch = q.trim().toLowerCase();
            const ids = Object.keys(users);

            const usersSubset = ids
                .filter(id => users[id].name.toLowerCase().includes(normalizedSearch))
                .map(id => users[id]);

            res.end(JSON.stringify({ data: usersSubset }));
        },
        '/users.json': (req, res, matches, users) => {
            res.setHeader('Content-Type', 'application/json');

            const { page = 1, perPage = 10 } = getParams(req.url);
            const ids = Object.keys(users);

            const usersSubset = ids.slice((page * perPage) - perPage, page * perPage)
                .map(id => users[id]);
            const totalPages = Math.ceil((ids.length) / perPage);
            res.end(JSON.stringify({ meta: { page, perPage, totalPages }, data: usersSubset }));
        },
    },
};

export default users => http.createServer((request, response) => {
    const routes = router[request.method];
    const result = Object.keys(routes).find((str) => {
        const { pathname } = url.parse(request.url);
        if (!pathname) {
            return false;
        }
        const regexp = new RegExp(`^${str}$`);
        const matches = pathname.match(regexp);
        if (!matches) {
            return false;
        }

        routes[str](request, response, matches, users);
        return true;
    });

    if (!result) {
        response.writeHead(404);
        response.end();
    }
});




// ######################## JS: Express ########################

/**
 Хотя модуль http и дает нам возможность писать веб-приложения, этот способ нельзя назвать удобным. Сильно помешает отсутствие роутинга и удобных механизмов расширения функциональности. И это мы еще не копнули вглубь.

 Разработка веб-приложений это, в основном, стандартный процесс с понятным набором "хотелок", многие из которых будут пройдены в рамках данного курса. Центральной частью проекта курса является микрофреймворк express.
 */

import Express from 'express';
const app = new Express();

app.get('/', (req, res) => {
    res.send('Hello World!');
});

app.listen(3000, () => {
    console.log('Example app listening on port 3000!');
});

/**
 Удивительное дело: курсы, которые вы прошли до этого, гораздо сложнее для понимания и освоения, чем курсы по конкретным инструментам, таким как express. И, скорее всего, тенденция будет продолжаться. Связано это с тем, что умение программировать требует от вас хорошо развитого computation thinking (вычислительного мышления), включающего в себя много пунктов, помимо абстрактного и логического мышления. А работа с конкретным инструментарием больше похожа на монотонный труд в стиле "делай раз, делай два". Вся сложность в инструментах, обычно, сосредоточена в количестве используемых концепций. Поэтому для новичков документация по express может показаться нереально сложной без шансов на понимание. Как вы скоро убедитесь, это дело наживное, и к концу курса вы сможете уверенно ориентироваться в возможностях фреймворка и сможете создавать свои приложения уже совсем по взрослому.


 # Фреймворк
 Программная платформа, определяющая способ структурирования кода приложения

 Фреймворк противопоставляют понятию библиотека. С библиотеками мы уже хорошо знакомы и писали их не раз. В программировании библиотека это код, который может быть использован в программном продукте для выполнения различных подзадач, важно, что при этом библиотека не влияет на архитектуру приложения и не накладывает на нее ограничений.

 Фреймворк это, как ни странно, тоже код, который диктует правила построения архитектуры приложения, задавая на начальном этапе разработки поведение по умолчанию — "каркас", который нужно будет расширять и изменять согласно указанным требованиям.

 Может показаться, что фреймворк — это штука, которая только мешает, но это не так. Большинство приложений укладывается в некоторые стандартные рамки, соблюдая которые можно автоматизировать очень много задач и писать намного меньше кода. А еще это возможность создавать и переиспользовать библиотеки, ориентированные на работу с фреймворками. В современном мире популярный каркас идет в нагрузку с сотнями полезных расширений, которые за вас делают все, что только можно вообразить, за пивом только не ходят.

 # Микрофреймворк
 Устоявшееся название для минималистичных веб-фреймворков.

 Представляет из себя набор middlewares (описываются позже)
 Определяет прямую связь между маршрутом и обработчиком
 Не определяет файловую структуру
 Содержит минимальное количество встроенных возможностей
 */

// HTTP Verb + Route + Handler.
app.get('/', (req, res) => {
    res.send('Hello World!');
});

/**
 Express как раз относится к классу микрофреймворков. Очень популярное направление, родоначальником которого считается Sinatra, Ruby-микрофреймворк, появившийся в далеком 2007 году. С тех пор в каждом языке появились десятки подобных решений, среди которых есть минимум один-два очень популярных. Получается, что зная express вам будет несложно начать работать с подобным микрофреймворком на любом другом языке.

 # Проект

 Поскольку мы метим в веб-разработчики, то будет грехом не написать свой блог :) В процессе создания блога мы рассмотрим следующие темы:
 Express JS (Middlewares)
 Роутинг
 Логгирование
 Функциональное тестирование
 Шаблонизация
 REST
 Session
 Twitter Bootstrap
 Авторизация/Аутентификация
 Flash
 */



// >>>>>> Маршруты <<<<<<

/**
 Любое приложение на express состоит минимум из трех элементов:

 1. Создание объекта приложения
 2. Определение обработчиков маршрутов
 3. Запуск приложения на определенном порту
 */

import Express from 'express';
const app = new Express();

app.get('/', (req, res) => {
    res.send('Hello World!');
});

app.listen(3000, () => {
    console.log('Example app listening on port 3000!');
});

/**
 С первым и последним пунктом все более-менее понятно, а вот обработчики — это уже интересно. Напомню, что микрофреймворки строятся по схеме: http verb + path + callback. В случае express глагол определяется функцией, которая вызывается на объекте app. Например если мы хотим определить маршрут GET /, то для этого необходимо вызывать функцию get и первым параметром передать в нее строку /. Таким же образом нужно поступать для любого другого маршрута. Вот список глаголов, которые нас будут интересовать в процессе этого курса:
 */

// И - Идемпотентный
app.get // И
app.post
app.delete // И

// Полное обновление
app.put // И

// Частичное обновление
app.patch // И

/**
 Семантика http подразумевает, что все эти глаголы, за исключением post, являются идемпотентными. Это должно обеспечиваться программистом, который реализует обработчики.


 # Динамические маршруты

 Самая главная и мощная функциональность системы роутинга — это работа с динамическими маршрутами.
 */
Route path: /users/:userId/books/:id
Request URL: http://localhost:3000/users/34/books/8989
    req.params: { "userId": "34", "id": "8989" }

app.get('/users/:userId/books/:id', (req, res) => {
    const { userId, id } = req.params;
});

/**
 Для динамических частей используется заполнитель :name, который состоит из двоеточия и произвольного имени. Express производит сопоставление актуального запроса со всеми шаблонами в порядке определения и выполняет соответствующие обработчики. Все динамические части маршрута попадают в объект req.params.

 Кроме этого, express позволяет использовать регулярные выражения прямо в шаблоне:
 */
// abcd, abxcd, abRANDOMcd, ab123cd
app.get('/ab*cd', (req, res) => {
    res.send('ab*cd');
});


/**
 Честно говоря, за свой многолетний опыт я не припомню ситуацию, когда мне это могло понадобится. Всегда, если у вас есть возможность управлять урлами, можно сделать хороший вариант на одних плейсхолдерах (заполнителях), без прямого использования регулярных выражений.

 # Именованные маршруты
 У системы маршрутизации есть еще одна важная задача - генерация ссылок. В стандартной поставке express такого механизма нет. Это приводит к тому, что люди, незнакомые с концепцией, генерируют адреса в html, используя строки. Даже существует специальный термин, который называется хардкодинг, при котором прописываются конкретные значения вместо генерации.

 <a href=`/posts/${post.id}`>edit</a>

 На любом веб-фреймворке, в любом языке так делать нельзя. Если вы измените свои маршруты, то без полной проверки сайта будет невозможно понять что и где сломалось, ведь все ссылки остались старыми. Кроме помощи при отладке и рефакторинге, такой механизм убирает дублирование и позволяет (работает не всегда) изменять маршруты без необходимости переписывать генерацию адресов в html.
 */

import Express from 'express';
import Router from 'named-routes';

const app = new Express();
const router = new Router();
router.extendExpress(app);
router.registerAppHelpers(app);

app.get('/admin/users/:id', 'admin.user', (req, res, next) => {
    //... implementation
    // the names can also be accessed here:
    const path = app.namedRoutes.build('admin.user', { id: 2 }); // /admin/users/2
    // the name of the current route can be found at req.route.name
});

// В примере выше был создан именованный маршрут admin.user. Теперь, где-то в другом обработчике можно строить ссылки используя имя маршрута:

app.get('/users', 'users', (req, res, next) => {
    const path = app.namedRoutes.build('admin.user', { id: 2 }); // /admin/users/2
    // path содержит путь с которым можно сделать что-то полезное
});


/**
 Преимущества:

 - Если удалится маршрут, то при генерации ссылки мы получим исключение. И тесты его поймают.
 - Если изменится маршрут, то везде будут автоматически подставлены новые адреса.
 После долгих раздумий я решил, что в этом курсе, все же, мы будем хардкодить ссылки. Это связано с тем, что использование соответствующего механизма в express сильно меняет стандартные интерфейсы, а цель этого курса изучить чистые концепции. В реальной жизни используйте соответствующие расширения.

 # Request/Response

 Каждый определяемый обработчик принимает на вход два параметра: req и res. В этом смысле, все очень похоже на ситуацию с http модулем с той лишь разницей, что там подобный обработчик один, а здесь на каждый маршрут свой. Request и Response предоставляют упрощенный интерфейс. Больше нет необходимости, по крайней мере в простых случаях, пользоваться ими как eventEmitter. На каждую задачу эти объекты предоставляют метод или свойство.
 */

// GET /users?page=3
app.get('/users', (req, res) => {
    console.log(req.query); // { page: 3 }
    res.status(200);
    res.send(users);
    // res.json(users);
});


/**
 Пройдемся по базовым возможностям:

 - req.query готовый к обработке query string, другими словами вам не придется парсить эти параметры, они уже поступают в виде объекта
 - Установка статуса работает через метод res.status(code)
 - Отправка данных выполняется функцией res.send(data). Все необходимые заголовки выставляются автоматически
 - Если необходимо отдавать данные в виде json, то express позволяет это делать без использования дополнительных механизмов. Все что нужно сделать это вызвать метод res.json(data), и данные будут автоматически сериализованы и отправлены клиенту.

 # Дополнительные материалы
 Named Routes (Документация) https://github.com/alubbe/named-routes
 */

/***@@@
 Ваше первое express приложение, будет представлять из себя простой счетчик, с доступом через http интерфейс. Над счетчиком можно выполнять следующие операции:

 / - получить текущее значение счетчика в виде json: { "value": 0 }
 <METHOD> /increment - увеличение на единицу
 <METHOD> /decrement - уменьшение на единицу
 <METHOD> /reset - сброс значения счетчика на значение по умолчанию.
 <METHOD> /set?value=5 - установка счетчика в конкретное значение, которое передается как query параметр с именем value.

 Значение по умолчанию равно нулю. Все точки входа, кроме /, должны возвращать 204 no content.

 Имена методов не указаны специально. Необходимо их выбрать правильно с учетом требований http к семантике глаголов. Важно анализировать идемпотентность операции и требований по обеспечению идемпотентности глаголами http.

 solution.js
 Реализуйте функцию, которая возвращает сконфигурированное express приложение по приведенному выше сценарию.
 */

// FILE: /app/bin/server.js:
import solution from '../solution';

const port = 8080;
solution().listen(port, () => {
    console.log(`Server was started on '${port}'`);
});


// FILE: /app/solution.js:
import Express from 'express';

export default () => {
    const app = new Express();

    const init = 0;
    let index = init;

    app.get('/', (req, res) => {
        res.json({ value: index });
    });

    app.delete('/reset', (req, res) => {
        index = init;
        res.status(204).end();
    });

    app.put('/set', (req, res) => {
        index = Number(req.query.value);
        res.status(204).end();
    });

    app.post('/increment', (req, res) => {
        index += 1;
        res.status(204).end();
    });

    app.post('/decrement', (req, res) => {
        index -= 1;
        res.status(204).end();
    });

    return app;
};




// >>>>>> Тесты <<<<<<

/**
 Функциональное тестирование — это тестирование ПО в целях проверки реализуемости функциональных требований, то есть способности ПО в определённых условиях решать задачи, нужные пользователям.

 В отношении сайтов такое тестирование можно провести, делая http запросы к соответствующим обработчикам и проверяя их ответ. Чтобы это было возможно, требуется небольшая дисциплина кода. В случае express она выражается в том, что определение приложения отделяется от его запуска.
 */
// src/app.js
import Express from 'express';

const app = new Express();
app.get('/', (req, res) => res.send('hello'));
export default app;

// bin/app
#!/usr/bin/env node

import app from '../src/app';
app.listen(4000);

/**
 Такое разделение позволяет библиотекам для тестирования самостоятельно запускать приложение и останавливать его при выполнении запросов. Что, в свою очередь, позволяет легко этими тестами управлять. Вам не придется следить за тем, чтобы поднять сервер или выключить, вы просто будете запускать тесты и проверять результат.

 # Supertest
 Supertest — это библиотека, созданная исключительно с целью проводить функциональное тестирование http интерфейса.
 */

// __tests__/app.test.js
import request from 'supertest';
import app from '../src/app';

test('request', async () => {
    const res = await request(app).get('/');

    if (res.error) {
        throw error;
    }

    expect(res.status).toBe(200);
});

/**
 После выполнения запроса она возвращает response, который содержит параметры ответа, а так же объект error, в случае если произошла ошибка. Все тесты этого курса написаны с помощью данной библиотеки. При этом важно отметить, что эта библиотека не позволяет проверить генерируемый html, поэтому возможны ситуации, при которых ваш http интерфейс работает, а формы на сайте сделаны неправильно, что означает невозможность использования сайта. На данном этапе в бой вступает приемочное тестирование, которое не рассматривается в рамках данного курса.

 # Superagent

 В основе библиотeки supertest лежит другая библиотека - superagent. Именно она позволяет формировать произвольные запросы к серверу.
 */

import request from 'superagent';

const res = await request
    .post('/api/pet')
    .type('form')
    .send({ name: 'Manny', species: 'cat' })
    .set('X-API-Key', 'foobar')
    .set('Accept', 'application/json');

/**
 # Дополнительные материалы
 Superagent https://github.com/visionmedia/superagent
 Supertest https://github.com/visionmedia/supertest
 */



// >>>>>> Логирование <<<<<<<

/**
 Запущенный веб-сервер должен как-то сигнализировать о том, что он работает и принимает запросы. Express по умолчанию этого не делает, и единственное, что хоть немного успокаивает, это то, что запущенный сервер заблокировал терминал. В такой ситуации очень сложно понимать, происходит ли вообще что-то.

 Как вы уже догадались, решается это добавлением базового логирования. В сильно урезанном виде такой лог выглядит следующим образом:
 */

[19/Nov/2016:17:30:59 +0000] GET / HTTP/1.1 304 - "-" "Chrome/54.0.2840.71"
    [19/Nov/2016:17:30:59 +0000] GET /assets/bootstrap.css HTTP/1.1 304 - "http://localhost:8080/" "Chrome/54.0.2840.71"
    [19/Nov/2016:17:30:59 +0000] GET /posts/new HTTP/1.1 200 1076 "http://localhost:8080/" "Chrome/54.0.2840.71"

/**
 На запрос каждого ресурса, а одна страница может содержать множество ресурсов, например, картинки или стили, в лог пишется строчка. Строчка состоит из следующих элементов:
 - Время запроса
 - Параметры: verb, pathname, protocol, response, host, user agent
 Возможно и больше, зависит от настроек логера. Главное, что это нужно делать обязательно. Очень сильно помогает в отладке.

 # Morgan
 В javascript особой популярностью пользуется библиотека morgan.
 */

import Express from 'express';
import morgan from 'morgan';

const app = new Express();
const logger = morgan('combined');
app.use(logger);

/**
 Использование morgan сводится к, буквально, паре строк. По умолчанию весь вывод идет в stdout, а не в файл. Это не просто удобно, но и правильно. С одной стороны, легко видеть вывод сразу после старта, что удобно при разработке. С другой, в продакшене запуск любых сервисов должен происходить посредством супервизора. Супервизор, в свою очередь, сам занимается централизованным логированием, а от наблюдаемых процессов как раз и требуется вывод в stdout. Это позволяет супервизору перехватывать логи веб-сервера и складывать их в правильное место.

 Если вам понадобится по какой-то причине изменить формат лога, то сделать это крайне просто. Достаточно создать логер с указанием формата: morgan(':id :method :url :response-time'). Morgan в поставке идет с набором готовых параметров для логирования. В терминологии библиотеки они называются токенами. Каждый токен — это имя вида :url, и на месте каждого токена в заданном формате появляется значение, соответствующее текущему запросу. Подробнее о том, какие есть токены, можно посмотреть в официальной документации библиотеки. При необходимости вы даже можете создавать свои токены.


 # Дополнительные материалы
 Morgan https://github.com/expressjs/morgan
 */



// >>>>>> Отладка <<<<<<

/**
 Настало время серьезно поговорить про отладку. На протяжении многих курсов вы постоянно занимались отладкой, иногда часами, а иногда и днями, не могли понять почему все работает не так как должно работать. Это норма! (c) В повседневной практике такое случается не редко.

 Обычно все еще хуже. Бага произошла на продакшене, и у вас уже нет возможности воспроизвести ситуацию. Чем сложнее система, тем меньше шансов что это возможно. Каким образом отлаживать код в такой ситуации? Здесь мы приходим к главной идее отладки. Правильная отладка — это хорошо настроенное логирование.

 Есть общие практики, принятые во всех экосистемах, о которых мы сейчас поговорим. В этой истории немного особняком стоит именно js. Основной способ логирования, принятый в js, идет своим путем, который, на мой взгляд, достаточно неплох.

 Классическое логирование выглядит так. Подключается специальная библиотека со следующим интерфейсом:
 */
logger.debug("I'm a debug message!");
logger.info("OMG! Check this window out!");
logger.error("HOLY SHI... no carrier.");

/**
 Как правило, вызовы приводят к одному и тому же результату за исключением одного. У них разный уровень логирования. В самом логе вывод будет скорее всего таким:

 [debug] I'm a debug message!
 [info] OMG! Check this window out!
 [error] HOLY SHI... no carrier.

 Уровни логирования имеют следующую семантику:

 TRACE - дебаговые сообщения для определения flow
 DEBUG - дебаговые сообщения для определения conditions
 INFO - этапы нормального flow
 WARN - некритичные ошибки (но результат должен быть верным)
 ERR - ошибки, могущие привести к неверному результату
 FATAL - "ща грохнусь!"

 Чем ближе к началу списка, тем более подробный (говорят "verbose") лог. Важно, что в коде присутствуют все уровни, и вызовы проставляются самим программистом на основе его понимания работы программы. А вот дальше, уже во время эксплуатации программы, на уровне конфигурации, задается, какой уровень логирования необходимо поддерживать для данного запуска. Предположим, что стоит уровень info, что типично для production систем. Это значит, что в лог будут выводиться только те строчки, которые предназначены для уровней с info по fatal. Во время разработки уровень обычно debug, на этом уровне выводится много отладочной информации, позволяющей понять как идут и преобразуются данные. А так же по каким частям кода идет flow.

 Логи — настолько важная часть всего программного продукта, что существует множество решений для сбора, агрегации, анализа логов, в том числе облачных.

 # Debug

 А теперь забудьте все, что я вам говорил до этого :D. Шутка. Но суровая правда в том, что в js доминирует немного другой подход, что не отрицает возможности комбинирования.

 Подход js по сути завязан на конкретную библиотеку, которая предложила нестандартный способ работы.
 */

import debug from 'debug';
const log = debug('http');
const name = 'App';

log('booting %s', name);
// http booting App

/**
 Первое, что бросается в глаза, это отсутствие уровней логирования. Второе: перед использованием логера импортируется специальная функция, которая вызывается так debug('http'). Передаваемая строчка представляет из себя namespace. Имя, которое, подобно уровню логирования, отделяет логи друг от друга. В отличие от уровней логирования, неймспейсы не имеют никаких ограничений, их может быть столько, сколько нужно, и называть их можно как угодно. Неймспейсы, по сути, отвечают за некоторую подсистему, по которой мы хотим логировать. На практике это оказывается крайне удобным подходом. Обычно мы примерно понимаем на каком уровне и в какой подсистеме произошла ошибка, и хочется выводить лог (подробный) только по этой подсистеме. В случае использования уровней логирования это сделать невозможно, и приходится выискивать нужные строчки в массе других. С использованием неймспейсов это естественный способ работы.
 */

import debug from 'debug';
const httpRequestLog = debug('http:request');
const rpcLog = debug('rpc');

httpRequestLog('request');
rpcLog('action');

/**
 Но это еще не все. Неймспейсы могут быть вложенными. Это тоже крайне полезная фича. Обычно на верхнем уровне каждая библиотека определяет неймспейсом свое имя, а внутри уже идет разделение на конкретные подсистемы. Кроме того, в любой файл можно наимпортировать сколько угодно логов и использовать их в любых комбинациях.

 А теперь самое главное. Так сложилось, что 99% самых популярных библиотек на js уже поставляются со встроенным логированием через debug. По сути, нам не очень-то и оставили выбор. На картинке выше как раз видно кусок лога express.

 Последний вопрос касается того, как управлять этим выводом. По умолчанию debug ничего не печатает. Чтобы это изменить, нужно передать переменную окружения DEBUG следующим образом:

 DEBUG=* bin/server.js
 DEBUG=http:* bin/server.js
 DEBUG=*,-not-this bin/server.js

 Пример демонстрирует три разных варианта использования:

 - Вывести все логи (это коснется не только вашего приложения, будут выведены логи всех библиотек входящих в ваше приложение)
 - Вывести все логи внутри неймспейса http
 - Вывести все логи за исключением not-this неймспейса

 Дополнительные материалы
 Debug https://github.com/visionmedia/debug#readme
 */



// >>>>>> Шаблоны <<<<<<

/**
 Если проанализировать http запросы к типичному сайту, то можно заметить, что большая часть этих запросов направлена на получение контента, а не его модификацию. Другими словами, основная работа обработчиков состоит в том, чтобы сформировать правильный html и отправить его клиенту (браузеру). Единственный способ для генерации html, с которым мы знакомы, это ручной сбор строчки, содержащей разметку, и отправка посредством метода send.
 */

app.get('/', (req, res) => {
    res.send('<div>Hello World!</div>');
});

/**
 Сказать, что этот способ плох, это ничего не сказать. Кроме того, что это крайне неудобно, существует масса других недостатков в таком подходе. Если заглянуть в историю развития web, то выяснится интересный факт: php появился как средство решения описанной выше задачи, а не как язык программирования.

 Задачу по формированию разметки называют шаблонизацией, а конкретные библиотеки для шаблонизации называют шаблонизаторами. Общий принцип работы такой: описываются файлы с разметкой, а библиотека предоставляет функции для загрузки этих шаблонов в код. Во время загрузки происходят необходимые подстановки и шаблон заполняется конкретными данными.

 # Jinja Like

 Классическим примером может служить шаблонизатор jinja из мира питона. Его популярность привела к тому, что в каждом языке есть множество шаблонизаторов, очень похожих и даже работающих так же, как jinja. Поэтому можно говорить о целом классе jinja-like шаблонизаторов.

 <h1 class="header">{{ pagename | title }}</h1>
 <div class="small">authors</div>
 <ul>
 {% for author in authors %}
 <li{% if loop.first %} class="first"{% endif %}>
 {{ author }}
 </li>
 {% endfor %}
 </ul>


 По сути jinja — это хоть и примитивный, но полноценный язык программирования, который вкрапливается в файл с разметкой и расширяет его во время обработки. Несмотря на очевидность этого решения, оно обладает рядом недостатков. Первое — это сложность редактирования такого рода шаблонов. Из-за перемешивания кода с версткой приходится скакать вверх-вниз чтобы добавить/удалить/изменить теги, и тоже самое нужно делать с конструкциями самого языка. Этот недостаток может быть не очевиден тем, кто никогда не видел альтернативных решений, и как мы увидим позже, они есть. Второе: в подобных шаблонизаторах текст вне конструкций шаблонизатора, то есть та самая верстка, никак не анализируется. Это легко приводит к проблемам типа "незакрытый тег", или семантическому нарушению html, когда неправильно друг в друга вкладываются теги, используются несуществующие атрибуты и тому подобное. И третий немаловажный момент: оформление шаблонов не проверяется автоматическими инструментами, и поэтому стиль будет сильно зависеть от человека.

 # Pug (Haml Like)

 Существует и совершенно другой подход к организации шаблонов. Когда я в первый раз увидел такое, то был немало удивлен. Кажется, что самостоятельно дойти до этого решения очень сложно. Чтобы не томить, сразу покажу пример:
 */

h1.header= pagename
    .small authors
ul
each author, index in authors
li(class= index === 0 && "first")= author

/**
 Этот пример почти идентичен тому, что было выше с использованием jinja-like шаблонизатора. Обратите внимание насколько чище шаблон во втором примере и на то, что он почти в два раза короче.

 История таких шаблонизаторов берет свое начало с haml, руби шаблонизатора, который в мире rails является решением номер один уже очень много лет. После этого оно было скопировано во многие языки, как и jinja. В js мире haml-like шаблонизатор был долгое время известен как jade, и лишь недавно его переименовали в pug.

 Попробуем разобраться с основными принципами работы таких шаблонизаторов. Во-первых, это так же язык программирования, но в отличие от jinja-like шаблонизаторов, то что не является кодом, на самом деле не является версткой. Все, что пишется в pug-шаблонах, будет обрабатываться парсером, другими словами, в haml-like шаблонизаторах вы не можете писать все что угодно вне управляющих конструкций. Во-вторых, шаблон строится с помощью особого синтаксиса, который задает теги в виде имен, а вложенность определяется отступом на следующем уровне.

 И, с одной стороны, у вас появляется новый язык и новый способ построения html. Что требует некоторого привыкания, но с другой, преимущества оказываются настолько сильными, что человек, распробовавший подобные шаблонизаторы, врядли добровольно вернется на jinja-like библиотеки. Ниже перечислены основные преимущества:

 - Шаблон чище, гораздо короче и уже
 - Отсутствует проблема незакрытых тегов (т.к. их просто нет)
 - Писать и модифицировать такие шаблоны гораздо проще
 - Стиль задается грамматикой (писать по разному практически невозможно)
 - Шаблоны валидируются, и соответствующая библиотека не даст делать совсем злые вещи
 - Вставляемые данные по умолчанию всегда экранируются (привет php!)

 Интеграция pug с express выглядит очень просто:
 */

// $ npm install pug

app.set('view engine', 'pug');

app.get('/', (req, res) => {
    const data = { title: 'Hey', message: 'Hello there!' };
    res.render('index', data);
})
// index.pug
html
head
title= title
body
h1= message


/**
 Все сводится к установке зависимости и установке pug в качестве движка для рендеринга шаблонов. После этого, внутри обработчиков можно начинать использовать метод render. Первый параметр которого - это путь до шаблона, второй - набор параметров для подстановок внутри шаблона.

 Это не единственный способ передачи параметров в шаблон. В большинстве случаев они передаются именно вторым параметром в render, но иногда возможны ситуации, в которых у нас есть сквозная функциональность, и было бы крайне неудобно прокидывать их в шаблон в каждом обработчике. Реализуется это через установку свойств в объект res.locals, а в шаблоне эти свойства становятся доступны как переменные. Эту особенность мы будем использовать позже, когда начнем работать с сессиями и аутентификацией. Помните, что злоупотреблять этим способом не стоит, явное лучше неявного. Стремитесь к тому, чтобы код был чистый (использовал чистые функции).

 # Наследование шаблонов

 На практике сайт не всегда состоит из уникальных страниц. Обычно меняется только контентная часть, а вокруг одно и тоже. Часть, которая не меняется, принято называть макетом или лейаутом (layout). Это настолько распространенный кейс, что большинство шаблонизаторов поддерживают механизм для выделения лейаутов. В pug он называется наследованием шаблонов. Ниже приведен пример такого наследования.
 */

//- layout.pug
html
head
title My Site - #{title}
block scripts
script(src='/jquery.js')
body
block content
block foot
#footer
p some footer content

//- page-a.pug
extends layout.pug

append scripts
script(src='/pets.js')

block content
h1= title
    - const pets = ['cat', 'dog']
each petName in pets
h2= petName

/**
 В шаблоне, который мы используем для рендеринга нашей страницы, пишется специальная директива extends .... В нее передается имя окружающего шаблона, который чаще является макетом. В макете определяется блок (или блоки), в которые будет происходить подстановка кусков шаблона. Далее необходимо в шаблоне (не макете) определить такие же блоки и наполнить их контентом. Синтаксис задания блоков в обоих местах одинаковый, только в одном случае блок не содержит тела, а в другом содержит.

 # Включения
 Так же бывает полезным механизм включения, позволяющий выделять из шаблонов общие части и переиспользовать их.

 # Чистота

 На просторах интернета постоянно спорят о том, что может быть в шаблоне, а чего нет. Что является логикой вывода, а что нет. При этом есть ряд правил, которые объективно нарушать не стоит.

 1. Ни в коем случае шаблон не должен порождать побочных эффектов. В шаблоне нельзя писать в базу, изменять данные на диске и вообще любым способом пытаться влиять на окружающую среду. Шаблон это исключительно чтение.
 2. Шаблоны должны быть декларативны, никакой мутации состояний, другими словами, если вы начинаете внутри шаблона вводить переменные и изменять их, то, по сути, шаблон превращается в полноценный скрипт, который вы программируете. Не допускайте этого.
 3. Использовать логику, влияющую на вывод внутри шаблона — это нормально. Если у вас, с точки зрения ui, блок показывается по определенному условию, то вы не сможете этого избежать, единственное о чем нужно помнить, это создавать вовремя правильные абстракции (функции) для избежания дублирования, а так же для выделения бизнес-правил.

 # Перезагрузка кода
 В отличие от js кода, express автоматически перечитывает файлы с шаблонами после каждого запроса, другими словами вам не требуется помощь nodemon для рестарта приложения при обновлении шаблонов.

 # Дополнительные материалы
 Pug https://pugjs.org/api/getting-started.html
 */

/***@@@
 Реализуйте приложение, которое представляет из себя блог. Сайт должен позволять просматривать список постов и давать возможность добавлять новые посты.

 GET /posts - список постов
 GET /posts/:id - страница поста
 GET /posts/new - форма для создания нового поста
 POST /posts - создание нового поста. В случае успеха ожидается редирект на страницу поста, в противном случае должен быть возвращен код 422 и отрисована форма с указанием ошибок.
 Приложение содержит одну сущность - Post, которая содержит три обязательных поля:

 title и body - задаются через форму.
 id - проставляется автоматически, для каждого нового поста должен увеличиваться на единицу

 entities/Post
 Реализуйте сущность Post

 solution.js
 Реализуйте недостающие обработчики express

 views/posts/index.pug
 Реализуйте вывод постов в табличной форме. Так же на страницы должны быть ссылки на просмотр постов и ссылка на создание нового.

 views/posts/new.pug
 Реализуйте форму создания нового поста

 views/posts/show.pug
 Реализуйте просмотр конкретного поста

 Подсказки
 К заданию подключен http://getbootstrap.com/ Вы можете его использовать.
 */

// FILE: /app/entities/Post.js:
export default class Post {
    static id = 1;

    constructor(title, body) {
        this.id = Post.id;
        Post.id += 1;
        this.title = title;
        this.body = body;
    }
}


// FILE: /app/solution.js:
import Express from 'express';
import bodyParser from 'body-parser';

import Post from './entities/Post';

export default () => {
    const app = new Express();
    app.set('view engine', 'pug');
    app.use('/assets', Express.static(process.env.NODE_PATH.split(':')[0]));
    app.use(bodyParser.urlencoded({ extended: false }));

    const posts = [
        new Post('hello', 'how are you?'),
        new Post('nodejs', 'story about nodejs'),
    ];

    app.get('/', (req, res) => {
        res.render('index');
    });

    app.get('/posts', (req, res) => {
        res.render('posts/index', { posts });
    });

    app.get('/posts/new', (req, res) => {
        res.render('posts/new', { form: {}, errors: {} });
    });

    app.get('/posts/:id', (req, res) => {
        const post = posts.find(p => p.id.toString() === req.params.id);
        res.render('posts/show', { post });
    });

    app.post('/posts', (req, res) => {
        const { title, body } = req.body;

        const errors = {};

        if (!title) {
            errors.title = "Can't be blank";
        }

        if (!body) {
            errors.body = "Can't be blank";
        }

        if (Object.keys(errors).length === 0) {
            const post = new Post(title, body);
            posts.push(post);
            res.redirect(`/posts/${post.id}`);

            return;
        }

        res.status(422);
        res.render('posts/new', { form: req.body, errors });
    });

    return app;
};


// FILE: /app/views/posts/index.pug:
extends ../layouts/app.pug

block content
div
a(href='/') Main page
// <table class="table">
//   <tbody>
//     <tr><th>Title</th></tr>
//     <tr><td><a href="/posts/1">hello</a></td></tr>
//     <tr><td><a href="/posts/2">nodejs</a></td></tr>
//     <tr><td><a href="/posts/3">asdfa</a></td></tr>
//     <tr><td><a href="/posts/4">111</a></td></tr>
//   </tbody>
// </table>

if posts.length > 0
    table.table
tr
th Title
for post in posts
    tr
td
a(href=`/posts/${post.id}`)= post.title
else
p Пусто



// FILE: /app/views/posts/new.pug:
extends ../layouts/app.pug

block content
// <form action="/posts" method="post">
//   <div><label>Title<sup>*</sup></label><input name="title"></div>
//   <div><label>Body<sup>*</sup></label><textarea rows="10" name="body"></textarea></div>
//   <input type="submit" value="Save">
//  </form>


h3 New Blog Post
form(action='/posts' method='post')
div
label
| Title
sup *
input(name='title' value=form.title)
if errors.title
    p= errors.title
div
label
| Body
sup *
textarea(rows=10 name='body')= form.body
if errors.body
    p= errors.body
input(type='submit' value='Save')

// FILE: /app/views/posts/show.pug:
extends ../layouts/app.pug

block content
div
a(href='/') Main page

h3= post.title
    = post.body




// >>>>>> Assets <<<<<<

/**
 Сайт — это не только динамически генерируемые страницы, но так же и различные статические файлы (ресурсы), такие как картинки, файлы стилей, шрифты. Раздача статики — это работа, которую на себя берут фреймворки и веб-сервера.

 В Express это работает следующим образом. Определяется специальный маршрут, который связывается с обработчиком Express.static(pathway). Обработчик в свою очередь принимает на вход путь, по которому он будет просматривать файлы на диске.
 */

import path from 'path';
import Express from 'express';
const app = new Express();

const pathway = path.join(__dirname, 'public');
app.use('/assets', Express.static(pathway));

// http://localhost:3000/assets/images/kitten.jpg
// http://localhost:3000/assets/css/style.css
// http://localhost:3000/assets/js/app.js
// http://localhost:3000/assets/images/bg.png
// http://localhost:3000/assets/hello.html


/**
 Важно отметить, что указанный маршрут /assets не участвует в поиске файла на диске, другими словами, он используется только для http адресов.

 # Bootstrap
 Представьте себе ситуацию: вы решили сделать сайт любителей игры "Мафия". И сразу же стало понятно, что вы не представляете себе, как он будет выглядеть. Дизайнер из вас так себе, да и нет времени и возможности делать дизайн самостоятельно, а следовательно, потом его нарезать, верстать и интегрировать в сайт. Современная верстка тоже не самое простое занятие, как может показаться на первый взгляд. Не говоря уже про то, что сверстать сайт так, чтобы он везде выглядел хорошо, еще та история, особенно если под "везде" мы понимаем не только разные браузеры, но и разные устройства, в том числе мобильные. Что делать?

 1. Заплатить дизайнеру/верстальщику -)
 2. Попробовать найти готовый сверстанный макет. В целом, это возможно, но чаще всего такие макеты готовят под конкретные cms, что накладывает на них определенный отпечаток. Так же эти макеты практически не расширяемы. Они не позволяют делать больше того, что заложено в них.

 Даже если макет будет найден, встает вопрос о том, как оформлять административный интерфейс. И на этом этапе должна появится мысль о том, что неплохо было бы автоматизировать этот процесс. Каждый сайт содержит административный интерфейс, причем все они более-менее одинаковые.

 В какой-то момент появилось направление так называемых css фреймворков. Наборы стилей и, возможно, js файлов, которые предоставляют базовые классы для формирования макетов, а так же готовые компоненты для наиболее часто встречающихся задач.

 Самым популярным фреймворком является Bootstrap. Более того, Bootstrap является одним из самых популярных проектов на всем гитхабе! Он позволяет очень быстро накидать внешний вид сайта и дает множество механизмов для его кастомизации. Например hexlet.io полностью построен на Bootstrap. Такой подход позволяет нам очень быстро внедрять фичи и не тратить время на цикл дизайна/верстки. И мы почти не пишем своих стилей.

 Во всех уроках этого курса в шаблонах используется Bootstrap. С одной стороны, мы хотим показать преимущества его использования на стадии прототипирования. С другой, надеемся на то что вы немного поизучаете его возможности и начнете использовать.
 */





// >>>>>>> REST <<<<<<

/**
 REST это магическая аббревиатура, которую так любят все использовать по любому случаю. Причем, чаще всего, не к месту. Чтобы ее понять, нужно немного отмотать назад и поговорить о том, как все начиналось.

 Одним из способов межпроцессной коммуникации (IPC) является удаленный вызов процедур (RPC). Идея этого подхода достаточно проста. В одной программе вызывается функция, которая на самом деле находится на другом компьютере (не всегда, но всегда в другом процессе). Прозрачно для программиста происходит синхронный запрос на удаленный компьютер, а затем результат возвращается в текущее место вызова, другими словами, RPC — это клиент-серверное взаимодействие.

 Существует множество технологий и протоколов, построенных на идеях RPC, например soap, json-rpc, xml-rpc, CORBA, D-Bus и другие. Многие из них достаточно сложны в использовании и реализации.

 С появлением интернета стали набирать обороты веб-сервисы, сайты, предоставляющие api для взаимодействия с ними. Попытки стандартизировать это взаимодействие привели к тому, что идеи RPC стали применяться и в вебе.

 Попробую на примерах раскрыть суть этого подхода с использованием http. Он состоит в том, что определяется единая точка входа в приложение, например, /myapi через которую, как ожидается, будут передаваться команды для управления сервисом. Можем предположить, что в простейшем случае действие определяется ассоциативным массивом из трех значений type, action, data. Посмотрим, как в таком случае будет выглядеть работа с сервисом (обратите внимание, что ниже описаны запросы к сервису со стороны клиента).
 */

// Создать пользователя
const response1 = await axios.post('/myapi', {
    type: 'user',
    action: 'create',
    data: {
        nickname: 'malloc',
    },
});

// Выполнить рассылку писем
const response2 = await axios.post('/myapi', {
    type: 'maillist',
    action: 'send',
    data: {
        id: 244,
    },
});

// Удалить проект
const response3 = await axios.post('/myapi', {
    type: 'project',
    action: 'delete',
    data: {
        id: 11,
    },
});


/**
 Как видно из примеров выше, http участвует в процессе только как способ передать данные на сервер. Это и называется транспортный протокол (хотя с точки зрения osi http не является транспортным протоколом, но это не важно, реальная жизнь не всегда совпадает с теоретическими моделями). А сама структура сообщений должна напоминать вам вызовы обычных функций, только расположенных на другом сервисе. В этом и есть вся суть удаленного вызова процедур.

 Широко известной и используемой технологией считается SOAP. Навороченный протокол не только для RPC, но и для обмена любыми произвольными сообщениями.

 Запрос:

 <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
 <soap:Body>
 <getProductDetails xmlns="http://warehouse.example.com/ws">
 <productID>12345</productID>
 </getProductDetails>
 </soap:Body>
 </soap:Envelope>

 Ответ:

 <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
 <soap:Body>
 <getProductDetailsResponse xmlns="http://warehouse.example.com/ws">
 <getProductDetailsResult>
 <productID>12345</productID>
 <productName>Стакан граненый</productName>
 <description>Стакан граненый. 250 мл.</description>
 <price>9.95</price>
 <currency>
 <code>840</code>
 <alpha3>USD</alpha3>
 <sign>$</sign>
 <name>US dollar</name>
 <accuracy>2</accuracy>
 </currency>
 <inStock>true</inStock>
 </getProductDetailsResult>
 </getProductDetailsResponse>
 </soap:Body>
 </soap:Envelope>


 Принцип точно такой же, как и в примере выше. Структура тела запроса целиком описывает то, что нужно делать, и http к этому никак не причастен, его задача доставить сообщение и вернуть ответ.

 Ирония судьбы в том, что изначально SOAP расшифровывался как Simple Object Access Protocol, что являлось прямой противоположностью тому, чем он являлся. Сложность SOAP, многословность, медленная работа — все это привело к тому, что использовать его стали сильно меньше, и современные web приложения часто выбирают REST-like подход.

 Перед тем, как перейти к REST, нельзя не упомянуть о хаотичном rpc подходе. Это подход (имя которому я сейчас придумал) уже частично использует http как прикладной протокол, но все так же ориентирован на вызов удаленных процедур, то есть на действия.

 Запросы в этом стиле выполняются так:
 */

// URI в этих запросах не идентифицируют ресурсы, они говорят только о действии
axios.post('/removeUser', { id: 5 });
axios.get('/getCountriesCount');
axios.post('/setProjectName', { name: 'new name' });

/**
 Его хаотичность выражается в том, что сервисы, построенные таким образом, не используют никаких стандартных реализаций, а все придумали самостоятельно. Что плохо со всех сторон. Во-первых, вы не сможете использовать стандартные библиотеки для популярных решений, во-вторых, вам придется изучать особенности поведения, которые, к тому же, будут несогласованными (неконсистентными).

 # Representational State Transfer (REST)

 Термин "REST" был введён Роем Филдингом, одним из создателей протокола "HTTP", лишь в 2000 году. В своей диссертации "Архитектурные стили и дизайн сетевых программных архитектур" ("Architectural Styles and the Design of Network-based Software Architectures") в Калифорнийском университете в Ирвайне он подвёл теоретическую основу под способ взаимодействия клиентов и серверов во Всемирной паутине, абстрагировав его и назвав "передачей представительного состояния".

 В отличие от веб-сервисов на основе SOAP, не существует "официального" стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем (я бы даже сказал набором практик), в то время как SOAP является протоколом.

 Чтобы протокол взаимодействия соответствовал REST-стилю, необходимо соблюсти, как минимум, 5 требований. Если сервис соблюдает только часть из них, то про такой протокол говорят, что он REST-like. Если соблюдаются все требования, то протокол является RESTful. На практике, есть ситуации, в которых невозможно следовать REST требованиям, поэтому большинство протоколов являются REST-like, даже если они утверждают другое.

 # Единообразие интерфейса

 1 Идентификация. В отличие от RPC, в котором протоколы ориентированы на действия (глагол), в REST стиле подразумевается ориентация на ресурсы (существительное). Взаимодействие с каждым ресурсом происходит посредством представлений ресурса, запрашиваемых по URI, который идентифицирует конкретный ресурс. То есть, мы никогда не взаимодействуем с самим ресурсом напрямую, а получаем лишь его представления, которых может быть много. Сервер может отдать данные в формате json или html, хотя при этом ни один из них не является реальным типом хранения внутри сервера.
 2 Манипуляция ресурсами через представление. Если клиент хранит представление ресурса, включая метаданные - он имеет достаточно данных для модификации или удаления ресурса.
 3 "Самоописываемые" сообщения. Каждое сообщение содержит достаточно информации, чтобы описать, каким образом его обрабатывать. К примеру, какой парсер необходимо применить для извлечения данных, может быть описано в Internet медиа-типе, другими словами, посылая на сервер json в теле http запроса, REST диктует обязательную установку типа контента в заголовке. В общем случае для обработки сообщения должно быть достаточно информации из самого сообщения (все, что может передаваться по http).

 По таблице ниже видно, что каждый URI является идентификатором либо одиночного ресурса, либо коллекции ресурсов (это тоже ресурс), а необходимые действия задаются посредством использования подходящего http глагола. И все это должно происходить в строгом соответствии семантике http, другими словами, REST использует то, что заложено в http, а не меняет это или добавляет свое.


 | GET       | /photos          | display a list of all photos                 |
 | GET       | /photos/new      | return an HTML form for creating a new photo |
 | POST      | /photos          | create a new photo                           |
 | GET       | /photos/:id      | display a specific photo                     |
 | GET       | /photos/:id/edit | return an HTML form for editing a photo      |
 | PATCH/PUT | /photos/:id      | update a specific photo                      |
 | DELETE    | /photos/:id      | delete a specific photo                      |

 # Кэширование
 Как и во Всемирной паутине, каждый из клиентов, а также промежуточные узлы между сервером и клиентами могут кэшировать ответы сервера. В каждом запросе клиента должно явно содержаться указание о возможности кэширования ответа и получения ответа из существующего кэша. В свою очередь, ответы могут явно или неявно определяться как кэшируемые или некэшируемые для предотвращения повторного использования клиентами в последующих запросах сохранённой информации. Правильное использование кэширования в REST-архитектуре устраняет избыточные клиент-серверные взаимодействия, что улучшает скорость и расширяемость системы.

 # Отсутствие состояния
 Протокол взаимодействия между клиентом и сервером не сохраняет какого-либо сессионного состояния после запроса и ответа (Stateless protocol). В случае необходимости, такое состояние должно сохраняться на клиенте. Только тогда пользователь отвязан от конкретного сервера, что, в свою очередь, позволяет масштабироваться и безболезненно переносить (балансировать) запросы между серверами.

 Примером такого состояния является корзина в интернет магазине. Если она привязана к пользовательской сессии и хранится на конкретном сервере (а не в браузере клиента), то отправить запрос пользователя на другой сервер станет невозможно. Он просто не увидит своей корзины. Эту проблему можно решить двумя способами. Первый - хранить ее на клиенте используя, например, cookie. Вторая - изменением способа хранения корзины на сервере и помещением ее в базу данных, которая доступна со всех серверов.

 На практике сайты активно используют понятие "сессии", при котором данные могут храниться на стороне сервера, что является нарушением REST.

 # Клиент-серверная архитектура
 Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделяя потребности интерфейса клиента от потребностей сервера, хранящего данные, повышается переносимость кода клиентского интерфейса на другие платформы, а упрощая серверную часть, улучшается масштабируемость.

 # Слои
 Клиент может взаимодействовать не напрямую с сервером, а через промежуточные узлы (слои). При этом клиент может не знать об их существовании, за исключением случаев передачи конфиденциальной информации. Промежуточные серверы выполняют балансировку нагрузки и могут использовать дополнительное кэширование.

 # Код по требованию (необязательное ограничение)
 REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев. Филдинг утверждает, что дополнительное ограничение позволяет проектировать архитектуру, поддерживающую желаемую функциональность в общем случае, но возможно за исключением некоторых контекстов.

 # Преимущества REST
 Филдинг указывал, что приложения, не соответствующие приведённым условиям, не могут называться REST-приложениями. Если же все условия соблюдены, то, по его мнению, приложение получит следующие преимущества:

 - Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна)
 - Производительность (за счёт использования кэша)
 - Масштабируемость
 - Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети)
 - Простота интерфейсов
 - Портативность компонентов
 - Лёгкость внесения изменений
 - Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины)

 # По-простому
 Грубо говоря, REST это набор рекомендаций о том, как лучше сделать для получения преимуществ, описанных абзацем выше. Чем больше рекомендаций вы выполните, тем более REST получается приложение. А поскольку жизнь сложна, то это нормально, что REST ориентированными сервисы являются только отчасти. Использования REST как догмы ни к чему хорошему не приведет. И REST никоим образом не заменяет собой rpc. Выбор решения зависит от ситуации и предъявляемых требований.

 # JSONAPI
 Хотя REST и выглядит хорошо, он все же слишком далек от конкретных реализаций и описывает только фундаментальные аспекты взаимодействия. Конкретные способы организации урлов, передаваемые данные, поведение в случае ошибок и многое другое, придется продумывать самостоятельно.

 Есть и другой путь. В 2013 году появился стандарт под названием jsonapi, в котором очень подробно описано как создавать REST-like сервисы. Для его реализации написано множество библиотек под все популярные языки программирования. Как минимум, я рекомендую с ним ознакомиться, а еще лучше - взять на вооружение. Использование открытых стандартов в промышленном программировании делает нашу жизнь проще, бизнес богаче, а волосы шелковистее.
 */


/***@@@
 html формы обладают одним недостатком, который нам придется обойти. Все что мы можем указать в method (аттрибут определяющий тип запроса к серверу) это get или post, а нам нужны и patch и delete. Решается это эмуляцией. На сервер посылается post, а в action формы записывается ссылка с таким параметром ?_method=PATCH. Поддержкой со стороны сервера занимается библиотека methodOverride. Подключается она следующим образом:
 */
app.use(methodOverride('_method'));

/**
 application.js
 Реализуйте оставшиеся части круда для работы с постами.

 GET /posts/:id/edit - редактирование поста
 PATCH /posts/:id - обновление поста
 DELETE /posts/:id - удаление поста
 views/posts/index.pug
 Реализуйте вывод постов в табличной форме. Для каждого поста нужно вывести ссылки для редактирования и удаления.

 views/posts/edit.pug
 Создайте форму для редактирования поста по образу и подобию формы создания поста new.pug.
 */

// FILE: /app/views/posts/edit.pug:
extends ../layouts/app.pug

block content

    .row.mt-3
    .col-sm-6.mx-auto
h3.text-xs-center Edit '#{post.title}'
form(action=`/posts/${post.id}?_method=PATCH` method='post')
include _form.pug

// FILE: /app/views/posts/index.pug:
extends ../layouts/app.pug

block content

if posts.length > 0
    table.table
tr
th Title
th Actions
for post in posts
    tr
td
a(href=`/posts/${post.id}`)= post.title
td
a(href=`/posts/${post.id}/edit`) Edit
form.form-inline.d-inline-block(action=`/posts/${post.id}?_method=DELETE` method='post')
button.btn.btn-link(type='submit') Delete
else
p Пусто





// >>>>>> Middlewares <<<<<<

/**
 До сих пор мы пользовались фреймворком express как черным ящиком. Что, кстати, характеризует его как хорошую абстракцию. Но помимо очевидного внешнего поведения у микрофреймворков есть еще одно интересное сходство. Давайте зададим себе вопрос: какими качествами должен обладать хороший фреймворк?

 Самое очевидное и важное — это концептуальный дизайн, который определяет то, с какими абстракциями мы имеем дело. Бывают фреймворки, в которых абстракции не очень удачные, и разработка на нем обрастает случайной сложностью. С другой стороны, в вебе более-менее выработан единый подход к организации серверных фреймворков. Доминирующей является архитектура MVC, с которой мы и работаем. Controller - контроллеры это наши обработчики, View - это шаблоны, а Model - это наши сущности и бизнес-логика.

 Замечание. Исторически MVC, который принят в вебе, сильно отличается от первоначального MVC, основное применение которого было толстые клиенты. В литературе можно встретить обозначение "MVC v2" для веб версии.

 Если предположить, что с дизайном все в порядке, то на сцену выходят более утилитарные качества:

 - Гибкость
 - Расширяемость
 - Модульность
 В этом месте мы поговорим о расширяемости, которая в свою очередь приводит к модульности. Рассмотрим самый простой пример - функции. Как можно расширить поведение функции?

 # Wrapping
 */
const f1 = x => x + 5;
const f2 = x => f1(x * 2);
const f3 = x => f2(x - 10) - 3;

f3(20); // ((((20 - 10) * 2) + 5) - 3) = 22

const nextF = (/** args */) => {
    // preprocessing
    const result = prevF(/** updatedArgs */);
    // afterprocessing
    return /** newResult */;
};

/**
 Нет ничего проще, чем расширять поведение функции. Нужно написать новую функцию, в которой используется первоначальная. Единственное условие, которое нужно соблюсти, это совпадение входов этих функций (количество и тип аргументов) и выходов (тип выхода). В таком случае код, использующий вашу обернутую функцию, даже не сможет догадаться о том, что она обернута, ну а главное, что его не нужно переписывать, ведь интерфейс функции не поменялся, хотя и появилось новое поведение. Такой способ так же называют декорированием, и в справочниках по шаблонам проектирования описывают как "паттерн декоратор".

 По похожей идее устроен express, а точнее connect, который является ядром микрофреймворка express.

 # Connect
 */

import Connect from 'connect';

const app = new Connect();
const logger = morgan('combined');

app.use(methodOverride('_method'));
app.use(logger);
app.use(bodyParser.urlencoded({ extended: false }));

// respond to all requests
app.use((req, res) => {
    res.end('Hello from Connect!');
});

/**
 # Middleware
 Connect представляет из себя механизм, который расширяется функциями, называемыми middleware. Каждый раз, когда мы используем use, очередная middleware добавляется в общую очередь. В конечном счете получается объект, наполненный мидлварами. Каждый запрос, отправляемый на обработку в connect, проходит через цепочку этих middleware пока не наткнется на терминальную мидлвару.

 В свою очередь каждая мидлвара принимает на вход три параметра: request, response и next. Она может поменять их и в конце должна вызвать next для передачи управления следующей по списку мидлваре. В этом и заключается вся мощь микрофреймворков. Удачный дизайн позволяет легко разбивать систему на модули-мидлвары и расширять за счет мидлвар, которые, в большом количестве, пишут сторонние разработчики.
 */

app.use((req, res, next) => {
    req.newProperty = 'hello from my middleware';
    next();
});

// вызов methodOverride возвращает функцию вида (req, res, next) => ...
app.use(methodOverride('_method'));

/**
 В Connect нет ничего кроме метода use добавляющего очередную мидлвару в стек.

 # Mount middleware
 Самое интересное в Connect, что обработчики конкретных маршрутов — это тоже, всего навсего, мидлвары. Их особенностью является привязка к конкретному маршруту, в отличие от мидлвар, которые выполняются для всех запросов.
 */

app.use('/foo', (req, res, next) => {
    // req.url starts with "/foo"
    next();
});

app.use('/bar', (req, res, next) => {
    // req.url starts with "/bar"
    next();
});

/**
 Такие мидлвары позволяют реализовывать базовый роутинг без привязки к конкретному глаголу http и без поддержки динамических маршрутов. В Express роутинг реализован без привязки к Mount Middlewares.

 # Terminate
 Но далеко не всегда мы хотим двигаться вглубь. Более того, в какой-то момент одна из мидлвар должна взять обработку на себя.
 */

// connect
app.use((req, res) => {
    res.end('Hello from Connect!');
});

// express
app.use((req, res) => {
    res.send('Hello from Express!');
});


/**
 У такого поведения, когда есть цепочка функций и любая из них в процессе обработки может принять решение остановки цепочки и возврата ответа, есть имя. Такие цепочки называют chain responsibility, и это тоже паттерн.

 # Дополнительные материалы
 Connect https://github.com/senchalabs/connect
 */


/***@@@
 Часто приложению нужно анализировать клиентов, которые приходят. Например, для пользователей ie6 часть функций может быть недоступна, поэтому желательно показывать предупреждение. Возможно сайт имеет оптимизированную версию для мобильных устройств и при определении оных, подставляет именно эту версию.

 Для подобных задач, нужна возможность удобно оперировать свойствами user-agent. В каждом языке есть по несколько популярных решений. Все они сводятся к тому что им передается значение заголовка user-agent, а на выходе получается ассоциативный массив со всевозможными параметрами.

 solution.js
 Реализуйте и экспортируйте по умолчанию мидлвару, которая добавляет в request свойство useragent. Значением поля должен быть объект, полученный в результате парсинга заголовка User-Agent используя библиотеку ua-parser-js, которая уже импортирована.

 В этом задании нет сервера!
 */

// FILE: /app/solution.js:
import UAParser from 'ua-parser-js';

// BEGIN (write your solution here)
export default (req, res, next) => {
    req.useragent = UAParser(req.headers['user-agent']);
    next();
};




// >>>>>> Ошибки <<<<<<

/**
 Разговор о мидлварах был бы не полным, если бы мы не обсудили обработку ошибок. Если запрашиваемый урл соответствует одному из определенных маршрутов express, то вызывается соответствующий обработчик (как теперь мы знаем — мидлвара). Но ведь к сайтам можно обращаться по любому адресу, даже такому, который в роутинге не описан. С точки зрения http такая ситуация должна приводить к ошибке 404 и, возможно, ответом будет специальная страница.

 Для реализации подобного поведения не нужны специальные механизмы. Все, что нужно для этого, мы уже изучили. Если хорошо подумать, то можно дойти до мысли, что 404 — это ситуация, при которой express не смог сопоставить ни один маршрут с запрошенным адресом, а значит мы можем определить мидлвару после определения всех маршрутов. Эта мидлвара и будет обработчиком ситуации 404.
 */

app.get('/', (req, res) => {
    res.send('hello');
});

app.use((req, res) => {
    res.status(404);
    res.render('404');
});

// С этой точки зрения все отлично, но часто возникает потребность вернуть ответ 404 даже в том случае, если маршрут был найден. Такое происходит, например, при обращении к удаленному/несуществующему ресурсу: /users/5.

app.get('/posts/:id', (req, res) => {
    const post = posts.find(post =>
        post.id.toString() === req.params.id);
    if (post) {
        res.render('posts/show', { post });
    } else {
        // ?
    }
});

// Интуиция подсказывает нам, что мы должны каким-то образом передать управление дальше, но не следующей по списку мидлваре, а мидлваре, отвечающей за ошибки. И это, действительно, делается так:

// regular middleware
app.use((req, res, next) => {
    // i had an error
    next(new Error('boom!'));
});


/**
 В данном примере, в отличие от всего, что мы видели раньше, в next передается ошибка. Это приводит к изменению поведения вызова последующих мидлвар. Все обычные мидлвары будут пропущены, а те, которые предназначены для обработки ошибок, будут вызваны.
 */

// error middleware for errors that occurred in middleware
// declared before this
app.use((err, req, res, next) => {
    // an error occurred!
});

/**
 Мидлвары для обработки ошибок отличаются от обычных тем, что они принимают на вход четыре параметра, а первый, при этом — ошибка, полученная от предыдущей мидлвары. Expess сам внутри себя определяет, что это мидлвара для обработки ошибок. Делается это посредством проверки количества аргументов у функции после вызова use. Кстати, этот прием называется "метапрограммирование", когда программа пользуется информацией о самой себе для принятия решений.
 */

/***@@@
 solution.js
 Реализуйте в приложении обработку ошибок 404, которые могут появляться как в случае явного перенаправления на мидлвару обрабатывающую ошибки, так и для случая когда ни один маршрут не совпал с запрашиваемым адресом.

 На эту ошибку должна рендерится страница с шаблоном views/404.pug
 */

// FILE: /app/bin/server.js:
import solution from '../solution';

const port = 8080;
solution().listen(port, () => {
    console.log(`Started on port ${port}`);
});


// FILE: /app/entities/Post.js
export default class Post {
    static id = 1;

    constructor(title, body) {
        this.id = Post.id;
        Post.id += 1;
        this.title = title;
        this.body = body;
    }
}


// FILE: /app/errors/NotFoundError.js:
export default class extends Error {
    constructor(...args) {
        super(...args);
        this.status = 404;
    }
}


// FILE: /app/solution.js
import Express from 'express';
// import morgan from 'morgan';

import Post from './entities/Post';
import NotFoundError from './errors/NotFoundError';

export default () => {
    const app = new Express();
    // app.use(morgan('combined'));
    app.set('view engine', 'pug');

    const posts = [
        new Post('hello', 'how are your?'),
        new Post('nodejs', 'story about nodejs'),
    ];

    app.get('/', (req, res) => {
        res.render('index', { posts });
    });

    app.get('/posts/:id', (req, res, next) => {
        const post = posts.find(p => p.id.toString() === req.params.id);
        if (post) {
            res.render('posts/show', { post });
        } else {
            next(new NotFoundError());
        }
    });

    app.use((req, res, next) => {
        next(new NotFoundError());
    });

    app.use((err, req, res, next) => { // eslint-disable-line
        res.status(err.status);
        switch (err.status) {
            case 404:
                res.render(err.status.toString());
                break;
            default:
                throw new Error('Unexpected error');
        }
    });

    return app;
};




// >>>>>> Сессии <<<<<<

/**
 В информатике, а конкретно в сетях, сессия — это интерактивный обмен информацией, также известный как диалог между двумя или более общающимися устройствами, или между компьютером и пользователем. Сессия (cеанс) устанавливается в определенный момент времени и позже завершается.

 # HTTP session
 Так как HTTP — это клиент-серверный протокол, HTTP сессия состоит из трёх фаз:

 1. Клиент устанавливает TCP соединение (или другое соединение, если не используется TCP транспорт).
 2. Клиент отправляет запрос и ждёт ответа.
 3. Сервер обрабатывает запрос и посылает ответ, в котором содержится код статуса и соответствующие данные.
 Начиная с версии HTTP/1.1, после третьей фазы соединение не закрывается, так как клиенту позволяется инициировать другой запрос. То есть, вторая и третья фазы могут повторяться.

 # User session
 Пользовательская сессия является более высокоуровневой абстракцией, чем HTTP-сессия. С помощью нее можно не только идентифицировать разных пользователей, но также хранить произвольные данные на каждого пользователя в рамках его сессии. Типичный пример это корзина товаров в интернет-магазине. Обратите внимание на то, что для пользовательской сессии не обязательно логиниться (выполнять аутентификацию) на сайте.

 Поддержка сессий обычно реализуется с помощью специальных библиотек в рамках используемого фреймворка. В задачи этих библиотек входит:

 - Установка соединения, то есть отправка специальной куки, которая содержит идентификатор сессии. Имя этой куки фиксированно и задается на этапе старта приложения.
 - Сохранение и извлечение данных из сессии. Этот пункт сильно зависит от используемого фреймворка. В случае express предоставляется специальный объект req.session, в который можно записывать необходимую информацию и читать ее в следующих запросах. Отдельный интерес представляет хранилище данных сессии. Это можно делать в памяти, прямо в куках (в зашифрованном виде), или в различных серверных хранилищах начиная от файлов, заканчивая базами данных.
 - Завершение сессии.
 */

import session from 'express-session';

app.use(session({
    resave: false,
    saveUninitialized: false,
}));

/**
 У библиотеки express-session очень много параметров, влияющих на работу сессии, и большое количество дополнений, позволяющих использовать различные хранилища. За подробностями обращайтесь к официальной документации.

 К счастью, использовать сессии гораздо проще чем их настраивать.
 */

app.get('/increment', (req, res) => {
    req.session.counter = req.session.counter || 0;
    req.session.counter += 1;
});

/**
 В примере выше в сессии инициализируется свойство counter значением 0, а затем, при каждом обновлении страницы, счетчик увеличивается на единицу. Это будет происходить для каждого браузера независимо, потому что кука устанавливается в браузер, и браузер является "пользователем".

 Для удаления сессии нужно вызывать асинхронный метод destroy.
 */

req.session.destroy(err => {
    // cannot access session here
})

/**
 # Аутентификация

 Аутентификация это процедура проверки подлинности, например:
 - Проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользователей
 - Подтверждение подлинности электронного письма путём проверки цифровой подписи письма по открытому ключу отправителя
 - Проверка контрольной суммы файла на соответствие сумме, заявленной автором этого файла

 Аутентификацию не следует путать с авторизацией (процедурой предоставления субъекту определённых прав) и идентификацией (процедурой распознавания субъекта по его идентификатору).

 Вот как может выглядеть процесс аутентификации в express:
 */
app.post('/session', (req, res) => {
    // ...
    if (user.passwordDigest === encrypt(password)) {
        req.session.userId = user.id;
        // ...
    }
    // ...
});

/**
 При совпадении паролей в сессию устанавливается идентификатор пользователя под ключом, который потом будет использоваться для проверки, аутентифицирован ли пользователь.

 Обратите внимание на то, что в примере выше используется не сам пароль, а его хешированная версия. С точки зрения безопасности ни в коем случае нельзя хранить пароли в открытом виде. Поэтому при создании пользователя пароль специальным образом хешируется, и в хранилище уже сохраняется этот хеш. Во время процедуры аутентификации пароль, вводимый пользователем, хешируется тем же способом, что и при регистрации, а затем происходит сравнение хешей.
 */

// encrypt.js
import crypto from 'crypto';

export default text => {
    const hash = crypto.createHmac('sha512', 'salt');
    hash.update(text);
    return hash.digest('hex');
};


/**
 Работа с аутентификацией это хороший повод воспользоваться полиморфизмом включения. У нашего приложения два базовых состояния. Пользователь аутентифицирован, либо мы работаем с гостем. Во-первых после аутентификации необходимо создавать пользователя, которого обычно называют currentUser и с помощью мидлвары верхнего уровня прокидывают в res.locals, что дает нам возможность использовать его не только в обработчиках, но и в шаблонах. Таким образом мы локализуем общий код и строим абстракцию поверх реализации аутентификации. Теперь приложение не зависит от того как на самом деле все работает. Но этого недостаточно для того чтобы решение было "хорошим". Такой подход все равно будет заставлять нас делать проверки в стиле if (res.locals.currentUser && res.locals.currentUser.nickname) .... И в этот момент в голове должен сразу произойти щелчок, что мы условиями разруливаем типы, а значит никаким ооп не пахнет. Решение этой задачи очень простое, нам нужно создать тип Guest и всегда устанавливать currentUser. Тогда условие остается только в одном месте (в той мидлваре, которая устанавливает текущего пользователя), а весь остальной код работает так, как будто пользователь всегда есть, только в одном случае это аутентифицированный пользователь, в другом случае гость. Теперь можно расширять Guest и User так, чтобы их можно было прозрачно подменить. Как минимум понадобится метод isGuest, которым мы можем проверить с кем сейчас идет работа. Посмотрите как в таком случае будет выглядеть наш лейаут:
 */
if currentUser.isGuest()
    ul.nav.navbar-nav.float-xs-right
li.nav-item
a.nav-link(href="/session/new") Sign in
li.nav-item
a.nav-link(href="/users/new") Sign up
else
form.form-inline.float-xs-right(action='/session?_method=DELETE' method='post')
button.btn.btn-link(type='submit') Sign out


/**
 entities/User.js
 Реализуйте сущность "Пользователь", которая будет использоваться в случае успешной аутентификации.

 views/session/new.pug
 Реализуйте форму для аутентификации

 solution.js
 Реализуйте регистрацию и аутентификацию пользователей на сайте:

 - GET /users/new - форма для создания нового пользователя
 - POST /users - создание нового пользователя. Должна производиться следующая валидация: пользователь и пароль не должны быть пустыми, никнейм должен быть уникальным. Если пользователь создан успешно то происходит перенаправление на главную страницу, иначе 422 и показ формы с подсветкой ошибок.
 - GET /session/new - страница с формой для аутентификации
 - POST /session - аутентификация. Если аутентификация не удалась, то выводим форму с сообщением Invalid nickname or password и статусом 422, иначе редирект на главную.
 - DELETE /session - удаление сессии. После закрытия сессии, должен произойти redirect на главную страницу.
 */

// FILE: /app/entities/User.js:
export default class {
    guest = false;

    constructor(nickname, passwordDigest) {
        this.nickname = nickname;
        this.passwordDigest = passwordDigest;
    }

    isGuest() {
        return this.guest;
    }
}


// FILE: /app/solution.js:
import Express from 'express';
import session from 'express-session';
import morgan from 'morgan';
import bodyParser from 'body-parser';
import methodOverride from 'method-override';

import encrypt from './encrypt';
import User from './entities/User';
import Guest from './entities/Guest';

export default () => {
    const app = new Express();
    app.use(morgan('combined'));
    app.use(methodOverride('_method'));
    app.set('view engine', 'pug');
    app.use(bodyParser.urlencoded({ extended: false }));
    app.use('/assets', Express.static(process.env.NODE_PATH.split(':')[0]));
    app.use(session({
        secret: 'secret key',
        resave: false,
        saveUninitialized: false,
    }));

    const users = [new User('admin', encrypt('qwerty'))];

    app.use((req, res, next) => {
        if (req.session && req.session.nickname) {
            const { nickname } = req.session;
            res.locals.currentUser = users.find(user => user.nickname === nickname);
        } else {
            res.locals.currentUser = new Guest();
        }
        next();
    });

    app.get('/', (req, res) => {
        res.render('index');
    });

    // BEGIN (write your solution here)
    app.get('/users/new', (req, res) => {
        res.render('users/new', { form: {}, errors: {} });
    });

    app.post('/users', (req, res) => {
        const { nickname, password } = req.body;

        const errors = {};
        if (!nickname) {
            errors.nickname = "Can't be blank";
        } else {
            const isUniq = users.find(user => user.nickname === nickname) === undefined;
            if (!isUniq) {
                errors.nickname = 'Already exist';
            }
        }

        if (!password) {
            errors.password = "Can't be blank";
        }

        if (Object.keys(errors).length === 0) {
            const user = new User(nickname, encrypt(password));
            users.push(user);
            res.redirect('/');
            return;
        }

        res.status(422);
        res.render('users/new', { form: req.body, errors });
    });

    app.get('/session/new', (req, res) => {
        res.render('session/new', { form: {} });
    });

    app.post('/session', (req, res) => {
        const { nickname, password } = req.body;
        const user = users.find(u => u.nickname === nickname);
        if (user && user.passwordDigest === encrypt(password)) {
            req.session.nickname = user.nickname;
            res.redirect('/');
            return;
        }
        res.status(422);
        res.render('session/new', { form: req.body, error: 'Invalid nickname or password' });
    });

    app.delete('/session', (req, res) => {
        req.session.destroy(() => {
            res.redirect('/');
        });
    });

    return app;
};


// FILE: /app/views/session/new.pug:
extends ../layouts/app.pug

block content

    .row.text-xs-center.mt-3
    .col-sm-4.mx-auto
h3 Login form
if error
    .alert.alert-warning= error
    form(action='/session' method='post')
.row.form-group
    .col-sm
input.form-control(name='nickname' placeholder='Nickname' value=form.nickname)
.row.form-group
    .col-sm
input.form-control(name='password' type='password' placeholder='Password')
.form-group
button.btn.btn-primary.btn-block(type='submit') Log in





// >>>>>> Авторизация <<<<<<

/**
 Авторизация - это предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.

 Ситуация, в которой термины используются неправильно, довольно распространена. Авторизация относится к списку таких терминов. Обычно ей называют аутентификацию. Об этом всегда стоит помнить, но мир (как минимум русскоязычный) уже не изменить.

 Рассмотрим простой пример с использованием авторизации, удаление поста.
 */

app.delete('/posts/:id', (req, res, next) => {
    if (res.locals.currentUser.isGuest()) {
        const error = new AccessDeniedError();
        return next(error);
    }

    state.posts = state.posts.filter(post =>
        !(post.id.toString() === req.params.id));
    res.redirect('/posts');
});

/**
 Удалить пост может только залогиненный пользователь. Все остальные (гости) должны получить в ответ 403 forbidden, код, который означает, что произошел отказ в доступе. В более сложных случаях нужно проверять, что пост может удалить только его автор. Любой сайт, сложнее чем сайт-визитка, содержит в себе множество проверок на допустимость тех или иных действий, что может привести к очень большому дублированию проверок по всем обработчикам. Разберем, как этого можно избежать.

 # Route Middlewares
 */
// a middleware sub-stack shows request info for any
// type of HTTP request to the /user/:id path
router.use('/user/:id', (req, res, next) => {
    console.log('Request URL:', req.originalUrl);
    next();
}, (req, res, next) => {
    console.log('Request Type:', req.method);
    next();
});

// Express позволяет указывать любое количество мидлвар для одного и того же маршрута. Для этого можно передать любое количество аргументов (являющихся мидлварами) в функцию use. Этим фактом мы и воспользуемся.

const requiredAuth = (req, res, next) => {
    if (res.locals.currentUser.isGuest()) {
        return next(new AccessDeniedError());
    }

    next();
};

app.delete('/posts/:id', requiredAuth, (req, res) => {
    state.posts = state.posts.filter(post =>
        !(post.id.toString() === req.params.id));
    res.redirect('/posts');
});

/**
 В примере выше определена мидлвара requiredAuth, которую можно подключать к любому маршруту. Она проверяет, залогинен ли пользователь или нет, если нет, то дальше по цепочке передается ошибка. Как мы уже знаем, это приводит к тому, что начинают выполняться только мидлвары, обрабатывающие ошибки. Этот механизм полезен не только для контроля доступа, таким образом можно выполнять любые подготовительные действия, которые используются разными маршрутами.
 */




// >>>>>> Flash <<<<<<

/**
 В веб-фреймворках есть один очень простой и полезный механизм, который называется flash. Этот механизм не имеет ничего общего с технологией flash, как можно было бы подумать. Он используется в ситуациях, когда пользователя надо оповестить об успешном/не успешном выполнении какого-либо действия, например, после аутентификации показать сообщение "Вы вошли!". Такая задача возникает, почти всегда, после отправки форм на сайте.

 Особенность этого механизма в том, что он должен запомнить сообщение в рамках одного запроса, а вывести его на другой http запрос, обычно это связано с редиректом после выполнения какой-либо операции пользователем. Например, если мы регистрируемся, то создание флеш сообщения происходит в момент POST /users, а вывод уже после редиректа на главную страницу. Способ, который для этого используется - записать данные в сессию пользователя, для того чтобы извлечь их при следующем запросе.
 */

app.delete('/session', (req, res) => {
    res.flash('info', `Good bye`);
    delete req.session.nickname;
    res.redirect('/');
});

/**
 Обратите внимание что потенциально можно вызывать функцию flash много раз.

 Обычно флеш сообщения делят на уровни: info, success, warning, которые при выводе различаются цветовой схемой, чтобы обозначать и разделять типы сообщений.

 Ниже приведен пример подключения соответствующей библиотеки и вывод сообщений в шаблоне:
 */

// npm: flash
import flash from 'flash';
app.use(flash());
for message in flash
    .alert(class=`alert-${message.type}`)
    = message.message


    /***@@@
     flash.js
     Реализуйте мидлвару flash, которая предоставляет соответствующую функциональность.
     */
// Подключение
    import flash from './flash';

// После подключения сессий
app.use(flash());

// Использование
res.flash('info', `Welcome, ${user.nickname}!`);
// Вывод в шаблоне
for message in flash
    .alert(class=`alert-${message.type}`)
    = message.message


// FILE: /app/entities/Guest.js:
export default class {
    guest = true;

    isGuest() {
        return this.guest;
    }
}

// FILE: /app/entities/User.js:
export default class {
    guest = false;

    constructor(nickname, passwordDigest) {
        this.nickname = nickname;
        this.passwordDigest = passwordDigest;
    }

    isGuest() {
        return this.guest;
    }
}


// FILE: /app/flash.js:
import assert from 'assert';

export default () => (req, res, next) => {
    assert(req.session, 'a req.session is required!');
    res.locals.flash = req.session.flash || [];
    req.session.flash = [];
    res.flash = (type, message) => {
        req.session.flash.push({ type, message });
    };
    next();
};




// ################ JS: Предметно-ориентированное проектирование ################

/**
 Курс посвящен процессу создания программных абстракций — моделей предметных областей. На примере разработки онлайн-системы для продажи билетов в кинотеатр, мы рассмотрим выделение правильных сущностей, нахождение связей между ними, и поговорим о предметно-ориентированном проектировании, инверсии контроля, принципе инверсии зависимостей, конечных автоматах.
 */


>>>>>> Введение <<<<<<

/**
 Обычно во вступлении мы рассказываем то, что ожидает вас внутри курса, но здесь я решил рассказать кое-что важное. Попробуйте самостоятельно ответить на вопрос. Какая основная задача программиста?

 Вероятно, вы ответите "писать код" и будете не правы. Писать код это всего лишь средство, причём не единственное. Также часто решением задачи является удаление кода или, вообще, отсутствие кода, и всё это тоже область компетенции программиста.

 Начать нужно с того, что программирование, как таковое, это не цель, это всего лишь средство достижения бизнес-целей той компании, которая вас нанимает. В конечном итоге всё программное обеспечение так или иначе служит удовлетворению потребностей бизнеса: увеличению прибыли, снижению издержек. Хорошая статья об этом есть в нашем блоге.

 На практике это означает очень простую вещь, перед тем как бросаться писать код, нужно понять цель того, что вам нужно сделать. Хочу ещё раз акцентировать ваше внимание, на том, что цель это зачем мы это делаем, а не что нужно сделать. У меня есть хорошая аналогия, которую мы постоянно наблюдаем в своей жизни. Вспомните приходы к доктору. Многие люди пытаются рассказывать доктору не только симптомы, но и выдвигают гипотезы, а некоторые прямо утверждают, что у них конкретная болезнь и, более того, они знают, как лечиться. Доктора обычно пропускают это мимо ушей, потому что его задача понять истинную причину. То же самое часто происходит в разработке. К вам приходит заказчик и говорит, что нужно сделать. Например: "Вася, добавь две колонки в базу". Возникает парадоксальная ситуация, чем более технически подкован заказчик тем, как правило, он больше пытается продавливать конкретные решения, вместо того, чтобы описывать свою бизнес-задачу (цель), оставляя вам манёвр для решения.

 Избежать этого невозможно, никто и никогда не будет давать идеальных задач, которые созданы исходя из бизнес-целей. Такое, конечно же, бывает, но гораздо реже, чем вам может показаться. В итоге бизнес-аналитикой занимается разработчик (кроме сложных случаев), и это нормально. Докопавшись до сути, может оказаться так, что кода писать не надо вообще и достаточно поменять правила игры.

 Дальше по курсу мы будем исходить из того, что все цели уже определены и нужно именно писать код, но перед тем, как мы двинемся дальше, я расскажу о том, как смотреть на мир глазами бизнеса и почему это полезно.

 Подумайте вот о чём. Откуда бизнес узнает, что нужно делать? Работая на дядю может сложиться впечатление, что там наверху умные люди, которые знают, что делают. На самом деле они не знают. Представьте, что вы начинаете с нуля свой стартап. После непродолжительного анализа станет понятно, что основная сложность не в том, чтобы понять "что делать", а в том, чтобы понять "что не делать". На эту тему есть обязательная книга к прочтению, которая поменяет ваше мировоззрение: "Бизнес с нуля. Метод Lean Startup."



 Не обращайте внимание на слово "стартап" в заголовке, эта методология одинаково хорошо работает и для больших бизнесов и для молодых проектов. Удивительно, но основная идея этого подхода пришла из научного мира и называется "научный метод":

 Нау́чный ме́тод — совокупность основных способов получения новых знаний и методов решения
 задач в рамках любой науки.

 Метод включает в себя способы исследования феноменов, систематизацию, корректировку новых
 и полученных ранее знаний. Умозаключения и выводы делаются с помощью правил и принципов
 рассуждения на основе эмпирических (наблюдаемых и измеряемых) данных об объекте. Базой
 получения данных являются наблюдения и эксперименты. Для объяснения наблюдаемых фактов
 выдвигаются гипотезы и строятся теории, на основании которых в свою очередь строится
 математическое описание — модель изучаемого объекта.
 Первое. Логика контринтуитивна. Понять, что нужно вашим пользователям заранее и без общения с ними, практически невозможно. Используя lean startup мы выдвигаем гипотезы, а не продумываем конкретные решения. Пример гипотез:

 Пользователи хотят заказывать такси без необходимости звонить оператору и диктовать адрес.

 Пользователю удобнее оплачивать такси с карты, чем наличными
 Проницательный читатель увидит, что при таком подходе, нет цели реализовать сразу всё, от и до продумав все части программы. Задачей станет реализовать только то, что может помочь подтвердить или опровергнуть гипотезу. Ведь если гипотеза не верна, это автоматически означает, что нужно корректировать все дальнейшие планы. В противном случае будут большие потери.

 После того, как гипотеза готова, делается всё необходимое для её проверки. Многие гипотезы, по факту, не требуют написания кода вообще. Например, гипотеза про удобство оплаты такси картой проверяется звонками друзьям/постами в соцсети. Согласитесь, что это сильно дешевле, проще и быстрее, чем месяцами писать приложение, а потом увидеть, что это никому не нужно.

 На выходе получается цепочка: Гипотеза -> Реализация (если нужно) -> Анализ данных. Повторяя эту цепочку снова и снова, мы получаем продукт, который действительно работает и отвечает бизнес-целям.

 Ключевые слова для самообразования:

 Customer development
 Business Model Canvas
 Minimum Viable Product
 Pivot

 # SMART
 Когда речь идёт про уже существующий бизнес или, даже, личные цели, то подойдёт такой подход как SMART:

 Это мнемоническая аббревиатура, используемая в менеджменте и проектном управлении для
 определения целей и постановки задач:

 * конкретный (specific);
 * измеримый (measurable);
 * достижимый (attainable);
 * значимый (relevant);
 * соотносимый с конкретным сроком (time-bounded)
 Этот подход хорошо расписан в вики, поэтому не буду заниматься копипастой.


 # impact mapping
 Impact Mapping простая и эффективная техника для определения целей заказчика и передача этих целей разработчикам.

 Impact Mapping — это диаграмма связей (mind map) по целям проекта с картой влияний, которые должны подтолкнуть бизнес заказчика к достижению целей.

 # Why?
 Центральный элемент нашей карты, который отвечает на ключевой вопрос: Зачем мы это делаем? Это цель, которую бизнес пытается достичь.

 # Who?
 На первом уровне мы отвечаем на вопросы: Кто поможет достичь желаемого результата? Кто может помешать? Кто пользователи нашего продукта? Сюда войдут все заинтересованные стороны, которые могут повлиять на цели бизнеса.

 # How?
 На втором уровне мы должны описать воздействия, которые должны оказать заинтересованные стороны, чтобы бизнес достиг целей. Мы ищем ответ на вопросы: Как они помогут бизнесу достичь целей? Как они могут помешать успеху проекта?

 # What?
 После ответа на основные вопросы можно обсудить конкретные задачи. Третий уровень отвечает на вопросы: Что мы можем сделать как организация или команда разработки, чтобы создать необходимые воздействия? Здесь будет описан конечный результат нашей работы.

 Подробнее об этом подходе можно прочитать в замечательной статье https://habrahabr.ru/post/246401/ Александра Бындю на Хабре.

 # User Story Mapping
 После определения карты влияний на цели можно определить роли пользователей, как они будут взаимодействовать с системой, важность задач, план релизов и т.д.

 Цель user story mapping в том, чтобы приоритезировать пользовательские истории по важности.

 Пример пользовательской истории:

 Я, как менеджер по продажам, хочу видеть отчёт по интересам клиентов в курсах, для того,
 чтобы принять решение о создании нового курса и приглашения этих клиентов принять в нём участие.
 Об этой полезной технике можно найти много статей на просторах сети. Подробнее на ней останавливаться не будем, пора переходить к самому курсу).

 # Проект: Электронная продажа билетов

 На протяжении курса мы будем создавать систему для продажи билетов в кинотеатре через интернет. Бизнес-анализ тоже будет присутствовать, но в очень ограниченном варианте. Основной упор на то, как писать код.

 # Основные темы
 По пути разберём много страшных слов, и я понимаю, что многие вещи, о которых будет говориться, вызовут ещё больше вопросов, чем ответов. Цель этого курса показать новые горизонты, а не дать всеобъемлющее руководство к действию. Этим курсом ваш путь только начинается.

 Domain-Driven Design
 Entity, Value-Object
 Repository
 Service Layer
 Inversion Of Control
 Dependency Inversion Principle
 Dependency Injection Container
 FSM

 # Дополнительные темы
 В процессе используем множество разных библиотек, таких как:

 - bottlejs
 - uuid-js/validate.js
 - lodash/date-fns
 */



>>>>>> Use cases <<<<<<

/**
 Существует очень высокоуровневый способ увидеть возможности проекта с высоты птичьего полёта. Это use case диаграмма из стандарта UML.

 # Unified Modeling Language (UML)

 Язык графического описания для объектного моделирования в области разработки программного обеспечения, моделирования бизнес-процессов, системного проектирования и отображения организационных структур.

 Мы уже встречались с ним в курсе автоматного программирования, когда использовали диаграмму состояний. UML включает в себя множество различных диаграмм на все случаи жизни. Некоторые из них очень полезны, другие менее. Как минимум, нужно научиться понимать диаграммы на базовом уровне, ведь большинство книг по проектированию так или иначе их используют. Особенно это касается диаграмм классов (все книги по паттернам), последовательностей и других.

 Но не советую слишком закапываться, очень легко увлечься и забыть о целях.

 # Диаграмма последовательностей
 В данном примере диаграмма прямо отражает то, как работает код, но так бывает не всегда.

 # Электронная продажа билетов
 На специальном сервисе я накидал диаграмму вариантов использования для нашего проекта. Ниже можно посмотреть на то, что получилось. Правда симпатично?
 Как видно из картинки, подразумевается, что у нас две роли. Клиент кинотеатра и менеджер. Роль != Человек, то есть менеджеров может быть много, в данном случае это не важно.

 Клиент может делать две вещи:
 Купить билет
 Вернуть билет

 Менеджер:
 Добавить залы в кинотеатре
 Добавить фильмы
 Добавить показы фильмов


 В реальном приложении таких вариантов использования было бы значительно больше. Практика показывает, что даже в этом случае не нужно пытаться их все уместить на диаграмме. Она нужна только для того, чтобы увидеть и понять ключевые возможности системы, а также познакомиться с действующими лицами.

 Бизнес-правила нашей системы продажи билетов очень просты:

 Ценообразование

 Цена зависит от типа зала
 Цена зависит от дня недели (повышающий коэффициент в выходные)

 --

 Возврат билета

 Возвращается полная стоимость покупки
 Можно вернуть только до начала фильма
 */


>>>>>> Сущности и связи <<<<<<

/**
 Настал момент, когда нужно начинать проектировать приложение. И делать мы это будем, используя Entity-relationship Model

 ERM - Модель данных, позволяющая описывать концептуальные схемы предметной области.

 # Сущности
 Этот подход включает в себя два основных понятия: сущность и связь. Проще всего начать с примеров:

 - Пользователь
 - Кинозал
 - Билет
 - Показ фильма

 Это сущности нашей предметной области, с которыми предстоит работать в коде. Как видите, понятие сущность довольно интуитивно. Но также оно обладает и рядом формальных характеристик:
 - Идентификация
 - Время жизни

 Идентификация означает, что мы можем рассматривать сущности независимо и выделять одни среди других. Например, у нас есть разные кинозалы, и это разные сущности. Другой пример это пользователи. Даже если два человека имеют одинаковые ФИО, мы всё равно сможем их различить на основе дополнительных признаков. В программировании обычно сущностям присваивается идентификатор (суррогатный ключ), который и используется для этой цели. Чаще всего эта задача возлагается на базу данных. В нашей ситуации базы нет, поэтому мы будем задавать его самостоятельно.
 */

const user = new User('Илон');
console.log(user.id);
// 896b677f-fb14-11e0-b14d-d11ca798dbac

// User.js
import uuid from 'uuid-js';

class User {
    constructor(name) {
        this.id = uuid.create().toString();
        this.name = name;
    }
}

/**
 Библиотека uuid-js позволяет генерировать уникальный идентификатор, который можно использовать для идентификации. Кстати uuid https://ru.wikipedia.org/wiki/UUID очень полезная штука, может пригодиться в некоторых типах задач.

 Время жизни означает, что наша сущность в какой-то момент появилась и когда-то может исчезнуть.

 # Связи

 Между собой сущности образуют связи. Например, человек может быть владельцем нескольких машин, но машина может принадлежать только одному человеку. Пользователи Хекслета проходят много курсов, каждый курс доступен всем пользователям.

 Таким образом можно выделить три основных типа связи: один к одному (o2o), один ко многим (o2m) и многие ко многим (m2m).

 Выше представлена диаграмма Entity-Relationship. Она входит в стандарт UML и неплохо помогает понять то, какие сущности составляют вашу предметную область и как они друг с другом связаны.

 Что можно сказать глядя на диаграмму?

 В одном зале может быть много показов фильмов;
 Один фильм может быть показан много раз;
 Фильмы и залы связаны друг с другом как "многие ко многим". То есть один фильм показывается в разных залах, а в одном зале идут разные фильмы.
 Всё это довольно очевидно и соответствует нашему опыту посещения кинозалов. В других предметных областях это уже не так просто, и то, как вы проектируете сущности и их связи, имеет сильное влияние на ваше приложение. Общее правило такое, чем больше связей и чем более они разнообразные, тем сложнее приложение. Часто бывает такое, что программисты "закладываются на будущее" (которое не факт, что наступит) и пытаются делать чуть ли не все связи m2m. Чаще всего такой подход оказывается примером over-engineering (гиперпроектирование), другими словами, не надо добавлять сложности там, где нет реальной потребности.

 Кроме влияния на логику работы, связи также сильно влияют на способ хранения сущностей в базе данных. Например, в реляционных базах данных, связь m2m всегда подразумевает наличие промежуточной таблицы. В свою очередь рефакторинг базы данных не такое простое занятие, как изменение кода.

 # Пример
 На Хекслете есть курсы. Каждый курс состоит из уроков. Урок не может существовать без курса. Вот как может быть представлена эта модель в коде:
 */
const course = new Course('JS: DDD');
const lesson1 = new Lesson(course, 'Введение');
const lesson2 = new Lesson(course, 'Модель Сущность-Связь');

/**
 Передача курса в конструктор удобна по двум причинам. Сразу становится видна и понятна связь урока с курсом. А также на уровне языка заложено бизнес-правило, что урок не может существовать без курса.

 Объекты-значения (Справочники)
 Кроме сущностей в предметной области всегда есть и значения, или, как их обычно называют, объекты-значения. В отличие от сущностей у них нет идентификации. Возьмём такое понятие как деньги (Money). Если мы не являемся казначейством, то нужно ли нам отличать одни 100$ от других 100$? Вероятно, нет. Для нас не существует сущности 100$, всё, что имеет значение, это номинальная стоимость этих денег, другими словами, в случае объектов-значений сравнение происходит не по идентификации, а на основе фактического значения. То же самое применимо ко всем справочным данным. Имена стран (производители фильмов), адреса, список городов и многое другое.

 Важно понимать, что это не абсолютная истина. Будет ли какое-то понятие сущностью или значением зависит от конкретной предметной области.
 */

/***@@@
 entities/Film.js
 Реализуйте и экспортируйте сущность Film.

 Пример использования:

 const film = new Film(name, duration);
 Свойства:

 id - идентификатор (автогенерируемое)
 name - название фильма
 duration - продолжительность
 createdAt - дата создания сущности
 entities/CinemaHall.js
 Реализуйте и экспортируйте сущность CinemaHall.
 */
const cinemaHall = new CinemaHall(name, rows, cols);

/**
 Свойства:

 id - идентификатор (автогенерируемое)
 name - название зала
 rows - количество рядов с сидениями
 cols - количество сидений в ряду
 filmScreenings - все добавленные сеансы
 createdAt - дата создания сущности
 entities/FilmScreening.js
 Реализуйте и экспортируйте сущность FilmScreening.
 */
const filmScreening = new FilmScreening(film, cinemaHall, time);

/**
 Свойства:

 id - идентификатор (автогенерируемое)
 film - фильм
 cinemaHall - зал
 time - время сеанса
 createdAt - дата создания сущности
 Во время создания сеанса, нужно добавлять сеанс в cinemaHall.

 solution.js
 Реализуйте и экспортируйте функцию по умолчанию, которая создает просмотр фильма FilmScreening
 */

const filmScreening = solution('snack', 150, 'smily hall', 30, 50, time);
{
    time: 150,
        film: {
    name: 'snack',
        duration: 150
},
    cinemaHall: {
        name: 'smily hall',
            rows: 30,
            cols: 50,
            filmScreenings: [[Object]],
    }
}


// FILE: /app/entities/CinemaHall.js:
import uuid from 'uuid-js';


export default class CinemaHall {
    constructor(name, rows, cols) {
        this.id = uuid.create().toString();
        this.name = name;
        this.rows = rows;
        this.cols = cols;
        this.createdAt = new Date();
        this.filmScreenings = [];
    }

    addFilmScreening(filmScreening) {
        this.filmScreenings.push(filmScreening);
    }
}


// FILE: /app/entities/Film.js:
import uuid from 'uuid-js';

export default class Film {
    constructor(name, duration) {
        this.id = uuid.create().toString();
        this.name = name;
        this.duration = duration;
        this.createdAt = new Date();
    }
}


// FILE: /app/entities/FilmScreening.js:
import uuid from 'uuid-js';

export default class FilmScreening {
    constructor(film, cinemaHall, time) {
        this.id = uuid.create().toString();
        this.film = film;
        this.cinemaHall = cinemaHall;
        this.time = time;
        this.createdAt = new Date();

        this.cinemaHall.addFilmScreening(this);
    }
}


// FILE: /app/solution.js:
import { Film, CinemaHall, FilmScreening } from './entities';

export default (filmName, duration, cinemaHallName, rows, cols, time) => {
    const film = new Film(filmName, duration);
    const cinemaHall = new CinemaHall(cinemaHallName, rows, cols);
    const filmScreening = new FilmScreening(film, cinemaHall, time);

    return filmScreening;
};


// FILE: /app/entities/index.js:
import Film from './Film';
import CinemaHall from './CinemaHall';
import FilmScreening from './FilmScreening';

export { Film, CinemaHall, FilmScreening };




// >>>>>>> Архитектура <<<<<<<

/**
 При разработке приложений с богатой предметной областью во весь рост встаёт вопрос о том, как правильно организовать код приложения, а если смотреть шире, то какую выбрать архитектуру. О том, какие варианты может предложить вам индустрия мы сейчас и поговорим, но перед тем, как я расскажу про существующие подходы, важно запомнить несколько вещей.

 Не существует единственного верного подхода при организации вашего приложения. Известные подходы — всего лишь видение конкретных людей для конкретных ситуаций и конкретных стеков (язык + инструментарий). Любая хорошая архитектура базируется на фундаментальных законах и принципах. Большую часть из них вы уже знаете:

 Изоляция побочных эффектов;
 Хорошая абстракция (абстракция данных, композиция, разделение);
 Сильные барьеры (между абстракциями);
 Слабые связи (возможность замены/независимого развития).

 Из популярного можно выделить следующие словосочетания:

 The Clean Architecture
 Onion Architecture
 Hexagonal Architecture

 Все эти архитектуры сводятся так или иначе к тому, что наше приложение представляет из себя набор слоёв (тех самых абстракций), которые связаны друг с другом определённым образом и отвечают за определённые аспекты системы.

 Начать стоит с того, что: Фреймворк — это не ваше приложение. Остановитесь на секундочку и хорошо обдумайте фразу. В типичных веб-приложениях фреймворк определяет вообще всё. Приложение на 100% переплетается с ним и становится его частью. Программист начинает мыслить в рамках возможностей фреймворка и его ограничений, и в его голове появляются несуществующие причинно-следственные связи.

 Да, конечно, сложно (и не нужно) делать абсолютную изоляцию, но и всегда нужно проводить чёткую грань между вашим приложением и тем фреймворком, который использует его.

 # Домен

 Первым и базовым слоем в приложении является Домен. Это реализация вашей модели предметной области. Чистая бизнес-логика без намёка на инфраструктуру.

 Вот что обычно характеризует домен:

 Чистый код (pure)
 Plain Old X Object (POXO)
 Бизнес-логика
 Валидация

 POXO - это обобщённое название, которое в каждом конкретном языке приобретает своё собственное имя. В Java POJO, в Ruby PORO, и так далее. Этой аббревиатурой описывают объекты, которые построены исключительно на возможностях самого языка, без дополнительных абстракций. Так подчёркивается, что домен не использует внешних библиотек, которые влияют на его организацию. Не надо фанатично относиться к этой идее. В некоторых языках сформировались свои правила, и они идут в разрез с общими концепциями.

 # Персистентность

 Реализовать логику только половина дела. В конце концов нужно сохранить наши изменения. Казалось бы, что эта часть должна быть самой простой, но нет. Состояние, его мутация и поддержка целостности настолько сложная история, что придуманы огромные и сложные фреймворки, называемые ORM. Обычно они построены вокруг двух самых распространённых паттернов:

 ActiveRecord
 DataMapper

 # Репозиторий
 Репозиторий — это хранилище однотипных сущностей. Позволяет как делать выборки, так и сохранять сущности внутри себя. Для простоты в нашем приложении репозитории будут хранить все данные в памяти.
 */

const film = new Film(name, duration);
repository = new FilmRepository
repository.save(film);

repository.find(film.id); // film
repository.find(unknownId); // Boom!


/**
 # Инфраструктура

 Именно в эту категорию попадает фреймворк, UI и вообще любая прикладная история. На картинке этот слой находится на самой внешней стороне. Из него происходит отправка электронных писем, смс, и выполняется так называемая логика приложения. Например, перенаправление на определённую страницу после создания какой-то сущности.

 # Сервисы

 Помните диаграмму вариантов использования? Вот именно эти варианты и являются единственным способом изменения состояния вашего приложения. Ваш домен обрастает слоем так называемых сервисов. Каждый сервис представляет собой набор функций, имитирующих бизнес-сценарии, например, "добавить в друзья", "поставить лайк".
 */

class CinemaService {
    createFilm(name, duration) {
        const film = new Film(name, duration);
        this.FilmRepository.save(film);
        return film;
    }
}


/**
 Инфраструктурный слой является главным пользователем вашего слоя сервисов. Сервисы могут вызываться в ui, в контроллерах, в асинхронных jobs. Слой сервисов настолько важен сам по себе, что Мартин Фаулер описывает его как шаблон проектирования Service Layer https://martinfowler.com/eaaCatalog/serviceLayer.html

 При проектировании сервисов нужно придерживаться некоторых правил, которые позволяют абстракции не протекать и максимально поддерживать чистоту.

 Входными данными в функции сервиса не могут быть сущности предметной области. Причина такого правила очень проста. Сервисы – слой поверх предметной области, он инкапсулирует в себе все сценарии. Если сущности окажутся снаружи, то логика становится размазанной между слоями (потекла абстракция), пропадает изоляция. Но так сделать не всегда возможно. Иногда это связано с устройством конкретных фреймворков, которые не дают нормально абстрагировать предметную область от инфраструктуры. В такой ситуации не стоит бороться насмерть за концептуальную чистоту, идите на компромиссы.

 То же самое касается выходных данных. В теории, отдавать наружу сущности нельзя по той же причине, по которой нельзя ими оперировать вне сервисов. Так как после возврата крайне просто начать ей оперировать, что сразу повлечёт за собой размазывание логики по слоям. Вместо сущности, как правило, отдают специальный "Data Transfer Object". В отличие от сущности он не содержит поведения и используется исключительно как контейнер для чтения.

 DTO - Используется для передачи данных между подсистемами приложения. DTO, в отличие от business object, не должен содержать какого-либо поведения

 Неизменяемый
 Просто данные

 Опять же, чтобы не усложнять, в тех системах, где нет готовых механизмов для трансляции, возвращают и сущности, но на уровне соглашений используют их исключительно как DTO.

 И последнее по списку, но не последнее по важности, не вызывайте сервисы из сервисов. Если появляется общий код, то выносите общую функциональность, но не позволяйте самому сервису начинать мешаться с доменом. Последнее означает то, что если сервисы начинают использовать внутри себя сервисы (тот же или другие), то с большой вероятностью происходит нарушение принципа одного уровня абстракции. Сервисы — слой поверх домена, а это значит что на одном уровне нельзя использовать и домен и сервис.
 */

/***@@@
 lib/BaseRepository.js
 Реализуйте базовый класс репозиторий со следующими методами:

 save(entity)
 find(id)
 Принцип работы:
 */

const repository = new CinemaHallRepository();
const hall = repository.save(cinemaHall);
repository.find(cinemaHall.id);

/**
 services/CinemaService.js
 Каждая реализация бизнес-сценария в сервисе самостоятельно отвечает за сохранение созданных сущностей в соответствующих репозиториях. Как пример, можно посмотреть реализацию createFilm. Доступ к репозиториям осуществляется через this.

 Реализуйте следующие методы (бизнес-сценарии):

 Добавление кинозала
 */
const cinemaHall = service.createCinemaHall(name, cols, rows);

// Добавление сеанса
const filmScreening = service.createFilmScreening(filmId, cinemaHallId, time);


// FILE: /app/entities/CinemaHall.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class CinemaHall extends ApplicationEntity {
    constructor(name, rows, cols) {
        super(name, rows, cols);
        this.id = uuid.create().toString();
        this.name = name;
        this.rows = rows;
        this.cols = cols;
        this.createdAt = new Date();
    }
}


// FILE: /app/entities/Film.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class Film extends ApplicationEntity {
    constructor(name, duration) {
        super(name, duration);
        this.id = uuid.create().toString();
        this.name = name;
        this.duration = duration;
        this.createdAt = new Date();
    }
}


// FILE: /app/entities/FilmScreening.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class FilmScreening extends ApplicationEntity {
    constructor(film, cinemaHall, time) {
        super(film, cinemaHall, time);
        this.id = uuid.create().toString();
        this.film = film;
        this.cinemaHall = cinemaHall;
        this.time = time;
        this.createdAt = new Date();
    }
}


// FILE: /app/entities/index.js:
import Film from './Film';
import CinemaHall from './CinemaHall';
import FilmScreening from './FilmScreening';

export { Film, CinemaHall, FilmScreening };


// FILE: /app/lib/BaseRepository.js:
export default class {
    data = [];

    all() {
        return this.data;
    }

    find(id) {
        const result = this.data.find(entity => entity.id === id);

        if (!result) {
            throw new Error('Entity not found');
        }

        return result;
    }

    save(entity) {
        this.data.push(entity);
    }
}

// FILE: /app/services/CinemaService.js:
import ApplicationService from './ApplicationService';
import { Film, CinemaHall, FilmScreening } from '../entities';

export default class extends ApplicationService {
    createCinemaHall(name, rows, cols) {
        const cinemaHall = new CinemaHall(name, rows, cols);
        this.CinemaHallRepository.save(cinemaHall);
        return cinemaHall;
    }

    createFilmScreening(filmId, cinemaHallId, time) {
        const film = this.FilmRepository.find(filmId);
        const hall = this.CinemaHallRepository.find(cinemaHallId);
        const filmScreening = new FilmScreening(film, hall, time);
        this.FilmScreeningRepository.save(filmScreening);
        return filmScreening;
    }

    createFilm(name, duration) {
        const film = new Film(name, duration);
        this.FilmRepository.save(film);
        return film;
    }
}




// >>>>>> Валидация <<<<<<

const cinemaHall = new CinemaHall(undefined, -5, 0);
cinemaHallRepository.save(cinemaHall);

/**
 Обратите внимание на то, что CinemaHall создаётся с неверными параметрами. Что будет, если мы попробуем выполнить такой код? Он выполнится и репозиторий с удовольствием сохранит сущность, которая не должна существовать. Вряд ли такое поведение системы можно назвать удачным. Очевидно, что должен существовать дополнительный механизм, предотвращающий подобные ошибки. Этот механизм существует и называется "валидация".

 Валидаций существует много разных типов, и делаться они могут на разных уровнях. Для начала давайте ответим на вопрос: А что необходимо валидировать? Первое правило валидации: никогда не доверяй пользовательским данным. Всё, что приходит из внешних источников, должно проходить валидацию. Даже если ваши пользователи это менеджеры, которые сидят в соседнем кабинете, это не повод им доверять. Хотя бы потому, что они могут ошибиться.

 Второй вопрос связан с тем, а какая, собственно, валидация существует. Можно выделить следующие виды:

 - Клиентская валидация
 - Валидация сообщений
 - Валидация на уровне обработчиков
 - Валидация сущностей (Бизнес-Правила)
 - Ограничения на уровне хранилища

 В этом уроке мы будем говорить про валидацию сущностей. Ту валидацию, которая отвечает за то, что наше представление предметной области находится в консистентном (согласованном) состоянии.

 # validate.js
 validate.js — это простая и мощная библиотека для валидации объектов js. Из всего, что было на просторах сети, мне она показалась наиболее удачной, для наших задач.
 */

const constraints = {
    username: {
        presence: true,
        exclusion: {
            within: ["nicklas"],
            message: "'%{value}' is not allowed"
        }
    },
    password: {
        presence: true,
        length: {
            minimum: 6,
            message: "must be at least 6 characters"
        }
    }
};

/**
 Для её использования, первым делом необходимо описать ограничения (constraints). К каждому свойству привязывается набор ограничений. Каждое ограничение может быть настроено согласно документации. Например, ограничение length конфигурируется параметром minimum. Подробнее о том, какие правила встроены в validate.js можно прочитать на официальном сайте http://validatejs.org/.

 # validate.js: check
 Дальше сконфигурированный объект с правилами передаётся в функцию validate вместе с проверяемым объектом. На выходе мы получаем либо массив с ошибками, либо undefined (в случае, если ошибок не было).
 */

import validate from 'validate';

validate({password: 'bad'}, constraints);
// => {
//   username: ["Username can't be blank"],
//   password: ['Password must be at least 6 characters']
// }

validate({username: 'nick', password: 'better'}, constraints);
// => undefined

validate({username: 'nicklas', password: 'better'}, constraints);
// => {username: ["Username 'nicklas' is not allowed"]}

validate({password: 'better'}, constraints, {fullMessages: false});
// => {username: ["can't be blank"]}


// Теперь попробуем прикрутить эту библиотеку к нашей системе. Вот как это будет выглядеть:

class CinemaService {
    createFilm(name, duration) {
        const film = new Film(name, duration);
        const errors = this.validate(film);
        // { name: "can't be blank" }
        if (!errors) {
            this.FilmRepository.save(film);
        }
        return [film, errors];
    }
}

/**
 Здесь есть пара тонкостей, про которые нужно сказать. Во-первых, массив с ошибками нужен, в том числе, снаружи, например для вывода сообщений об ошибках в формах. Во-вторых, мы не можем использовать функцию validate напрямую. Связано это с тем, что есть некоторые виды валидаторов, например uniqueness, которые проверяют уникальность сущности, делая обращения к репозиторию. А это значит, что валидатору нужен доступ к объектам репозиториям (ведь объекты мы храним в памяти). То есть в проекте появляется процесс инициализации, в рамках которого мы конфигурируем наш валидатор, передавая репозитории во внутрь.

 Обязательно изучите процесс инициализации приложения в практике к этому
 уроку
 Такой подход к валидации, который подразумевает то, что сущность может быть создана в невалидном состоянии, не единственный способ организации валидации. Более того, в определённых кругах этот подход считается неверным. Я оставлю этот вопрос за рамками урока, но скажу так. На практике, в подавляющем большинстве проектов используются orm, валидация в которых устроена так же, как описано выше. Более того, ограничения, обычно, описываются прямо в самой сущности.

 # Собирая всё вместе
 */

export default class User {
    static constraints = {
        email: {
            presence: true,
            email: true,
            uniqueness: true,
        },
    };

    constructor(email) {
        this.id = uuid.create().toString();
        this.email = email;
    }
}
import makeValidator from './lib/validator';
const validate = makeValidator(repositories);

// const validate = entity => validate(entity, entity.constructor.constraints);
const user = new User('test@gmail.com');
const errors = validate(user);


/***@@@
 lib/validation.js
 Добавьте кастомный валидатор и назовите его dateObject, который проверяет, является ли свойство датой. Подробности смотрите в документации библиотеки.

 entities/CinemaHall.js
 Добавьте следующие ограничения:

 name не может быть пустым
 rows не может быть пустым и должно быть числом
 cols не может быть пустым и должно быть числом
 entities/Film.js
 Добавьте ограничения:

 name не может быть пустым
 duration не может быть пустым
 entities/FilmScreening.js
 Добавьте ограничения:

 film не может быть пустым
 cinemaHall не может быть пустым
 time не может быть пустым
 entities/FilmScreening/Ticket.js
 Добавьте ограничения:

 filmScreening не может быть пустым и должен быть уникальным в паре с place. Для этого используется такая запись: javascript // Скоуп определяет поле в рамках которого проверяется уникальность. uniqueness: { scope: ['place'], },
 user не может быть пустым
 place не может быть пустым
 services/MoneyService.js
 Реализуйте покупку билета
 */
const place = { row: 5, col: 3 };
const [ticket] = moneyService.buyTicket(user.id, filmScreening.id, place);


/**
 Подсказки
 Валидатор uniqueness реализован в файле lib/validation.js.
 */


// FILE: /app/entities/CinemaHall.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class CinemaHall extends ApplicationEntity {
    static constraints = {
        name: {
            presence: true,
        },
        rows: {
            presence: true,
            numericality: true,
        },
        cols: {
            presence: true,
            numericality: true,
        },
    };


    constructor(name, rows, cols) {
        super();
        this.id = uuid.create().hex;
        this.name = name;
        this.rows = rows;
        this.cols = cols;
        this.createdAt = new Date();
    }
}

// FILE: /app/entities/Film.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class Film extends ApplicationEntity {
    static constraints = {
        name: {
            presence: true,
        },
        duration: {
            presence: true,
        },
    };

    constructor(name, duration) {
        super();
        this.id = uuid.create().hex;
        this.name = name;
        this.duration = duration;
        this.createdAt = new Date();
    }
}


// FILE: /app/entities/FilmScreening.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class FilmScreening extends ApplicationEntity {
    static constraints = {
        film: {
            presence: true,
        },
        cinemaHall: {
            presence: true,
        },
        time: {
            presence: true,
        },
    };

    constructor(film, cinemaHall, time) {
        super();
        this.id = uuid.create().hex;
        this.film = film;
        this.cinemaHall = cinemaHall;
        this.time = time;
        this.createdAt = new Date();
    }
}

// FILE: /app/entities/FilmScreening/Ticket.js:
import uuid from 'uuid-js';
import ApplicationEntity from '../ApplicationEntity';

export default class FilmScreeningTicket extends ApplicationEntity {
    static constraints = {
        filmScreening: {
            presence: true,
            uniqueness: {
                scope: ['place'],
            },
        },
        user: {
            presence: true,
        },
        place: {
            presence: true,
        },
    };

    constructor(filmScreening, user, place) {
        super();
        this.id = uuid.create().hex;
        this.filmScreening = filmScreening;
        this.user = user;
        this.place = place;
        this.createdAt = new Date();
    }
}

// FILE: /app/lib/validation.js:
import _ from 'lodash';
import validate from 'validate.js';

export default (repositories) => {
    const entityValidator = entity => validate(entity, entity.constructor.constraints);
    validate.validators.uniqueness = (value, options, key, attributes) => {
        if (!value) {
            return null;
        }
        const className = attributes.constructor.name;
        const repository = repositories[`${className}Repository`];
        const scope = options.scope || [];
        const params = { [key]: value, ..._.pick(attributes, scope) };
        const result = repository.findBy(params);
        if (result && result.id !== attributes.id) {
            return 'already exists';
        }
        return null;
    };

    validate.validators.association = (value) => {
        if (!value) {
            return null;
        }
        return entityValidator(value);
    };

    validate.validators.dateObject = (value) => {
        if (!(value instanceof Date)) {
            return 'are not date';
        }
        return null;
    };


    return entityValidator;
};

// FILE: /app/services/ApplicationService.js:
import BaseService from '../lib/BaseService';

export default class extends BaseService {
}

// FILE: /app/services/CinemaService.js:
import ApplicationService from './ApplicationService';
import { Film, FilmScreening, CinemaHall } from '../entities';

export default class extends ApplicationService {
    createCinemaHall(name, rows, cols) {
        const cinemaHall = new CinemaHall(name, rows, cols);
        const errors = this.validate(cinemaHall);
        if (!errors) {
            this.CinemaHallRepository.save(cinemaHall);
        }
        return [cinemaHall, errors];
    }

    createFilm(name, duration) {
        const film = new Film(name, duration);
        const errors = this.validate(film);
        if (!errors) {
            this.FilmRepository.save(film);
        }
        return [film, errors];
    }

    createFilmScreening(filmId, cinemaHallId, time) {
        const film = this.FilmRepository.find(filmId);
        const hall = this.CinemaHallRepository.find(cinemaHallId);
        const filmScreening = new FilmScreening(film, hall, time);
        const errors = this.validate(filmScreening);
        if (!errors) {
            this.FilmScreeningRepository.save(filmScreening);
        }
        return [filmScreening, errors];
    }
}


// FILE: /app/services/MoneyService.js:
import ApplicationService from './ApplicationService';
import { FilmScreeningTicket } from '../entities';

export default class extends ApplicationService {
    buyTicket(userId, filmScreeningId, place) {
        const user = this.UserRepository.find(userId);
        const screening = this.FilmScreeningRepository.find(filmScreeningId);

        const ticket = new FilmScreeningTicket(screening, user, place);
        const errors = this.validate(ticket);
        if (!errors) {
            this.FilmScreeningTicketRepository.save(ticket);
        }
        return [ticket, errors];
    }
}


// FILE: /app/services/UserService.js:
import ApplicationService from './ApplicationService';
import { User } from '../entities';

export default class extends ApplicationService {
    createUser(email) {
        const user = new User(email);
        const errors = this.validate(user);
        if (!errors) {
            this.UserRepository.save(user);
        }
        return [user, errors];
    }
}




// >>>>>> Dependency Injection Container <<<<<<

const repository = new UserRepository();
repository.save(user);

/**
 Каждый раз, когда в коде встречается подобная запись, мы уже можем сделать вывод, что полиморфизм включения обошёл этот код стороной. Подменить реализацию UserRepository не представляется возможным, ведь он прямо жестко закодирован в месте своего использования. Такая ситуация не всегда является проблемой, но, всё же, хотелось бы иметь возможность лёгкой подмены компонентов системы. Да и в тестах часто бывает нужно подменять реализации и использовать стабы.

 В этой ситуации мы можем воспользоваться DIP (dependency inversion principle), то есть принципом инверсии зависимостей:

 Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
 Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
 Хотя он и звучит страшно, на практике, особенно в динамических языках, применять его проще простого. Грубо говоря, всё сводится к тому, что мы передаём зависимости снаружи, а клиентский код ими пользуется. Например так:
 */

const createUser = (userData, UserRepository) => {
    const user = new User(userData);
    const repository = new UserRepository(); // приходит снаружи
    repository.save(user);
}


/**
 Как видите, теперь код не зависит от конкретной реализации репозитория. Так мы получаем преимущества от ООП. Только всегда будьте прагматиками. Инверсия ради инверсии, это так себе обоснование для усложнения. В реальности не так часто бывает нужна подмена, как об этом кричат в некоторых книжках, но всё же это важная тема.

 Рядом с DIP всегда появляется словосочетание Dependency Injection или Внедрение Зависимостей — это набор способов, с помощью которых можно доставить зависимости. Кроме внедрения через параметры функции, выделяют следующие способы:

 - Через конструктор
 - Через сеттер

 Кроме, собственно, полиморфизма, многим компонентам часто нужны готовые объекты, представляющие различные подсистемы программы. К таким компонентам могут относиться соединения с базой данных, доступы к кешам, любые компоненты с состоянием. Единственный способ получать к ним доступ без внедрения зависимостей — это использование глобальных переменных.

 Многие действительно так и делают, более того, экосистемы некоторых языков подталкивают к таким подходам. Например, в Ruby очень часто объекты делаются глобальными переменными.

 Из этой ситуации есть несколько хорошо изученных выходов.

 # Service Locator

 Сервис-локатор (service locator) - это чуть более продвинутая альтернатива глобальным переменным. Этот паттерн подразумевает наличие одного глобального объекта, который и является сервис-локатором. В начале программы он инициализируется всеми нужными сервисами. В процессе жизни программы каждый компонент сам запрашивает у локатора нужные зависимости. Честно скажем, что этот подход так себе, но за неимением лучшего, может стать неплохим подспорьем.
 */

import locator from './locator'

const sendEmail = (subject, body) => {
    const email = new locator.emailKlass(subject, body);
    locator.emailSender.send(email);
}

/**
 # DI Container
 Самый продвинутый вариант называется Dependency Injection Container. При таком подходе контейнер становится центральной частью системы. С одной стороны он предоставляет интерфейс для описания всех сервисов и их зависимостей, с другой стороны сам занимается созданием графа объектов, попутно внедряя зависимости в те места, где они нужны. Такой подход особенно распространён в таких языках как Java/C#. Возможно, вы даже слышали такое название, как Spring Framework.

 Ниже представлен один из вариантов того, как могли бы выглядеть части системы, использующей контейнер:
 */

class SendService {
    constructor(EmailKlass, sender) {
        this.EmailKlass = EmailKlass;
        this.sender = sender;
    }

    sendEmail(subject, body) {
        const email = new this.EmailKlass(subject, body);
        this.sender.send(email);
    }
}

/**
 Как видите, класс не запрашивает никаких зависимостей сам, они внедряются через конструктор какой-то внешней системой.

 # bottlejs
 bottlejs — это библиотека, которая позиционирует себя как DI Micro Container. В отличие от своих старших собратьев, она очень простая (я бы сказал деревянная и обладает ограниченными возможностями, но вполне себе позволяет собрать приложение и внедрить зависимости снаружи).
 */

const bottle = new Bottle();
bottle.service('Barley', Barley);
bottle.service('Water', Water);
bottle.factory('Beer', (container) => {
    const barley = container.Barley;
    const water = container.Water;

    barley.halved();
    water.spring();
    return new Beer(barley, water);
});
bottle.container.Beer;

/***@@@
 index.js
 Соберите контейнер bottlejs так чтобы:

 свойство repositories хранило все объекты репозиториев, доступные по их именам (например, repositories.user)
 свойство entities хранило в себе все классы сущностей
 свойство validate хранило в себе валидатор с установленными внутрь репозиториями
 свойство services хранило в себе объекты сервисов, доступные по их именам (например, services.user)

 services/CinemaService.js
 Реализуйте бизнес-сценарий создание сеанса:
 */

const time = new Date();
const [film] = service.createFilm('first glance', 100);
const [cinemaHall] = service.createCinemaHall('first', 5, 5);
const [filmScreening] = service.createFilmScreening(film.id, cinemaHall.id, time);



// FILE: /app/src/index.js:
import Bottle from 'bottlejs';
import _ from 'lodash';
import services from './services';
import entities from './entities';
import repositories from './repositories';
import makeValidator from './lib/validator';

export default () => {
    const bottle = new Bottle();
    bottle.factory('repositories', () => {
        const result = Object.keys(repositories)
            .reduce(
                (acc, repoName) => ({ ...acc, [_.camelCase(repoName)]: new repositories[repoName]() }),
                {},
            );
        return result;
    });

    bottle.factory('entities', () => entities);
    bottle.factory('validate', container => makeValidator(container));

    bottle.factory('services', (container) => {
        const result = Object.keys(services).reduce((acc, serviceName) => {
            const service = new services[serviceName](container);
            return { ...acc, [_.camelCase(serviceName)]: service };
        }, {});
        return result;
    });

    return bottle.container;
};



// FILE: /app/src/services/CinemaService.js:
// @flow

import ApplicationService from './ApplicationService';

export default class extends ApplicationService {
    createCinemaHall(name, rows, cols) {
        const cinemaHall = new this.entities.CinemaHall(name, rows, cols);
        const errors = this.validate(cinemaHall);
        if (!errors) {
            this.repositories.cinemaHall.save(cinemaHall);
        }
        return [cinemaHall, errors];
    }

    createFilm(name, duration) {
        const film = new this.entities.Film(name, duration);
        const errors = this.validate(film);
        if (!errors) {
            this.repositories.film.save(film);
        }
        return [film, errors];
    }

    createFilmScreening(filmId, cinemaHallId, time) {
        const film = this.repositories.film.find(filmId);
        const hall = this.repositories.cinemaHall.find(cinemaHallId);
        const filmScreening = new this.entities.FilmScreening(film, hall, time);
        const errors = this.validate(filmScreening);
        if (!errors) {
            this.repositories.filmScreening.save(filmScreening);
        }
        return [filmScreening, errors];
    }
}




// >>>>>> Предметная область <<<<<<

/**
 Предметно-ориентированное проектирование (Domain-driven design) - это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом.

 Данный термин был впервые введён Э. Эвансом в его книге с таким же названием «Domain-Driven Design».

 Представьте себе, что перед вами поставили задачу разработать биллинг (система тарификации, выставление счетов, обработка платежей) для интернет-провайдера. С чего вы начнёте проектирование такой системы? А начать надо с анализа предметной области. Познакомиться с основными сущностями системы и их взаимоотношениями, другими словами, вам будет необходимо разобраться в онтологии предметной области.

 И вот тут на сцену выходит DDD. Центральная идея этого подхода заключается в том, что разработчики постоянно активно сотрудничают с экспертами предметной области (со стороны заказчика) и вместе с ними формируют так называемый единый язык. Этот язык будет использоваться для общения между всеми членами команды, а позже отразится в исходном коде разрабатываемой программы.

 Ubiquitous Language — это не бизнес-жаргон, навязанный разработчикам, а настоящий язык, созданный целостной командой – экспертами в предметной области, разработчиками, бизнес-аналитиками и всеми, кто вовлечён в создание системы. Роль в команде не столь существенна, поскольку каждый член команды использует для описания проекта единый язык. Процесс создания единого языка более творческий чем формальный, так как он, как и любой другой естественный язык, постоянно развивается, а те артефакты, которые вначале способствовали разработке полезного единого языка, со временем устаревают. В итоге остаются только самые устойчивые и проверенные элементы.

 Наиболее важное для разработчика – это умение слушать экспертов, получать максимальное количество полезных знаний о предметной области. В то же время эксперты также должны прислушиваться к разработчикам и их пожеланиям. Команда учится и растёт вместе, если она действует сплочённо, получая более глубокое понимание бизнеса.

 # Bounded context

 Это второе по значимости свойство DDD после единого языка. Оба эти понятия взаимосвязаны и не могут существовать друг без друга.

 Итак, ограниченный контекст – это явная граница, внутри которой существует модель предметной области, которая отображает единый язык в модель программного обеспечения.

 В каждом ограниченном контексте существует только один единый язык.

 - Ограниченные контексты являются относительно небольшими.
 - Ограниченный контекст достаточно велик только для единого языка изолированной предметной области, но не больше.
 - Единый значит «вездесущий» или «повсеместный», т. е. язык, на котором говорят члены команды и на котором выражается отдельная модель предметной области, которую разрабатывает команда.
 - Язык является единым только в рамках команды, работающей над проектом в едином ограниченном контексте.
 - Попытка применить единый язык в рамках всего предприятия или что хуже, среди нескольких предприятий, закончится провалом.

 Например, система биллинга крупной телекоммуникационной компании может иметь следующие ключевые элементы (контексты):

 - Клиентское обслуживание
 - Система безопасности и защиты
 - Резервное копирование
 - Взаимодействие с платёжными системами
 - Ведение отчётности
 - Система уведомлений


 В этом уроке были представлены самые базовые понятия и идеи предметно-ориентированного проектирования. За более подробным описанием можно обратиться к отличной статье на Хабре, либо к книге Эрика Эванса. Также не могу не порекомендовать моё выступление на одной из региональных конференций, в котором я рассказываю о похожих идеях, помогающих улучшить качество кода, который мы пишем.
 */


/***@@@
 В этом упражнении мы добавим в домен две сущности Price и CapitalTransaction.

 Price - это цена за билет с привязкой к конкретному залу. Это не единственный возможный вариант формирования цены, но в нашем кинотеатре залы различаются по уровню комфорта. Кроме этого цена увеличивается в выходные. Увеличение происходит по формуле price * weekendMultiplier, где weekendMultiplier это постоянный и единый для всех коэффициент, равный 1.3.

 Price связан с CinemaHall как o2o.
 */

const value = 500;
const price = new Price(cinemaHall, value);

const friday = new Date('31.03.2017');
price.calculateFor(friday); // 500
const saturday = new Date('1.04.2017');
price.calculateFor(saturday); // 650

/**
 Вторая сущность CapitalTransaction - представляет из себя движение денежных средств. Каждый раз когда продается билет, создается CapitalTransaction с привязкой к билету и его стоимости. В будущем эта же сущность будет использоваться и при возврате билета. Она отражает реальный приход и уход денег. Особенно это актуально с применением скидок или частичным возвратом стоимости.

 Это разделение позволяет нам избавится от изменений сущности ticket. Любые манипуляции с билетом будут приводить к создании новой CapitalTransaction. Таким образом упрощается код и сохраняется история действий.
 */

const capitalTransaction = new CapitalTransaction(ticket);
capitalTransaction.cost == ticket.cost; // true

/**
 src/entities/Price.js
 Реализуйте сущность Price. Она должна уметь рассчитывать цену билета на основе даты сеанса.

 Валидация:

 Свойство cinemaHall должно существовать и быть уникальным
 Свойство value должно существовать и быть числом
 src/entities/CapitalTransaction.js
 Реализуйте сущность CapitalTransaction.

 Свойство createdAt равное текущей дате на момент создания сущности
 Валидация:

 Свойство ticket должно существовать
 Свойство cost должно существовать и быть числом
 src/services/MoneyService.js
 Реализуйте следующие бизнес-сценарии:

 Создание сеанса фильма
 На этом этапе сеанс фильма создается с привязкой к стоимости рассчитанной на основе Price того зала в котором проходит сеанс.
 */

const [filmScreening] = services.MoneyService
    .createFilmScreening(film.id, cinemaHall.id, time);

/**
 Покупка билета
 Кроме самого билета должна создавать CapitalTransaction.
 */

const [ticket] = moneyService.buyTicket(user.id, filmScreening.id, place);
const capital = repositories.capitalTransaction.findBy({ ticket });
capital.ticket === ticket; // true
capital.cost === ticket.cost; // true


// FILE /app/src/entities/CapitalTransaction.js:
import uuid from 'uuid-js'; // eslint-disable-line
import ApplicationEntity from './ApplicationEntity';

export default class CapitalTransaction extends ApplicationEntity {

    static constraints = {
        ticket: {
            presence: true,
            association: true,
        },
        cost: {
            presence: true,
            numericality: true,
        }
    };

    constructor(ticket) {
        super();
        this.id = uuid.create().hex;
        this.ticket = ticket;
        this.cost = ticket.cost;
        this.createdAt = new Date();
    }
}


// FILE /app/src/entities/Price.js:
import uuid from 'uuid-js'; // eslint-disable-line
import dateFns from 'date-fns'; // eslint-disable-line
import ApplicationEntity from './ApplicationEntity';

export default class Price extends ApplicationEntity {
    static weekendMultiplier = 1.3;

    static constraints = {
        cinemaHall: {
            presence: true,
            uniqueness: true,
        },
        value: {
            presence: true,
            numericality: {
                greaterThanOrEqualTo: 0,
            },
        },
    };

    constructor(cinemaHall, value) {
        super();
        this.id = uuid.create().hex;
        this.cinemaHall = cinemaHall;
        this.value = value;
    }

    calculateFor(time) {
        return dateFns.isWeekend(time) ?
            this.value * this.constructor.weekendMultiplier : this.value;
    }
}


// FILE: /app/src/services/MoneyService.js:
import ApplicationService from './ApplicationService';

export default class extends ApplicationService {
    createPrice(cinemaHallId, value) {
        const cinemaHall = this.repositories.CinemaHall.find(cinemaHallId);
        const price = new this.entities.Price(cinemaHall, value);
        const errors = this.validate(price);
        if (!errors) {
            this.repositories.Price.save(price);
        }
        return [price, errors];
    }

    // BEGIN (write your solution here)
    createFilmScreening(filmId, cinemaHallId, time) {
        const film = this.repositories.Film.find(filmId);
        const cinemaHall = this.repositories.CinemaHall.find(cinemaHallId);
        const price = this.repositories.Price.findBy({ cinemaHall });
        const cost = price.calculateFor(time);
        const screening = new this.entities.FilmScreening(film, cinemaHall, time, cost);

        const errors = this.validate(screening);
        if (!errors) {
            this.repositories.FilmScreening.save(screening);
        }
        return [screening, errors];
    }

    buyTicket(userId, filmScreeningId, place) {
        const user = this.repositories.User.find(userId);
        const screening = this.repositories.FilmScreening.find(filmScreeningId);

        const ticket = new this.entities.FilmScreeningTicket(screening, user, place);
        const errors = this.validate(ticket);
        if (errors) {
            return [ticket, errors];
        }

        const capitalTransaction = new this.entities.CapitalTransaction(ticket);
        this.validate(capitalTransaction, { exception: true });

        this.repositories.FilmScreeningTicket.save(ticket);
        this.repositories.CapitalTransaction.save(capitalTransaction);

        return [ticket, errors];
    }
}





// >>>>>> Мутация <<<<<<

/**
 На протяжении всего курса, в практической части, мы разрабатывали сценарии, в которых происходило только добавление сущностей. Добавление это наиболее простая операция из всех возможных, потому что в ней отсутствует (почти) изменяемость данных. Но большинство сценариев в реальной жизни обычно связано с изменением:

 Обновление расписания
 Возврат билета
 Удаление кинозала
 Изменение конфигурации кинозала
 И вот тут начинаются настоящие проблемы. Попробуйте ответить себе на следующие вопросы:

 Можно ли безопасно удалить из системы кинозал?
 Можно ли безопасно изменить конфигурацию зала в любой момент времени?
 Простая ли операция возврата билета?
 На все эти (и многие другие) вопросы ответ: нет. Возврат билета затрагивает множество связанных сущностей. Например, в зале нужно освободить место для возможности перепродажи. Удаление кинозала из системы приведёт к тому, что все предыдущие просмотры фильмов в этом зале станут не консистентными, мы потеряем историю операций. Изменение конфигурации зала приведёт к поломке старых покупок. Удаление сеанса связано с возвратом билетов, а эта операция, в свою очередь, порождает цепочку других изменений.

 Итак, чем же нам грозит изменяемость:

 Сложное обновление связанных сущностей;
 Отсутствие истории;
 Рассинхронизация;
 Повреждение старых связей.
 В связи с этим хочется сформулировать первое правило мутации:

 Не мутируй!

 И действительно, на практике часто можно и нужно проектировать систему так, чтобы изменяющие действия превращались в append only. Проницательный читатель вероятно заметил, что эта идея очень сильно коррелирует с главным принципом функционального программирования, а именно отсутствием изменений. Это действительно так, проблема изменяемого состояния – это не проблема кода и программирования, это особенность физической реальности. И на практике гораздо лучше пытаться уйти от изменений, чем пытаться создать систему, которая консистентно обновляет все нужные связи, что в общем случае невозможно и рождает очень много случайной сложности.

 # Изменение конфигурации зала

 В такой ситуации правильно создать новый зал с другой конфигурацией, а предыдущий архивировать. То есть перевести конечный автомат жизненного цикла зала в состояние archived. Соответственно, все старые данные остаются в согласованном виде. У нас появляется история, и мы можем отследить момент, в который произошла физическая перепланировка зала.

 # Возврат билетов

 При возврате билета, правильно не удалять записи о том, что был приход денег. Правильно создать новую запись, в которой отражается расход. Кроме стандартных плюсов, мы получаем возможность проводить глубокий бизнес-анализ ситуации с возвратами. Сам билет также может быть переведён в состояние (везде конечные автоматы) возвращён.


 # Current

 Ещё один подход для ухода от мутации связан с тем, что вводится понятие current. Например, на Хекслете есть понятие "Упражнение". Это задание, которое выполняется в нашей ide. Перед тем как новая версия упражнения попадает на сайт, она проходит этап сборки и верификации. На этом этапе происходит упаковка всех зависимостей и кода упражнения в Docker-образ, а также выполнение различных проверок на работоспособность, в первую очередь, конечно же, тестов.

 Исправлять упражнение ни в коем случае нельзя. Потому что всегда есть пользователи, которые проходят старую версию упражнения. И если бы мы делали изменение текущей версии, то у части пользователей упражнение перестало бы работать. Выход из ситуации очень простой. Мы разделяем понятия Exercise и Exercise::Build. И после того, как успешно пройдёт новый Exercise::Build, в Exercise будет записан Current Exercise Build. После этого все новые старты будут использовать эту сборку, а старые — ту, которая была актуальна на момент старта. Для функционирования такого механизма нужно всегда записывать Current Exercise Build в объект, представляющий собой запущенную практику, тогда всё будет работать даже если появится новая сборка.

 На практике это очень простая тактика. Хекслет использует её просто повсеместно, и, таким образом, мы сильно снижаем затраты на синхронизацию данных.
 */


/***@@@
 Добавление возможности возвращать билет, требует небольшого изменения существующего кода. В первую очередь изменение касается билетов. У билета появляется конечный автомат с двумя состояниями active и returned и событием refund. По умолчанию билет активен, но если делается рефанд то он переходит в состояние returned. Практический смысл в том, что 1) мы не удаляем билет и сохраняется история 2) появляется возможность повторно продать места занятые этим билетом. Второй пункт требует еще одного изменения внутри сущности Ticket.
 */

class Ticket {
    static constraints = {
        filmScreening: {
            presence: true,
            uniqueness: {
                scope: ['place'], conditions: { _fsm: { state: 'active' } },
            },
        },
    }
}

/**
 То есть теперь мы проверяем уникальность сеанса только среди тех билетов, текущее состояние которых active.

 Еще одно изменение касается сущности CapitalTransaction. В соответствии с принципом неизменяемости, возврат билетов создает новую сущность CapitalTransaction, но теперь, каким-то образом, нужно отличать приход от возврата. Это можно сделать следующим образом. Вводится понятие type с возможными значениями loss (убыток) и income (доход). Этот тип устанавливается в конструктор при создании сущности. Кроме этого, на основании значения свойства type изменяется знак свойства cost. В свою очередь, в будущем, это поможет удобно делать вычисления используя запросы к базы данных, без необходимости сначала выбирать данные в память.

 src/entities/CapitalTransaction.js
 Напишите конструктор с учетом логики описанной выше.
 */
const capitalTransaction = new CapitalTransaction(ticket, 'loss');

/**
 src/services/MoneyService.js
 Реализуйте бизнес-сценарий возврат билета:
 */
moneyService.refundTicket(ticket.id);


// app/src/entities/FilmScreening/Ticket.js:
import uuid from 'uuid-js'; // eslint-disable-line
import StateMachine from 'javascript-state-machine'; // eslint-disable-line
import ApplicationEntity from '../ApplicationEntity';

export default class FilmScreeningTicket extends ApplicationEntity {
    static constraints = {
        filmScreening: {
            presence: true,
            uniqueness: {
                scope: ['place'], conditions: { _fsm: { state: 'active' } },
            },
        },
        user: {
            presence: true,
        },
        place: {
            presence: true,
        },
        cost: {
            presence: true,
            numericality: {
                greatThan: 0,
            },
        },
    };

    constructor(filmScreening, user, place) {
        super();
        this.id = uuid.create().hex;
        this.filmScreening = filmScreening;
        this.cost = filmScreening.cost;
        this.user = user;
        this.place = place;
        this.createdAt = new Date();
        this._fsm(); // eslint-disable-line
    }
}

StateMachine.factory(FilmScreeningTicket, {
    init: 'active',
    transitions: [
        { name: 'refund', from: 'active', to: 'returned' },
    ],
});


// FILE: /app/src/entities/ApplicationEntity.js:
// @flow

import BaseEntity from '../lib/BaseEntity';

export default class extends BaseEntity {

}


// FILE: /app/src/entities/CapitalTransaction.js:
import uuid from 'uuid-js'; // eslint-disable-line
import ApplicationEntity from './ApplicationEntity';

export default class CapitalTransaction extends ApplicationEntity {
    static types = ['income', 'loss'];

    static constraints = {
        ticket: {
            presence: true,
        },
        cost: {
            presence: true,
            numericality: true,
        },
        type: {
            presence: true,
            inclusion: CapitalTransaction.types,
        },
    };

    constructor(ticket, type) {
        super();
        this.id = uuid.create().hex;
        this.ticket = ticket;
        this.type = type;
        this.createdAt = new Date();

        switch (type) { // eslint-disable-line
            case 'income':
                this.cost = ticket.cost;
                break;
            case 'loss':
                this.cost = -ticket.cost;
                break;
        }
    }
}


// FILE: /app/src/entities/CinemaHall.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class CinemaHall extends ApplicationEntity {
    static constraints = {
        name: {
            presence: true,
        },
        rows: {
            presence: true,
            numericality: true,
        },
        cols: {
            presence: true,
            numericality: true,
        },
    };

    constructor(name, rows, cols) {
        super();
        this.id = uuid.create().hex;
        this.name = name;
        this.rows = rows;
        this.cols = cols;
    }
}


// FILE: /app/src/entities/Film.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class Film extends ApplicationEntity {
    static constraints = {
        name: {
            presence: true,
        },
        duration: {
            presence: true,
        },
    };

    constructor(name, duration) {
        super();
        this.id = uuid.create().hex;
        this.name = name;
        this.duration = duration;
    }
}


// FILE: /app/src/entities/FilmScreening.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class FilmScreening extends ApplicationEntity {
    static constraints = {
        film: {
            presence: true,
        },
        cinemaHall: {
            presence: true,
        },
        cost: {
            presence: true,
            numericality: true,
        },
        time: {
            presence: true,
        },
    };

    constructor(film, cinemaHall, time, cost) {
        super();
        this.id = uuid.create().hex;
        this.film = film;
        this.cost = cost;
        this.cinemaHall = cinemaHall;
        this.time = time;
    }
}


// FILE: /app/src/entities/Price.js
import uuid from 'uuid-js';
import dataFns from 'date-fns';
import ApplicationEntity from './ApplicationEntity';

export default class Price extends ApplicationEntity {
    static weekendMultiplier = 1.3;

    static constraints = {
        cinemaHall: {
            presence: true,
            uniqueness: true,
        },
        value: {
            presence: true,
            numericality: true,
        },
    };

    constructor(cinemaHall, value) {
        super();
        this.id = uuid.create().hex;
        this.cinemaHall = cinemaHall;
        this.value = value;
    }

    calculateFor({ createdAt }) {
        return dataFns.isWeekend(createdAt) ?
            this.value * this.constructor.weekendMultiplier : this.value;
    }
}


// FILE: /app/src/entities/User.js:
import uuid from 'uuid-js';
import ApplicationEntity from './ApplicationEntity';

export default class User extends ApplicationEntity {
    static constraints = {
        email: {
            presence: true,
            email: true,
        },
    };

    constructor(email) {
        super();
        this.id = uuid.create().hex;
        this.email = email;
    }
}


// FILE: /app/src/entities/index.js:
import Film from './Film';
import Price from './Price';
import User from './User';
import CinemaHall from './CinemaHall';
import FilmScreening from './FilmScreening';
import FilmScreeningTicket from './FilmScreening/Ticket';
import CapitalTransaction from './CapitalTransaction';

export default {
    Price,
    CapitalTransaction,
    User,
    Film,
    FilmScreening,
    FilmScreeningTicket,
    CinemaHall,
};


// FILE: /app/lib/BaseEntity.js:
export default class {

}


// FILE: /app/lib/BaseRepository.js:
import _ from 'lodash';

export default class {
    data = [];

    all() {
        return this.data;
    }

    find(id) {
        const result = this.data.find(entity => entity.id === id);
        if (!result) {
            throw new Error('Entity not found');
        }
        return result;
    }

    findAllBy(params) {
        return _.filter(this.data, params);
    }

    findBy(params) {
        const result = this.findAllBy(params);
        return result.length > 0 ? result[0] : null;
    }

    save(entity) {
        const foundEntity = this.findBy(entity);
        if (foundEntity) {
            this.data = this.data.filter(e => e.id !== foundEntity.id);
        }
        this.data.push(entity);
    }
}


// FILE: /app/lib/BaseService.js:
export default class {
    constructor({ repositories, entities, validate }) {
        this.repositories = repositories;
        this.entities = entities;
        this.validate = validate;
    }
}

// FILE: /app/lib/validator.js:
import _ from 'lodash';
import validate from 'validate.js';

import BaseEntity from './BaseEntity';

export default ({ repositories }) => {
    const entityValidator = (entity, options = { exception: false }) => {
        const errors = validate(entity, entity.constructor.constraints);
        if (errors && options.exception) {
            const err = new Error(`${entity.constructor.name} is not valid.
        Errors: (${JSON.stringify(errors)})`);
            err.errors = errors;
            throw err;
        }
        return errors;
    };

    validate.validators.uniqueness = (value, options, key, attributes) => {
        if (!value) {
            return null;
        }
        const className = attributes.constructor.name;
        const repository = repositories[className];
        const scope = options.scope || [];
        const conditions = options.conditions || {};
        const params = { [key]: value, ...conditions, ..._.pick(attributes, scope) };
        const result = repository.findBy(params);
        const isEntity = result instanceof BaseEntity;
        if (result || (isEntity && result.id !== value.id)) {
            return 'already exists';
        }
        return null;
    };

    validate.validators.association = (value) => {
        if (!value) {
            return null;
        }
        return entityValidator(value);
    };

    return entityValidator;
};


// FILE /app/src/repositories/FilmScreening/TicketRepository.js:
// @flow

import ApplicationRepository from '../ApplicationRepository';

export default class extends ApplicationRepository {
}


// FILE: /app/src/repositories/ApplicationRepository.js:
// @flow

import BaseRepository from '../lib/BaseRepository';

export default class extends BaseRepository {
}

// FILE: /app/src/repositories/CapitalTransactionRepository.js:
import ApplicationRepository from './ApplicationRepository';

export default class CapitalTransactionRepository extends ApplicationRepository {
}

// FILE: /app/src/repositories/CinemaHallRepository.js:
// @flow

import ApplicationRepository from './ApplicationRepository';

export default class extends ApplicationRepository {
}


// FILE: /app/src/repositories/FilmRepository.js:
// @flow

import ApplicationRepository from './ApplicationRepository';

export default class extends ApplicationRepository {
}

// FILE: /app/src/repositories/FilmScreeningRepository.js:
// @flow

import ApplicationRepository from './ApplicationRepository';

export default class FilmScreeningRepository extends ApplicationRepository {
}


// FILE: /app/src/repositories/PriceRepository.js:
import ApplicationRepository from './ApplicationRepository';

export default class PriceRepository extends ApplicationRepository {
}


// FILE: /app/src/repositories/UserRepository.js:
// @flow

import ApplicationRepository from './ApplicationRepository';

export default class extends ApplicationRepository {
}

// FILE: /app/src/repositories/index.js:
// @flow

import FilmScreening from './FilmScreeningRepository';
import Film from './FilmRepository';
import Price from './PriceRepository';
import CinemaHall from './CinemaHallRepository';
import User from './UserRepository';
import FilmScreeningTicket from './FilmScreening/TicketRepository';
import CapitalTransaction from './CapitalTransactionRepository';

export default {
    Price,
    CapitalTransaction,
    FilmScreening,
    FilmScreeningTicket,
    Film,
    CinemaHall,
    User,
};



// FILE: /app/src/services/ApplicationService.js:
// @flow

import BaseService from '../lib/BaseService';

export default class extends BaseService {
}


// FILE: /app/src/services/CinemaService.js:
// @flow

import ApplicationService from './ApplicationService';

export default class extends ApplicationService {
    createCinemaHall(name, rows, cols) {
        const cinemaHall = new this.entities.CinemaHall(name, rows, cols);
        const errors = this.validate(cinemaHall);
        if (!errors) {
            this.repositories.CinemaHall.save(cinemaHall);
        }
        return [cinemaHall, errors];
    }

    createFilm(name, duration) {
        const film = new this.entities.Film(name, duration);
        const errors = this.validate(film);
        if (!errors) {
            this.repositories.Film.save(film);
        }
        return [film, errors];
    }
}
// FILE: /app/src/services/MoneyService.js:
import ApplicationService from './ApplicationService';

export default class extends ApplicationService {
    createPrice(cinemaHallId, value) {
        const cinemaHall = this.repositories.CinemaHall.find(cinemaHallId);
        const price = new this.entities.Price(cinemaHall, value);
        const errors = this.validate(price);
        if (!errors) {
            this.repositories.Price.save(price);
        }
        return [price, errors];
    }

    createFilmScreening(filmId, cinemaHallId, time) {
        const film = this.repositories.Film.find(filmId);
        const cinemaHall = this.repositories.CinemaHall.find(cinemaHallId);
        const price = this.repositories.Price.findBy({ cinemaHall });
        const cost = price.calculateFor(time);
        const screening = new this.entities.FilmScreening(film, cinemaHall, time, cost);

        const errors = this.validate(screening);
        if (!errors) {
            this.repositories.FilmScreening.save(screening);
        }
        return [screening, errors];
    }

    refundTicket(ticketId) {
        // BEGIN (write your solution here)
        const ticket = this.repositories.FilmScreeningTicket.find(ticketId);
        if (ticket.is('returned')) {
            return false;
        }
        const capitalTransaction = new this.entities.CapitalTransaction(ticket, 'loss');
        this.validate(capitalTransaction, { exception: true });
        this.repositories.CapitalTransaction.save(capitalTransaction);
        ticket.refund();
        this.repositories.FilmScreeningTicket.save(ticket);
        return true;
        // END
    }

    buyTicket(userId, filmScreeningId, place) {
        const user = this.repositories.User.find(userId);
        const screening = this.repositories.FilmScreening.find(filmScreeningId);

        const ticket = new this.entities.FilmScreeningTicket(screening, user, place);
        const errors = this.validate(ticket);
        if (errors) {
            return [ticket, errors];
        }

        const capitalTransaction = new this.entities.CapitalTransaction(ticket, 'income');
        this.validate(capitalTransaction, { exception: true });

        this.repositories.FilmScreeningTicket.save(ticket);
        this.repositories.CapitalTransaction.save(capitalTransaction);

        return [ticket, errors];
    }
}

// FILE: /app/src/services/UserService.js:
import ApplicationService from './ApplicationService';

export default class extends ApplicationService {
    createUser(email) {
        const user = new this.entities.User(email);
        const errors = this.validate(user);
        if (!errors) {
            this.repositories.User.save(user);
        }
        return [user, errors];
    }
}


// FILE /app/src/service/index.js:
// @flow

import Cinema from './CinemaService';
import Money from './MoneyService';
import User from './UserService';

export default {
    Cinema,
    Money,
    User,
};


// FILE: /app/src/index.js:
// @flow

import Bottle from 'bottlejs';
import services from './services';
import entities from './entities';
import repositories from './repositories';
import makeValidator from './lib/validator';

export default () => {
    const bottle = new Bottle();
    bottle.factory('repositories', () => {
        const result = Object.keys(repositories).reduce((acc, repoName) =>
            ({ ...acc, [repoName]: new repositories[repoName]() }), {});
        return result;
    });

    bottle.factory('entities', () => entities);
    bottle.factory('validate', container => makeValidator(container));

    bottle.factory('services', (container) => {
        const result = Object.keys(services).reduce((acc, serviceName) => {
            const service = new services[serviceName](container);
            return { ...acc, [serviceName]: service };
        }, {});
        return result;
    });

    return bottle.container;
};




// ################ JS: Разработка абстракций для асинхронности ################


/***@@@
 diff.js
 Реализуйте и экспортируйте по умолчанию функцию, которая сравнивает два файла построчно. Сигнатура функции: (path1, path2, callback), где path1 и path2 — пути до первого и второго файла соответственно, а callback — это функция, которая будет вызвана после проведения сравнения. Сигнатура функции callback — (err, data).

 Результатом функции является массив, каждый элемент которого состоит из двух элементов. Первый — это строчка из первого файла, второй — это соответствующая строчка из второго. Если строки совпадают, то они не попадают в результат. Если в одном из файлов строка отсутствует, то в массиве подставляется null. Подробнее в примере:
 */

diff('fixtures/file4', 'fixtures/file5', (err, data) => {
    console.log(data);
    // [['text', 'ext'], ['', 'haha'], ['ehu', ''], ['', 'text'], ['aha', null]];
});

// Содержимое файла file4

hello, world
text

ehu

aha

// Содержимое файла file5

hello, world
ext
haha

text

/**
 Подсказки
 Данные, которые читаются из файла, преобразуются к строке используя метод toString.
 Альтернативный способ, это передача в readFile вместо двух, три аргумента. Подробнее можно посмотреть в документации.
 */

// FILE: /app/diff.js:
import fs from 'fs';

const compare = (data1, data2) => {
    const lines1 = data1.split('\n').slice(0, -1);
    const lines2 = data2.split('\n').slice(0, -1);
    const biggestFile = lines1.length > lines2.length ? lines1 : lines2;

    return biggestFile.reduce((acc, line, index) => {
        if (lines1[index] === lines2[index]) {
            return acc;
        }

        return [...acc, [lines1[index], lines2[index]].map(x => (x === undefined ? null : x))];
    }, []);
};

export default (path1, path2, callback) => {
    fs.readFile(path1, (err, data1) => {
        if (err) {
            callback(err);
            return;
        }

        fs.readFile(path2, (err2, data2) => {
            if (err2) {
                callback(err2);
                return;
            }

            callback(null, compare(data1.toString(), data2.toString()));
        });
    });
};



/***@@@
 asyncFilter.js
 Реализуйте и экспортируйте по умолчанию функцию asyncFilter.
 */

const coll = [10, 53, true, false, '', NaN, 22];
asyncFilter(coll, v => typeof v === 'number', result => {
    console.log(result); // => [10, 53, NaN, 22]
});

// Так как фильтр асинхронный, то вызов предиката для каждой функции должен выполняться после setTimeout.

/**
 Подсказки
 Проверка на соответствие внутри фильтра должна быть нестрогой как и в обычном фильтре:
 */

[10, 53, true, false, '', NaN, 22].filter(v => v);
// => [ 10, 53, true, 22 ]


// FILE: /app/asyncFilter.js:
export default (coll, fn, callback) => {
    const iter = (items, acc) => {
        if (items.length === 0) {
            callback(acc);
            return;
        }
        const [head, ...rest] = items;
        const newAcc = fn(head) ? [...acc, head] : acc;
        setTimeout(iter, 0, rest, newAcc);
    };

    iter(coll, []);
};



/***@@@
 Асинхронные задачи имеют свойство заканчиваться с ошибками. Иногда эти ошибки плавающие и пропадают при повторных выполнениях кода, чем некоторые разработчики активно пользуются. С одной стороны можно вызов повторить самостоятельно, с другой, достаточно написать обобщенную функцию retry, которая, в случае ошибок, повторяет нужный асинхронный вызов, столько раз, сколько попросят.

 retry.js
 Реализуйте и экспортируйте по умолчанию функцию retry. Функция принимает на вход три аргумента:

 Количество попыток асинхронного вызова в случае ошибок.
 Функция выполняющая асинхронную задачу. Она должна принимать на вход коллбек, который вызывается внутри (так callback(err, body)) и сигнализирует об успешном или ошибочном завершении.
 Коллбек, который будет вызван после того как функция retry закончит свою работу. Она принимает на вход ошибку и тело ответа.
 Логика работы функции следующая:

 Вызывается функция выполняющая асинхронную операцию. Если она выполнилась успешно, то функция retry завершает работу вызывая колбек переданный последним параметром.
 Если асинхронная операция закончилась с ошибками, то пробуем запустить еще раз, если общее количество запусков не превысило число, переданное первым параметром.
 */

// Пытаемся прочитать файл и даем функции 3 попытки.
retry(3, callback =>
    fs.readFile('file.txt', (err, body) => {
        callback(err, body);
    }), (err, result) => {
    console.log(result);
});

/**
 Подсказки
 Коллбек передаваемый в конце и коллбек который передается в функцию с асинхронной операцией - две разные функции даже не смотря на то, что они принимают одинаковые параметры.
 */

// FILE: /
const noop = () => {};

const retry = (count, fn, callback = noop) => {
    const cb = (err, result) => {
        if (!err || count <= 1) {
            callback(err, result);
            return;
        }

        retry(count - 1, fn, callback);
    };

    fn(cb);
};

export default retry;


/***@@@
 solution.js
 Реализуйте и экспортируйте по умолчанию функцию concat. Эта функция применяется в том случае, когда асинхронная операция возвращает коллекцию, а на выходе нужно получить массив, состоящий из всех элементов коллекций, которые вернула каждая асинхронная операция.
 */

concat(['dir1', 'dir2', 'dir3'], fs.readdir, (err, files) => {
    // files is now a list of filenames that exist in the 3 directories
});


// FILE /app/solution.js:
const noop = () => {};

const once = (fn) => {
    let called = false;

    return (...args) => {
        if (called) return;
        called = true;
        fn(...args);
    };
};

const each = (coll, iteratee, callback = noop) => {
    const oncedCallback = once(callback);
    let completed = 0;
    if (coll.length === 0) {
        callback(null);
        return;
    }

    const cb = (err) => {
        if (err) {
            oncedCallback(err);
            return;
        }
        completed += 1;
        if (completed === coll.length) {
            oncedCallback(null);
        }
    };

    coll.forEach(item => iteratee(item, cb));
};

export default (coll, fn, callback) => {
    let result = [];
    each(coll, (item, cb) => {
        fn(item, (err, y) => {
            result = result.concat(y || []);
            cb(err);
        });
    }, (err) => {
        callback(err, result);
    });
};



/***@@@
 filter.js
 Реализуйте и экспортируйте по умолчанию функцию filter. Отфильтрованная коллекция должна сохранять порядок элементов.
 */

filter(['file1', 'file2', 'file3'], (filePath, callback) => {
    fs.access(filePath, err => {
        callback(null, !err)
    });
}, (err, results) => {
    // results now equals an array of the existing files
});

// FILE: /app/filter.js:
const noop = () => {};

const once = (fn) => {
    let called = false;

    return (...args) => {
        if (called) return;
        called = true;
        fn(...args);
    };
};


export default (coll, iteratee, callback = noop) => {
    const oncedCallback = once(callback);
    let completed = 0;
    const { length } = coll;
    if (length === 0) {
        callback(null, []);
    }

    const mappedColl = [];
    const iteratorCallback = (item, index, err, result) => {
        if (err) {
            oncedCallback(err);
            return;
        }
        if (result) {
            mappedColl[index] = item;
        }
        completed += 1;
        if (completed === length) {
            oncedCallback(err, mappedColl.filter(v => v !== undefined));
        }
    };

    coll.forEach((item, index) => iteratee(item, iteratorCallback.bind(null, item, index)));
};


/***@@@
 Tree.js
 Расширьте реализацию дерева функциями addChild и removeChild и добавьте два события: add и remove, которые должны порождаться при добавлении или удалении узла. Сам узел должен передаваться в функцию обратного вызова. Если удаляемого ключа нет, то нужно бросать исключение (текст любой), событие, при этом, не генерируется.
 */

tree = new Tree('start');
tree.addChild('example');

tree.on('add', node => {
    console.log('add %s', node.getKey());
});
tree.addChild('test');

tree.on('remove', node => {
    console.log('remove %s', node.getKey());
});
tree.removeChild('example');


// FILE /app/Tree.js:
import EventEmitter from 'events';

class Tree extends EventEmitter {
    constructor(key, parent) {
        super();
        this.parent = parent;
        this.key = key;
        this.children = new Map();
    }

    getKey() {
        return this.key;
    }

    getParent() {
        return this.parent;
    }

    addChild(key) {
        const child = new Tree(key, this);
        this.children.set(key, child);
        this.emit('add', child);

        return child;
    }

    removeChild(key) {
        const child = this.children.get(key);
        if (!this.children.has(key)) {
            throw new Error(`Key '${key}' does not exists`);
        }
        this.children.delete(key);
        this.emit('remove', child);
    }
}

export default Tree;




// ###### JS: Архитектура фронтенда ######

/**
 Знание JavaScript и умение работать с DOM это базовые кирпичики, на которых строится все остальное. Они необходимы, но не достаточны для создания приложений которые хорошо работают, легко поддерживаются и расширяются. Скорее наоборот. Работа с чистым DOM без глубокого понимания принципов организации кода буквально сразу превратится в кашу.

 Такой подход еще работает для тех разработчиков, кто делает небольшие виджеты, например, на jquery. Но как появится задача реализовать полноценное фронтенд приложение, те подходы, которые использовались при построении виджетов, сразу начнут давать сбои. Достаточно добавить десяток-другой обработчиков, как код превратится в неподдерживаемую лапшу.

 К счастью, научиться строить архитектуру фронтенд приложений не так сложно. Более того, все эти подходы были разработаны десятки лет назад, буквально тогда, когда только появились первые визуальные интерфейсы. Сейчас в это трудно поверить, но все уже придумано довольно давно.

 Более того, эти подходы практически не меняются от фреймворка к фреймворку. Именно поэтому, в этом курсе, они даются "сырыми" без привязки к каким-то фреймворкам. Здесь рассказываются и изучаются глубинные подходы, которые являются определяющими в архитектуре.

 Основные темы этого курса:

 Управление состоянием и его организация
 Model-View-Controller
 Контролируемые и не контролируемые формы
 Автоматное программирование
 Работа с текстами. Интернационализация, локализация, плюрализация
 */



// >>>>>> Состояние приложения <<<<<<

/**
 Манипулирование домом — задача простая только в самых примитивных ситуациях. Как только понадобится реализовать полноценное, пусть и небольшое, приложение, код моментально превращается в тыкву. Десятка обработчиков достаточно для того чтобы потеряться. С каждым новым событием сложность кода растет еще быстрее, а, ведь, в реальных приложениях событий сотни. Почему так происходит?

 Хотя подобная проблема касается не только фронтенда, именно в нем, она достигает своего апогея. Событийная архитектура и дом, без должного внимания, порождают запутанный код буквально сразу. Понятно что где-то здесь появляется Архитектура, но где конкретно и как, это вопрос.

 Подойдем к правильной архитектуре со стороны бекенда. Как вы уже знаете или догадываетесь, в бекенде приложения состоят минимум из двух частей - базы данных и собственно самого кода. Формы отправляемые на сервер, изменяют состояние приложения, которое хранится в базе, далее, на основе этого состояния формируется ответ в виде HTML страницы.

 По сути, в типичных веб проектах, приложение занимается двумя вещами, либо обновляет данные в базе, либо извлекает эти данные и на основе них формирует HTML. Необходимость базы данных довольно очевидна и понятна для всех, но тоже самое не очевидно во фронтенде, DOM позволяет хранить состояние внутри себя и более того, провоцирует так делать. На протяжении курса мы встречались с этой ситуацией не раз, когда нужно выполнить некоторое действие, а оно зависит от того что сейчас на экране. Для анализа приходилось лезть в DOM и смотреть что же там происходит. Первый шаг в построении правильной архитектуры, состоит в выделении состояния из дома, в некое подобие базы данных, основанной на обычном объекте js. При такой организации кода, вырисовывается следующая схема работы:

 Возникает событие
 Меняется состояние
 Обновляется DOM
 Ниже реализация этой идеи на примере простого счетчика. Состояние, в данном случае, одно число. Кнопка инкремента увеличивает его на единицу, кнопка декремента соответственно уменьшает.

 <div id="result">0</div>
 <button id="increment">+</button>
 <button id="decrement">-</button>
 */

const app = () => {
    let counterValue = 0

    const result = document.getElementById('result');

    const incHandler = () => {
        counterValue += 1;
        result.textContent = counterValue;
    };

    const decHandler = () => {
        counterValue -= 1;
        result.textContent = counterValue;
    };

    const inc = document.getElementById('increment');
    inc.addEventListener('click', incHandler);

    const dec = document.getElementById('decrement');
    dec.addEventListener('click', decHandler);
};

app();

/**
 Главная особенность кода выше, в том как идет работа с состоянием. Здесь нет никаких обращений к дому для извлечения текущего значения, оно хранится в переменной и доступно для всех обработчиков. Обратите внимание на структуру кода. Состояние и навешивание колбеков находятся внутри функции. Это важно, как минимум, по двум причинам. Во-первых, такой подход позволяет использовать данный файл как модуль, импортировать из него другие функции (если они там есть) и, например, тестировать их. Если код вызывается на уровне модуля, то импорт привел бы к его немедленному исполнению. Во-вторых, состояние локально (оно определено внутри функции), а значит мы можем запустить несколько версий приложения, это особенно актуально при написании тестов. Напротив, определение состояния на уровне модуля, сделало бы его "синглотоном" (что-то существующее в единственном экземпляре), другими словами, состояние было бы всегда одним и общим для всего кода, который его использует. Не было бы возможности начать с чистого листа.

 Перед тем как смотреть более сложный пример, в котором состояние представлено объектом, давайте разберемся с тем, что включает в себя понятие состояние. Если коротко, то состояние это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере. Их количество и содержимое меняются в зависимости от того, какие кнопки мы нажимаем и что пытаемся загрузить. В общем случае, любое визуальное изменение в приложении или на странице, это всегда изменение состояния и никак иначе. Невозможна ситуация при которой на странице сайта меняется какая-то деталь, но состояние при этом остается тем же. Изменение представления возможно только на основе изменения состояния. Вы можете возразить, что анимация через CSS не меняет ничего в нашем приложении и будете правы лишь на половину. Да, анимация в css не связана с нашим приложением, но внутри браузера это состояние есть и оно меняется.

 Отличным примером неочевидного, для начинающего фронтенд специалиста, состояния, служит состояние формы. Представьте себе поле для ввода телефона, которое отслеживает ошибки при вводе и сразу их показывает. Если ошибок нет, то оно позволяет выполнить сабмит формы, иначе кнопка заблокирована. Что в данном случае является состоянием? Однозначно состояние валидности данных формы: "валидно" и "не валидно". На основе этого состояния определяется обводить красной рамкой поле для ввода или нет. Ну, и, конечно, состоянием является заблокированность кнопки.

 <form>
 <input type="text" class="phone" name="phone" value="">
 <input type="submit" class="submit" disabled value="Save">
 </form>
 */

const app = () => {
    const state = {
        registrationProcess: {
            valid: true,
            submitDisabled: true,
        }
    };

    const input = document.querySelector('.phone');

    input.addEventListener('keyup', () => {
        if (input.value === '') {
            state.registrationProcess.valid = true;
            state.registrationProcess.submitDisabled = true;
        } else if (!input.value.match(/^\d+$/)) {
            state.registrationProcess.valid = false;
            state.registrationProcess.submitDisabled = true;
        } else {
            state.registrationProcess.valid = true;
            state.registrationProcess.submitDisabled = false;
        }

        render(state);
    });
};

const render = (state) => {
    const input = document.querySelector('.phone');
    const submit = document.querySelector('.submit');

    submit.disabled = state.registrationProcess.submitDisabled;

    if (state.registrationProcess.valid) {
        input.style.border = null;
    } else {
        input.style.border = "thick solid red";
    }
}

app();

// Как видно из примера, состояние описывается обычным js объектом, который создается при старте приложения:

const state = {
    registrationProcess: {
        valid: true,
        submitDisabled: true,
    }
};

// Нет никаких правил по формированию его структуры, как удобно так и делайте. Главное не привязывайте структуру состояния к визуальному оформлению, оформление зависит от состояния, но никак не наоборот. Пример того как делать не стоит ниже:

const state = {
    centralBlock: {
        valid: true,
        submitDisabled: true,
    },
    sideBar: {
        formValue: 'value'
    },
};

/**
 Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придется править.

 Далее обработчики событий. Они должны иметь доступ к состоянию, так как оно меняется именно в обработчиках. Поэтому обработчики определяются в той же функции где и создается состояние (главное не делать это на уровне модуля, состояние должно быть локально относительно приложения). Кроме того, обработчики это то место, где выполняются ajax запросы. В нашем примере их нет, но на будущее не забывайте.
 */

input.addEventListener('keyup', () => {
    if (input.value === '') {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = true;
    } else if (!input.value.match(/^\d+$/)) {
        state.registrationProcess.valid = false;
        state.registrationProcess.suthisbmitDisabled = true;
    } else {
        state.registrationProcess.valid = true;
        state.registrationProcess.submitDisabled = false;
    }

    render(state);
});


/**
 Последнее, что делается в обработчиках, в нашем примере, вызывается функция render, которая принимает на вход состояние и меняет DOM на его основе. Этот момент ключевой. Изменение DOM может происходить только внутри функции render. Весь остальной код может менять только состояние.

 Теперь наше приложение разделено на три независимых части: состояние, обработчики и рендеринг. Эта модель работы на тривиальных приложениях (в пару тройку обработчиков) смотрится избыточной, но если обработчиков станет хотя бы 10, то вы увидите, что с приложением достаточно удобно работать. Виден поток данных, всегда можно отследить, что изменилось и как одни части приложения зависят от других. К тому же сокращается дублирование. Например, изменение состояния может идти из разных частей приложения, но логика отрисовки при этом остается неизменной. В такой ситуации достаточно описать новый способ изменения уже существующего состояния, а рендеринг сделает все остальное.
 */

const render = (state) => {
    const input = document.querySelector('.phone');
    const submit = document.querySelector('.submit');
    submit.disabled = state.registrationProcess.submitDisabled;
    if (state.registrationProcess.valid) {
        input.style.border = null;
    } else {
        input.style.border = "thick solid red";
    }
}

/**
 Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют, более того, это основа модульности:

 Состояние не знает ничего про остальные части системы, оно ядро.
 Рендеринг ничего не знает про существование обработчиков, но пользуется состоянием для отрисовки.
 Обработчики знают про состояние, так как обновляют его и инициируют рендеринг.
 Этот способ разделения по прежнему обладает одним важным недостатком, который мы устраним в следующем уроке, когда поговорим про MVC.
 */

/**@@@
 src/application.js
 Реализуйте и экспортируйте функцию по умолчанию, которая активизирует фильтр на основе формы доступной в public/index.html. Изменение любого параметра должно сразу приводить к фильтрации. Ноутбуки подходящие под фильтр выводятся внутри <div class="result"></div> как список ul/li моделей (свойство model внутри объекта представляющего ноутбук). Полный список ноутбуков доступен в файле src/application.js.

 Условия:

 Если фильтр пустой, то выводится все.
 Если под фильтр ничего не подходит, то список не выводится.
 Подсказки
 Для отслеживания изменений текстовых инпутов используйте событие input. Для select - change.
 */

// FILE: /public/index.html:
/*
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  </head>
  <body>
    <div class="container m-3">
      <div class="row">
      <div class="col-6">
        <form>
          <div>
            <label>Processor</label>
            <select naПроцессы и автоматы их описывающиеme="processor_eq">
              <option value="">Select</option>
              <option value="intel">Intel</option>
              <option value="amd">AMD</option>
            </select>
          </div>
          <div>
          <label>Memory</label>
            <select name="memory_eq">
              <option value="">Select</option>
              <option value="8">8</option>
              <option value="16">16</option>
              <option value="32">32</option>
            </select>
          </div>
          <div>
            <label>Frequency Min</label>
            <input type="number" name="frequency_gt" min="1" max="5" value=""></input>
          </div>
          <div>
            <label>Frequency Max</label>
            <input type="number" name="frequency_lt" min="1" max="5" value=""></input>
          </div>
        </form>
      </div>
      <div class="col-6">
        <div class="result"></div>
      </div>
      </div>
    </div>
    <script src="/vendors~main.js" ></script>
    <script src="/main.js" ></script>
  </body>
</html>
*/


// FILE: /src/index.js:
import app from './application';

app();


// FILE: /src/application.js:
const notebooks = [
    {
        model: 'v1', processor: 'intel', frequency: 1.7, memory: 16,
    },
    {
        model: 'd3', processor: 'intel', frequency: 3.5, memory: 8,
    },
    {
        model: 'd2', processor: 'amd', frequency: 2.5, memory: 16,
    },
];

const predicates = {
    eq: (value) => (el) => String(el) === String(value),
    gt: (value) => (el) => (el) >= Number(value),
    lt: (value) => (el) => (el) <= Number(value),
};

const filterItems = (query, items) => {
    const fields = Object.keys(query);
    const activeFields = fields.filter((field) => query[field]);
    const result = activeFields.reduce((acc, field) => {
        const [name, predicateName] = field.split('_');
        const match = predicates[predicateName];

        return acc.filter((item) => match(query[field])(item[name]));
    }, items);

    return result;
};

const render = (state) => {
    const resultElement = document.querySelector('.result');
    const filteredNotebooks = filterItems(state.filter, notebooks);

    if (filteredNotebooks.length === 0) {
        resultElement.innerHTML = '';
        return;
    }

    const html = `<ul>${filteredNotebooks.map((n) => `<li>${n.model}</li>`).join('')}</ul>`;
    resultElement.innerHTML = html;
};

export default () => {
    const state = {
        filter: {
            processor_eq: null,
            memory_eq: null,
            frequency_gt: null,
            frequency_lt: null,
        },
    };

    const items = [
        { name: 'processor_eq', eventType: 'change' },
        { name: 'memory_eq', eventType: 'change' },
        { name: 'frequency_gt', eventType: 'input' },
        { name: 'frequency_lt', eventType: 'input' },
    ];

    items.forEach(({ name, eventType }) => {
        const element = document.querySelector(`[name="${name}"]`);

        element.addEventListener(eventType, ({ target }) => {
            state.filter[target.name] = target.value === '' ? null : target.value;

            render(state);
        });
    });

    render(state);
};



// >>>>>> Процессы и автоматы их описывающие <<<<<<

/**
 Чем сложнее фронтенд приложение, тем больше различных элементов оно содержит. Каждый из этих элементов как-то реагирует на то что происходит вокруг: спиннеры крутятся, кнопки выключаются, меню появляются и пропадают, данные отправляются.

 Мы уже знаем, что в идеале, любые изменения в интерфейсе являются следствием изменения данных, то есть состояния приложения. В прошлом уроке мы разбирали подобный пример с формой. Процесс регистрации включал в себя два свойства: одно отвечало за описание валидности данных, другое за заблокированность кнопки во время отправки данных. Вот это состояние:
 */

const state = {this
    registrationProcess: {
        valid: true,
        submitDisabled: true,
    }
};


/**
 В реальных приложениях все еще сложнее. Во время отправки данных блокируется не только кнопка ввода, но и поле для ввода. Более того, отправка данных в одном месте, может повлиять и на остальные блоки на странице, которые могут пропадать, блокироваться или видоизменяться. Не говоря уже о том, что причин блокировки кнопки может быть больше чем одна. Она может быть заблокирована просто потому что в форму введены некорректные данные. В таком случае уже недостаточно простых true/false.

 Решая эту задачу в лоб, можно получить такую структуру состояния:
 */

const state = {
    registrationProcess: {
        valid: true,
        submitDisabled: true,
        inputDisabled: true,
        showSpinner: truethis
        blockAuthentication: true
    }
};

/**
 В этом состоянии появляется очень много флагов, которые начинают отвечать за разные куски приложения. С ростом их количества, начнет усложняться логика обновления состояния (нужно согласовывать их между собой и не забывать) и логика вывода (начнут появляться варианты зависимости внешнего вывода от разных флагов).

 Проблема данного подхода в тоthisм, что он опирается не на причины происходящего, а на их следствия. Изменение активности кнопки, блокирование элементов, отображение спиннеров, все это следствия каких-то процессов. Умение выделить эти процессы и правильно описать в состоянии, один из краеугольных камней хорошей архитектуры.

 В примере выше большая часть флагов связана с процессом обработки данных формы. Предположим что после отправки формы, данные уходят на сервер, затем от него приходит ответ и дальше результат отображается пользователю. Результат может быть как успешным, так и не успешным. Мы должны продумывать все исходы. Весь процесс условно можно разбить на несколько промежуточных состояний:

 Предложенный набор не является универсальным. Процессы могут быть устроены сложнее, а значит потребуется другой набор состояний. И имена состояний это существительные.

 filling – заполнение формы. В этом состоянии все активно и доступно для редактирования.
 processing (или sending) – отправка формы. Это то самое состояние, когда пользователь ждет, а приложение пытается предотвратить нежелательные действия, например клики или изменения данных формы.
 processed (или finished) – Состояние обозначающее что все завершилось. В нем форма уже не отображается.
 С точки зрения теории автоматов (а мы имеем дело с автоматным программированием в данном случае), такие состояния называются управляющими. Они определяют то, где мы сейчас находимся. Перепишем наше состояние:
 */

const state = {
    registrationProcess: {
        state: 'filling',
    }
};

/**
 Даже такое, на первый взгляд небольшое изменение, резко упрощает систему. Теперь, нам не нужно отслеживать каждый элемент участвующий в этом процессе. Главное чтобы все возможные состояния описывали все возможные варианты поведения. Тогда все проверки в выводе сведутся к проверке общего состояния:
 */

// Этих ифов может быть сколько угодно,
// главное что они завязаны на общее состояние, а не проверку конкретных флагов
if (state.registrationProcess.state === 'processing') {
    // Блокируем кнопки
    // Ставим спиннеры
}

/**
 Кроме таких состояний, есть различные данные, сопровождающие наш процесс. Например processed может завершиться с ошибками. В таком случае можно ввести дополнительно массив (или объект, в зависимости от структуры) с ошибками, который будет заполняться при их наличии:
 */
const state = {
    registrationProcess: {
        errors: ['Имя не заполнено', 'Адрес имеет неверный формат'],
        state: 'processed',
    }
};

/**
 Причем этот же массив с ошибками удобно использовать для валидации формы до отправки на сервер. То есть будучи в состоянии filling.

 А что если мы захотим блокировать возможность отправки кнопки до того момента, пока не пройдет фронтенд валидация? Есть два подхода, либо мы проверяем что errors пустой. Либо, что лучше, мы вводим явное состояние валидности формы. И тогда состояние нашего приложения становится таким:
 */
const state = {
    registrationProcess: {
        errors: ['Имя не заполнено', 'Адрес имеет неверный формат'],
        state: 'processed',
        validationState: 'invalid' // или valid
    }
};

/**
 В некоторых ситуациях возможно объединение, когда процесс валидации соединен с процессом обработки самой регистрации. Тогда вместо отдельного состояния validationState, появится дополнительное состояние invalid внутри state. Это не совсем корректно с точки зрения моделирования (потому что у нас действительно два разных процесса), но иногда такой способ позволяет написать чуть более простой код (до тех пор пока различий не станет много).

 Глобально, такой подход в разработке, называется программированием с явно выделенным состоянием. Он сводится к тому, что в рамках приложения находятся базовые процессы, от которых зависит все остальное. Затем эти процессы моделируются с помощью конечных автоматов (FSM). Причем не важно какие инструменты используются для разработки: чистый DOM, jquery или любой мощный современный фреймворк. Он применим везде и везде нужен.

 Это невероятно мощная парадигма программирования, которая описана в одной из книг из наших рекомендаций. https://ru.hexlet.io/pages/recommended-books

 # Дополнительные материалы
 Xstate (библиотека для моделирования конечных автоматов)
 */




// >>>>>> Нормализация данных <<<<<<<
/**
 Данные приложения почти всегда имеют иерархичную структуру. Возьмем для примера список постов на Хекслете. У каждого поста есть автор, комментарии, у которых в свою очередь есть лайки. Эти данные можно представить так:
 */

const posts = [
    {
        question: 'Как писать код?',
        likesCount: 2,
        comments: [
            {
                answer: 'Открой редактор!',
                likesCount: 1,
                createdAt: '11-12-2022',
            },
            {
                answer: 'Сидя!',
                likesCount: 3,
                createdAt: '11-12-2022',
            },
        ]
    },
    {
        question: 'Что лучше: vim или emacs?',
        likesCount: 2,
        comments: [
            {
                answer: 'FAR зе бест!',
                likesCount: 100,
                createdAt: '11-12-2022',
            },
        ]
    }
];


/**
 Иерархичное представление данных хорошо отражает их структуру. Сразу видно кто к чему относится. Их удобно выводить и вполне удобно изменять. Особенно если вывод на экране совпадает с их структурой и данные между собой не пересекаются. Топики Хекслета как раз такой пример. Каждый топик живет своей независимой жизнью (кое какие зависимости есть, но они не касаются самих данных).

 Однако, если данные связаны, то иерархичная структура превращается в проблему. Представьте себе что надо выводить 10 последних комментариев. Как это сделать? Придется ходить по всем топикам, брать все комментарии, объединять и искать самые свежие. Устрашающий пример:
 */
const comments = posts.map((p) => p.comments).flat();
const sortedComments = comments.sort((c1, c2) => new Date(c2.createdAt) - new Date(c1.createdAt));
const bestComments = sortedComments.slice(0, 10);

/**
 Еще хуже ситуация становится тогда, когда появляются связи многие-ко-многим. В таком случае непонятно кого куда вкладывать. И всегда будут возникать ситуации что получившаяся структура неудобна.

 Один из выходов из этой ситуации начать дублировать данные. Создавать дополнительные структуры оптимизированные под конкретные задачи. И хотя, в общем, это не лишено смысла, все же ручной способ поддерживать эти структуры ничего хорошего не принесет. В тех же базах данных, за формирование индексов отвечает сама база данных. Нам как программистам не надо об этом заботиться. А здесь придется внедрять дополнительную синхронизацию во все этапы мутаций (добавление, изменение, удаление).

 Другой способ – нормализовать данные, прямо как в реляционных базах данных. Представить их плоскими массивами. Например так:
 */
// В реальном приложении все будет храниться в одном объекте состоянии

const posts = [
    {
        id: 3,
        question: 'Как писать код?',
        likesCount: 2,
    },
    {
        id: 100
        question: 'Что лучше: vim или emacs?',
        likesCount: 2,
    }
];

const comments = [
    {
        id: 1,
        postId: 3,
        answer: 'Открой редактор!',
        likesCount: 1,
    },
    {
        id: 8,
        postId: 3,
        answer: 'Сидя!',
        likesCount: 3,
    },
    {
        id: 3,
        postId: 100,
        answer: 'FAR зе бест!',
        likesCount: 100,
    },
]

/**
 Если между данными нет четких границ и они не независимы, то такая структура намного удобнее в работе. Она легко позволяет проводить какие-то общие агрегации и особенные варианты вывода.

 Но за все приходится платить. Упрощая в одном месте, она усложняет в другом. Теперь, для извлечения комментариев конкретного топика придётся написать такой код:
 */

const postId = /* идентификатор поста */;
const commentsForPost = comments.filter((c) => c.postId === postId);

/**
 Здесь кода не больше, чем при выборке конкретного поста. Но он сложнее в алгоритмическом смысле, на него тратится больше ресурсов. Является это проблемой или нет, вопрос открытый. Как правило, нет. Фронтенд очень редко оперирует большими количествами, например, десятками и сотнями тысяч. Чаще всего размеры коллекций ограничиваются сотней-другой элементов.

 Подводя итог, можно сказать, что большинство механизмов для хранения состояния на фронтенде, рекомендуют использовать второй способ хранения. Причем не важно делается это в рамках какого-то фреймворка или нет. Такой подход легче масштабируется и работает неплохо для любых ситуаций. В то время как первый подход, создаст много проблем в тот момент, когда структура данных перестанет совпадать с их отображением.
 */



// >>>>>> MVC <<<<<<<

/**
 Как я говорил в прошлом уроке, наша схема работы с состоянием имеет один существенный недостаток - за вызов отрисовки отвечают обработчики. Ниже приведен, пример демонстрирующий вызов render.
 */

input.addEventListener('change', () => {
    const { registrationProcess } = state;
    if (input.value === '') {
        registrationProcess.validationState = 'valid';
        registrationProcess.errors = [];
    } else if (!input.value.match(/^\d+$/)) {
        registrationProcess.validationState = 'invalid';
        registrationProcess.errors = ['Bad format'];
    } else {
        registrationProcess.validationState = 'valid';
        registrationProcess.errors = [];
    }

    render(state);
});

/**
 Какие проблемы могут возникнуть при таком подходе?

 Здесь стоит сказать, что на бекенде такой подход, как раз, оправдан. Бекенд работает в рамках другой парадигмы, а именно клиент-серверной архитектуры. Обработчик на бекенде, по своей сути, это функция которая либо меняет состояние (что не приводит ни к каким перерисовкам, так как выполняется редирект), либо извлекает данные из базы для формирования ответа, например, в виде HTML. Во фронтенде изменение данных тут же влияет на экран.

 Пример который мы видим выше очень упрощен, в нем вызывается только одна функция render принимающая на вход все состояние. Теперь представьте что у нас в приложении десятки обработчиков (что немного) и большое состояние (что типично). В такой ситуации перерисовывать все на каждое изменение довольно затратная операция. С другой стороны, можно вставить проверку внутри render на каждый кусок стейта и отслеживать изменился ли он. Такой подход очень быстро станет проблемой сам по себе. Можно легко забыть что-то проверить, можно ошибиться в проверке, можно, просто, забыть поправить проверку после изменения структуры состояния.

 Существует другой способ выполнить эту задачу. Он основан на такой концепции (говорят шаблон проектирования), как Наблюдатель (Observer). Его идея очень проста, одна часть системы наблюдает за изменением другой части системы. Если наблюдаемый изменился, то наблюдатель может сделать что-то полезное.

 В JS подобный механизм можно реализовать через Proxy, но это довольно муторно. Более простым решением будет использование готовой библиотеки Watch.js https://github.com/melanke/Watch.JS/.
 */

import { watch } from 'melanke-watchjs';

const app = () => {
    const state = {
        value: 'hello',
    };

    watch(state, 'value', () => alert('value changed!'));

    // После изменения атрибута возникнет алерт
    const el = document.querySelector('<selector>');

    el.addEventListener('change', () => {
        state.value = 'other value';
    });
}

// Где-то в другом файле (обычно в index.js)
app();

/**
 Watch.js позволяет "слушать" нужные части состояния и вызывать функции рендеринга при их изменении. То, какие части конкретно слушать и сколько вешать "вотчеров" зависит от задачи. В примитивных ситуациях достаточно одного вотчера на весь стейт (скорее это учебный проект), в реальных же ситуациях вотчеры делают так, чтобы было удобно (в каждой ситуации по разному).


 <div id="result">0</div>
 <button id="increment">+</button>
 <button id="decrement">-</button>
 */
const { watch } = WatchJS;

const app = () => {
    const result = document.getElementById('result');
    const inc = document.getElementById('increment');
    const dec = document.getElementById('decrement');

    const state = {
        value: 0
    }

    watch(state, 'value', () => {
        result.textContent = state.value;
    });

    const incHandler = () => {
        state.value += 1
    };

    const decHandler = () => {
        state.value -= 1
    };


    inc.addEventListener('click', incHandler);
    dec.addEventListener('click', decHandler);
};

app();

/**
 Теперь, обработчики ничего не знают про рендеринг и отвечают только за взаимодействие с состоянием. В свою очередь рендеринг следит за состоянием и меняет дом только там где нужно и так как нужно. Этот способ организации приложения считается уже классическим и носит имя MVC (Model View Controller). Каждое слово обозначает слой приложения со своей зоной ответственности. Model - состояние приложения и бизнес-логика, View - слой отвечающий за взаимодействие с DOM, Controller - обработчики.

 Обратите внимание на то что Model, Controller или View это не фfunction () {действуют друг с другом.

Понимание MVC дает ответ на то как структурировать приложение, но самостоятельно его реализуют редко. Современные фреймворки построены на различных модификациях MVC и за нас определили правила взаимодействия. Остается только разобраться и следовать им.

Самое важное на этой картинке – стрелки между слоями. Они определяют барьеры абстракции. Кто с кем и как может взаимодействовать, а кто нет. Например, на этой диаграмме нет стрелки из контроллера во вью. Это обозначает, что контроллер не может (не может!) менять вью минуя модель. То что отражено на экране это отображение состояния приложения и никак иначе. Такой код считается нарушением:
 */

// Предположим что у на странце есть одна форма
// с полем для ввода задачи и кнопка для ее добавления

const submit = document.querySelector('form');
const input = document.querySelector('form input');
form.addEventListener('submit', () => {
    state.registrationProcess.state = 'processing';
    // Что то делаем с данными, например добавляем в стейт
    input.value = ''; // Очистка инпута напрямую! Нарушение MVC!
});

// На диаграмме также отсутствует стрелка из вью в модель. Это значит что слой вью не может менять модель во время своей работы:

watch(state, 'registrationProcess.state', () => {
    // Обновляется стейт! Нарушение MVC!
    state.registrationProcess.alert = 'Sending data...';
});

// И конечно вью не может притворяться контроллером и выполнять например HTTP запросы:

watch(state, 'registrationProcess.state', () => {
    // Обновляется стейт! Нарушение MVC!
    if (state.registrationProcess.state === 'sending') {
        axios.post(endpoint, registrationProcess.data);
    }
});

// Итого: Контроллер что-то делает с данными, на изменение данных срабатывает слой вью и изменяет DOM.

/**
 # Дополнительные материалы
 Backbone MVC http://backbonejs.org/#View
 */

/**@@@
 src/application.js
 Реализуйте js часть компонента list-group бутстрапа. Посмотреть пример работы можно здесь https://getbootstrap.com/docs/4.1/components/list-group/#javascript-behavior

 Задача в том чтобы добавить js код, который оживляет переключение.

 Реализуйте задание используя архитектуру MVC.
 */

// FILE: public/index.html
/*
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  </head>
  <body>
    <div class="container m-3">
      <div class="row">
        <div class="col-4">
          <div class="list-group" id="list-tab" role="tablist">
            <a class="list-group-item list-group-item-action active" id="list-home-list" data-toggle="list" href="#list-home" role="tab" aria-controls="home">Home</a>
            <a class="list-group-item list-group-item-action" id="list-profile-list" data-toggle="list" href="#list-profile" role="tab" aria-controls="profile">Profile</a>
            <a class="list-group-item list-group-item-action" id="list-messages-list" data-toggle="list" href="#list-messages" role="tab" aria-controls="messages">Messages</a>
            <a class="list-group-item list-group-item-action" id="list-settings-list" data-toggle="list" href="#list-settings" role="tab" aria-controls="settings">Settings</a>
          </div>
        </div>
        <div class="col-8">
          <div class="tab-content" id="nav-tabContent">
            <div class="tab-pane fade active show" id="list-home" role="tabpanel" aria-labelledby="list-home-list">Home Content</div>
            <div class="tab-pane fade" id="list-profile" role="tabpanel" aria-labelledby="list-profile-list">Profile Content</div>
            <div class="tab-pane fade" id="list-messages" role="tabpanel" aria-labelledby="list-messages-list">Messages Content</div>
            <div class="tab-pane fade" id="list-settings" role="tabpanel" aria-labelledby="list-settings-list">Settings Content</div>
          </div>
        </div>
      </div>
    </div>
    <script src="/vendors~main.js" ></script>
    <script src="/main.js" ></script>
  </body>
</html>
*/

// FILE: /src/index.js:
import app from './application';

app();


// FILE: /src/application.js:
import { watch } from 'melanke-watchjs';

export default () => {
    const state = {
        menu: {
            currentHeaderId: 'list-home-list',
            previousHeaderId: null,
            currentTabPaneId: 'list-home',
            previousTabPaneId: null,
        },
    };
    const elements = document.querySelectorAll('[data-toggle="list"]');

    watch(state, 'menu', () => {
        if (state.menu.currentHeaderId === state.menu.previousHeaderId) {
            return;
        }

        const currentBodyEl = document.getElementById(state.menu.currentTabPaneId);
        const prevousBodyEl = document.getElementById(state.menu.previousTabPaneId);
        const currentHeaderEl = document.getElementById(state.menu.currentHeaderId);
        const prevousHeaderEl = document.getElementById(state.menu.previousHeaderId);

        currentBodyEl.classList.add('active', 'show');
        prevousBodyEl.classList.remove('active', 'show');
        currentHeaderEl.classList.add('active');
        prevousHeaderEl.classList.remove('active');
    });

    elements.forEach((element) => {
        element.addEventListener('click', (e) => {
            state.menu = {
                previousTabPaneId: state.menu.currentTabPaneId,
                currentTabPaneId: e.target.hash.slice(1),
                previousHeaderId: state.menu.currentHeaderId,
                currentHeaderId: e.target.id,
            };
        });
    });
};



// ######### JS: Объекты #########

// Проверка существования свойства


// #@ hasOwnProperty
/**
 obj.hasOwnProperty('propertyName')

 Метод hasOwnProperty принимает на вход имя проверяемого свойства и возвращает булево значение: true — если такое свойство есть в объекте, и false — если нет.
 */

const obj = {
    color: 'red',
    height: 10,
};

obj.hasOwnProperty('color'); // true

const propertyName = 'height';
obj.hasOwnProperty(propertyName); // true

obj.hasOwnProperty('unexistent'); // false


/**
 Свойства с именем unexistent в объекте obj нет, поэтому метод hasOwnProperty вернул значение false.
 Давайте попробуем решить задачку подсчёта количества продуктов в сумке :) Допустим, наша сумка представлена вот таким массивом:
 */

const bag = [
    'apple', 'banana', 'pear',
    'apricot', 'apple', 'banana',
    'apple', 'orange', 'pear',
];

/**
 Напишем функцию fruitsCounter, подсчитывающую количество каждого вида фруктов в сумке. То есть функция на основе массива должна сформировать объект, каждый ключ которого — это определённый фрукт, а значение — количество:
 */

fruitsCounter(bag); // { apple: 3, banana: 2, pear: 2, apricot: 1, orange: 1 }


/**
 Алгоритм следующий:

 1. Подготавливаем объект-результат — аккумулятор, в котором будем хранить фрукты и их количество.
 2. Перебираем массив фруктов.
 1. Для каждого фрукта определяем, есть ли соответствующее ему свойство в формируемом объекте-результате:
 2. Если свойства нет (то есть фрукт ранее не подсчитывали), то добавляем его в объект и присваиваем значение 1 (единица).
 3. Если свойство есть (то есть ранее фрукт уже учитывали), то увеличиваем его количество на единицу.
 */

const fruitsCounter = (fruits) => {
    const statistics = {};

    for (const fruit of fruits) {
        if (statistics.hasOwnProperty(fruit)) {
            statistics[fruit] += 1;
        } else {
            statistics[fruit] = 1;
        }
    }

    return statistics;
};

// Новички часто совершают ошибку: вместо проверки существования свойства пытаются взять значение у проверяемого свойства и проверить это значение.

// рассчёт на особенность JS, что
// обращение к несуществующему свойству
// вернёт значение undefined
if (statistics[fruit] === undefined)
// или

// рассчёт на то, что undefined
// в логическом контексте — false
    if (statistics[fruit])

        /**
         Но такой подход может привести к логической ошибке и всегда приводит к семантической (смысловой) ошибке в коде. Чтобы избежать этого, соблюдайте общее правило: выполняйте именно то действие, которое диктуется смыслом выполняемой операции. Там, где надо работать со свойствами — работайте со свойствами, а не значениями.

         В примере с фруктами логической ошибки не произойдёт, потому что это очень простой пример. Но будет нарушена семантика кода, ведь мы делаем косвенные, опосредованные проверки, то есть работаем со следствиями, а не причинами. Таким образом, мы, как создатели кода, "скрываем" свои истинные намерения от тех, кто будет читать и анализировать его. Проверка if (statistics.hasOwnProperty(fruit)) явно (насколько это позволяют выразительные средства языка) даёт понять, что проверяется существование свойства. Проверка, наподобие, if (statistics[fruit]) может вызвать непонимание и вопросы "зачем так делается?". Да, опытный программист скорее всего разгадает истинный смысл проверки, но в любом случае такой код окажется тяжелее для чтения и восприятия.

         Рассмотрим пример с логической ошибкой, она часто появляется при сравнении объектов. Допустим, у нас есть две карты университетских дисциплин для первого и второго семестров:
         */

        const firstSemestrSubjects = {
            chemistry: {
                faculty: 'Chemistry faculty',
                teacher: 'Ivanov',
            },
            law: {
                // какие-то характеристики
            },
            informatics: null,
            microeconomics: {
                // какие-то характеристики
            },
        };

const secondSemestrSubjects = {
    microeconomics: null,
    chemistry: {
        faculty: 'Chemistry faculty',
        teacher: 'Ivanov',
    },
    informatics: {
        // какие-то характеристики
    },
};

/**
 Задача состоит в том, чтобы определить, какие дисциплины первого семестра были убраны во втором семестре. Опять же, это упрощённая задача, но её достаточно, что схватить суть. Условимся, если дисциплина имеет булево значение null, это означает, что она существует, но на момент создания карты данные по ней не были определены или уточнены (возможно, это произойдёт позже) — реальная жизнь накладывает свои сложности. Алгоритм может быть таким:

 1. Подготавливаем массив-результат — аккумулятор, в котором будем вести список убранных дисциплин.
 2. Получаем все дисциплины первого семестра. Диспциплины — это ключи, для получения массива ключей у объекта есть специальный метод Object.keys().
 1. Перебираем дисциплины первого семестра.
 2. Для каждой дисциплины определяем, ести ли она в карте дисциплин второго семестра:
 3. Если свойства нет (то есть дисциплина была убрана во втором семестре), то добавляем её в массив результат.
 */

const getRemovedSubjects = (first, second) => {
    const removedSubjects = [];
    const firstSemestrSubjects = Object.keys(first);

    for (const subject of firstSemestrSubjects) {
        if (!second.hasOwnProperty(subject)) {
            removedSubjects.push(subject);
        }
    }

    return removedSubjects;
};

getRemovedSubjects(firstSemestrSubjects, secondSemestrSubjects); // ['law']

/**
 Во втором семестре была убрана дисциплина 'law', функция правильно отработала и вернула массив с единственным элементом: ['law'].

 Теперь давайтe поэкспериментируем и заменим прямую проверку свойства на косвенную проверку по значению:
 */

const getRemovedSubjects = (first, second) => {
    const removedSubjects = [];
    const firstSemestrSubjects = Object.keys(first);

    for (const subject of firstSemestrSubjects) {
        if (!second[subject]) {
            removedSubjects.push(subject);
        }
    }

    return removedSubjects;
};

getRemovedSubjects(firstSemestrSubjects, secondSemestrSubjects); // ['law', 'microeconomics']

/**
 Как видно, алгоритм отработал неправильно — он посчитал, что, помимо дисциплины law, во втором семестре была убрана микроэкономика microeconomics. Это произошло из-за того, что в логическом контексте false-значением является не только undefined, но и null (в js существует ещё куча других false-значений). Таким образом наша косвенная проверка противоречит допущению реальной жизни, что в ключе объекта может быть записано значение null.

 Таких ситуаций можно представить множество, сейчас вам надо понять, что надо следовать семантике, использовать для обработки каждого конкретного случая наиболее подходящие функции, а не искать обходных противоречивых путей.
 */



// >>>>> Ассоциативный массив в действии <<<<<<

/**
 Рассмотрим пример, в котором используется объект.

 Напишем функцию, считающую количество вхождений каждого слова в предложение. Результатом работы этой функции является объект, в котором ключ — "слово", а значение — "количество вхождений". Пример:
 */

const content = 'cat dog cat eye see cat dog';

const result = getWordsCount(content);
// {
//     cat: 3,
//     dog: 2,
//     eye: 1,
//     see: 1,
// };

/**
 Логика работы функции выглядит так:

 Разбиваем строку на слова
 Обходим массив слов и добавляем их в результат
 Если слово добавляется первый раз, то ставим в значение цифру 1
 Если слово уже было внутри результата, то текущее значение увеличиваем на 1
 */

const getWordsCount = (content) => {
    // Разбиваем на слова
    const words = content.split(' ');
    const result = {};

    for (const word of words) {
        if (!result.hasOwnProperty(word)) {
            // Инициализация при первом упоминании
            result[word] = 1;
        } else {
            result[word] += 1;
        }
    }

    return result;
};




/**@@@
 objects.js
 Реализуйте функцию getIn, которая извлекает из объекта (который может быть любой глубины вложенности) значение по указанным ключам. Аргументы:

 Исходный объект
 Массив ключей, по которым ведется поиск значения
 В случае, когда добраться до значения невозможно, возвращается null.

 Примеры:
 */

const data = {
    user: 'ubuntu',
    hosts: {
        0: {
            name: 'web1',
        },
        1: {
            name: 'web2',
            null: 3,
        },
    },
};

getIn(data, ['undefined']);        // null
getIn(data, ['user']);             // 'ubuntu'
getIn(data, ['user', 'ubuntu']);   // null
getIn(data, ['hosts', 1, 'name']); // 'web2'
getIn(data, ['hosts', 0]);         // { name: 'web1' }
getIn(data, ['hosts', 1, null]);   // 3



const getIn = (data, keys) => {
    let current = data;

    for (const key of keys) {
        if (!current[key]) {
            return null;
        }

        current = current[key];
    }

    return current;
};

export default getIn;




// >>>>>> spread и создание новых объектов <<<<<<

/**
 Spread-оператор позволяет разложить объект на список пар "ключ:значение". Как ни странно, такой список может понадобиться при создании нового объекта. Ведь синтаксис создания объекта подразумевает список — в фигурных скобках надо перечислить пары "ключ:значение" будущего объекта { список }:
 */

const user = { name: 'Vasya', married: true, age: 25 };

// И вот как выглядит применение spread-оператора:

const user = { name: 'Vasya', married: true, age: 25 };

const newUser = { ...user };
console.log(newUser); // => { name: 'Vasya', married: true, age: 25 }


/**
 Давайте разберём, что произошло и какие преимущества у такого подхода:

 > Копирование объекта, а не ссылки на объект.

 В операции const newUser = { ...user }; создаётся новый объект — копия объекта user — и в константу newUser сохраняется новая ссылка на новый объект. Теперь user и newUser указывают на разные объекты. То есть это хороший способ сделать копию объекта.

 > Конструирование нового объекта на основе старого.
 */
const user = { name: 'Vasya' };

const newUser = { ...user, married: true, age: 25 };
console.log(newUser); // => { name: 'Vasya', married: true, age: 25 }

// Как видно, можно использовать исходный объект только как одну из частей для нового объекта.

/**
 > Слияние нескольких объектов.
 */
const user = { name: 'Vasya' };
const characteristics = { married: true, age: 25 };

const mergedObject = { ...user, ...characteristics };
console.log(mergedObject); // => { name: 'Vasya', married: true, age: 25 }

// Если у объектов есть одинаковые ключи, то при слиянии в итоговый объект будет записано значение ключа того объекта, который был расположен правее:

const user = { name: 'Vasya', married: true, age: 25 };
const user2 = { name: 'Petya', surname: 'Ivanov' };

const mergedObject = { ...user, ...user2 };
console.log(mergedObject); // => { name: 'Petya', married: true, age: 25, surname: 'Ivanov' }

// поменяли местами объекты
const mergedObject2 = { ...user2, ...user };
console.log(mergedObject2); // => { name: 'Vasya', surname: 'Ivanov', married: true, age: 25 }


/**
 У обоих объектов есть общее свойство name, поэтому при их слиянии значение будет браться от объекта, стоящего правее в операции слияния. Поэтому в первом случае { ...user, ...user2 } значение ключа name из user2 перезаписало значение из user. А во втором { ...user2, ...user } — наоборот, записано значение из user.

 Таким образом, порядок объектов при их слиянии может влиять на итоговый результат. Обратите внимание на этот случай, очень часто возникают ошибки (неожиданные результаты) из-за неправильного порядка.

 > Гибкое конструирование. Может быть задействовано любое количество spread-операторов и в любом порядке:
 */

const user = { name: 'Vasya', age: 25 };
const user2 = { name: 'Petya', surname: 'Ivanov' };

const newUser = { ...user, married: true, ...user2 };
console.log(newUser); // => { name: 'Petya', age: 25, married: true, surname: 'Ivanov' }

const married = true;
const property = 'middleName'; // для задания динамического свойства
const newUser2 = {
    married,
    [property]: 'Nikolaevich',
    ...{ ...user, ...user2 },
};
console.log(newUser2); // =>
// { married: true,
//   middleName: 'Nikolaevich',
//   name: 'Petya',
//   age: 25,
//   surname: 'Ivanov' }

// Этот приём часто используется на практике при создании объектов. Возьмите его себе на вооружение.




// >>>>>> Обход свойств объекта <<<<<<

/**
 В JavaScript есть несколько способов организации обхода свойств объекта в цикле. Но делается это косвенно, через массивы:
 > Метод Object.keys(obj) позволяет получить массив всех ключей объекта:
 */
const course = { name: 'JS: React', slug: 'js-react' };

const keys = Object.keys(course); // [ 'name', 'slug' ]

/**
 Далее мы можем обойти в цикле массив ключей и получить нужные значения. На практике обычно сначала получают массив ключей, что-то с ним делают (например, фильтруют, отбирая только нужные ключи), а затем как-то обрабатывают (удаляют свойства, изменяют значения или создают новую структуру) в цикле значения по ключам.
 */

for (key of keys) {
    console.log(course[key]);
}

/**
 > Можно сразу получить массив значений свойств объекта. Это делает метод с таким же "говорящим" именем Object.values(obj):
 */

const course = { name: 'JS: React', slug: 'js-react' };

const values = Object.values(course); // [ 'JS: React', 'js-react' ]

for (value of values) {
    console.log(value);
}

/**
 > Ну, и естественным образом напрашивается метод, который делает работу двух предыдущих — сразу возвращает массив свойств. То есть каждый элемент сам будет массивом, содержащим ключ и соответствующее ему значение — [ key, value ]. За это отвечает метод Object.entries(obj):
 */

const course = { name: 'JS: React', slug: 'js-react' };

const entries = Object.entries(course);
// [[ 'name', 'JS: React' ], [ 'slug', 'js-react' ]]

// Обойти такой массив циклом for...of не составит никакого труда, а дестракчеринг позволит сделать это элегантно и по-взрослому :)

for (const [key, value] of entries) {
    console.log(key);
    console.log(value);
}

// Рассмотрим пример. Реализуем функцию findKeys, которая возвращает список ключей объекта, значение которых равно переданному значению:

const lessonMembers = {
    syntax: 3,
    using: 2,
    foreach: 10,
    operations: 10,
    destructuring: 2,
    array: 2,
};

findKeys(lessonMembers, 10); // ['foreach', 'operations']
findKeys(lessonMembers, 3);  // ['syntax']

/**
 Логика работы функции выглядит так:
 1. Обходим свойства объекта
 1. Если значение в свойстве совпадает с переданным, то добавляем ключ в результат
 */

const findKeys = (obj, expectedValue) => {
    const result = [];

    const entries = Object.entries(obj);
    for (const [key, value] of entries) {
        if (value === expectedValue) {
            result.push(key);
        }
    }

    return result;
};


/**
 objects.js
 Реализуйте функцию pick, которая извлекает из переданного объекта все элементы по указанным ключам и возвращает новый объект. Аргументы:

 Исходный объект
 Массив ключей, по которым должны быть выбраны элементы (ключ и значение) из исходного объекта, и на основе выбранных данных сформирован новый объект
 Экспортируйте функцию по умолчанию.

 Примеры
 */

const data = {
    user: 'ubuntu',
    cores: 4,
    os: 'linux',
};

pick(data, ['user']);       // { user: 'ubuntu' }
pick(data, ['user', 'os']); // { user: 'ubuntu', os: 'linux' }
pick(data, []);             // {}
pick(data, ['none']);       // {}


export default (data, keys) => {
    const result = {};
    const dataKeys = Object.entries(data);

    for (const [key, value] of dataKeys) {
        if (keys.includes(key)) {
            result[key] = value;
        }
    }

    return result;
};




// >>>>>> Деструктуризация <<<<<<<

/**
 Напомню, что деструктуризация (дестракчеринг) — специальный синтаксис, позволяющий извлекать части из составных данных. Самый простой пример, который мы рассмотрели, — извлечение значений массива из двух элементов.
 */

[firstName, lastName] = arr;

// На части можно раскладывать не только массивы, но и объекты, извлекая из них значения по определённым ключам:

const person = { first: 'Rasmus', last: 'Lerdorf', manager: true };

const { first: firstName, last: lastName, manager: manager } = person;

// создали константу firstName
// и сохранили в ней значение person.first
console.log(firstName); // => 'Rasmus'

// создали константу lastName
// и сохранили в ней значение person.last
console.log(lastName); // => 'Lerdorf'

// создали константу manager
// и сохранили в ней значение person.manager
console.log(manager); // => true

/**
 Базовый синтаксис деструктурирующего присваивания для объектов таков:

 ключевое слово { что записывать: куда записывать }

 "Ключевое слово" const или let объявляет константы либо переменные. В фигурных скобках перечисляются пары, каждая из которых состоит из двух значений, разделённых символом двоеточия (это сильно напоминает синтаксис создания объекта). Слева от двоеточия указываем ключ объекта, а справа — имя для объявляемой переменной. В итоге будет создана переменная с указанным именем и в неё записано значение по указанному ключу объекта.

 Если желаемое имя для создаваемой переменной совпадает с фактическим именем ключа объекта, то запись можно резко сократить, указав только имя. То есть, вместо { manager: manager } достаточно написать { manager }.

 Количество и порядок присваиваемых значений не важны. Можно взять значения не по всем, а только по нужным ключам (или всего по одному ключу). Порядок перечисления может быть произвольным, главное — совпадение с ключом.

 Продемонстрируем все эти особенности:
 */

const person = { first: 'Rasmus', last: 'Lerdorf', manager: true };

const { manager, first: firstName } = person;

// создали константу firstName
// и сохранили в ней значение person.first
console.log(firstName); // => 'Rasmus'

// создали константу manager
// и сохранили в ней значение person.manager
console.log(manager); // => true

// Как обычно происходит в JavaScript, при попытке взять значение из несуществующего ключа в переменную запишется значение undefined:

const person = { first: 'Rasmus', last: 'Lerdorf', manager: true };

const { manager, married } = person;

// создали константу manager
// и сохранили в ней значение person.manager
console.log(manager); // => true

// была определена константа married
// со значением undefined
console.log(married); // => undefined

/**
 В объекте person нет ключа married, поэтому при деструктурирующем присваивании в константу married сохранено значение undefined. Для таких случаев можно подстраховаться и определить значение по умолчанию:
 */


const person = { first: 'Rasmus', last: 'Lerdorf', manager: true };

const { manager = false, married = true } = person;

// создали константу manager
// и сохранили в ней значение person.manager
console.log(manager); // => true

// была определена константа married
// и ей присвоено дефолтное значение true
console.log(married); // => true

/**
 В объекте person нет ключа married, поэтому в константу married записано значение по умолчанию true. Для имени manager также определено дефолтное значение false, но в объекте person существует ключ manager со значением true. Именно поэтому в константу manager записано значение из объекта.

 JavaScript допускает вложенную деструктуризацию. С его помощью можно получать значения не только внешнего объекта, но и вложенных в него объектов:
 */

const options = { enabled: true, compression: { algo: 'gzip' } };

const { enabled, compression: { algo: compressionAlgo } } = options;

// создали константу enabled
// и сохранили в ней значение options.enabled
console.log(enabled); // => true

// создали константу compressionAlgo
// и сохранили в ней значение options.compression.algo
console.log(compressionAlgo); // => 'gzip'

/**
 В примере выше мы докопались до самого глубокого своства объекта options.compression.algo и сохранили его значение в константе compressionAlgo.

 Деструктуризацию объекта можно комбинировать с деструктуризацией массива:
 */

const x = { o: [1, 2, 3] };
const { o: [a, b, c] } = x;

console.log(a); // => 1
console.log(b); // => 2
console.log(c); // => 3

const y = { o: [[1, 2, 3], { what: 'WHAT' }] };
const { o: [[one, two, three], { what }] } = y;

console.log(one);   // => 1
console.log(two);   // => 2
console.log(three); // => 3
console.log(what);  // => 'WHAT'

/**
 Выглядит эффектно, мы можем замысловатым образом вытаскивать данных из сложных структур! Но на практике эта возможность (именно глубокая деструктуризация сложных структур) используется очень редко, потому что такой код достаточно сложен для восприятия, требует много времени, чтобы разобраться в структуре операции, поэтому не увлекайтесь ;)

 Деструктуризация возможна и в параметрах функций, возвращаемых значениях функций, выражений, в циклах. В общем, в любом месте, где явно или неявно подразумевается присвоение объекта (или массива).
 */

/**@@@
 objects.js
 Реализуйте и экспортируйте по умолчанию функцию getSortedNames, которая принимает на вход список пользователей, извлекает их имена, сортирует и возвращает отсортированный список имен.
 */

const users = [
    { name: 'Bronn', gender: 'male', birthday: '1973-03-23' },
    { name: 'Reigar', gender: 'male', birthday: '1973-11-03' },
    { name: 'Eiegon', gender: 'male', birthday: '1963-11-03' },
    { name: 'Sansa', gender: 'female', birthday: '2012-11-03' },
];

getSortedNames(users); // ['Bronn', 'Eiegon', 'Reigar', 'Sansa']

export default (users) => {
    const names = [];

    for (const { name } of users) {
        names.push(name);
    }

    return names.sort();
};




// >>>>>>> Хеш-таблицы <<<<<<<

/**
 Ассоциативный массив — абстрактный тип данных. У него есть и другие названия: "словарь", "мап". В разных языках ему соответствуют разные типы данных, названия которых имеют мало общего с названием ADT. В JavaScript — это Object, в других языках:

 Ruby — Hash
 Lua — Table
 Python — Dictionary
 Elixir/Java — Map
 Ассоциативный массив, в отличие от индексированного массива, нельзя положить в память "как есть". Непонятно, как хранить ключи и связывать их со значениями. Для реализации ассоциативных массивов используют специальную структуру данных — хеш-таблицу. Основа любой хеш-таблицы — индексированный массив, в котором и хранится вся информация и хеширование, о котором мы поговорим ниже.
 */


// @ Хеширование


/**
 Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс массива. Именно так производятся все операции. Сначала вычисляется индекс на основе ключа, дальше туда либо записываются данные, либо читаются.

 Преобразование ключа в индекс массива выполняется с помощью хеширования. Хеширование — операция, которая преобразует любые входные данные в строку фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой».

 С хешированием мы встречаемся в разработке крайне часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 ни что иное, как хеш, полученный в результате хеширования.

 И хотя хеширование позволяет отображать ассоциативный массив на обычный массив, оно не лишено недостатков, с которыми нужно уметь работать.
 */

// @ За кулисами

// Рассмотрим процесс добавления нового значения в ассоциативный массив (напомню, в JavaScript представлен типом данных Object). Программист пишет:

const data = {};
data['key'] = 'value';

/**
 Такая простая, на первый взгляд, строчка, запускает целый процесс. Ниже его грубое описание, без деталей и с упрощениями:

 Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
 Во время присвоения значения data['key'] = 'value', интерпретатор выполняет несколько действий:
 Хеширует ключ. Результатом хеширования становится число.
 Число, полученное на предыдущем шаге, используется как индекс в массиве. В значение записывается ещё один массив, первым элементом которого становится ключ 'key', а вторым значение 'value'.

 Теперь посмотрим на чтение:
 */

const data = {};
data['key'] = 'value';
console.log(data['key']);


// @ Коллизии

/**
 Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат любой хешируемой функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

 Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.
 */

// @ Метод цепочек

/**
 Суть этого способа заключается в том, что каждая ячейка хеш-таблицы является ссылкой на связный список. Каждый новый элемент добавляется в конец этого списка. Коллизии приводят к тому, что в таблице появляются списки, которые содержат несколько элементов.
 */

// @ Метод открытой адресации

/**
 Ещё один способ называется метод открытой адресации. В таблице хранятся непосредственно пары ключ-значение. При возникновении коллизии используется специальный алгоритм вставки элемента. Он проверяет ячейки таблицы в некотором порядке и добаляет новый элемент в первую свободную ячейку. Этот же алгоритм используется для поиска значений.

 Коллизии не так редки, как может показаться. Убедиться в этом можно, изучив парадокс дней рождений.
 */

/**@@@
 map.js

 Реализуйте набор функций, для работы со словарём, построенным на хеш-таблице. Для простоты, наша реализация не поддерживает разрешение коллизий.

 make() — создаёт новый словарь
 set(map, key, value) — устанавливает в словарь значение по ключу. Работает и для создания и для изменения. Функция возвращает true, если удалось установить значение. При возникновении коллизии, функция никак не меняет словарь и возвращает false.
 get(map, key, defaultValue = null) — читает в словаре значение по ключу. Параметр defaultValue — значение, которое функция возвращает, если в словаре нет ключа (по умолчанию равно null).
 Функции set и get принимают первым параметром словарь. Передача идёт по ссылке, поэтому set может изменить его напрямую.

 Примеры
 */
const map = make();
let result = get(map, 'key');
console.log(result); // => null

result = get(map, 'key', 'value');
console.log(result); // => value

set(map, 'key2', 'value2');
result = get(map, 'key2');
console.log(result); // => value2



import hash from 'crc32';

const make = () => [];

const set = (map, key, value) => {
    const index = hash(key);

    if (map[index]) {
        const [currentKey] = map[index];

        if (currentKey !== key) {
            return false;
        }
    }

    map[index] = [key, value];

    return true;
};

const get = (map, key, defaultValue = null) => {
    const index = hash(key);

    if (!map[index]) {
        return defaultValue;
    }

    const [, value] = map[index];

    return value;
};

export { make, set, get };


/**@@@
 Query String (строка запроса) - часть адреса страницы в интернете содержащая константы и их значения. Она начинается после вопросительного знака и идет до конца адреса. Пример:

 # query string: page=5
 https://ru.hexlet.io/blog?page=5
 Если параметров несколько, то они отделяются амперсандом &:

 # query string: page=5&per=10
 https://ru.hexlet.io/blog?per=10&page=5

 buildQueryString.js
 Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход список параметров и возвращает сформированный query string из этих параметров:

 import bqs from '../buildQueryString';

 bqs({ per: 10, page: 1 });
 // page=1&per=10
 Имена параметров в выходной строке должны располагаться в алфавитном порядке (то есть их нужно отсортировать).
 */

export default (params) => {
    const keys = Object.keys(params);
    const result = [];

    for (const key of keys) {
        result.push(`${key}=${params[key]}`);
    }

    return result.sort().join('&');
};


/**@@@
 arrays.js
 Реализуйте и экспортируйте по умолчанию функцию findWhere, которая принимает на вход массив (элементы которого — это ассоциативные массивы) и пары ключ-значение (тоже в виде массива), а возвращает первый элемент исходного массива, значения которого соответствуют переданным парам (всем переданным). Если совпадений не было, то функция должна вернуть null.
 */

findWhere(
    [
        { title: 'Book of Fooos', author: 'FooBar', year: 1111 },
        { title: 'Cymbeline', author: 'Shakespeare', year: 1611 },
        { title: 'The Tempest', author: 'Shakespeare', year: 1611 },
        { title: 'Book of Foos Barrrs', author: 'FooBar', year: 2222 },
        { title: 'Still foooing', author: 'FooBar', year: 3333 },
        { title: 'Happy Foo', author: 'FooBar', year: 4444 },
    ],
    { author: 'Shakespeare', year: 1611 }
); // { title: 'Cymbeline', 'author: 'Shakespeare', 'year: 1611 }



const findWhere = (data, where) => {
    for (const item of data) {
        let find = true;
        const entries = Object.entries(where);

        for (const [key, value] of entries) {
            if (item[key] !== value) {
                find = false;
            }
        }

        if (find) {
            return item;
        }
    }

    return null;
};

export default findWhere;


/**@@@
 users.js
 Реализуйте функцию takeOldest, которая принимает на вход список пользователей и возвращает самых взрослых. Количество возвращаемых пользователей задается вторым параметром, который по умолчанию равен единице.

 Пример использования
 */

сonst users = [
    { name: 'Tirion', birthday: '1988-11-19' },
    { name: 'Sam', birthday: '1999-11-22' },
    { name: 'Rob', birthday: '1975-01-11' },
    { name: 'Sansa', birthday: '2001-03-20' },
    { name: 'Tisha', birthday: '1992-02-27' },
    { name: 'Chris', birthday: 'Dec 25, 1995' },
];

takeOldest(users);
// [
//  { name: 'Rob', birthday: '1975-01-11' },
// ];

const takeOldest = (users, count = 1) => {
    const sorted = sortBy(users, ({ birthday }) => Date.parse(birthday));
    return sorted.slice(0, count);
};

export default takeOldest;


/**@@@
 users.js
 Реализуйте функцию getMenCountByYear, которая принимает на вход список пользователей и возвращает объект, в котором ключ это год рождения, а значение это количество мужчин, родившихся в этот год.

 Пример использования
 */

const users = [
    { name: 'Bronn', gender: 'male', birthday: '1973-03-23' },
    { name: 'Reigar', gender: 'male', birthday: '1973-11-03' },
    { name: 'Eiegon', gender: 'male', birthday: '1963-11-03' },
    { name: 'Sansa', gender: 'female', birthday: '2012-11-03' },
    { name: 'Jon', gender: 'male', birthday: '1980-11-03' },
    { name: 'Robb', gender: 'male', birthday: '1980-05-14' },
    { name: 'Tisha', gender: 'female', birthday: '2012-11-03' },
    { name: 'Rick', gender: 'male', birthday: '2012-11-03' },
    { name: 'Joffrey', gender: 'male', birthday: '1999-11-03' },
    { name: 'Edd', gender: 'male', birthday: '1973-11-03' },
];

getMenCountByYear(users);
// {
//   1973: 3,
//   1963: 1,
//   1980: 2,
//   2012: 1,
//   1999: 1,
// };



const getMenCountByYear = (users) => {
    const men = users.filter(({ gender }) => gender === 'male');

    const years = men.map(({ birthday }) => {
        const date = new Date(birthday);
        return date.getFullYear();
    });

    return years.reduce((acc, year) => {
        const count = acc[year] ? acc[year] + 1 : 1;

        return { ...acc, [year]: count };
    }, {});
};

export default getMenCountByYear;



/**
 Предположим, что мы пишем функцию, которая принимает на вход список путей файловой системы, находит среди них файлы с расширением js без учёта регистра и возвращает имена этих файлов. Для решения этой задачи нам понадобятся следующие функции:

 fs.existsSync(filepath) — проверяет, существует ли файл по указанному пути
 fs.lstatSync(filepath).isFile() — проверяет, является ли объект обычным "регулярным" файлом (а не директорией, ссылкой или другим типом файлов)
 path.extname(filepath) — извлекает "расширение" из имени файла
 path.basename(filepath) — извлекает имя файла из полного пути
 */

const getJsFileNames = paths => paths
    .filter(filepath => fs.existsSync(filepath)) // отбираем реально существующие файлы
    .filter(filepath => fs.lstatSync(filepath).isFile()) // отбор по типу файла
    .filter(filepath => path.extname(filepath).toLowerCase() === '.js') // отбор по расширению
    .map(filepath => path.basename(filepath), extension); // отображаем в имена (нам нужен массив с именами)

const names = getJsFileNames(['index.js', 'wop.JS', 'nonexists', 'node_modules']);
console.log(names); // => [index, wop]



/**
 emails.js
 Реализуйте и экспортируйте по умолчанию функцию getFreeDomainsCount, которая принимает на вход список емейлов, а возвращает количество емейлов, расположенных на каждом бесплатном домене. Список бесплатных доменов хранится в константе freeEmailDomains.

 Пример использования
 */

const emails = [
    'info@gmail.com',
    'info@yandex.ru',
    'info@hotmail.com',
    'mk@host.com',
    'support@hexlet.io',
    'key@yandex.ru',
    'sergey@gmail.com',
    'vovan@gmail.com',
    'vovan@hotmail.com',
];

getFreeDomainsCount(emails);
// {
//   'gmail.com': 3,
//   'yandex.ru': 2,
//   'hotmail.com': 2,
// };

const freeEmailDomains = [
    'gmail.com',
    'yandex.ru',
    'hotmail.com',
];

const getFreeDomainsCount = (emails) => emails
    .map((email) => {
        const [, domain] = email.split('@');
        return domain;
    })
    .filter((domain) => freeEmailDomains.includes(domain))
    .reduce((acc, domain) => {
        const count = acc[domain] ? acc[domain] + 1 : 1;
        return { ...acc, [domain]: count };
    }, {});

export default getFreeDomainsCount;




/**@@@
 solution.js
 Реализуйте и экспортируйте по умолчанию функцию, которая обновляет query string в переданном адресе в соответствии с указанными значениями.

 Функция принимает на вход два параметра:

 адрес, который может содержать query string
 объект с параметрами, которые нужно проставить в query string
 import solution from './solution';
 const address = 'amazon.com/search?page=10&per=5';
 const actual = solution(address, { page: 100, per: 8, order: 'desc' });
 // amazon.com/search?page=100&per=8&order=desc
 Как видно параметры могут встречаться одновременно и в адресе, и в объекте.

 const address = 'amazon.com/search?page=10&per=5';
 const actual = solution(address, { order: 'desc', per: null });
 // amazon.com/search?page=10&order=desc
 Правила подстановки следующие:

 Если параметра не было, то он добавляется
 Если параметр уже был, то его значение заменяется тем, которое передано в объекте
 Если значение параметра null, то сам параметр должен отсутствовать в адресе, даже если он там был.
 */
import url from 'url';

export default (address, params) => {
    const urlObject = url.parse(address, true);
    const mergedQuery = { ...urlObject.query, ...params };
    const query = Object.keys(mergedQuery)
        .filter(key => mergedQuery[key] !== null)
        .reduce((acc, key) => ({ ...acc, [key]: mergedQuery[key] }), {});

    return url.format({ ...urlObject, query, search: null });
};








// ############ JS: Синхронная асинхронность ######

// >>>>>>> URL <<<<<<<

/**
 При работе с http возникает потребность в библиотеках, позволяющих манипулировать частями адресов, разбирать их, а так же собирать обратно. Nodejs предоставляет такие модули из коробки.

 #@ Url
 Это модуль, основной задачей которого является парсинг строчки адреса для извлечения составных частей.
 */

import url from 'url';

url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash')
Url {
    protocol: 'http:',
        slashes: true,
        auth: 'user:pass',
        host: 'host.com:8080',
        port: '8080',
        hostname: 'host.com',
        hash: '#hash',
        search: '?query=string',
        query: 'query=string',
        pathname: '/p/a/t/h',
        path: '/p/a/t/h?query=string',
        href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' }

/**
 Тоже самое можно визуализировать:

 ┌─────────────────────────────────────────────────────────────────────────────┐
 │                                    href                                     │
 ├──────────┬┬───────────┬─────────────────┬───────────────────────────┬───────┤
 │ protocol ││   auth    │      host       │           path            │ hash  │
 │          ││           ├──────────┬──────┼──────────┬────────────────┤       │
 │          ││           │ hostname │ port │ pathname │     search     │       │
 │          ││           │          │      │          ├─┬──────────────┤       │
 │          ││           │          │      │          │ │    query     │       │
 "  http:   // user:pass @ host.com : 8080   /p/a/t/h  ?  query=string   #hash "
 │          ││           │          │      │          │ │              │       │
 └──────────┴┴───────────┴──────────┴──────┴──────────┴─┴──────────────┴───────┘

 (all spaces in the "" line should be ignored -- they're purely for formatting)
 Как видно, этот модуль дал нам возможность извлечь query params из адреса, но в виде строки. Дальше, как вы уже догадались, нам понадобится еще один модуль - querystring.

 #@ Querystring
 Он также входит в поставку nodejs и работает очень просто:
 */

import querystring from 'querystring';

// w=%D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3&foo=bar
querystring.parse(str);
// { w: 'эрланг', foo: 'bar' }

querystring.stringify({ w: 'эрланг', foo: 'bar' });
// w=%D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3&foo=bar

/**
 Здесь необходимо сделать пояснение. Спецификация http разрешает использовать в адресах только те символы, которые входят в ASCII character-set. Возникает вопрос: как быть, если у нас есть другие символы? А для этого применяется специальное кодирование, называемое url encoding. Например, слово скрипт будет закодировано в строку: %D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82.

 Модуль querystring делает кодирование/декодирование автоматически, это видно в примере выше. Но если вам вдруг понадобилось делать это руками, то js спешит на помощь:
 */

encodeURI('эрланг');
// %D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3

decodeURI('%D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3');
// эрланг

// А теперь собираем все вместе:

import url from 'url';
import querystring from 'querystring';

const uri = '/?q=%D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3';
const { query } = url.parse(uri);
const { q } = querystring.parse(query);
console.log(q); // => 'эрланг'
/*
По правде говоря, можно сделать проще: url.parse() принимает вторым параметром флаг, который как раз включает парсинг параметров запроса.
*/

import url from 'url';
import querystring from 'querystring';

const uri = '/?q=%D1%8D%D1%80%D0%BB%D0%B0%D0%BD%D0%B3';
const { query } = url.parse(uri, true);
console.log(query); // => { q: 'эрланг' }

// Обратная задача – конструирование адреса по его частям – выполняется так же просто с помощью функции format того же модуля:

const data = {
    hostname: 'ru.hexlet.io',
    pathname: 'my',
    query: { page: 5 }
};

url.format(data);

/*
В общем случае в url.format нужно передать объект такой же структуры как и urlObject, получаемый после url.parse. Для более полного понимания работы этой функции нужно смотреть в документацию. У нее есть хитрые кейсы в случае наличия или отсутствия определенных ключей и их значений в передаваемом объекте.
*/



// >>>>>>> GET <<<<<<<

/*
Предположим, что мы хотим программно выполнить get запрос к Хекслету. В nodejs сделать это довольно просто:
*/

import http from 'http';

http.get('http://ru.hexlet.io/my', res => {
    console.log(res.statusCode);
});

/*
Вторым параметром передается коллбек, который будет вызван после получения ответа. Он так же принимает на вход объект response, который содержит в себе параметры ответа.

Этих параметров внутри response очень много, и только некоторые из них наиболее часто используются или могут быть нам интересны. В первую очередь это следующий набор:
*/

// response
{
    headers: /* ... */,
    statusCode: 301,
        statusMessage: 'Moved Permanently',
};

/*
Также get позволяет передавать первым параметром не адрес, а набор опций, из которого будет составлен адрес. Такое бывает полезно, когда у нас нет готового адреса, но есть его части:
*/

import http from 'http';

// headers, method, port, ...
const options = {
    hostname: 'ru.hexlet.io',
    path: 'my',
};

http.get(options, res => {
    console.log(res.statusCode);
});

/*
Обо всех доступных опциях можно прочитать в официальной документации, а из самых распространенных мы выделим следующие:

headers - объект, в котором ключ это название заголовка
method - например GET
port
hostname
path
Body

В запросе выше не хватает одной важной детали: получение тела ответа. Тут нас поджидает небольшой сюрприз. Объект response не содержит внутри себя тело ответа. Связано это с тем, что ответ может приходить чанками, и response дает возможность получать эти чанки сразу и независимо друг от друга. С одной стороны, это более гибкая возможность, которая позволяет работать с большим телом, без того чтобы занимать много оперативной памяти; с другой стороны, для простых запросов приходится доставать тело немного более сложным способом, чем хотелось бы. Но, в конечном итоге, все сводится к понятному коду, который нужно просто запомнить.

http.get(url, res => {
  const body = [];
  res.on('data', chunk => {
    body.push(chunk.toString());
  }).on('end', () => {
    const html = body.join();
    console.log(html);
  });
});

Как видно из примера выше, объект response представляет из себя eventEmitter с событиями data и end. Первое вызывается после получения очередного чанка с данными, второе вызывается после того, как все данные пришли и нужно обозначить конец обработки.


#@ Buffer
Из кода сбора чанков в body можно сделать вывод, что chunk – это не строка. Это действительно так, chunk – это объект типа Buffer, который предназначен для хранения потока байтов в виде массива фиксированного размера. Нужно это по той простой причине, что данные, передаваемые по http, не обязательно имеют текстовое представление. Возможна передача также и бинарных данных, таких как картинки, архивы и тому подобное.

const str = 'string as bytes';
const buffer = new Buffer(str, 'utf-8');
console.log(buffer);
// <Buffer 73 74 72 69 6e 67 20 61 73 20 62 79 74 65 73>
buffer.toString();
// string as bytes


#@ Errors
Во время выполнения запроса может произойти все, что угодно. Библиотека http обрабатывает эти ошибки и кидает соответствующие исключения. К таким ошибкам относятся например:

Проблемы с DNS
Ошибки уровня tcp
Ошибки парсинга http ответа

Если для программы важно не завершаться в случае таких ошибок, то можно ловить событие error на объекте request, который возвращается после выполнения get запроса и производить желаемое действие:
*/

import http from 'http';

const uri = 'http://ru.hexlet.io/my';

const req = http.get(uri, res => {
    console.log(res.statusCode);
});

req.on('error', e => {
    console.log(`Got error: ${e.message}`);
});




// >>>>>>> POST-запрос <<<<<<<

/**
 Разобравшись с get запросом, пора переходить к post и передаче данных на сервер. Для начала познакомимся с методом request модуля http. Ниже пример обычного GET запроса, который мы делали с помощью http.get:
 */

const options = {
    hostname: 'ru.hexlet.io',
    path: 'my',
    method: 'GET', // default
}

const req = http.request(options, res => {
    console.log(res.statusCode);
});

req.end();

/**
 На самом деле, http.get – это обертка над http.request, которая выполняет req.end автоматически. Ее добавили в модуль http только потому, что это очень частый вариант использования. Другими словами, http.request — универсальный способ делать http запросы. Для выполнения любого запроса, нужно лишь правильно подставить глагол в опцию method, будь то хоть POST, хоть HEAD.

 Следующий аспект это заголовок Content-Length. Как вы помните из курса http, этот заголовок обязателен при наличии тела запроса. Он содержит цифру — количество байт в теле запроса. Так как данные формы обычно отправляют, используя тип application/x-www-form-urlencoded, то перед подсчетом размера тела его нужно сначала сформировать, выполнив правильные преобразования.
 */

// Content-Type: application/x-www-form-urlencoded

const postData = querystring.stringify({
    'msg': 'Hello World!',
    'key': 'value',
});

// msg=Hello%20World!&key=value

// Content-Length: ?

Buffer.byteLength(postData);
// 28

/**
 Рекомендуется всегда использовать такой способ определения размера тела запроса, потому что он считает количество байт, в отличие от length, который считает количество символов в текстовом представлении. Различия будут проявляться при использовании символов, не входящих в ASCII.
 */

'Пошло поехало'.length; // 13
Buffer.byteLength('Пошло поехало'); // 25
// Теперь можно собрать все вместе и выполнить post запрос с передачей данных формы:

const options = {
    hostname: 'www.google.com',
    path: '/upload',
    method: 'POST',
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(postData)
    }
};

const req = http.request(options, (res) => {
    console.log(`STATUS: ${res.statusCode}`);
});

req.write(postData);
req.end();

/**
 Данные отправляются с помощью метода write объекта request. Часто можно упростить отправку до вызова req.end(postData). write больше полезен тогда, когда используется отправка с помощью чанков, например, в случае передачи больших бинарных данных (картинки, видео).
 */


/**@@
 В сети существует множество видов атак на посетителей веб-сайтов, которые могут привести к утечке персональных данных, различных доступов и даже к выполнению несанкционированных действий. Один из таких видов называется CSRF (Межсайтовая подделка запроса).

 Если жертва заходит на сайт, созданный злоумышленником, от её лица тайно отправляется запрос на другой сервер (например, на сервер платёжной системы), осуществляющий некую вредоносную операцию (например, перевод денег на счёт злоумышленника). Для осуществления данной атаки жертва должна быть аутентифицирована на том сервере, на который отправляется запрос, и этот запрос не должен требовать какого-либо подтверждения со стороны пользователя, который не может быть проигнорирован или подделан атакующим скриптом.

 Основное применение CSRF — вынуждение выполнения каких-либо действий на уязвимом сайте от лица жертвы (изменение пароля, секретного вопроса для восстановления пароля, почты, добавление администратора и т. д.)

 Один из способов защиты, это использование специального токена, который генерируется для каждой страницы и отправляется с формами на сервер, при выполнении потенциально опасных действий.


 solution.js
 Реализуйте и экспортируйте по умолчанию функцию, которая с помощью http запросов, эмулируя поведение пользователя, выполняет регистрацию на сайте.

 Функция принимает на вход четыре параметра:

 Адрес формы регистрации (get запрос)
 Адрес по которому необходимо отправить данные формы (post запрос)
 nickname - значение поля nickname из формы регистрации
 Коллбек, который будет вызван после окончания операции. Коллбек принимает на вход единственный параметр - err в случае если произошла ошибка.
 */

import request from '../solution';

const registrationFormUrl = 'http://localhost:8080';
const submitFormUrl = 'http://localhost:8080/users';
const nickname = 'legolas';
request(registrationFormUrl, submitFormUrl, nickname, (err) => {
    // ...
});

/**
 На сайте реализована защита от csrf, поэтому перед непосредственной отправкой данных формы на соответствующий адрес, необходимо сделать запрос на форму регистрации, извлечь из нее токен и отправить его вместе с данными формы по нужному адресу.

 Обработка ошибок
 В случае если первый запрос вернет статус не 200, то вызываем коллбек и передаем туда ошибку. В случае если второй запрос вернет статус не 302, то так же вызываем коллбек и передаем ошибку.

 Подсказки
 Для извлечения токена из тела запроса, воспользуйтесь функцией getToken
 */

import url from 'url';
import http from 'http';
import querystring from 'querystring';

const getToken = body => body.match(/value="(\w+)"/)[1];

export default (registrationFormUrl, submitFormUrl, nickname, callback) => {
    http.get(registrationFormUrl, (gres) => {
        if (gres.statusCode !== 200) {
            callback(new Error(`Expected 200, but was ${gres.statusCode} for '${registrationFormUrl}'`));
        } else {
            const body = [];
            gres
                .on('data', (chunk) => {
                    body.push(chunk.toString());
                })
                .on('end', () => {
                    const html = body.join('');
                    const data = querystring.stringify({ nickname, token: getToken(html) });
                    const urlObject = url.parse(submitFormUrl);
                    const options = {
                        host: urlObject.hostname,
                        port: urlObject.port,
                        path: urlObject.path,
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Content-Length': Buffer.byteLength(data),
                        },
                    };

                    const req = http.request(options, (res) => {
                        if (res.statusCode === 302) {
                            callback(null);
                        } else {
                            callback(new Error(`Expected 302, but was ${res.statusCode} for '${submitFormUrl}'`));
                        }
                    });

                    req.end(data);
                });
        }
    });

};




// >>>>>>> Promises <<<<<<<

/**
 Промисы стали настоящим спасением человечества и среди прогрессивных разработчиков являются основным способом управления асинхронным кодом.

 Полное описание всех возможностей и аспектов поведения промисов является объемной задачей, которая может запутать на первых порах, поэтому в этом уроке мы остановимся на ключевых особенностях поведения. Все остальное можно почерпнуть из стандарта и/или документации.

 Знакомству с промисами способствует понимание темы "конечные автоматы".

 Начнем по традиции с примера:
 */

const file = '/tmp/hello1.txt';
import { writeFile, readFile } from 'fs-promise';

writeFile(file, 'hello world')
    .then(() => readFile(file, 'utf8'))
    .then(contents => console.log(contents))
    .catch(err => console.log(err));
// hello world

/**
 В этом примере происходит запись файла, затем чтение этого же файла, затем вывод содержимого этого файла в консоль, а в случае ошибки, возникшей на любом этапе, она была бы выведена на экран.

 Абзац выше – это пример того, как выглядит типичная программа, построенная на промисах. Так что такое промис?

 Объект, используемый для асинхронных операций. Промис содержит в себе результат выполнения и позволяет строить цепочки из вычислений, избегая проблемы callback hell

 Интерфейс:

 Promise.prototype.then(onFulfilled, onRejected)
 Promise.prototype.catch(onRejected)
 Отсутствие callback hell происходит благодаря тому, что мы всегда работаем на уровне последовательных вызовов then, а не уходим в глубину.

 Разберем пример выше по косточкам. Первый вызов writeFile(file, 'hello world') возвращает тот самый промис, и пока не важно, как он строится внутри, сейчас мы пытаемся понять то, как с ним работать.
 */

// Вызов ничем не отличается кроме того, что мы не передаем коллбек
writeFile(file, 'hello world')

    /**
     После этого у нас есть два варианта:

     Мы вызываем then и передаем функцию onFulfilled, которая будет вызвана в случае успешного выполнения асинхронной операции
     Мы вызываем catch и передаем функцию onRejected, которая будет вызвана, в случае ошибок в результате выполнения асинхронной операции.
     Функция onFulfilled принимает на вход данные, которые были получены в результате предыдущего выполнения. Таким образом идет передача данных по цепочке.
     */

    .then(() => readFile(file, 'utf8'))
    .then(contents => console.log(contents))

/*
Данные, возвращаемые из функции onFulfilled, переходят по цепочке в функцию onFulfilled следующего then. Но если вернуть promise, то в следующем then окажутся данные, полученные в результате выполнения этого промиса, а не сам промис. Что и происходит в примере выше: мы возвращаем readFile(), а ниже получаем contents. То есть, промисы хорошо комбинируются друг с другом.

#@ Конечный автомат
Теперь попробуем посмотреть внутрь промиса. С концептуальной точки зрения промис – это конечный автомат, у которого три состояния: pending, fulfilled, rejected.

#@ Promise states

Изначально он находится в состоянии pending, а дальше может перейти в одно из двух: либо выполнен (fulfilled), либо отклонен (rejected). И все, больше никакие переходы невозможны. Придя один раз в одно из терминальных (конечных) состояний, промис больше не подвержен изменениям, как бы мы не старались снаружи заставить его перейти в другое состояние.

Реализация
*/

const promiseReadFile = filename => {
    return new Promise((resolve, reject) => {
        fs.readFile(filename, (err, data) => {
            err ? reject(err) : resolve(data);
        });
    });
};

/**
 Любая функция возвращающая промис, внутри себя создает объект промиса привычным способом. Конструктор Promise принимает на вход функцию, внутри которой запускается выполнение асинхронной операции. Делается это, кстати, сразу, промисы не являются примером отложенного (lazy) выполнения кода. Но это еще не все. Промис требует от нас некоторых действий для своей работы. Во входную функцию передаются две другие: reject и resolve. reject должна быть вызвана в случае ошибки с передачей внутрь объекта error, а resolve — в случае успешного завершения асинхронной операции с передачей внутрь данных, если они есть.

 #@ Ошибки
 Ошибка обрабатывается ближайшим обработчиком onRejected в цепочке вызовов. При этом существует два варианта определения обработчика. Первый - через catch, второй - с помощью передачи в then второго параметра. Это продемонстрировано в примере ниже:
 */

promiseReadFile('file1')
    .then(data => promiseWriteFile('file2', data))
    .then(() => promiseReadFile('file3'))
    .then(data => console.log(data))
    .catch(err => console.log(err));
// .then(null, err => console.log(err));

/**
 #@ Promise.all
 Иногда возникает необходимость дождаться выполнения нескольких асинхронных операций. В этом случае можно воспользоваться идиомой Promise.all. Работает она очень просто: в эту функцию передается массив промисов, а дальше в then приходит массив с результатами выполнения.
 */

const readJsonFiles = filenames => {
    // N.B. passing readJSON as a function,
    // not calling it with `()`
    return Promise.all(filenames.map(readJSON));
}

readJsonFiles(['a.json', 'b.json'])
    .then(results => {
        // results is an array of the values
        // stored in a.json and b.json
    });




/**@@
 В этом упражнении необходимо создать библиотеку для работы с http, которая оборачивает встроенный в node.js модуль http в промисы. Интерфейсом библиотеки являются две функции: get и post.

 Определение функции get:
 */

export const get = (url, config = {}) =>
    dispatch({ ...config, url, method: 'GET' });
// Использование:

const host = 'http://ru.hexlet.io';

get('http://ru.hexlet.io').then(response => {
    console.log(response.status); // 301
});

// Определение функции post:

export const post = (url, data, config = {}) =>
    dispatch({ ...config, url, data, method: 'POST' });

const data = { nickname: 'scooter' };

post('https://ru.hexlet.io/users', data).then(response => {
    console.log(response.status); // 201
});

/**
 config – это объект со следующей структурой:

 method - глагол http
 data - объект содержащий данные, которые будут отправлены в теле запроса
 url - адрес назначения
 params - параметры, которые будут подставлены в адрес как query params
 headers - заголовки запроса
 response – это тоже объект, состоящий из:

 status - код ответа
 statusText - текст ответа соответствующий коду
 headers - заголовки ответа
 data - тело ответа
 Дополнительной фишкой библиотеки является автоматическое кодирование данных при выполнении post запроса и установка следующих заголовков:

 'Content-Type': 'application/x-www-form-urlencoded'
 'Content-Length': ...

 dispatcher.js
 Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход конфигурацию запроса (примеры в solution.js) и возвращает промис. В промисе должен выполняться запрос, соответствующий параметрам из входной конфигурации.

 Подсказки
 Документация модуля http - https://nodejs.org/api/http.html
 */

import http from 'http';
import url from 'url';
import querystring from 'querystring';

const getSearch = (queryParams, params) => {
    const mergedQuery = { ...queryParams, ...params };
    const keys = Object.keys(mergedQuery);
    const newQueryParams = keys
        .filter(key => mergedQuery[key] !== null && mergedQuery[key] !== undefined)
        .reduce((acc, key) => ({ ...acc, [key]: mergedQuery[key] }), {});

    return keys.length > 0 ? `?${querystring.stringify(newQueryParams)}` : '';
};


const prepareData = (data, headers) => {
    if (data === undefined) {
        return [data, headers];
    }

    const preparedData = querystring.stringify(data);
    const bufferData = Buffer.from(preparedData, 'utf-8');

    return [bufferData, {
        ...headers,
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(bufferData),
    }];
};

export default (config) => {
    const [data, headers] = prepareData(config.data, config.headers || {});

    const urlObject = url.parse(config.url, true);
    const search = getSearch(urlObject.query, config.params);

    const options = {
        hostname: urlObject.hostname,
        port: urlObject.port,
        method: config.method,
        path: `${urlObject.pathname}${search}`,
        headers,
    };

    return new Promise((resolve, reject) => {
        const req = http.request(options, (res) => {
            const responseData = [];
            res.on('data', (chunk) => {
                responseData.push(chunk);
            });

            res.on('end', () => {
                const response = {
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: res.headers,
                    data: responseData.join(''),
                };

                resolve(response);
            });
        });

        req.on('error', reject);

        if (data) {
            req.write(data);
        }

        req.end();
    });
};



// >>>>>>> JSON <<<<<<<

Хотя мы и привыкли чаще всего иметь дело с программами, которые пишутся для людей, это не всегда так. Некоторые программы вообще никак не соприкасаются с человеком, другие общаются и между собой и с человеком тоже.

    В такой ситуации важно договориться не только о способе передачи данных, таком как протокол http, но и о том, как будут представлены данные, так чтобы их могли читать программы, написанные на разных языках и выполняющиеся в разных окружениях.

    Одним из таких способов представления структурированных данных является json.

    JSON
JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он основан на подмножестве языка программирования JavaScript.

{
    "firstName": "John",
    "lastName": "Smith",
    "isAlive": true,
    "age": 25,
    "address": {
    "streetAddress": "21 2nd Street",
        "city": "New York",
        "state": "NY",
        "postalCode": "10021-3100"
},
    "phoneNumbers": [
    {
        "type": "home",
        "number": "212 555-1234"
    },
    {
        "type": "office",
        "number": "646 555-4567"
    },
    {
        "type": "mobile",
        "number": "123 456-7890"
    }
],
    "children": [],
    "spouse": null
}
Структура подозрительно смахивает на объекты, с которыми мы работаем в js. По большому счету это и есть текстовое представление наших объектов.

    json стал настолько популярным форматом, что в большом количестве языков библиотека для преобразования в json и обратно входит в стандартную поставку. Можно даже сказать, что этот формат стандарт де-факто для обмена информацией между сервисами в интернете. Его характеристики:

    Языко-независимый
Текстовый
Человеко-ориентированный
Доступен везде
js так же имеет встроенные средства для трансляции в json и обратно, причем как в браузере, так и в nodejs:

    const obj = { key: 'value', keys: ['v1', 'v2'] };

const str = JSON.stringify(obj);
// {"key":"value","keys":["v1","v2"]}

JSON.parse(str);
// { key: 'value', keys: [ 'v1', 'v2' ] }

/**
 Media Type
 При передаче контента по интернету мы должны явно специфицировать, какого типа этот контент. Достигается это использованием заголовка content-type. А вот значение, которое можно туда подставить, не является произвольным. Существует такое понятие, как media type (раньше – MIME type), которое представляет из себя строковой идентификатор. Для json он выглядит так: application/json.
 */


/**@@@@
 Перед описанием задания рассмотрим несколько концепций.

 Конфигурация приложения (как существительное) – это различные параметры, которые используются в процессе работы, например, логины, пароли, ключи к другим системам и внешним сервисам, адреса, квоты и тому подобные вещи.

 Конфигурация бывает статической (файл с настройками) или динамической. Динамическую конфигурацию, обычно, хранят в системах, подобных consul. Это такая распределенная key-value база данных с кучей плюшек.

 key-value означает что эта база данных подобна словарю. В нее можно записать значение по определенному ключу, и прочитать это же значение (или перезаписать ее). Основной интерфейс состоит из двух функций set(key, value) и get(key). На практике такая база, обычно, предоставляет простой HTTP-интерфейс, в котором GET запрос извлекает данные по ключу, а POST устанавливает значение.

 Под распределенностью понимается то что она автоматически синхронизируется между всеми нодами (машинами, серверами) кластера (группа серверов). То есть, если вы делаете изменение в локальной версии базы для конкретного сервера, то через некоторый, как правило, очень короткий промежуток времени, это же значение появится и на всех остальных машинах кластера.

 Главная идея в том, что конфигурация обновляется (разными способами) и постоянно актуализируется, а приложение каждый раз обращается к этому сервису для получения последних данных.

 В текущем уроке мы будем использовать такой сервис для определения списка урлов, по которым располагается сайт.

 // Обращение к консулу для извлечения значения по ключу 'backends'
 get(`http://localhost:5456/backends`);
 Запрос возвращает json следующей структуры:

 [
 {
    "url": "http://ru.hexlet.io",
    "lang": "ru"
  }, {
    "url": "http://en.hexlet.io",
    "lang": "en"
  }, {
    "url": "http://gr.hexlet.io",
    "lang": "gr"
  }
 ]
 Как видно из структуры, у хекслета есть языковые версии сайтов и их список лежит в консуле под ключем backends.

 Сама задача заключается в следующем. На воображаемом сервисе, который мы разрабатываем, появилась задача определять самый незагруженный поддомен (подразумевается, что каждый поддомен обслуживается на своем сервере) и обновлять его в консуле с некоторой периодичностью.

 Процесс описывается следующим алгоритмом:

 Делаем запрос в consul на чтение значения ключа backends и извлекаем список адресов
 Делаем запрос ко всем серверам на статусную страницу (адрес строится так: ${url}/status) для домена ru.hexlet.io это будет ru.hexlet.io/status.
 Находим самый незагруженный сервер.
 Обновляем запись в consul.
 Запрос на статусную страницу возвращает данные в виде json:

 {
  "workload": "10",
  "url": "http://ru.hexlet.io"
}
 Параметр workload означает нагрузку на сервер, чем он меньше, тем нагрузка меньше.

 Для обновления самого незагруженного поддомена в консуле, необходимо выполнить следующий запрос:
 */

// value - это url самого незагруженного поддомена, взятый из json статусной страницы
post(setCurrentBackendUrl, { value: url });
// post('http://localhost:5456/backends/current', { value: url });
/**
 Этот запрос в консул, устанавливает значение { value: url } по ключу backends/current

 solution.js
 Реализуйте и экспортируйте по умолчанию функцию, которая обновляет значение по ключу backends/current в consul. Функция принимает на вход два адреса: 1) адрес по которому можно получить список серверов 2) адрес для обновления значения текущего незагруженного поддомена (post запросом).

 Функция должна вернуть promise, выполняющий обновление значения по ключу backends/current.

 Подсказки
 Функции get и post возвращают promise.
 */

import { get, post } from 'hexlet-http-request';

export default (backendsListUrl, setCurrentBackendUrl) => get(backendsListUrl)
    .then((result) => {
        const data = JSON.parse(result.data);
        const promises = data.map(({ url }) => get(`${url}/status`));

        return Promise.all(promises);
    })
    .then((responses) => {
        const best = responses.map(v => JSON.parse(v.data))
            .reduce((min, cur) => (cur.workload < min.workload ? cur : min), { workload: Infinity });
        return post(setCurrentBackendUrl, { value: best.url });
    });




// >>>>>>> Итераторы и Генераторы <<<<<<<

/**
 Этот урок посвящен механизму, основное предназначение которого не связано с асинхронным кодом. Этот механизм называется генераторами и, фактически, представляет из себя улучшенный итератор. А поскольку с итераторами мы тоже не знакомы, то начнем наше повествование с них.

 Итак, вообразим следующую задачу: необходимо сделать объект, содержащий в себе коллекцию (чего угодно), итерируемым. На практике это означает, что мы можем идти циклом по самому объекту, хотя, как мы знаем, по умолчанию это невозможно. Пример:
 */
// Упадет с ошибкой
for (const v of { a: 1, b: 2 }) {
    console.log(v);
}

// obj это объект и for спокойно по нему пройдется
const obj = makeIterator(); // Устройство функции makeIterator будет раскрыто позже
for (const v of obj) {
    console.log(v);
}
// Во втором примере, obj представляет из себя итерируемый объект (iterable object). Мы можем самостоятельно сделать его таким:

const obj = {
    collection: ['yo', 'ya'],
    [Symbol.iterator]: makeIterator,
};

for (const v of obj) {
    console.log(v);
}
// yo
// ya
/**
 Напомню, что Symbol – это специальный неизменяемый тип данных. В основном используется в свойствах объектов. js предоставляет несколько встроенных символов, одним из которых и является iterator.

 Чтобы сделать любой объект итерируемым, нужно создать свойство со значением Symbol.iterator и записать туда специальную функцию, о структуре которой мы сейчас и поговорим.

 Эта функция не является общей для всех итерируемых объектов, ее содержимое зависит от объектов, для которых она предназначена. Общее правило - функция должна реализовывать The iterable protocol.
 */
const makeIterator = function () {
    let nextIndex = 0;

    const next = () => {
        if (nextIndex < this.collection.length) {
            const value = this.collection[nextIndex++];
            return { value, done: false };
        }
        return { done: true };
    };
    return { next };
};

/**
 Функция makeIterator не имеет параметров, потому что так она вызывается внутри js. Из этого следует, что доступ к текущему объекту, к которому она прикреплена, возможен только через this, а значит она должна быть объявлена как functionDeclaration, а не arrowFunction. Требование к возвращаемому значению этой функции следующее:

 Необходимо вернуть объект с методом next. Каждый вызов next будет возвращать объект с двумя свойствами: value и done. value – это значение текущего элемента коллекции, а done – это флаг конца коллекции. Как только next завершает перебор, то возвращается { done: true }, и это является сигналом к тому, что итерирование завершено.

 Можно продемонстрировать работу этой функции, немного переписав ее для возможности прямого вызова:
 */

const makeIterator = coll => {
    let nextIndex = 0;

    const next = () => {
        if (nextIndex < coll.length) {
            const value = coll[nextIndex++];
            return { value, done: false };
        }
        return { done: true };
    };
    return { next };
}

// Еще раз отмечу, что выше мы создали пример только для демонстрации, в реальном коде такая функция не сделает объект итерируемым.

const it = makeIterator(['yo', 'ya']);
it.next(); // { value: 'yo', done: false }
it.next(); // { value: 'ya', done: false }
it.next(); // { done: true }

/**
 Именно так будет вызываться next скрыто от наших глаз в момент итерации по объекту.

 Что можно заметить, глядя на эту функцию? Она содержит в себе скрытое состояние, которое необходимо для запоминания текущей позиции. Как мы помним, состояние – штука сложная, и, программируя в таком стиле, легко допустить ошибку.

 Оказывается, что можно переложить задачу по управлению состоянием на машину. И делается это с помощью так называемых, генераторов.
 */

const makeIterator = function* (coll) {
    for (const value of coll) {
        yield value;
    }
};

const it = makeIterator(['yo', 'ya']);
it.next(); // { value: 'yo', done: false }
it.next(); // { value: 'ya', done: false }
it.next(); // { value: undefined, done: true }

/**
 Как видно из примера, генераторы вводят новый синтаксис в язык. Во-первых, это звездочка после слова function. Она просто указывает на то, что мы имеем дело с генератором. Во-вторых, выражение yield (подчеркиваю: это – не инструкция).

 Генератор, в отличие от обычной функции, при своем вызове не выполняет тело, а возвращает специальный объект с методом next. Каждый раз, когда вызывается next, запускается тело генератора с того места, где оно остановилось последний раз. При первом вызове выполнение идет с самого начала генератора и продолжается до встречи с выражением yield. В этот момент управление передается наружу, next возвращает то, что было передано в yield, а генератор замирает в этом состоянии, на выражении yield. Последующие вызовы начинают работу от yield.

 Еще один пример для осознания:
 */

const gen = function* () {
    yield 1;
    yield 2;
    yield 3;
};

const it = gen();
it.next(); // { value: 1, done: false }
it.next(); // { value: 2, done: false }
it.next(); // { value: 3, done: false }
it.next(); // { value: undefined, done: true }

// Или даже так:

const it = gen();
[...it]; // [1, 2, 3]

// Кроме yield в генераторах можно использовать версию yield*, которая ожидает на вход коллекцию и делает yield для каждого элемента этой коллекции.

const makeIterator = function* () {
    yield* this.collection;
};

// Теперь можно переписать наш первый пример вот таким образом:

const obj = {
    collection: ['yo', 'ya'],
    [Symbol.iterator]: function* () {
        yield* this.collection;
    },
};

for (const v of obj) {
    console.log(v);
}
// yo
// ya





@@@@@
    seq.js
Реализуйте и экспортируйте по умолчанию класс, который представляет собой бесконечную последовательность. Объекты этого класса должны быть итерируемыми.

    import Seq from './seq';

const seq = new Seq(1, x => x + 1);
// или так: const result = seq.skip(50).skip(150).take(3);
const result = seq.skip(200).take(3);
for (const value of result) {
    actual.push(value);
    console.log(value);
}
// 201
// 202
// 203

// Можно обойти еще раз
for (const value of result) {
    actual.push(value);
    console.log(value);
}
// 201
// 202
// 203

for (const value of seq.skip(10).take(1)) {
    console.log(value);
}

// 11

/**
 Как видно из примера выше, методы класса построены с применением fluent interface.

 Конструктор класса принимает на вход три параметра:

 Стартовое значение последовательности
 Функцию, которая генерирует новое значение последовательности на основе предыдущего
 Количество элементов последовательности, по умолчанию последовательность бесконечна (Infinity)
 Также на классе определено две функции: skip(n) и take(m). Первая пропускает первые n элементов, вторая ограничивает коллекцию m элементами.

 Linter
 Readme
 Terminal 1
 Terminal 2
 */

import '@babel/polyfill';

class Seq {
    constructor(start, next, count = Infinity) {
        this.start = start;
        this.next = next;
        this.count = count;
        this.current = start;
    }

    // Синтаксис объявления генератора на уровне класса
    *[Symbol.iterator]() {
        const initValue = this.current;
        for (let i = 0; i < this.count; i += 1) {
            yield this.current;
            this.current = this.next(this.current);
        }
        this.current = initValue;
    };

    take(count) {
        return new Seq(this.start, this.next, count);
    }

    skip(count) {
        let newStart = this.current;
        for (let i = 0; i < count; i += 1) {
            newStart = this.next(newStart);
        }
        return new Seq(newStart, this.next, this.count);
    }
}

export default Seq;



// >>>>>>> Корутины <<<<<<<

/**
 В Computer Science под генераторами понимается data producer, то есть сущность в языке, которая только выдает наружу данные, используя yield. При этом существует более общая концепция, которая называется coroutine или сопрограмма. В отличие от генераторов, она может не только генерировать данные, но так же может и потреблять их (data consumer). Самым удивительным в этой истории является то, что генераторы в js, по сути, являются корутинами, а использование их в качестве генераторов – это всего лишь один из возможных вариантов.

 Сопрограмма — компонент программы, обобщающий понятие функции, который дополнительно поддерживает множество входных точек (а не одну, как функция), остановку и продолжение выполнения с сохранением определенного положения.
 */

const gen = function* () {
    const a = yield 10;
    const b = yield;
    return a + b;
};

const coroutine = gen();
const result = coroutine.next(); // { value: 10, done: false }
coroutine.next(result.value + 1); // const a = 11
console.log(coroutine.next(15)); // const b = 15
// { value: 26, done: true }

/**
 Главное, на что нужно обратить внимание, это появление выражения yield справа от знака равно: const a = yield 10.

 Попробуем по шагам выполнить этот код:

 Создание корутины const coroutine = gen();
 Вызов next(). Первый вызов приводит к тому, что наружу возвращается { value: 10, done: false }, так как внутри мы оказываемся в точке yield 10.
 Вызов next(result.value + 1). Выражение result.value + 1 равно 11, поэтому в итоге происходит вызов next(11). Внутри корутины мы находимся в этой позиции const a = yield. Аргумент, переданный в next, оказывается записанным в константу a внутри корутины и код продолжает выполнятся до следующего вызова yield, на котором корутина останавливается, и управление возвращается наружу.
 Дальнейший вызов next(15) приводит к тому, что константа b становится равна 15, а наружу возвращается { value: 26, done: true }.
 Если обобщить, то yield <что-то> производит данные наружу, const a = yield потребляет данные, а const a = yield <что-то> производит и потребляет в два шага.

 Теперь, используя немного магии, мы можем создать обертку над генераторами для работы с асинхронным кодом.
 */

co(function* () {
    const a = yield Promise.resolve(1);
    const b = yield Promise.resolve(2);
    const c = yield Promise.resolve(3);

    console.log([a, b, c]); // => [1, 2, 3]
});

/**
 Идея в том, что функция co автоматически итерирует по генератору, извлекая значение из промисов и передавая их дальше в next по цепочке. В целом, на этом можно было бы и остановиться, но для полной имитации синхронной работы хотелось бы поддержки со стороны try/catch. И генераторы дают возможность трансформировать ошибки в исключения.
 */

co(function* () {
    const a = yield Promise.resolve(1);
    try {
        const b = yield Promise.reject(new Error('Boom'));
    } catch (e) {
        console.log(e.message); // => 'Boom'
    }
});

/**
 Чтобы такой код заработал, необходимо в функции co отслеживать состояние rejected и использовать метод throw, который есть у нашего генератора. Ниже пример того, как это можно было бы сделать (без промисов):
 */

const gen = function* () {
    try {
        const a = yield;
        yield new Error('Boom');
    } catch (e) {
        console.log(e.message);
    }
    console.log('after Boom');
};

const coroutine = gen();
coroutine.next();
const result = coroutine.next();
coroutine.throw(result.value); // => { value: undefined, done: true }

// Boom
// After Boom

// Метод throw() возобновляет выполнение тела генератора кидая внутри исключение и возвращает объект со свойствами done и value.


/**@@
 co.js
 Реализуйте и экспортируйте по умолчанию функцию co. Она должна принимать на вход генератор и возвращать promise. Функция co опирается на то, что внутри генератора yield используется только для promise.
 */

co(function* () {
    const a = yield Promise.resolve(1);
    const b = yield Promise.resolve(2);
    const c = yield Promise.resolve(3);

    return [a, b, c]; // [1, 2, 3]
}).then(data => console.log(data));
// [1, 2, 3]

// В случае, если promise внутри генератора переходит в состояние rejected, то co трансформирует возникшую ошибку в исключение.

co(function* () {
    try {
        yield Promise.reject(new Error('boom'));
    } catch (err) {
        console.log(err.message);
    }
});
// boom

export default (generator) => {
    const iterator = generator();

    const next = (result) => {
        const { value } = result;
        if (result.done) {
            return value;
        }

        return value.then(
            res => next(iterator.next(res)),
            err => next(iterator.throw(err)),
        );
    };

    return next(iterator.next());
};




// >>>>>>> async/await <<<<<<<

/**
 Концепция async/await для работы с асинхронным кодом впервые появилась на платформе .net в 2011 году. С тех пор разработчики многих языков оценили удобство этой конструкции и начали ее внедрение. Например, такое произошло с python, в котором есть уже встроенная поддержка этого механизма, а также с языком kotlin. js тоже не остается в стороне, и не смотря на то, что этот механизм находится в стадии разработки (он не утвержден), многие его уже активно используют в продакшен среде. Хекслет начал использовать async/await еще в 2015 году, за что отдельное спасибо babel.

 Использование async/await очень похоже на то, как мы работаем с генераторами:
 */

const load = async () => {
    const a = await Promise.resolve(5);
    const b = await Promise.resolve(10);
    return a + b;
};
load().then(value => console.log(value)); // => 15

/**
 Первым делом необходимо добавить ключевое слово async перед определением функции. Это обязательное условие для включения механизма. После вызова функция async всегда возвращает Promise. Внутри функции async также можно использовать другие асинхронные операции, ставя перед ними ключевое слово await. Сами операции должны возвращать Promise. По правде говоря, async/await – это механизм, построенный вокруг и для промисов.

 Стоит отметить, что async функция не является генератором, это обычная функция, которая выполняется сверху вниз и, в конце концов, может вернуть результат. Только в отличие от обычного кода на js, await дожидается выполнения асинхронной операции и возвращает ее значение. Как видно, код такой функции плоский и очень легко читается.

 Еще одной особенностью таких функций является то, что наружу всегда будет возвращен промис, даже если мы возвращаем что-то другое, как в примере выше. Внутри происходит автоматическое преобразование Promise.resolve(a + b). Кстати, это означает, что код, вызывающий async функцию, может применять к ней await, и так далее по цепочке вверх.

 Теперь можно посмотреть на более комплексный пример и сравнить генераторы с async/await:
 */

import { get } from 'hexlet-http-request';

const getFriends = id => {
    return co(function* () {
        const link = `http://ru.hexlet.io/users/${id}.json`;
        const user = yield get(link);
        yield Promise.all(user.friends.map(f => get(f.link)));
    });
};

getFriends(5).then(friends => console.log(friends));
Версия с async/await:

import { get } from 'hexlet-http-request';

const getFriends = async id => {
    const link = `http://ru.hexlet.io/users/${id}.json`;
    const user = await get(link);
    return await Promise.all(user.friends.map(f => get(f.link)));
};

const load = async () => {
    const friends = await getFriends(5);
    console.log(friends);
};

load();
/**
 Здесь можно отметить следующий момент: async/await не предоставляют возможности выполнить одновременно несколько асинхронных операций, для этого нужно будет пользоваться Promise.all, что логично, ведь await ждет промис.
 */


/**@@
 Эта задача полностью повторяет задачу про CSRF. Цель – увидеть катастрофическую разницу между использованием коллбеков и async/await.

 Для выполнения http запросов воспользуйтесь импортированными функциями из библиотеки hexlet-http-request, которую мы реализовывали в одном из уроков.

 solution.js
 Реализуйте и экспортируйте по умолчанию функцию, которая с помощью http запросов, эмулируя поведение пользователя, выполняет регистрацию на сайте.

 Функция принимает на вход следующие параметры:

 Адрес формы регистрации (get запрос)
 Адрес, по которому необходимо отправить данные формы (post запрос)
 nickname - значение поля nickname из формы регистрации
 На сайте реализована защита от csrf, поэтому перед непосредственной отправкой данных формы на соответствующий адрес необходимо сделать запрос на форму регистрации, извлечь из нее токен и отправить его вместе с данными формы по нужному адресу.

 В упражнении доступен веб-доступ, по которому открывается этот сайт. Попробуйте посмотреть исходный код страницы, найти там этот токен, а так же выполните регистрацию.

 Обработка ошибок
 В случае, если первый запрос вернет статус не 200, то бросаем исключение с ошибкой
 В случае, если второй запрос вернет статус не 302, то также брсоаем исключение с ошибкой
 Подсказки
 Для извлечения токена из тела запроса воспользуйтесь функцией getToken
 */

import { get, post } from 'hexlet-http-request';

const getToken = body => body.match(/value="(\w+)"/)[1];


export default async (registrationFormUrl, submitFormUrl, nickname) => {
    const response = await get(registrationFormUrl);
    if (response.status !== 200) {
        throw new Error(`Expected 200, but was ${response.status} for '${registrationFormUrl}'`);
    }
    const data = { nickname, token: getToken(response.data) };
    const response2 = await post(submitFormUrl, data);
    if (response2.status !== 302) {
        throw new Error(`Expected 302, but was ${response2.status} for '${submitFormUrl}'`);
    }
};


// ######## JS: Полиморфизм #########

/**
 ООП – тяжело формализуемое понятие, у которого очень много аспектов. В разные времена под ООП понимали и до сих пор понимают разные вещи. Существует как минимум два вида ООП, одно сформулированное Аланом Кеем, создателем языка SmallTalk, и другое - то, которое про полиморфизм, наследование и инкапсуляцию (Гради Буч). В современном мире, обычно под ООП имеют в виду второе, хотя первое живёт и здравствует во многих языках. Но даже когда мы говорим про второй вид ООП, всё равно разные языки делают акцент на разные возможности. То, что в одних языках считается признаком настоящего ООП, в других неприемлемо.

 Если попытаться как-то обобщить и найти самое фундаментальное, то чем обладают все ООП-языки (по Бучу), то скорее всего общей точкой соприкосновения окажется полиморфизм подтипов.

 Полиморфизм (подтипов), пожалуй, самая важная отличительная черта современного объектно-ориентированного программирования. Бенджамин Пирс. Автор книги Теория Типов В Языках Программирования.

 В этом курсе мы подробно рассмотрим полиморфизм, механизмы его реализации и, самое главное, научимся правильно его применять. Основные темы данного курса:

 > Виды полиморфизма: подтипов и параметрический
 > Диспетчеризация и её виды.
 > Инверсия зависимостей, а с ней и инъекция
 > DI-контейнер
 > SOLID (SRP, OCP, ISR, DIP)

 Кроме того, мы познакомимся с понятием "шаблоны проектирования". Разберём их влияние на структуру кода, и познакомимся с некоторыми популярными:
 > Null Object
 > Strategy
 > Factory

 Поговорим о том, когда полиморфизм необходим, а когда он не нужен или даже вреден. Познакомимся с несколькими техниками, позволяющими получить полиморфное поведение без использования объектов. Для этого рассмотрим различные виды диспетчеризации.
 */




// >>>>>>> Параметрический полиморфизм <<<<<<<
/**
 Слово "полиморфизм" в зависимости от контекста может означать разные вещи. Когда о полиморфизме говорят программисты на императивных языках, они, как правило, подразумевают "полиморфизм подтипов". В то же время программисты на функциональных языках имеют в виду "параметрический полиморфизм". О последнем и поговорим.

 В этом уроке появляется код на Java. Не переживайте, если не понимаете его до конца, наша цель — разобраться с концепциями, а не с Java.

 В библиотеке lodash есть функция _.concat(), которая объединяет переданные ей массивы:
 */

_.concat([1], [2, 3, 1]); // [1, 2, 3, 1]
_.concat(['one'], ['two', 'three']); // ['one', 'two', 'three']
_.concat([true], [false, false, true]); // [true, false, false, true]

// Эта функция объединяет любые массивы, независимо от типа данных, содержащихся внутри. Попробуем реализовать её самостоятельно.

// Это немного урезанная версия функции concat, она работает только с двумя аргументами
// каждый из которых – массив
// Функция создаёт новый массив, затем обходит по очереди переданные массивы и добавляет их значения
// во вновь созданный массив. Затем он возвращается наружу.

const concat = (arr1, arr2)
{
    const result = [];
    arr1.forEach((value) => result.push(value));
    arr2.forEach((value) => result.push(value));
    return result;
}

/**
 Посмотрите внимательно на этот код. Выполняются ли в нём какие-либо операции над данными внутри массива? Правильный ответ: нет. Эти данные перекладываются из одного массива в другой, но над ними не происходит никаких действий. Наша новая функция concat, также как и исходная _.concat может работать с массивами, содержащими любые типы данных.

 Для разработчиков, которые писали только на динамических языках, такое поведение кажется естественным, но в статических языках не всё так просто. Ниже пример определения массивов в Java:
 */

int numbers[] = {3, 1, 2, 5, 4};
String words[] = {"one", "two", "three"};
// В глаза бросается необходимость указывать тип. Для первого массива это int, для второго String. Нельзя создать массив без указания типа его значений. То же самое касается функций, обрабатывающих массивы:

class Main {
    public static void main(String[] args) {
    int[] a = {1, 2, 3, 4};
    int[] b = {4, 16, 1, 2, 3, 22};
    concat(a, b);
}

public static int[] concat(int[] arr1, int[] arr2) {
    int[] result = new int[arr1.length + arr2.length];
    int count = 0;

    for (int i = 0; i < arr1.length; i++) {
        result[i] = arr1[i];
        count++;
    }

    for (int j = 0; j < arr2.length; j++) {
        result[count] = arr2[j];
        count++;
    }

    return result;
}
}

/**
 Обратите внимание на сигнатуру метода concat: int[] concat(int[] arr1, int[] arr2). В отличие от варианта на JavaScript, здесь указано что входными параметрами являются массивы чисел. То есть для массива строк эта функция работать не будет. Не будет она работать и для всех остальных типов данных.

 Что это означает на практике? Очень простую и печальную вещь. Нам придётся реализовывать подобную функцию для каждого типа, при том что алгоритм внутри абсолютно идентичен.

 Именно тут нам пригодится параметрический полиморфизм. Статическим языкам приходится вводить в язык специальные конструкции, которые позволяют описывать подобные алгоритмы безотносительно типа параметра. В некоторых языках их называют шаблонами (C++) или дженериками (Java, C#):
 */

class Main {
    public static void main(String[] args) {
    Integer[] a = {1, 2, 3, 4};
    Integer[] b = {4, 16, 1, 2, 3, 22};
    myArrayMerge(a, b);
}

public static<T> T[] myArrayMerge(T[] arr1, T[] arr2) {
    T[] result = (T[]) new Object[arr1.length + arr2.length];
    int count = 0;

    for (int i = 0; i < arr1.length; i++) {
        result[i] = arr1[i];
        count++;
    }

    for (int j = 0; j < arr2.length;j++) {
        result[count] = arr2[j];
        count++;
    }

    return result;
}
}

/**
 В этом коде появляется тип T, что как раз и означает возможность использования с любым типом внутри массива. Теперь метод concat работает подобно аналогу из JavaScript.

 Параметрический полиморфизм даёт возможность писать обобщённые алгоритмы для составных типов, что в некоторых случаях значительно сокращает количество кода. Иногда за это приходится платить сложностью решения, но для большинства типичных операций сложность растёт не сильно. Это видно и по коду выше.

 В динамических языках для реализации обобщённых алгоритмов, параметрический полиморфизм не нужен. Любая коллекция может содержать любые типы данных в любой момент времени. Благодаря этому не требуется вводить дополнительных языковых конструкций и изучать новые концепции.

 В литературе использование параметрического полиморфизма часто называется обобщённым программированием.
 */


// >>>>>>> Диспетчеризация по ключу (данные) <<<<<<<

/**
 В связке с полиморфизмом постоянно возникает выражение "динамическая диспетчеризация". С самим понятием мы познакомимся позже, а сейчас поговорим про диспетчеризацию в принципе.

 Диспетчеризация (от английского dispatch - отсылать, отправлять) - процесс координации каких-либо действий. Например, диспетчер в аэропорту разводит самолёты, диспетчер в службе такси связывает доступного водителя и клиента.

 Рассмотрим условный код, в котором выбор ветки исполнения идёт по конкретному значению переменной:
 */

let databaseConfiguration;

if (env === 'development') {
    databaseConfiguration = {
        adapter: 'sqlite',
    };
} else if (env === 'production') {
    databaseConfiguration = {
        adapter: 'postgresql',
    };
}

/**
 Во всех проектах существует понятие "среда", это то окружение, в котором происходит запуск проекта. Во время разработки код запускают в среде разработчика, её традиционно называют development. Среда, в которой приложение работает по-настоящему, называется production. В зависимости от среды, приложения по разному стартуют, конфигурируются и даже работают, например в разных средах могут использоваться разные базы данных.

 Код выше как раз типичный пример того, как меняется конфигурация в зависимости от среды. Процесс выбора можно назвать процессом диспетчеризации.

 Статичная условная конструкция, в которой диспетчеризация идёт по строкам, легко заменяется на свитч. Так код становится понятнее и проще:
 */

let databaseConfiguration;

switch (env) {
    case 'development':
        databaseConfiguration = {
            adapter: 'sqlite',
        };
        break;
    case 'production':
        databaseConfiguration = {
            adapter: 'postgresql',
        };
        break;
}


// Хотя кода и стало чуть больше, switch сам по себе более явно описывает процесс диспетчеризации. Но можно пойти ещё дальше и сделать диспетчеризацию по ключу ассоциативного массива:

const databaseSettingsByEnv = {
    development: {
        adapter: 'sqlite',
    },
    production: {
        adapter: 'postgresql',
    },
};

const databaseConfiguration = databaseSettingsByEnv[env];


// Значение по умолчанию легко добавить через оператор ||:

const databaseConfiguration = databaseSettingsByEnv[env] || { adapter: 'memory' };

// Либо через _.get
// const databaseConfiguration = _.get(databaseSettingsByEnv, env, { adapter: 'memory' });

/**
 Этот вариант лучше предыдущих двух сразу по нескольким причинам. Во-первых, он короче, во-вторых, он гибче. Условные конструкции это статичный код, который нельзя поменять без переписывания самой программы в отличие от последнего варианта. А вот данные это совсем другое дело. Для удобства их часто кладут в файлы конфигурации, которые используют формат JSON или YAML, например:

 development:
 adapter: sqlite

 production:
 adapter: postgresql

 При таком подходе легко добавить новое поведение без изменения самого кода приложения. Его мощь особенно чувствуется в ситуациях, когда обработкой занимается не наш код, а код библиотеки или фреймворка. Ведь мы не можем просто взять, открыть исходники и поправить их.
 */

/**@@
 html.js
 Реализуйте и экспортируйте по умолчанию функцию getLinks(tags), которая принимает на вход список тегов, находит среди них теги a, link и img, а затем извлекает ссылки и возвращает список ссылок. Теги подаются на вход в виде массива, где каждый элемент это тег. Тег имеет следующую структуру:

 name - имя тега.
 href или src - атрибуты. Атрибуты зависят от тега: img - src, a - href, link - href.
 */

import getLinks from './html.js';

const tags = [
    { name: 'img', src: 'hexlet.io/assets/logo.png' },
    { name: 'div' },
    { name: 'link', href: 'hexlet.io/assets/style.css' },
    { name: 'h1' },
];

const links = getLinks(tags);

// [
//   'hexlet.io/assets/logo.png',
//   'hexlet.io/assets/style.css'
// ];


const mapping = {
    a: 'href',
    img: 'src',
    link: 'href',
};

const getLinks = (tags) => {
    const filteredTags = tags.filter((tag) => mapping[tag.name]);
    const paths = filteredTags.map((tag) => tag[mapping[tag.name]]);

    return paths;
};

export default getLinks;



// >>>>>>> Диспетчеризация по ключу (функции) <<<<<<<

/**
 Диспетчеризация по ключу ассоциативного массива мощнее чем кажется на первый взгляд. Далеко не всегда достаточно выбирать разные данные, иногда приходится выполнять другой код.

 Предположим что нам надо сформировать массив с фамилиями наших пользователей. Главное условие – для девушек берётся девичья фамилия.

 Реализуем эту задачу, используя старый добрый if:
 */

const lastNames = users.map((user) => {
    if (user.gender === 'female') {
        return user.maidenName;
    }
    return user.lastName;
});

// Теперь решим эту задачу с помощью диспетчеризации по ключам объекта, но в отличие от предыдущего урока, в значениях у нас будут функции:

// Определяем key-value, где ключ это пол, а значение это функция, возвращающая нужное значение для пола

const mapping = {
    female: (user) => user.maidenName,
    male: (user) => user.lastName,
};

// Выбираем нужную функцию по названию пола и вызываем её
// Внутрь функции передается пользователь

const lastNames = users.map((user) => mapping[user.gender](user));

/**
 В некоторых ситуациях такой вариант решения задачи лучше. В нём явно прослеживаются зависимости, особенно если их становится много. Кроме того, конфигурация данными позволяет вынести их в другое место и расширять поведение без переписывания кода, который использует эти данные.

 Ещё один пример – парсинг данных в зависимости от их типа:
 */

import yaml from 'js-yaml';

const mapping = {
    yml: yaml.safeLoad,
    json: JSON.parse
};

const parse = (type, data) => mapping[type](data);

/**
 Дополнительные материалы
 Пример использования диспетчеризации по ключу в проектах Хекслета https://github.com/Hexlet/hexlet-exercise-kit/blob/master/import-documentation/src/index.js#L15
 */


/**@@
 html.js
 Реализуйте и экспортируйте по умолчанию функцию stringify(tag), которая принимает на вход тег и возвращает его текстовое представление. Например:
 */

import stringify from './html';

const tag = {
    name: 'hr',
    class: 'px-3',
    id: 'myid',
    tagType: 'single',
};
const html = stringify(tag); // <hr class="px-3" id="myid">

const tag = {
    name: 'div',
    tagType: 'pair',
    body: 'text2',
    id: 'wow',
};
const html = stringify(tag); // <div id="wow">text2</div>

/**
 Внутри структуры тега есть три специальных ключа:

 name - имя тега
 tagType - тип тега, определяет его парность (pair) или одиночность (single)
 body - тело тега, используется для парных тегов
 */


const buildAttrs = (tag) => {
    const excluded = ['name', 'tagType', 'body'];

    return Object.keys(tag)
        .filter((attr) => !excluded.includes(attr))
        .map((attr) => ` ${attr}="${tag[attr]}"`)
        .join('');
};

const mapping = {
    single: (tag) => {
        const attrs = buildAttrs(tag);
        return `<${tag.name}${attrs}>`;
    },
    pair: (tag) => {
        const attrs = buildAttrs(tag);
        return `<${tag.name}${attrs}>${tag.body}</${tag.name}>`;
    },
};

const stringify = (tag) => {
    const build = mapping[tag.tagType];
    return build(tag);
};

export default stringify;




// >>>>>>> Диспетчеризация по имени файла <<<<<<<

/**
 Ещё один интересный приём – диспетчеризация по имени файла.

 В некоторых системах принято иметь не один файл с разными ключами для конфигурации, а разные файлы, относящиеся к разным средам. Например:

 configs/
 database.development.json
 database.production.json
 database.test.json
 Где-то в исходниках должен быть код, который выбирает какой файл загружать. Ниже код использует диспетчеризацию по ключу:
 */

import fs from 'fs';

const configFileNamesByEnv = {
    development: 'database.development.json',
    production: 'database.production.json',
    test: 'database.test.json',
};

const filename = configFileNamesByEnv[env];
const raw = fs.readFileSync(filename);
const config = JSON.parse(raw);

// Нетрудно заметить, что имея название среды запуска, можно составить подходящее имя файла. Так и сделаем:

const filename = `database.${env}.json`;
const raw = fs.readFileSync(filename);
const config = JSON.parse(raw);

// Код стал намного короче и больше не требует изменения при расширении.

/**@@
 DatabaseConfigLoader.js
 Реализуйте и экспортируйте по умолчанию класс DatabaseConfigLoader, который отвечает за загрузку конфигурации для базы данных. У класса следующий интерфейс:

 Конструктор - принимает на вход путь, по которому нужно искать конфигурацию
 load(env) - метод, который грузит конфигурацию для конкретной среды окружения. Он загружает файл database.${env}.json, парсит его и возвращает результат наружу.
 */

const pathToConfigs = path.join(__dirname, '__fixtures__');
const loader = new DatabaseConfigLoader(pathToConfigs);
const config = loader.load('production'); // loading database.production.json

// {
//   host: 'google.com',
//   username: 'postgres',
// };

/**
 В этом классе и конфигурации реализована поддержка расширения. Если в загружаемом конфиге есть ключ extend, то нужно загрузить конфигурацию с этим именем (он соответствует env). Далее конфигурации мержатся между собой так, что приоритет имеет загруженный раньше. Более подробный пример посмотрите в тестах.

 Подсказки
 Для чтения файла используйте соответствующую синхронную функцию из модуля fs.
 */

import fs from 'fs';
import path from 'path';
import _ from 'lodash';

export default class {
    constructor(pathToConfigs) {
        this.pathToConfigs = pathToConfigs;
    }

    load(env) {
        const fileName = `database.${env}.json`;
        const filePath = path.join(this.pathToConfigs, fileName);
        const raw = fs.readFileSync(filePath);
        const config = JSON.parse(raw);

        if (!config.extend) {
            return config;
        }

        const newEnv = config.extend;
        const configWithoutExtend = _.omit(config, 'extend');

        return { ...this.load(newEnv), ...configWithoutExtend };
    }
}




// >>>>>>> Полиморфизм (утиная типизация) <<<<<<<
/**
 Начнём знакомство с полиморфизмом подтипов с задачки. Представьте себе функцию, которая проверяет, есть ли комментарии у статьи или топика (вопросы пользователей Хекслета под уроками и проектами). Статья в коде представлена объектом класса Article, а топик – Topic.
 */

const hasComments = (commentable) => {
    // Если это статья
    if (commentable instanceof Article) {
        return commentable.getArticleComments().length > 0;
        // Если это топик
    } else if (commentable instanceof Topic) {
        return commentable.getTopicComments().length > 0;
    }
}

class Article {
    // some code

    getArticleComments() {
        return this.comments;
    }
}

class Topic
{
    // some code

    public getTopicsComments()
    {
        return this.comments;
    }
}

// Article.first() - метод, который возвращает первую статью из базы данных
const article = Article.first();
console.log(hasComments(article));

/**
 С подобным кодом мы уже сталкивались ранее. Каждый новый тип, потребует от нас добавления кода в эту условную конструкцию. Его можно заменить на диспетчеризацию по ключу, но особенно лучше не станет. Всё равно придётся описывать поведение для каждого класса в дополнении к тому, что поведение и так описано внутри каждого класса. Но можно сделать кое-что лучше. Достаточно согласовать интерфейс всех типов и договориться о том, что метод для извлечения комментариев будет называться getComments(). Тогда код станет таким:
 */

const hasComments = (commentable) => commentable.getComments().length > 0;

const article = Article.first();
console.log(hasComments(article));

const topic = Topic.first();
console.log(hasComments(topic));

/**
 Теперь функцию hasComments(commentable) можно вызывать с любым объектом, имеющим метод getComments() с необходимой сигнатурой. Эта функция не поменяется даже при добавлении нового класса, содержащего такой же метод.

 Способность функции, обрабатывать объекты разных типов одинаковым образом, называется полиморфизмом подтипов (почему подтипов, мы разберёмся в следующих уроках, но это не про наследование), а сама функция – полиморфной функцией.

 Как видно из кода выше, для реализации такого полиморфизма, в JavaScript не нужно наследование и интерфейсы. В миру такой подход называют "утиной типизацией". Если что-то ходит как утка и крякает как утка, то это утка.

 Технически, самое простое и понятное что делает полиморфизм подтипов (для клиентского кода) – убирает условные конструкции. Любую условную конструкцию можно заменить полиморфизмом и любую полиморфную функцию можно заменить ифами. Другими словами, полиморфизм подтипов не является неотъемлемой частью разработки, код можно писать и без него. С другой стороны, иногда встречаются ситуации, в которых он здорово помогает, но не сказать что это происходит постоянно.

 В чем разница между параметрическим и полиморфизмом подтипов? В первом случае, реализуется общий алгоритм для контейнера (например массива), который содержит значение или значения типа T. Этот алгоритм не зависит от T и для любых T выполняется идентично. Во втором, алгоритм построен вокруг самого объекта и использует его методы. В полиморфизме подтипов, полиморфная функция работает только с теми объектами, которые имеют необходимые для реализации алгоритма методы.
 */


/**@@
 FileKV.js
 В программировании, для некоторых задач распространены key-value базы данных. Внешне они работают по принципу ассоциативных массивов, но живут как отдельные программы и умеют делать много полезных штук: например, сохранять данные на диск, переносить данные между машинами в сети и тому подобное.

 В этой задаче реализована подобная база данных в виде класса FileKV, который сохраняет свои данные на диске в указанном файле. Она имеет следующий интерфейс:
 */

import FileKV from '../FileKV';

const map = new FileKV('/path/to/dbfile');
// Получение значения по ключу
map.get('key'); // 'value'
map.get('unkonwnkey'); // null
// Получение значения и дефолт
map.get('unkonwnkey', 'default value'); // 'default value'
// Установка и обновление ключа
map.set('key2', 'value2');
map.get('key2'); // 'value2'
// Удаление ключа
map.unset('key2');
map.get('key2'); // null
map.set('key', 'value');
// Возврат всех данных из базы
map.toObject(); // { key: 'value' }

/**
 В целях тестирования бывает полезно иметь реализацию такой базы данных, которая хранит данные в памяти, а не во внешнем хранилище. Это позволяет легко сбрасывать состояние между тестами и не замедлять их.

 InMemoryKV.js
 Реализуйте и экспортируйте по умолчанию класс InMemoryKV, который представляет собой in-memory key-value хранилище. Данные внутри него хранятся в обычном объекте. Интерфейс этого класса совпадает с FileKV за исключением конструктора. Конструктор InMemoryKV принимает на вход объект, который становится начальным значением базы данных.
 */

import InMemoryKV from '../InMemoryKV';

const map = new InMemoryKV({ key: 10 });
map.get('key'); // 10

/**
 keyValueFunctions.js
 Реализуйте и экспортируйте по умолчанию функцию swapKeyValue, которая принимает на вход объект базы данных и меняет в нём ключи и значения местами.

 swapKeyValue — полиморфная функция, она может работать с любой реализацией key-value, имеющей такой же интерфейс.
 */

import InMemoryKV from '../InMemoryKV';
import swapKeyValue from '../keyValueFunctions';

const map = new InMemoryKV({ key: 10 });
map.set('key2', 'value2');
swapKeyValue(map);
map.get('key'); // null
map.get(10); // 'key'
map.get('value2'); // 'key2'


// FILE: InMemoryKV.js
import _ from 'lodash';

class InMemoryKV {
    constructor(initial = {}) {
        this.map = _.cloneDeep(initial);
    }

    set(key, value) {
        this.map = { ...this.map, [key]: value };
    }

    unset(key) {
        this.map = _.omit(this.map, key);
    }

    get(key, defaultValue = null) {
        return _.get(this.map, key, defaultValue);
    }

    toObject() {
        return this.map;
    }
}

export default InMemoryKV;

// FILE: keyValueFunctions.js

const swapKeyValue = (map) => {
    const data = map.toObject();
    Object.entries(data).forEach(([key, value]) => {
        map.unset(key);
        map.set(value, key);
    });
};

export default swapKeyValue;



// >>>>>>> Null Object Pattern <<<<<<<
/**
 На сайтах, у которых есть аутентификация, внутри присутствует понятие "текущий пользователь". Это тот пользователь который аутентифицировался через форму (или вошёл через социальную сеть). Текущий пользователь активно используется для вывода различных блоков информации, например, чтобы отобразить блок этого пользователя. Подобный код обычно выглядит так:
 */
// где-то в воображаемом шаблоне articles/index.html.slim
if isAuthenticated && currentUser.hasArticles()
    each article in currentUser.getArticles()
// тут выводим статьи

/**
 Обратите внимание на проверку существования пользователя. Если её не сделать, то код упадёт с ошибкой, потому что вызывается метод hasArticles() у null (так как пользователь отсутствует если он не залогинился****). Когда этих проверок одна-две, то ничего страшного, но если их десятки и больше, то код быстро захламляется. Кроме того, такую проверку очень легко забыть вставить.

 Можно ли решить эту задачу каким-то другим способом? Оказывается можно. Достаточно использовать полиморфизм подтипов. Для этого создаётся класс описывающий пользователя не прошедшего аутентификацию, например, Guest. Затем в него добавляются все необходимые методы, для которых мы хотим получить полиморфное поведение.
 */

class Guest
{
    hasArticles() {
        return false;
    }

    getArticles() {
        return [];
    }
}

/**
 Большинство этих методов возвращает false либо пустые списки, так как у этого пользователя ничего нет. Зачем тогда он нужен? Всё очень просто, теперь клиентский код, всегда рассчитывает на существование пользователя, ему больше не нужно проверять аутентификацию:
 */
if currentUser.hasArticles()
    each article in currentUser.getArticles()
// тут выводим статьи

/**
 Условные конструкции уйдут по всем шаблонам, но остаётся вопрос. А где и как происходит сам процесс создания нашего пользователя? И вот здесь останется тот единственный if, благодаря которому произойдёт создание правильного объекта. Это происходит на этапе обработки входящего запроса, и конкретное место зависит от используемого фреймворка. Код в этом месте выглядит примерно так:
 */

const fetchCurrentUser = (req) => {
    const userId = req.session.userId;
    // Если id есть в сессии, то выбираем пользователя из базы, иначе возвращаем гостя
    return userId ? User.find(userId) : new Guest();
};

/**
 У такого способа использования полиморфизма есть особое название: шаблон проектирования "null object". Он часто используется внутри фреймворков и иногда встречается в прикладном коде. На Хекслете таких мест как минимум 3. Например, в классе Guest у нас десятки методов. Вот его содержимое (не полностью):
 */
// # Код на руби, но он прост как две копейки
/*
class Guest
    def id
    nil
    end

    def avatar
    nil
    end

    def github_account
    false
    end

    def has_passed_at_least_one_project?
        false
        end

    def city
    ''
    end

    def seeking_job?
        true
        end

    def mentor?
        false
        end

    def locale?
        nil
        end

    def guest?
        true
        end

    def current_subscription_object
    FreeSubscription.new(self)
    end

    def to_s
    'guest'
    end

    def topics_count
    0
    end
    end
*/

/**@@
 На Хекслете доступ к курсам оформляется через подписку. Подписка, это отдельная сущность, которая хранит в себе информацию о самой подписке, когда она началась, сколько продолжается, оплачена ли и так далее. Типичная проверка на наличие подписки (а значит доступ к платному контенту) выглядит так:

 // Эти примеры сильно упрощены, к тому же Хекслет написан на Rails
 // но для демонстрации идеи такая реализация подойдет
 */

user.getCurrentSubscription().hasPremiumAccess();
user.getCurrentSubscription().hasProfessionalAccess();

// Но не у всех пользователей есть подписка, на Хекслете есть и большая бесплатная часть. Так как подписка может отсутствовать, в коде придется делать так:

if (user.getCurrentSubscription() && user.getCurrentSubscription().hasPremiumAccess()) {
    // есть преимум доступ, показываем что-то особенное
}

// Чтобы избежать постоянных проверок на существование подписки, мы внедрили Null Object. Теперь подписка есть всегда и достаточно написать:

if (user.getCurrentSubscription().hasProfessionalAccess()) {
    // есть профессиональный доступ, показываем что-то особенное
}

/**
 FakeSubscription.js
 Реализуйте и экспортируйте по умолчанию класс FakeSubscription, который повторяет интерфейс класса Subscription за исключением конструктора. В конструктор FakeSubscription принимает пользователя. Если пользователь администратор user.isAdmin(), то все доступы разрешены, если нет – то запрещены.

 User.js
 Допишите конструктор пользователя, так, чтобы внутри устанавливалась реальная подписка если она передана снаружи и создавалась фейковая в ином случае.
 */

import Subscription from '../Subscription';
import User from '../User';

const user1 = new User('vasya@email.com', new Subscription('premium'));
user1.getCurrentSubscription().hasPremiumAccess(); // true
user1.getCurrentSubscription().hasProfessionalAccess(); // false

const user2 = new User('vasya@email.com', new Subscription('professional'));
user2.getCurrentSubscription().hasPremiumAccess(); // false
user2.getCurrentSubscription().hasProfessionalAccess(); // true

// Внутри создается фейковая, потому что подписка не передается
const user3 = new User('vasya@email.com');
user3.getCurrentSubscription().hasPremiumAccess(); // false
user3.getCurrentSubscription().hasProfessionalAccess(); // false

const user4 = new User('rakhim@hexlet.io'); // администратор, проверяется по емейлу
user4.getCurrentSubscription().hasPremiumAccess(); // true
user4.getCurrentSubscription().hasProfessionalAccess(); // true


// FILE: FakeSubscription.js
class FakeSubscription {
    constructor(user) {
        this.user = user;
    }

    hasProfessionalAccess() {
        return this.user.isAdmin();
    }

    hasPremiumAccess() {
        return this.user.isAdmin();
    }
}

export default FakeSubscription;

// FILE: User.js

import FakeSubscription from './FakeSubscription';

class User {
    constructor(email, currentSubscription = null) {
        this.email = email;

        this.currentSubscription = currentSubscription || new FakeSubscription(this);

    }

    getCurrentSubscription() {
        return this.currentSubscription;
    }

    isAdmin() {
        return this.email === 'rakhim@hexlet.io';
    }
}

export default User;




// >>>>>>> Код, который убивает полиморфизм <<<<<<<
/**
 Формирование объектов
 Посмотрите на функцию ниже и скажите, является ли она полиморфной?
 */

const sayHiByEmail = (user) => {
    const sender = new EmailSender();
    // Отправляем email пользователю
    sender.send(user.getEmail(), 'hi!');
};

/**
 С одной стороны да, пользователь передаётся снаружи и у нас есть возможность его подменить, передав туда объект другого класса. С другой стороны, внутри функции явно используется класс EmailSender и его подменить не получится без переписывания самого кода.

 Этот код демонстрирует простую, но важную идею. Полиморфизм подтипов возможен тогда, когда объект попадает в функцию снаружи, а не конструируется прямо внутри неё.

 Честно говоря, объект можно создавать и внутри функции, но в таком случае имя класса должно формироваться (или получаться) динамически. Этот приём мы рассмотрим позже, в уроке про метапрограммирование.

 Проверка типов
 Ещё один пример с подвохом. Есть ли полиморфизм в коде ниже?
 */

const sayHi = (user) => {
    if (user instanceof User) {
        console.log(`Hello, ${user}!`);
    } else if (user instanceof Guest) {
        console.log('Hello, guest!');
    } else {
        console.log('Who you are?');
    }
};

/**
 В данном примере, вроде бы, всё нормально, объект передаётся снаружи, но есть одна загвоздка. Внутри функции явно проверяется тип, а это значит, что поведение определяется не типом, а сама функция решает как себя вести. Более того, функция жёстко связана с теми типами, которые определены внутри неё и её придётся переписывать при их изменении. И как результат – отсутствие полиморфизма подтипов.

 Проверка типа иногда встречается и её можно использовать к месту, чтобы не усложнять код, но чаще, она говорит о плохом дизайне. Такой код, можно сказать, не соответствует ООП в современном его понимании.

 Для решения задачи выше, есть несколько подходов:

 Перенос логики внутрь самих классов. Тогда код функции превратится в такой: user.sayHi(). С этим подходом нужно быть осторожным, так как легко получить божественный объект. Гораздо чаще нужно применять другой подход.
 Понадобится добавить новый интерфейс в виде методов isUser и isGuest.
 */

const sayHi = (user) => {
    if (user.isUser()) {
        console.log(`Hello, ${user}!`);
    } else if (user.isGuest()) {
        console.log('Hello, guest!');
    } else {
        console.log('Who you are?');
    }
};

// И хотя кода меньше не стало, всё же это полиморфизм подтипов. Код завязан на методы, а не на типы. Изменение структуры классов не коснётся этой функции если сама логика останется той же.



/**@@
 helpers.js
 Реализуйте и экспортируйте по умолчанию функцию getGreeting(user), которая возвращает приветствие для пользователя. Это приветствие показывается пользователю на сайте. Если пользователь гость, то выводится "Nice to meet you Guest!", если не гость, то "Hello <Имя>!", где "<Имя>" это имя реального пользователя.

 В этой задаче, способ решения остается на ваше усмотрение. Используйте знания полученные в этом курсе.
 */

import Guest from '../Guest';
import User from '../User';
import getGreeting from '../helpers';

const guest = new Guest();
getGreeting(guest); // 'Nice to meet you Guest!'

const user = new User('Petr');
getGreeting(user); // 'Hello Petr!'



// FILE: Guest.js:

class Guest {
    constructor() {
        // BEGIN (write your solution here)
        this.type = 'guest';
        // END
        this.name = 'Guest';
    }

    getName() {
        return this.name;
    }

    // BEGIN (write your solution here)
    getTypeName() {
        return this.type;
    }
    // END
}

export default Guest;


// FILE: User.js:
class User {
    constructor(name) {
        // BEGIN (write your solution here)
        this.type = 'user';
        // END
        this.name = name;
    }

    getName() {
        return this.name;
    }

    // BEGIN (write your solution here)
    getTypeName() {
        return this.type;
    }
    // END
}

export default User;


// FILE: helpers.js:

export default (someUser) => {
    const mapping = {
        guest: (guest) => `Nice to meet you ${guest.getName()}!`,
        user: (user) => `Hello ${user.getName()}!`,
    };

    return mapping[someUser.getTypeName()](someUser);
};



// >>>>>>> Инверсия зависимостей <<<<<<<

/**
 Каждый раз, когда внутри функции создаётся объект, появляется зависимость функции от класса этого объекта. Другими словами функция жёстко завязана на работу в паре с конкретным классом. Есть формальный способ, позволяющий легко проверить насколько ваш код завязан в узел. Возьмите любую функцию и мысленно представьте что вы переносите её в другой проект. Сколько за собой она потянет зависимостей (а те в свою очередь свои зависимости)? Если перенос функции потребует переноса большого количества кода, то говорят что в коде высокая связанность.

 Для развязки кода придуман даже специальный термин: Принцип Инверсии Зависимостей. Ещё он известен как DIP из SOLID. Вот его формулировка:

 Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
 Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
 В зависимости от языка, в эти фразы вкладывается немного разный смысл. В общем и целом, они говорят о том, что не нужно завязываться на конкретную реализацию класса. Создание объектов в том месте где они используются, связывает нас с классом этих объектов без возможности его подменить. Правильный подход, с точки зрения этого принципа, инвертировать зависимости, то есть не работать с классами напрямую, а получать объекты нужных классов снаружи, например, через параметры функции.

 Кроме того, DIP говорит о завязке на интерфейсы вместо классов в сигнатурах функций. Об этом мы поговорим позже, когда закончим с основными понятиями.

 Было:
 */

const doSomething = () => {
    const logger = new Logger();
    // some code
};

// Стало:

const doSomething = (logger) => {
    // some code
};

/**
 В докладах на тему DIP, докладчики любят, в качестве аналогии, приводить принцип Голливуда: Не надо нам звонить, мы сами вас наберём. Под этим имеется в виду, что не нужно пользоваться классами напрямую, а вместо этого получать готовые объекты как внешнюю зависимость.

 Нужно ли всегда придерживаться этого принципа? Откровенно говоря, код целиком построенный в таком стиле становится излишне абстрактным и сложным для понимания. В программировании нет серебряных пуль и в каждой конкретной ситуации нужно смотреть на условия и решаемую задачу. Если подмена реализации нужна, то делаем её, если нет – то работаем напрямую.

 Почти всегда, когда речь идёт про инверсию зависимостей, рядом появляется термин "инъекция зависимостей". В то время как DIP говорит о модульности, инъекция зависимостей говорит о конкретных способах её достижения. О том каким образом можно передать зависимости в код использующий их. Всего есть три способа инъектировать зависимости:

 Передать их как аргументы функций или методов. Именно этот способ мы использовали до сих пор.

 doSomethingUsefull(new Logger());
 Через конструктор в тех ситуациях где используются объекты.
 */

const app = new Application(new Logger());

// Через сеттеры. По возможности лучше этот способ не использовать. Он связан с мутацией объектов и нарушением целостности (подробнее было в курсе по объектно-ориентированному дизайну).

const app = new Application();
app.setLogger(new Logger());

/**
 Как видите, за громким термином скрывается очень простая штука – передача параметров. С другой стороны, термины позволяют понять больше смысла без необходимости знать дополнительный контекст. Главное не увлекаться, а то можно превратиться в архитектурных астронавтов.
 */


/**@@
 Создайте полноценное консольное приложение, которое показывает текущую погоду в городе. Оно работает так:

 $ npx babel-node bin/weather.js berlin
 Temperature in berlin: 26C

 Это консольное приложение обращается внутри себя к сервису погоды. Сервис погоды расположен на localhost:8080. Информацию по городу можно извлечь сделав GET запрос на урл /api/v2/cities/<имя города>. Данные от сервиса возвращаются в виде json: { "name": "<имя города>", temperature: "<температура>" }.

 src\WeatherService.js
 Реализуйте логику работы сервиса. Сделайте так, чтобы http-клиент не был зашит внутри класса, используйте инъекцию зависимостей для проброса клиента во внутрь.

 То как выполнять http-запросы через axios можно подсмотреть в его документации.

 bin/weather.js
 Реализуйте код, вызывающий сервис и печатающий на экран ожидаемую строку. Для извлечения города из аргументов командной строки, воспользуйтесь свойством argv глобального объекта process. Первый аргумент (передаваемое имя города) находится под индексом 2. Посмотреть описание и пример можно в документации.

 Подсказки
 Попробуйте ответить на вопросы:

 Сервис погоды это абстракция данных или нет?
 Кто отвечает за формирование текста, который мы ожидаем на выходе?
 Что должен вернуть метод lookup(cityName)?
 Может ли bin содержать определения?
 */

// FILE: WeatherService.js
import { resolve } from 'url';

class WeatherService {
    apiUrl = 'http://localhost:8080/api/v2/';

    constructor(httpClient) {
        this.httpClient = httpClient;
    }

    async lookUp(cityName) {
        const url = resolve(this.apiUrl, `cities/${cityName}`);
        const response = await this.httpClient.get(url);
        return JSON.parse(response.data);
    }
}

export default WeatherService;


// FILE: bin/weather.js

import axios from 'axios';
import WeatheService from '../WeatherService';

const weather = new WeatheService(axios);
const cityName = process.argv[2];

weather.lookUp(cityName).then((data) => {
    const message = `Temperature in ${data.name}: ${data.temperature}C`;
    console.log(message);
});



// >>>>>>> Стратегия (Паттерн) <<<<<<<

/**
 Закрепим пройденную теорию на одном практическом примере, показывающем типичное применение полиморфизма подтипов.

 Представьте себе задачу расчёта стоимости туристической страховки. Эта страховка, которую желательно купить при выезде за границу, на случай внезапных болезней или травм.

 Сумма страховки зависит от большого числа факторов. Некоторые из факторов могут влиять на сам процесс подсчёта стоимости, то есть они изменяют не значения в формуле подсчёта, а саму формулу.

 Конкретно в случае страховок, скорее всего есть одна большая формула, куда подставляются значения и вычисление происходит за один заход. Для нас сейчас главное сама концепция, а не точное знание внутренностей страхового бизнеса.

 Если решать эту задачу в лоб, то она будет выглядеть как большое месиво вычислений со множеством условных конструкций. Со временем такой код становится крайне тяжёлым для восприятия из-за большого числа состояний, которые надо удерживать в голове.
 */

// Примеры с потолка
if (age < 18) {
    let cost = salary * age;

    if (country === 'uganda') {
        cost = cost / 2;
    }
} else if (age >= 18 && age < 24) {
    // ...
}

/**
 Можно ли как-то сделать код понятнее и проще для восприятия? Иногда да. Из всех факторов участвующих в расчёте, нужно попытаться найти те, которые влияют на вычисление глобально. Они проявляются как глобальный if на верхнем уровне. Предположим, что в случае страховки это возраст. То есть считаем что возраст определяет формулу расчёта стоимости страховки. Следующим шагом смотрим на ветки в этой условной конструкции и то, какие диапазоны там указаны. Допустим такую картину:

 До 18
 От 18 до 24
 От 24 до 65
 Старше 65

 Обратите внимание на важную деталь. Выше мы договорились, что каждая возрастная группа, определяет алгоритм расчёта стоимости страховки. То есть они между собой независимы, хотя и сам процесс вычисления местами может быть схож (и будет скорее всего).

 Теперь делаем переход от логической структуры к коду. Каждая возрастная группа - класс, отвечающий за вычисления стоимости для этой группы:
 */

class LessThan18 {
    // Параметры, это те самые факторы, по которым строится вычисление
    calculate(params) {
        // тут считаем и возвращаем результат
    }
}

// Имя конечно так себе, в реальном коде стоит придумать что-нибудь говорящее
class MoreThan18AndLessThan24 {
    // Структура параметров должна 100% совпадать с остальными классами,
    // так как только в этом случае возможен полиморфизм
    calculate(params) {
        // тут считаем и возвращаем результат
    }
}

// Остальные классы
/**
 Главное, что мы получили - разделили процесс вычисления на независимые блоки кода, которые проще для восприятия. Каждый такой класс называется стратегией (вычисления). Очень важно то, что стратегия не является абстракцией, объектом с состоянием и временем жизни. Поэтому данные передаются не в конструктор, а в сам метод (вспомните курс объектно-ориентированный дизайн). По сути, это обычная функция (вычисление), которая упакована в класс только с одной целью — получить полиморфизм подтипов. Всё тоже самое можно сделать (и код будет проще) используя диспетчеризацию функций по ключам.

 Дальше возникает вопрос, а каким образом и где выбрать правильную реализацию, с которой нужно работать? Вариантов здесь несколько. Выбор реализации может быть делегирован внешнему коду, то есть если мы применяем инверсию зависимостей, то работаем уже с готовой стратегией:
 */

calculateCost(strategy, params) {
    strategy.calculate(params);
}

/**
 Пока мы только ушли от проблемы, но не решили её. В любом случае, где-то будет код, который содержит либо условную конструкцию, либо реализует один из способов диспетчеризации, которые мы разобрали в предыдущих уроках. В самом простом случае этот код будет выглядеть так:
 */

chooseCostInsuranceStrategy(user) {
    if (user.getAge() < 18) {
        return new LessThan18();
    } else if (/* ... */) {
        // some code
    }
}

strategy = chooseCostInsuranceStrategy(user);
strategy.calculate(params);

/**
 Как видно по примерам выше, кода с использованием стратегии будет больше (но не так много если используется диспетчеризация функций по ключам в ассоциативном массиве). Это касается фактически всех ситуаций, в которых задействован полиморфизм подтипов в JavaScript. Это цена, которую придётся заплатить за разделение, упрощающее расширение кода и уменьшающее его сложность. С другой стороны, очень легко попасть в ловушку и, наоборот, сделать сложность кода выше, чем оно было до внедрения полиморфизма подтипов. Этот полиморфизм делает код многословным и излишне абстрактным, если применять его налево и направо. А расширение нужно не так часто, как об этом говорят. Более того, инвертировать зависимости можно по ходу действия, когда в этом появляется необходимость.
 */

/**@@
 TicTacToe – известная игра в крестики нолики, на поле 3x3. В этом задании, вам предстоит реализовать данную игру. Основной движок игры находится в файле ticTacToe.js. В директории strategies находится код, который отвечает за поведение AI (искусственный интелект!). В зависимости от выбранного уровня игры, включается либо Easy стратегия, либо Normal.

 Задание специально построено так, чтобы предоставить вам максимальную свободу в организации кода. Результат будет хорошей лакмусовой бумажкой, по которой можно оценить насколько архитектурная тема была понята.

 TicTacToe.js
 Реализуйте класс TicTacToe, который представляет собой игру крестики-нолики. Принцип его работы описан в коде ниже:
 */

// По умолчанию выбран easy уровень. Его можно изменить, передав в конструктор строку 'normal'
const game = new TicTacToe();

// Если переданы аргументы, то ходит игрок. Первый аргумент – строка, второй – столбец.
game.go(1, 1);
// Ход компьютера
game.go();

game.go(0, 1);
game.go();

// Метод go возвращает true если текущий ход победный и false в ином случае
const isWinner = game.go(2, 1); // true

/**
 strategies/Easy.js
 Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно слева направо и сверху вниз (начиная с левого верхнего угла). Как только она встречает свободное поле, то вставляет туда значение.

 strategies/Normal.js
 Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно слева направо и снизу вверх (начиная с левого нижнего угла). Как только она встречает свободное поле, то вставляет туда значение.

 Подсказки
 Нумерация строк и столбцов игрового поля должна начинаться с левого верхнего угла.
 */

// FILE: TicTacToe.js

/* eslint-disable class-methods-use-this */

import Easy from './strategies/Easy';
import Normal from './strategies/Normal';

class TicTacToe {
    mapLevelToStrategy = {
        easy: Easy,
        normal: Normal,
    };

    constructor(level = 'easy') {
        this.strategy = new this.mapLevelToStrategy[level]();
        this.field = [
            Array(3).fill(null),
            Array(3).fill(null),
            Array(3).fill(null),
        ];
    }

    getField() {
        return this.field;
    }

    go(row = null, col = null) {
        if (row === null || col === null) {
            const [autoRow, autoCol] = this.strategy.getNextStep(this.field);
            this.field[autoRow][autoCol] = 'AI';
            return this.isWinner('AI');
        }

        this.field[row][col] = 'Player';
        return this.isWinner('Player');
    }

    isWinner(type) {
        if (this.field.find((row) => this.populatedByOnePlayer(row, type))) {
            return true;
        }

        for (let i = 0; i < 3; i += 1) {
            if (this.populatedByOnePlayer(this.field.map((el) => el[i]), type)) {
                return true;
            }
        }

        const diagonal1 = [this.field[0][0], this.field[1][1], this.field[2][2]];
        if (this.populatedByOnePlayer(diagonal1, type)) {
            return true;
        }

        const diagonal2 = [this.field[2][0], this.field[1][1], this.field[0][2]];
        if (this.populatedByOnePlayer(diagonal2, type)) {
            return true;
        }

        return false;
    }

    populatedByOnePlayer(row, type) {
        return row.every((value) => value === type);
    }
}

export default TicTacToe;


// FILE: strategies/Easy.js

class Easy {
    getNextStep(field) {
        return field.reduce((acc, row, i) => {
            const j = row.indexOf(null);
            if (acc.length === 0 && j !== -1) {
                return [i, j];
            }
            return acc;
        }, []);
    }
}

export default Easy;


// FILE: strategies/Normal.js

class Normal {
    getNextStep(field) {
        return field.reduceRight((acc, row, i) => {
            const j = row.indexOf(null);
            if (acc.length === 0 && j !== -1) {
                return [i, j];
            }
            return acc;
        }, []);
    }
}

export default Normal;




// >>>>>>> Фабрика (Паттерн) <<<<<<<

/**
 Применение полиморфизма подтипов не убирает условные конструкции полностью (кроме некоторых случаев диспетчеризации, например по ключу или по имени файла). Чаще условная конструкция остаётся одна, только на уровне выбора подходящей реализации, а вот затем эта реализация используется внутри полиморфной функции прямым способом без условий. В прошлом уроке мы рассмотрели пример функции, которая выбирает необходимую реализацию стратегии на основе возраста пользователя и возвращает её наружу.
 */

const chooseCostInsuranceStrategy = (user) => {
    if (user.getAge() < 18) {
        return new LessThan18();
    } else if (/* ... */) {
        // some code
    }
}

/**
 Функция, которая: выбирает нужный класс, создаёт объект и возвращает его наружу, называется фабрикой (более точно фабричным методом). Громкое имя для очень простой штуки. Фабрика может быть реализована любым способом включая всё что разбиралось в этом курсе.

 В общем случае фабрикой называют всё подряд, что создаёт объект или коллекции объектов. Причём не обязательно разных классов, класс может быть и один, но сам процесс создания, включает в себя какие-то предварительные вычисления. В реальных проектах фабрики могут быть достаточно большими.

 Фабрики часто реализуются как классы с одним статическим методом – factory. Сами фабрики объектами не делают (иногда таки делают), так как это не абстракция данных, а подменять их смысла нет, иначе получится подмена подменятора.
 */

export default class {
    static factory(/* параметры */) {
        // код фабрики
    }
}


// # Диспетчеризация класса

// JavaScript позволяет создавать объекты, используя ссылку на класс

const className = Application;
const app = new className();

// Такой синтаксис открывает широкий простор для диспетчеризации. Например, в некоторых ситуациях получится уйти от условных конструкций вообще:

import ManagerPolicy from './policies/ManagerPolicy';
import WorkerPolicy from './policies/WorkerPolicy';

// Policy – обычно это имя используют для авторизации, то есть системы проверки прав доступа
const mapping = {
    manager: ManagerPolicy,
    worker: WorkerPolicy,
};

const getUserPolicy = (user) => {
    const className = mapping[user.getType()];
    return new className();
};


/**@@
 ConfigFactory.js
 Создайте фабрику, которая принимает на вход путь до файла конфигурации в формате либо json либо yaml и возвращает объект класса Config. Конструктор класса onfig принимает на вход объект с данными, полученными из конфигурационных файлов и предоставляет к нему доступ с помощью метода getValue.
 */

import path from 'path';
import ConfigFactory from '../ConfigFactory';

const filePath = path.join(__dirname, '__fixtures__', 'test.yml');
const config = ConfigFactory.factory(filePath);
config.getValue('key'); // value
console.log(config.constructor.name); // Config

/**
 Учтите что файлы формата YAML могут иметь разные расширения: yaml и yml. Фабрика должна работать с обоими.

 parsers/JsonParser.js
 Реализуйте класс, отвечающий за парсинг json. Используйте внутри JSON.parse.

 parsers/YamlParser.js
 Реализуйте класс, отвечающий за парсинг yaml. Для парсинга используется сторонний компонент js-yaml. Используйте метод safeLoad.

 Подсказки
 Получить расширение файла можно с помощью path.extname
 Для чтения файлов используйте fs.readFileSync
 */


// FILE: ConfigFactory.js:
import path from 'path';
import fs from 'fs';
import JsonParser from './parsers/JsonParser';
import YamlParser from './parsers/YamlParser';
import Config from './Config';

export default class ConfigFactory {
    static factory(filePath) {
        const mapping = {
            yaml: YamlParser,
            yml: YamlParser,
            json: JsonParser,
        };

        const fileExtension = path.extname(filePath).replace('.', '');
        const parser = new mapping[fileExtension]();
        d
        const rawData = fs.readFileSync(filePath).toString();
        const data = parser.parse(rawData);

        return new Config(data);
    }
}

// FILE: parsers/JsonParser.js:
export default class JsonParser {
    parse(data) {
        return JSON.parse(data);
    }
}

// FILE: parsers/YamlParser.js:
export default class YamlParser {
    parse(data) {
        return yaml.safeLoad(data);
    }
}



// >>>>>>> Шаблоны проектирования (Паттерны) <<<<<<<

/**
 Паттерн проектирования – подход к решению какой-то типовой задачи. Ранее мы уже рассмотрели некоторые из них, начиная от разных видов диспетчеризации, заканчивая Стратегией и Фабрикой. Этих паттернов очень много, каждый день придумываются новые, и даже каждый программист имеет какие-то свои паттерны для своих задач.

 Паттерны, в общем, не связаны с понятием ООП, но именно в ООП их любят структурировать и описывать. Поэтому эта тема особенно распространена в языках с классовой структурой, например Java, C# или PHP. И большинство этих паттернов сводится к тому, как правильно применять полиморфизм подтипов в разных ситуациях. Вот только некоторые из широко известных, которые опираются на полиморфизм:

 Адаптер
 Стратегия
 Абстрактная фабрика
 Мост
 Композит
 Декоратор
 Посредник
 Цепочка ответственности
 Наблюдатель
 Состояние
 Шаблонный метод
 Посетитель

 Некоторые из них связаны с абстракцией и имеют внутреннее состояние, другие – обычные функции, упакованные в классы только ради полиморфизма (но могли бы быть реализованы и обычными функциями, которые диспетчеризуются разными способами).

 В мире ООП паттернов, их основным источником считается книга Приёмы объектно-ориентированного проектирования. Паттерны проектирования. В ней действительно описано много полезных подходов, но будьте осторожны. Учтите следующие моменты:

 > Примеры в книге описаны на языке C++ и имеют более сложную реализацию, чем это нужно в динамических языках.
 > Многие паттерны рождаются вследствие ограничений конкретного языка, например паттерн Команда. В JavaScript это естественный способ писать код и для этого не нужны классы.
 > Не все паттерны описанные в этой книге, так уж важны для веб-разработчиков. Вероятность того, что вам придётся когда-то иметь дело с абстрактной фабрикой, крайне низка.
 > Самих паттернов намного больше чем указано в этой книге. Паттерны это не догма, всё течёт, всё развивается.
 */

// #@ Полиморфизм в паттернах или Паттерн создания Паттернов
/**
 Большая часть паттернов, которая связана с полиморфизмом, строится по одному и тому же принципу. Зная его, вы сможете самостоятельно принимать правильные решения, даже не зная про паттерн для данной ситуации. Ключевая идея состоит в том, что берётся всё множество вариантов поведения и на каждый создаётся свой собственный класс.

 Например в Стратегии, количество классов-стратегий совпадает с количеством разных способов вычисления. Если их будет пять, то придётся создать пять классов. По крайней мере в классовых языках. В языках, где предпочитают функции, будет создано пять разных функций и это всё равно будет Стратегия.
 */

// #@ Антипаттерны

/**
 Раз есть паттерны, значит и существуют антипаттерны, это типовые ошибки, которые совершают программисты. Многие из них имеют вполне конкретные, часто шуточные, названия: "паблик морозов" или "божественный объект". Самое удивительное, что подходы считавшиеся раньше паттернами, иногда перетекают в раздел антипаттернов. Самый яркий пример это паттерн "Одиночка (Singleton)" – объект который может существовать только в единственном экземпляре. Как показала жизнь, это плохо почти всегда. Кроме того, код с синглтонами крайне сложно тестировать.
 */

// #@ Обучение паттернам

/**
 Новичков, которые начитались статей и наслушались старших товарищей, очень волнует вопрос изучения паттернов. Нужно ли их учить? Сколько их учить? По каким книгам и так далее.

 Попробуем разобраться. Как показывает практика, про паттерны все говорят, но мало кто действительно прочитал и понял их и может разумно применять. Причин этому несколько. Во-первых, крайне сложно осознать паттерн не столкнувшись с реальной проблемой, которую он решает. Во-вторых, настоящее понимание паттернов завязано на те вещи, которые мы разбирали на протяжении всей профессии: именование (оно чертовски важно), менеджмент состояния, побочные эффекты, абстракции, расширяемость, полиморфизм подтипов. Без понимания этих вещей, попытка использовать паттерны, почти наверняка, превратится в культ карго. Причём из всего списка выше, паттерны, по эффекту оказываемому на код, находятся на последнем месте.

 Важно понимать что паттерны это не причина, а следствие. Остерегайтесь мышления в стиле "вот есть паттерн, как его натянуть на ситуацию". Сначала нужно понять ситуацию, а потом возникнет паттерн. И совершенно нормально, что первые годы разработки (а у кого-то и больше), задачи будут решаться так как получается. Обучение происходит через ошибки и неправильные решения, этого не надо бояться и избегать. Главное это последовательное улучшение, а здесь помогут книги и наставники (на работе или в сети). О том как лучше читать книги, в том числе по паттернам, мы писали в статье.
 */

/**
 В этом задании будем работать с классами, которые представляют теги HTML. Метод render(), позволяет получить текстовое представление тега:
 */

import InputTag from '../tags/InputTag';

const tag = new InputTag('submit', 'Save');
tag->render(); // <input type="submit" value="Save">

/**
 Предположим, что эта система нужна для генерации разных кусков верстки, которая может быть очень разнообразной. Попробуйте ответить на вопрос, сколько понадобится классов для представления всех возможных комбинаций тегов?

 Если создавать по классу на каждый возможный вариант верстки, то классов будет бесконечно много и смысла в такой реализации очень мало. Но вместо этого лучше использовать композицию. Создать класс для каждого индивидуального тега (в html5 их около 100 штук), а затем путем комбинирования получить все возможные варианты верстки.

 tags/LabelTag.js
 Реализуйте класс LabelTag, который умеет оборачивать другие теги:
 */

import InputTag from '../tags/inputTag';
import LabelTag from '../tags/labelTag';

const inputTag = new InputTag('submit', 'Save');
const labelTag = new LabelTag('Press Submit', inputTag);

labelTag->render();

// <label>
//   Press Submit
//   <input type="submit" value="Save">
// </label>


export default class LabelTag {
    constructor(text, child) {
        this.text = text;
        this.child = child;
    }

    render() {
        return `<label>${this.text}${this.child}</label>`;
    }

    toString() {
        return this.render();
    }
}




// >>>>>>> Объектная композиция <<<<<<<

/**
 В этом уроке, описывается система, которая помогает правильно организовывать код построенный на классах.

 В языках, где ООП построено без инкапсуляции, подобные проблемы решаются проще и возникают реже. Если хочется узнать как это бывает, попробуйте пописать код на Clojure или Elixir.

 Предположим что мы делаем сайт имеющий механизм аутентификации. После её выполнения, пользователю выводится приветствие, которое строится по разному в зависимости от возраста пользователя. Если пользователю не исполнилось 18, то пишется одно, всем остальным — другое.

 В данном случае, реализация в лоб, через if, будет лучшим решением задачи. Но в этом уроке мы отрабатываем использование полиморфизма в рамках классовой модели, поэтому пойдём другим путём. Сама задача специально упрощена, чтобы не тратить время на её анализ

 Первый порыв у многих разработчиков ввести два типа (интерфейса и класса): Under18 и Above18. Дальше в каждом из классов, которые реализуют эти интерфейсы добавить по методу getGreetingMessage(). В итоге мы получили полиморфизм подтипов:
 */

// Где-то в шаблоне
// Правильный класс для пользователя выбирается на момент начала обработки http-запроса -.
// = user.getGreetingMessage()

/**
 Это решение хоть и работает, но ведёт не по тому пути. Сегодня у нас до 18 и после, потом появится отдельное поведение для тех кто старше 65. Всё станет ещё хуже, когда кроме этих разделений, появится дополнительное разделение на девушек и парней. В таком случае мы получим большое число комбинаций, под каждую из которых придётся создать отдельный класс пользователя:

 девушки старше 18
 девушки младше 18
 парни старше 18
 парни младше 18
 ...

 В книжках по паттернам любят приводить пример с разделением средств передвижения по типам: плавающие, летающие и ездящие. А потом, внезапно оказывается, что некоторые одновременно и плавают и ездят.

 Теперь попробуем ответить на вопрос, почему эту задачу не надо решать подтипами в любом случае. Сам по себе, пользователь, это сущность взятая из нашей предметной области. Предметная область и вывод текста на экран, это совершенно разные вещи. Второе относится к логике приложения, но не бизнес-логике. Если об этом не задумываться, то в конце концов настанет момент, когда внутри пользователя окажется вообще всё что только происходит на сайте, ведь оно всё так или иначе связано с самим пользователем. И мы получим божественный объект.

 Правильное решение основано на композиции, подходе при котором создаются классы под конкретные задачи. Начнём сначала. В нашей задаче есть две ситуации: пользователи до 18 лет и пользователи старше. Создадим интерфейс GreetingMessage с методом getGreetingMessage и реализуем его в двух классах, один GreetingForUnder18 и другой GreetingForAbove18. В каждом из них, будет тот вывод, который нужен для конкретного пользователя.

 Как пользователь будет взаимодействовать с объектами этих классов? Варианта два, либо мы передаём его в конструктор, либо в сам метод getGreetingMessage. Что правильнее? Всегда пытайтесь понять, имеем ли мы дело с абстракцией данных или нет. С самим пользователем всё понятно. Пользователь это абстракция данных, у него есть уникальность (все пользователи отличаются) и время жизни. А вот вывод сообщения, это операция без состояния. Само наличие класса и объекта для него обусловлено желанием получить полиморфизм подтипов и ничем более. Поэтому в данном примере лучше передавать пользователя через метод:
 */

// Где-то в шаблоне
// = greeting.getGreetingMessage(user)
// За кадром остался вопрос выбора и создания соответствующего объекта. За это отвечает фабрика, которая вызывается где-то до формирования вывода из шаблона.

const buildGreetingObject = (user) => {
    if (user.getAge() < 18) {
        return new GreetingForUnder18();
    } else {
        return new GreetingForAbove18();
    }
}

/**
 Главное в этой схеме, то что пользователь остался пользователем. Он по-прежнему отвечает только за логику ядра приложения. Даже если добавятся новые условия вывода сообщения и наши два класса превратятся в 10 классов (потому что 10 вариантов вывода в зависимости от разных параметров), то это никак не повлияет на пользователя.

 Что ещё более важно, при появлении новых задач, не связанных с выводом сообщения, пользователь по-прежнему не будет затронут. Например, мы захотим отправлять письма разным пользователям после регистрации. В зависимости от количества видов писем, будет создано такое же количество классов, реализующих интерфейс RegistrationEmailText. Принцип работы останется таким же. Фабрика, выбор нужного типа в начале процесса регистрации и полиморфное поведение при отправке письма.

 Внимательный читатель заметит, что результат подозрительно похож на стратегию. Как ни странно, это и есть стратегия.

 В итоге, в коде появляется большое количество небольших интерфейсов (типов) и множество классов их реализующих. Количество классов, реализующих конкретный интерфейс, равно количеству возможных вариантов поведения. Большинство объектов этих классов не имеют своего состояния и нужны для организации полиморфного кода.

 Стоит ли так писать код? Иногда да, но чаще нет. Слепое следование ООП, делает код сложнее и тяжелее, там где подходит простая функция или условная конструкция, начинают вырастать параллельные иерархии классов. В примерах выше это хорошо прослеживается. Задача, которая может быть реализована десятью строчками, решается многими десятками строчек и четырьмя файлами (фабрика, классы и интерфейс). А программист знакомый с абстрактными классами и наследованием, наворотит ещё больше файлов.

 Обычно, получаемая сложность оправдывается расширяемостью, но это так не работает. Расширяемость нужно добавлять тогда когда нужно и только туда куда нужно. Другой вопрос, что сам способ организации кода через композицию объектов, является краеугольным камнем при организации кода построенного на классах. При этом надо чётко отслеживать, где у нас абстракция данных, а где действия без состояния, представленные объектами.
 */


/**@@
 Адаптер – популярный шаблон проектирования. Он используется тогда, когда нужно использовать код, не поддерживающий необходимый интерфейс. В такой ситуации, создается "обертка" над необходимым кодом, которая поддерживает нужный интерфейс. Это очень похоже на адаптеры электронных устройств в реальной жизни.

 В текущем задании, есть код отвечающий за генерацию паролей, он находится в классе PasswordBuilder. Для генерации паролей, этот класс использует внешний объект.

 Суть данного задания, внедрить в эту систему внешнюю библиотеку.

 Обратите внимание на то, что задача решается не через исправление кода самой библиотеки, а за счет создания адаптера, благодаря которому соединяется код задания и код библиотеки.

 PasswordGeneratorAdapter.js
 Реализуйте класс PasswordGeneratorAdapter, который представляет собой адаптер к пакету generate-password.
 */

import PasswordBuilder from '../PasswordBuilder';
import PasswordGeneratorAdapter from '../PasswordGeneratorAdapter';

const builder = new PasswordBuilder(new PasswordGeneratorAdapter());

// Первый параметр длина пароля (setLength в генераторе)
// Второй, набор опций
// Для настройки генератора смотрите официальную документацию https://github.com/brendanashworth/generate-password
const passwordInfo = builder.buildPassword(10, ['upperCase', 'numbers']);
// {
//    password: '9G/y{JYY',
//    digest: 'aee5e4e6a6cc1fdd77e5669ee49cbcd3ff7e1803',
// }

// Вторым параметром в buildPassword передается набор опций:
/**
 uppercase
 numbers
 symbols
 Каждая из этих опций, соответствует опциям внутри библиотеки generate-password.
 */


import generator from 'generate-password';

export default class PasswordGeneratorAdapter {
    constructor() {
        this.options = {
            symbols: false,
            numbers: false,
            uppercase: false,
        };
    }

    generatePassword(length, options) {
        options.forEach((option) => {
            this.options[option] = true;
        });
        this.options.length = length;

        return generator.generate(this.options);
    }
}