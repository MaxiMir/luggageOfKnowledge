# JQUERY #

```js
jQuery(); // единственная глобальная функция <-> $()

$(); // может встречаться в других фреймворках JS. Поэтому:
$j = jQuery.noConflict(); // удалить псевдоним '$' из глобального пространства имен. Чтобы код с $ необходимо его передать вначале: jQuery(function($) {...});
$j('p').css({'font-size': '5px'});
```

### ОСНОВЫ:

```js
jQuery('.main_items'); // селектор по классу
jQuery('#head'); // селектор по id
jQuery('p', '.nav'); // 2-й параметр - селектор родителя
jQuery('p'); // селектор по тегу

jQuery(document.ready(function() { 
  // <-> jQuery(function($) {...}); - наиболее часто используется. ready() - событие - документ полностью загружен
  alert('Страница загружена');
}));

const h5 = jQuery('<h5>Hello!</h5>'); // возвращает объект с HTML разметкой для послед. работы. !Функция не добавляет разметку и не добавляется на страницу
alert(h5); // => object Object

$('p', '.nav').append(h5); // append() -  добавляет контент внутрь выбранных элементов в конец, после имеющихся
```

### БАЗОВЫЕ СЕЛЕКТОРЫ:

```js
$('*'); // Все элементы
$('*').css({ 'border': '2px solid black' }); // css() - метод для задания стилей для элемента
$('*', '.main_nav').css({ 'border': '2px solid black' }); // задать рамку для всех дочерних элементов .main_nav
$('.class'); // элементы с классом class
$('.main_nav.clearfix'); // элементы с несколькими классами
$('.main_nav .item'); // элементы .item вложенные в .main_nav
$('#id'); // элемент с индентификатором id
$('span'); // элементы с заданным именем тега
$('.main_nav, .footer, span');  // выбор множества
```

### СЕЛЕКТОРЫ ИЕРАРХИИ:

```js
$('.container > .row'); // элементы row, которые являются непосредственными потомками элементов container
$('.parent + .next'); // элемент next, который следует непосредственно за элементом parent (один уровень вложенности)
$('.parent ~ .next'); // элементы next, которые следуют за элементами из parent (один уровень вложенности)
```

### СЕЛЕКТОРЫ ПО АТРИБУТАМ:

```js
$('[name]'); // элементы содержащие атрибут name
$('[src]');
$('[class]');
$('img[alt]');
$('[name = value]'); // элементы, у которых значение атрибута name совпадает с value
$('[name != value]'); // элементы, у которых значение атрибута name не совпадает с value
$('[name ^= value]'); // элементы, у которых значение атрибута name начинается с value
$('[class $= value]'); // элементы, у которых значение атрибута class заканчивается на value
$('[name *= value]'); // элементы, у которых значение атрибута name содержит подстроку value
$('[name ~= value]'); // элементы, у которых значение атрибута name содержит слово(т.е отделено пробелом) value
$('[name |= value]'); // элементы, у которых значение атрибута name имеют префикс value (равен value или имеет вид value-*)
$('[class|=full]'); // => '.full...' или '.full-...'
$('[class|=full], [name], [data-type="submit hello"]'); // элементы, соответсвующие всем заданным условиям на атрибуты одновременно. Если 1 слово ковычки можно не ставить, т.е data-type=submit
```

### СЕЛЕКТОРЫ ПО ФИЛЬТРУ:

```js
$('input[name=name]').focus(); // сфокусировать на поле input[name=name]
':focus' // элемент, находящийся в фокусе
':first' // первый найденный элемент <-> .eq(0)

$('input:first');
':last' // последний найденный элемент <->
':eq()' // элемент под заданным номером. Индексация с 0. Если < 0, отсчет с конца
':not(selector)' // все найденные элементы, кроме указанных в selector

$('input:not(input:eq(2))');
':even' // элементы с четными номерами позиций
':odd' // элементы с нечетными номерами позиций
':gt(n)' // элементы c индексом > n
':lt(n)' // элементы c индексом < n
':header' // элементы, явл. заголовками
':hidden' // невидимые элементы

$('input:hidden').attr('type', 'text'); // задание атрибутов
':visible' // видимые элементы
':lang(language)' // элементы, в которых указаны языки содержимого

$(':root') // корневой элемент документа - <html>
```

### ФИЛЬТРЫ ДОЧЕРНИХ ЭЛЕМЕНТОВ:

```js
// !!! nth - индексация начинается с 1
':first-child' // первые дочерние элементы

$('p:first-child');
':last-child' // последние дочерние элементы
':nth-child()' // элементы с определенным порядком

$('p:nth-child(even)'); // четные дочерние элементы

$('p:nth-child(2n+1)'); // 1,3,5,..
':nth-child-last()' // (четные/нечетные под опред. индексом)
':only-child' // единственные по типу потомки в родительских категориях
':only-of-type' // единственные потомки, заданного селектора
':first-of-type' // первые потомки заданного селектора

$('p:first-of-type');
':last-of-type' // последние потомки заданного селектора
':nth-first-of-type' // дочерние элементы заданного селектора

$('p:nth-of-type(1)'); // один элемент этого типа
':nth-last-of-type' // c определ. порядком
```

### ФИЛЬТРЫ ПО СОДЕРЖИМОМУ:

```js
':contains(text)' // элементы с заданным текстом

$('span:contains("hello")');
':empty' // пустые элементы
':has(selector)' // элементы, которые содержат элемент из selector

$('div:has(i, span)');
':parent' // непустые элементы
```

### ФИЛЬТРЫ ЭЛЕМЕНТОВ ФОРМ:

```js
':button' // элементы с тегом button или типом button
':radio' // радио-кнопки
':checkbox' // элементы чек-боксы(checkbox)
':text' // текстовые поля
':password' // поля ввода пароля
':file' // поля загрузки файлов
':submit' // кнопки отправки формы
':reset' // кнопки очистки формы
':image' // изображения для отправки формы
':input' // элементы формы (input, textarea или button)
':selected' // выбранные элементы со статусом selected
':focus' // элементы находящиеся в фокусе
':checked' // выбранные элементы (со статусом checked)
':enabled' // активные элементы формы (со статусом enabled)
':disabled' // активные элементы формы (со статусом disabled)
```

### РАБОТА СО СТИЛЯМИ И АТРИБУТАМИ:

```js
const elem = document.body

elem.attr() // возвращает/изменяет значение атрибута
elem.removeAttr() // удаляет атрибут у выбранных элементов

elem.addClass() // добавляет класс к выбранным элементам на странице
elem.removeClass() // удаляет класс(ы) у элементов на странице
elem.toggleClass() // изменяет наличие класса(ов) у элементов на противоположное
img.toggleClass('redClass', true); // при true - только добавление, без удаления
img.toggleClass((index, className) => { // работа с коллекцией элементов
  if (className === 'redClass') {
    return 'greenClass';
  } else if (className === 'redClass greenClass') { // функция удалит оба класса
    return '';
  }

  return 'redClass';
});

elem.hasClass('foo') // проверяет наличие заданного класса хотя бы у одного из выбранных элементов
elem.val() // возвращает/изменяет значение атрибута value

$('input').val(function (ind, v) { // => в атрибут val будет записан порядковый номер элемента
  return ind;
});
```

### РАБОТА С ПАРАМЕТРАМИ И СТИЛЯМИ:

```js
elem.css(); // Возвращает/изменяет CSS параметры
elem.css('width', 100);
elem.css({ // с помощью литерал объекта
  'width': 100,
  'height': 50,
  'marginBottom': 10
});

elem.css('width'); // => 100px
elem.css('borderWidth', function (ind, v) {
  return ind * 2;
});

elem.height(); // возвращает/изменяет высоту элемента без учета внутр. и внешн. отступа. Работает только с первым элементом в выборке
elem.height(300);
elem.innerHeight(); // высота элемента вместе с учетом внутреннего оступа.
elem.outerHeight(); // высота элемента вместе с учетом внутреннего оступа и толщины рамки
elem.outerHeight(true); // -//- если true + внешний отступ

elem.width(); // возвращает/изменяет ширину элемента без учета внутр. и внешн. отступа. Работает только с первым элементом в выборке
elem.innerWidth(); // ширина элемента вместе с учетом внутреннего оступа.
elem.outerWidth(); // ширина элемента вместе с учетом внутреннего оступа и толщины рамки
elem.outerWidth(true); // -//- если true + внешний отступ

elem.position(); // возвращает/изменяет позицию элемента относительно ближайшего родителя, у которого задан тип позиционирования (relative/absolute/fixed)
elem.offset(); // возвращает кооридинаты выбранного элемента относительно начала страницы
elem.offset().left; // позиция от левого края страницы
elem.offset().top; // позиция от верхнего края страницы
elem.offset({ left: 200, top: 50 }); // изменение позиционирования элемента

elem.scrollTop(); // возвращает/изменяет величину вертикального скролла
elem.scrollLeft() // возвращает/изменяет величину горизонтального скролла
$(document).scrollTop(1000); // document - текущая html страница. Перемещает горизонтальную полосу прокрутки
```

### ДОБАВЛЕНИЕ СОДЕРЖИМОГО:

```js
elem.html() // возвращает/изменяет html-содержимое элементов на странице
  .text() // возвращает/изменяет текст, находящийся в элементах на странице
  .append()  // добавляет заданное содержимое в конец элементов на странице
  .appendTo()

$(content)
  .appendTo(selector)
  .prepend() // добавляет заданное содержимое в начало элементов на странице
  .prependTo()

$(content)
  .prependTo(selector)
  .after() // добавляет заданное содержимое после элемента на странице
  .insertAfter()

$(content)
  .insertAfter(selector)
  .before() // добавляет заданное содержимое перед элементом на странице
  .insertBefore()

$(selector).before(content)

$(content).insertBefore(selector)
  .wrap() // окружает элементы на странице заданными html-элементами. Оборачивает каждый элемент выборки

$('.inner').wrap(function () {
  return '<div class=\'' + $(this).text() + '\'></div>';
});

elem.wrapInner(); // обертывает содержимое выбранных элементов заданными html-элементами. Таким образом получается, что все выбранные объекты "обертываются изнутри".

elem.wrapAll() // оборачивает все элементы
$('.inner').wrapAll('<div class=\'new\'></div>');

elem.unwrap() // удаляет родительские элементы, при этом их содержимое остается на месте
```

### УДАЛЕНИЕ СОДЕРЖИМОГО:

```js
elem.detach() // удаляет элементы на странице
elem.remove() // удаляет элементы на странице

$('.sf-menu li').remove(); // удаляем все li в .sf-menu
$('.sf-menu li').remove('.current');  // удаляем все li c классом .current в .sf-menu

const p = $('.label.massage').remove(); // сохраняем удаленный элемент. записи о привязанных обработчиках событий этого эл-та удаляются. ! С detach() остаются
$('#content-form fieldset').append(p);

elem.empty(); // удаляет содержимое элементов на странице
$('.sf-menu li').empty();
```

### МЕТОДЫ АНИМАЦИОННЫХ ЭФФЕКТОВ:

```js
elem.hide(); // скрывает/показывает (display: none) элементы на странице за счет плавного изменения его размера и прозрачности
elem.show();
elem.toggle(); // показывает или скрывает выбранные элементы

elem.slideUp(); // разворачивает/сворачивает элементы на
elem.slideDown(); // странице за счет плавного изменения высоты элементов
elem.slideToggle(); // поочередно разворачивает/сворачивает элементы на странице
elem.slideToggle(900);

elem.fadeIn(); // скрывает/показывает (opacity: 0) элементы на странице
elem.fadeOut(); // за счет плавного изменения прозрачности

elem.fadeTo(); // плавно изменяет прозрачность элементов.
elem.fadeTo(1000, 0.5); // продолжительность анимации (1с.) / задание прозрачности
elem.fadeToggle(); // поочередно скрывает/показывает элементы на странице

elem.animate(); // выполняет анимацию, созданную пользователем
elem.queque(); // представляет/изменяет очередь функций
elem.clearQueue(); // очищает очередь функций
elem.dequeue(); // начинает выполнение след. функции в очереди
elem.stop(); // останавливает выполнение текущей анимации
elem.delay(); // приостанавливает выполнение след. анимаций на заданное время
```

### СОБЫТИЯ МЫШИ:

```js
elem.click() // устанавливает обработчик `клика` мышью по элементу, либо, запускает это событие
elem.dbclick() // устанавливает обработчик двойного `клика` по элементу, либо, запускает это событие
elem.hover() // устанавливает обработчик двух событий: появления/исчезновения курсора над элементом

elem.mousedown() // устанавливает обработчик нажатия кнопки мыши, либо, запускает это событие
elem.mouseup() // устанавливает обработчик поднятия кнопки мыши, либо, запускает это событие

elem.mouseenter() // устанавливает обработчик появления курсора в области элемента, либо, запускает это событие. Появление этого события, отработано лучше, чем стандратного mouseover. Не обладает св-вом `всплытия`
elem.mouseleave() // устанавливает обработчик выхода курсора из области элемента, либо, запускает это событие. Появление этого события, отработано лучше, чем стандратного mouseout. Не имеет обладает св-вом `всплытия`

elem.mousemove() // устанавливает обработчик движения курсора в области элемента, либо, запускает это событие

elem.mouseover() // устанавливает обработчик появления курсора в области элемента, либо, запускает это событие. Обладает св-вом `всплытия`
elem.mouseout() // устанавливает обработчик выхода курсора из области элемента, либо, запускает это событие. Обладает св-вом `всплытия`


elem.mouseenter({ a: 'hello', b: 'world' }, event => { // в {} можно передать необ. параметры. event - объект event object - текущее событие
  elem.stop().fadeIn(300); // при наведении показывается список. stop() - для отмены пред. запущенных анимаций (для корректного показа тек. анимации).
});

elem.mouseleave(() => {
  elem.stop().fadeOut(300); // при наведении скрывается список. stop() - для отмены пред. запущенных анимаций (для корректного показа тек. анимации).
});

// <->

elem.hover(
  () => elem.stop().fadeIn(300),
  () => elem.stop().fadeOut(300)
);
```

### СОБЫТИЯ КЛАВИАТУРЫ:

```js
elem.keydown() // устанавливает обработчик перехода клавиши клавиатуры в нажатое состояние, либо, запускает это событие
elem.keyup() // устанавливает обработчик возвращение клавиши клавиатуры в ненажатое состояние, либо, запускает это событие
elem.keypress() // устанавливает обработчик ввода символа с клавиатуры, либо, запускает это событие

$('input[name=name]').keydown(function (event) {
  alert(event.which); // .which - свойство код нажатой клавиши => 75
});

$('input[name=name]').keyup(function (event) {
  alert(event.which); // .which - код символа => 1040
  const email = $('input[<name></name>=email]');
  email.val($(this).val()); // вводимые символы дублируются в другую область
});
```

### СОБЫТИЯ ФОРМЫ:

```js
elem.focus() // устанавливает обработчик получения фокуса, либо, запускает это событие. Событие не `всплывает`
elem.blur() // устанавливает обработчик потери фокуса, либо, запускает это событие. Событие не `всплывает`
elem.focusin() // устанавливает обработчик получения фокуса самим элементом или одним из его дочерних. Событие `всплывает`
elem.focusout() // устанавливает обработчик потери фокуса самим элементом или одним из его дочерних. Событие `всплывает`
elem.select() // устанавливает обработчик выделения текста, либо, запускает это событие
elem.submit() // устанавливает обработчик отправки формы, либо, запускает это событие
elem.change() // устанавливает обработчик изменения элемента формы, либо, запускает это событие. Сработает когда элемент потеряет фокус

$('input[name=name]').focus({}, function () { // фокус на элементе
  $(this).val('Введите текст');
});

$('input[name=name]').blur({}, function () { // потеря фокуса
  alert('Закончили?');
});

$('input[name=name]').select(function () {
  alert('Выбран элемент');
});

$('.form').submit(function (e) {
  e.preventDefault(); // форма не будет отправляться
  alert($('input[name=name]').val());
});
```

### СОБЫТИЯ ЗАГРУЗКИ СТРАНИЦЫ:

```js
$(document).ready() // устанавливает обработчик готовности дерева DOM
$(document).load() // устанавливает обработчик завершения загрузки элемента
$(document).unload() // устанавливает обработчик ухода со страницы (при переходе по ссылке, закрытии браузера и т.д.)
```

### СОБЫТИЯ БРАУЗЕРА:

```js
$(document).error() // устанавливает обработчик ошибки при загрузке элементов(например, отстутствие необходимой картинки на сервере)
$(document).resize() // устанавливает обработчик изменения размеров окна браузера, либо, запускает это событие
$(document).scroll() // устанавливает обработчик `прокрутки` элементов документа, либо, запускает это событие

$('img').error(function () { });
$(window).resize(function () { }); // в () функция-обработчик

$(function () {
  // один обработчик на 2 события:
  $(window).on('resize scroll', { user: 'Max Min' }, function (e) { // ! лучше везде использовать on. Если заменить .on на .one - события обработаются 1 раз.
    $('#resize-text').text('Width: ' + window.innerWidth + ', Height: ' + window.innerHeight);
    $('#scroll-text').text('Position Y: ' + window.scrollY);
  });

  // обработчики отдельно:
  $(window).on({
    resize: function () {
      $('#resize-text').text('Width: ' + window.innerWidth + ', Height: ' + window.innerHeight);
    },
    scroll: function (e) { // ! e - необходимо указать для .data
      $('#scroll-text').text('Position Y: ' + window.scrollY);
      console.log(e.data.user);
    }
  }, { user: 'Max Min' }); // данные для передачи в функцию-обработчик
});

/*
<div id='scroll' style='left: 90%; top: 90%; opacity: 0.6; width: 100px; height: 30px; background-color: gray; display: none'>UP</div>
*/

$(function () {
  $(window).scroll(function () { // функция поднимает скролл вверх, при клике на появл. элемент
    if ($(this).scrollTop() > 500) { // .scrollTop() - на сколько px передвинули скролл
      $('#scroll').fadeIn(500); // показываем скрытый элемент
    }
  });

  $('#scroll').click(function () {
    $(window).scrollTop(0); // поднимаем вверх скролл
  });
});

// (*) метод on поддерживает делегированную обработку событий. Событие вешается на родителя элемента:

elem.on('click', 'li', function (e) { // обработчики для нескольких событий, указываются через ' '. 'li' - селектор
  e.preventDefault(); // отмена стандартного поведения элемента
  $('sf-menu').append('<li><a href="index-2.php">Item2</a></li>');
}); // !При клике на новые элементы меню, событие клик срабатывает (*).

elem.off(); // удаляем ранее зарегистрированный(е) обработчик(и)
elem.off('resize'); // удаляем определенный обработчик

elem.on('click.my', 'li', function () { }); // .my - указываем пространство имен


$('.sf-menu').bind('click', {}, function () { }); // аналог .on(). Не поддерживает делегированную обработку событий. УСТАРЕЛ (с вер.1.7) И УДАЛЕН (с вер. 1.9)!
$('.sf-menu li').inbind(); // удаление обработчиков событий зарегистрированных с помощью спец. методов(.click() и т.д.) и .bind(), .one()

$('.sf-menu').live(); // устанавливает обработчик событий для выбранного элемента. Поддерживает делегированную обработку событий. УСТАРЕЛ (с вер.1.7) И УДАЛЕН (с вер. 1.9)!
$('.sf-menu').die(); // удаление обработчиков событий зарегистрированных с помощью live()

$('.sf-menu').delegate('li', 'click', {}, function () { }); // метод - делегированная обработка событий. УСТАРЕЛ!
$('.sf-menu').undelegate(); // удаление обработчиков событий зарегистрированных с помощью delegate()

$('.sf-menu li').one('click', function () { }); // событие обработается только 1 раз для 1 элемента

$('.sf-menu li').trigger('click'); // вызывает событие у выбранных элементов, что приводит к запуску обработчиков этого события

$('.sf-menu li').on('myEvent', function () { }); // регистрация пользовательского события
$('.sf-menu li').trigger('myEvent'); // инициализация пользовательского события

// или можно так:
$('.sf-menu li').click(function () {
    $(this).trigger('myEvent');
});

$('.sf-menu li').triggerHandler('click'); // позволяет выполнить код функции-обработчика конкретного события без инициализации данного события
```

### МЕТОДЫ РАБОТЫ С КОЛЛЕКЦИЕЙ ЭЛЕМЕНТОВ:

```js
elem.children() // находит все дочерние элементы у выбранных элементов. При необходимости, можно указать селектор для фильтрации
elem.closest() // находит ближайший, соответсвующий заданному селектору элемент, из числа следующих: сам выбранный элемент, его родитель, его  прародитель, и т.д. до начала дерева DOM
elem.find() // находит элементы по заданному селектору, внутри выбранных элементов
elem.next() // находит элементы, которые лежат непосредственно после каждого из выбранных элементов
elem.nextAll() // находит все элементы, которые лежат после каждого из выбранных элементов
elem.nextUntil() // находит элементы, которые лежат каждого из выбранных, но не дальше элемента, удолетв. заданному селектору
elem.prev() // находит элементы, которые лежат непосредственно до каждого из выбранных элементов
elem.prevAll() // находит все элементы, которые лежат до каждого из выбранных
elem.offsetParent() // возвращает ближайшего предка с позиционированием, отличным от static
elem.parent() // находит родительские элементы у всех выбранных элементов
elem.parents() // находит всех предков у выбранных элементов,т.е. не только прямых родителей, но и прародителей, прапрародителей и тд., до начала дерева DOM - тега html
elem.parentsUntil() // находит предков, как и .parents, но прекращает поиск перед элементом, удолетворяющим заданному селектору(не попадает в выборку).
elem.siblings() // находит все соседние элементы (под соседними понимаются элементы с общим родителем), при этом сами выбранные элементы в результат не включаются.
```

### МЕТОДЫ ФИЛЬТРАЦИИ:

```js
elem.eq() // возвращает элемент, идущий под заданным номером в наборе выбранных элементов
elem.filter() // фильтрует набор выбранных элементов с помощью заданного селектора или функции
elem.first() // возвращает первый элемент в наборе
elem.has() //  фильтрует набор выбранных элементов, оставляя те, которые имеют потомков, соотвествующих селектору
elem.is() //  проверяет, содержится ли в наборе, хотя бы один элемент, удолетворяющий заданному селектору
elem.last() // возвращает последний элемент в наборе
elem.not() // возвращает элементы, не соответсвующие заданным условиям
elem.slice() // возвращает элемнеты с индексами из определенной области (например, от 0 до 5)

$('.address').eq(1); //  2-й элемент выборки
$('.address').eq(-1); // последний элемент выборки

$('li').filter(function (ind, val) { // код функции будет вызываться для каждого эл-та выборки
  return $(this).attr('class') == 'current;'; // true -> данный элемент будет включент в выборку, иначе будет исключен из выборки
  // или
  return ind % 2 == 0;
});

$('div').has('.mini-items'); // выбирает все элементы, которые имеют один или более элемент, содержащийся внутри них.
$('span').parent().not('div, h1'); // выборка родителей span, всех кроме div,h1
$('span').parent().not(function (ind) {
  return $(this).is('h2'); // если h2 - элемент будет исключен
  // если возвращается true - элемент не попадает в выборку
  // если возвращается false - элемент попадает в выборку
});

if ($('section').is('.mini-items')) { }

$('section').is($('.mini-items')); // jQuery выборка

$('div').slice(4); // выбрать элементы из выборки начиная и включая элемент с индексом 4
$('div').slice(4, 8); // выбрать элементы из выборки начиная и включая элемент с индексом 4 до 8(не входит)
```

### МЕТОДЫ ОБРАБОТКИ ВЫБОРКИ:

```js
elem.each() // вызывает заданную функцию для каждого элемента набора
elem.map() // вызывает заданную функцию для каждого элемента набора, и в итоге создает новый набор из значений, возвращенных этой функцией

// сохраняем ширину картинок в массив:
const widths = [];

$('img').each(function (ind, elem) { // elem <-> $(this)
  widths.push($(elem).width()); // push() - добавляет элемент в конец массива
});

const result = $('li').map(function (ind, elem) {
  return $(elem).text();
});

result.get(); // get() - конвертация из объекта в массив

$('li').add('.address', 'section_main'); // добавление элементов c классом .address из .section_main в выборку

$('div')
  .find('span')
  .css('background-color', 'yellow')
  .andSelf()
  .css('border', '1px solid red'); // добавляет предыдущий набор jQuery к текущему в пределах одной цепочки команд и возвращает объединенный набор. Теперь объединим текущий объект jQuery с предыдущим и установим красную границу вокруг всех элементов <div> и элементов <span> внутри них.

$('grid_7').children().each(function () { // текст в div .grid_7 метод children() проигнорирует
  alert($(this).text());
});

// а здесь нет:
$('grid_7').contents().each(function () {
}); // contents - возвращает все дочерние элементы выбранных элементов, а также текстовое содержимое и комментарии

$('li').parent().css({ 'border': '1px solid red' }).end().css({ 'border': '1px solid black' }); // возвращает предыдущий набор элементов
```

### AJAX:

```js
$('#ajax').ajaxSend(function (e, XHR, obj) {
  alert('send')
}); // XHR - чистый XMLHttpRequest. Функция-обработчик вызывается перед отправкой запроса

$('#ajax').ajaxСomplete(function (e, XHR, obj) {
  alert('complete')
}); // функция-обработчик вызывается после завершения запроса

$('#ajax').ajaxSuccess(function (e, XHR, obj) {
  alert('success')
}); // функция-обработчик вызывается после удачного завершения запроса

$('#ajax').ajaxError(function (e, XHR, obj) {
  alert('error')
}); // функция-обработчик вызывается после неудачного завершения запроса

const jqXHR = $.get('server.php', result, function (data, status, jqXHR) {
}, 'json'); /* запрос методом GET.
1-й аргумент - путь к скрипту-обработчику,
2-й аргумент - отправляемые данные,
3-й аргумент пользовательская callback-функция, которая будет вызвана после ответа сервера,
4-й - тип данных ожидаемых от сервера.
data - данные возвращемые сервером, status - статус выполнения запроса.
Метод возвращает объект jQuery XMLHttpRequest */
jqXHR.done(() => {}); // функция-обработчик выполняется в случае успешного выполнения запроса к серверу
jqXHR.fail(() => {}); // функция-обработчик выполняется в случае ошибочного выполнения запроса к серверу
jqXHR.always(() => {}); // функция-обработчик выполняется в любом случае
jqXHR.then(() => {}, data => {}); // 1 функция-обработчик выполняется в случае успешного выполнения запроса к серверу, 2 - в случае ошибочного

jqXHR = $.post('server.php', result, (data, status, jqXHR) => { }, 'json'); // запрос методом POST

jqXHR = $.getJSON('server.php', result, (data, status, jqXHR) => {}) // запрос JSON данных у сервера методом GET
// <->
$.ajax({
  url: 'server.php',
  dataType: 'json',
  data: result,
  success: function (data, status, jqXHR) {
  }
});

jqXHR = $.getScript('server.php', function (data, status, jqXHR) { }) // запрос скрипта(например, echo 'alert("HI!")') у сервера методом GET

$('grid_5').load('server.php', result, function (data, status, jqXHR) { }, 'json'); // загружает данные с сервера (html) и вставляет в указанный элемент.

```

### УТИЛИТЫ:

```js
const el = document.getElementById('stuck_container');

if ($.contains(document.body, el)) { // проверяет на содержание в 1-ом аргументе 2-го аргумента.
  $(el).css({'border': '1px solid red'}); // JS->JQuery элемент
}

const ul = $('.sf-menu');
$.data(ul, 'data', 'Hello World!'); // метод позволяет хранить данные, привязанные к определенному элементу
console.log($.data(ul, 'data')); // => Hello World!

const nums = {
  one: 10,
  two: 20
}

$.data(ul, 'data', nums);
$.data(ul, 'data').one // => 10;
$.data(ul, 'data').two // => 20;

$.removeData(ul); // удаляет все данные, привязанные к определенному элементу
$.removeData(ul, data); // удаляет данные по ключу, привязанные к определенному элементу


const object1 = {
  one: 10,
  two: 20,
  three: {
    val1: 'Hello',
    val2: 'world',
    val3: '!'
  }
}

const object2 = {
  one: 100,
  four: 'string',
  three: {
    val1: 'Ben',
    val2: 'Bob'
  }
};

const result = $.extend(object1, object2); // метод объединяет содержимое 2-х или более объектов. Возвращает 1-й исходный объект, при результат операции записывается в 1-й переданный объект

JSON.stringify(result); // приведение в строку формата JSON => {'one':100, 'two':20,'three':{'val1':'Ben','val2':'Bob'},'four':'string'}

result = $.extend(true, object1, object2); // false - по умолч., при true - рекурсивное объединение объектов


const arr = [1,2,3,4,5,6,7,8,9,10];

function func(el, ind) {
  if (el === 4 || ind === 2) {
    return false;
  } else {
    return true;
  }
}

$.grap(arr, func); // ищет в заданном массиве элементы, удовлетворяющие условиям фильтрующей функции. Возвращает массив с найденными элементами (в исходный массив изменения не вносятся). => [1,2,5,6,7,8,9,10];

$.grap(arr, func, true); // вернет те ячейки, для которых функция вернула false => [3,4]



const info = [1, 'Bob', 'Ben'];
$.inArray('Bob', info); // ищет заданный элемент в массиве. Возвращает индекс этого элемента или -1 в случае его отсутствия => 1

$.isArray(info); // проверяет, является ли заданный элемент массивом => true

$.isEmptyObject(info); // позволяет узнать является ли переданный объект пустым => false

$.isFunction(func); // проверяет, является ли заданный элемент функцией => true

$.isNumeric('hello'); // проверяет, является ли заданный элемент числом или может быть к нему приведен => false

$.isPlainObject({ 'one':'hello' }); // проверяет, является ли заданный элемент пользовательским объектом (создан через {} или new Object()) => true

$.isWindow(window); // проверяет, является ли заданный элемент объект типом Window => true

$.makeArray(obj); // Конвертирует массивоподобные объекты, в массивы => [object HTMLLIElement].[object HTMLLIElement].[object HTMLLIElement].

$.merge(obj1, obj2); // объединяет содержимое двух массивов. Результат объединения записывается в первый из этих массивов (он же будет возвращен в качестве результата выполнения функции).

$('a').click($.noop()); // пустая функция (т. е. которая ничего не делает). Может быть использована в случаях, когда по каким-либо причинам нужно установить пустые функции обратного вызова (callback)

$.parseJSON('{ "name":"Jorn" }'); // конвертирует строку с json-данными в javascript-объект.

const str = '<li><a href="#">Hi!</a></li>';
const html = $.parseHTML(str); // преобразует переданную строку с HTML-кодом в массив DOM-узлов самого верхнего уровня. Пробелы в начале и конце строки тоже будут преобразованы в текстовые узлы. Чтобы этого избежать можно воспользоваться функцией $.trim().
elem.append(html);

$.trim('     Hello World       '); // удаляет символы пробелов, табов и переносов строк из начала и конца строки => Hello World

$.now(); // <-> new Date().gateTime() возвращает количество миллисекунд с начала эпохи UNIX => 1476999670122

$.type({}); // возвращает тип данных => object
```
