// ###### JS: Автоматическое тестирование ######

/**
 Код профессиональных разработчиков содержит меньше ошибок, чем код начинающих. Это происходит не потому, что они умнее, внимательнее к деталям или видят код насквозь. Настоящая причина кроется в том, что они пишут тесты.

 Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их на приемлемом уровне. Тесты дают уверенность, что изменения в одной части системы не сломали другие части.

 Однако, тесты нужны не только для проверки работоспособности кода. Существуют и другие автоматизированные виды тестов, например, тесты производительности или тесты на уязвимости.

 Среди разных видов автоматизированных тестов, программисты, в первую очередь, отвечают за функциональные тесты. Эти тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы. Например, регистрация пользователя должна, как это ни странно, регистрировать пользователя. И тесты это подтверждают.

 По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

 > Модульные
 > Интеграционные
 > Системные

 Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты. У программистов на такие тесты должно быть направлено основное внимание. Их всё ещё достаточно просто писать (если экосистема проекта подготовлена к этому) и они охватывают гораздо большую часть системы.

 Наиболее сложные и максимально эффективные — системные тесты. В случае сайтов — это тестирование через браузер. Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. Сложность этих тестов в том, что им приходится опираться на вёрстку сайта, которая часто и непредсказуемо меняется. Кроме того, в браузере невозможно точно определить, когда закончилось одно действие и началось другое (с точки зрения программы). Именно поэтому такие тесты часто ломаются, их сложно писать и поддерживать.

 Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты. Этот курс знакомит с общими принципами тестирования и шаг за шагом проводит через все возникающие во время тестирования задачи.
 */



// #>>>>>> Зачем и как писать тесты? <<<<<<

/**
 Какую главную задачу должны решать тесты? Этот вопрос невероятно важен. Ответ на него даёт понимание того, как правильно писать тесты и как писать их не нужно.

 Представьте, что вы написали функцию capitalize(text), которая делает заглавной первую букву переданной строки:
 */

capitalize('hello'); // 'Hello'


// Вот один из вариантов её реализации:

const capitalize = text => {
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};


/**
 Что мы делаем после создания функции? Проверяем, как она работает. Например, открываем REPL и вызываем функцию с разными аргументами:

 $ node
 Welcome to Node.js v12.4.0.
 > capitalize('hello')
 'Hello'
 > capitalize('how are you')
 > 'How are you'

 Таким нехитрым способом убеждаемся, что функция работает. По крайней мере для тех аргументов, которые мы передали в неё. Если во время проверки заметили ошибки, то исправляем функцию и повторяем всё заново.

 Фактически, весь этот процесс и есть тестирование. Но не автоматическое, а ручное. Задача такого тестирования — убедиться, что код работает как надо. И нам совершенно без разницы, как конкретно реализована эта функция. Это и есть главный ответ на вопрос, заданный в начале урока.

 Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.
 */


// #@ Автоматические тесты

/**
 Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

 Даже если вы не знакомы с исключениями, ничего страшного. В этом курсе достаточно знать две вещи: для чего они нам нужны и какой у них синтаксис. До сих пор в курсах Хекслета вы встречались с ошибками, которые возникают непроизвольно: вызов несуществующей функции, обращение к несуществующей константе и так далее. Но ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. Исключения создаются такой конструкцией:
 */

throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');


// Пример теста:

if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
    // Выбрасываем исключение и завершаем выполнение теста
    throw new Error('Функция работает неверно!');
}

/**
 Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он работает в том же окружении и подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой. Обнаруженные ошибки в тестах исправляются и жизнь продолжается дальше ;)

 В коде, тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:

 src/
 ├── bin
 │   └── hexlet.js
 ├── half.js
 └── index.js
 tests/
 └── half.test.js


 Структура этой директории зависит от того, на базе чего пишутся тесты, например, на базе какого фреймворка. В простых случаях, она отражает структуру исходного кода. Если предположить, что наша функция capitalize(text) определена в файле src/capitalize.js, то её тест лучше поместить в файл tests/capitalize.test.js. Слово test в имени модуля с тестами, используется только для более явного обозначения цели файла.

 Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:

 $ node tests/capitalize.test.js
 # Если все хорошо, код молча выполнится.
 # Если есть ошибка, то будет выведено сообщение об ошибке.
 */


// #@ Как пишутся тесты

/**
 Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые функции, вызывать их с необходимыми аргументами и проверять, что функции возвращают ожидаемые значения.

 Если поменялась сигнатура функции (входные или выходные параметры, её имя), то придётся переписывать тесты. Если сигнатура осталась той же, но поменялись внутренности функции:
 */
const capitalize = (text) => {
    const [firstSymbol, ...restSymbols] = text;

    return `${firstSymbol.toUpperCase()}${restSymbols.join('')}`;
};

/**
 Тогда тесты должны продолжать работать без изменений.

 Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.
 */


// #@ Сколько и какие нужно писать проверки?

/**
 Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически не осуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

 При написании тестов нужно ориентироваться на разнообразие входных данных. У любой функции есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

 > Работа с пустой строкой
 > Обработка null
 > Деление на ноль (в большинстве языков вызывает ошибку)
 > Специфические ситуации для конкретных алгоритмов

 Для capitalize пограничным случаем будет пустая строка:
 */
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

/**
 Добавив тест на пустую строку, мы увидим, что вызов показанной в начале урока функции capitalize завершается с ошибкой. Внутри неё идёт обращение к первому индексу строки без проверки его существования. Исправленная версия кода:
 */

const capitalize = (text) => {
    if (text === '') {
        return '';
    }
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};

/*
    В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария:

    > Функция выполнилась так, что не был выполнен ни один условный блок
    > Функция выполнилась так, что был выполнен только первый условный блок
    > Функция выполнилась так, что был выполнен только второй условный блок
    > Функция выполнилась так, что были выполнены оба условных блока

    Комбинация всех возможных вариантов поведения функции называется цикломатической сложностью. Это число показывает все возможные пути кода внутри функции. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

    Иногда пограничные случаи не связаны с условными конструкциями. Особенно часто такие ситуации встречаются там, где есть вычисления границ слов или массивов. Такой код может работать в большинстве ситуаций, но только в некоторых может давать сбой:
*/



// В этой функции забыли отнять единицу от длины
// Этот код сработает в некоторых ситуациях (когда последний элемент undefined) или в массиве нет элементов
// Но в остальных случаях вернёт неверное значение
const last = (elements) => elements[elements.length];


// #@ Проверка входных данных

/**
 Особняком стоят ошибки типов входных данных. Например, в функцию capitalize можно передать число вместо строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

 Ещё один интересный вопрос. Нужно ли внутри capitalize обрабатывать такие ситуации? Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних уровнях.

 Ответственность за передачу правильных данных в функцию capitalize лежит не на ней, а на коде, который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

 Но даже если ошибка обрабатывается внутри функции, это не значит, что надо бросаться писать тест, покрывающий данную ошибку. Попытка покрывать каждую (особенно ошибочную ситуацию) тестами, выливается в огромное число тестов, которые требуют поддержки и времени на написание. Нужно уметь во время остановиться и двигаться дальше, к покрытию другого или нового кода.
 */

// #@ Собирая всё вместе

//

/*
 В конечном итоге мы получили такую структуру директорий:
    src/
    └── capitalize.js
    tests/
    └── capitalize.test.js

    Содержимое теста:
*/

if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');

/*
    Запуск:

    $ node tests/capitalize.test.js

    Если всё написано правильно, то запуск тестов завершится с выводом строки Все тесты пройдены! Если в тестах или в коде есть ошибка, то сработает исключение и мы увидим сообщение, указывающее на это.
 */


/*
    // FILE: /tests/collection.test.js

    Напишите тесты для функции get(obj, key, defaultValue). Тесты должны быть построены по такому же принципу, как это описывалось в теории урока: проверка через if и исключение в случае провала теста.

    Эта функция извлекает значение из объекта при условии, что ключ существует. В ином случае возвращается defaultValue.
*/

get({ key: 'value' }, 'key'); // 'value'
get({}, 'key', 'defaultValue'); // 'defaultValue'


import getFunction from '../functions';

const get = getFunction();

if (get({ key: 'value' }, 'key') !== 'value') {
    throw new Error('boom!');
}
if (get({}, 'key', 'value') !== 'value') {
    throw new Error('boom!');
}
if (get({ key: 'value' }, 'key', 'default value') !== 'value') {
    throw new Error('boom!');
}



// # >>>>>> Утверждения (Asserts) <<<<<<#

/**
 Каждую проверку, которую мы написали для функции capitalize, в тестировании принято называть утверждением (assert). Утверждения — ключевая часть тестов. Именно они проверяют функциональность кода:
 */

import capitalize from '../src/capitalize';

// Первое утверждение (проверка на пустую строку)
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

// Второе утверждение (проверка на слово)
if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

/**
 Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Node.js поставляется с модулем assert, в котором есть несколько функций, упрощающих написание утверждений:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert(capitalize('') === '');
assert(capitalize('hello') === 'Hello');

/**
 В самом простом случае assert используется как функция, которая проверяет истинность переданного значения. Другими словами, assert(true) означает что всё хорошо, а assert(false) говорит об ошибке. Последний вариант выбрасывает исключение с таким сообщением:

 AssertionError [ERR_ASSERTION]: false == true

 Расшифровка сообщения: "Ожидалось, что значением выражения будет истина, но оказалось, что это ложь". Кроме сообщения, выводится трассировка стека (стектрейс), по которому можно найти сработавшее утверждение.

 Функция assert сделала наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

 С другой стороны, вывод сообщения об ошибке крайне не информативный. Единственный способ понять, что произошло — открывать код с упавшим утверждением (ещё есть вариант передать сообщение об ошибке последним параметром, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий). Это пытаются исправить с помощью специализированных утверждений, заточенных под конкретные ситуации. Например, при сравнении двух значений подходит функция assert.equal(actual, expected). Перепишем код выше:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert.equal(capitalize(''), '');
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize('hello'), 'Hello');

/**
 Вывод таких утверждений значительно понятнее:

 Thrown:
 AssertionError [ERR_ASSERTION]: 'hello' == 'Hello'
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: 'hello',
 expected: 'Hello',
 operator: '=='

 В этом выводе есть не только информация об ошибке, но и данные, которые передавались в утверждение. Такой формат упрощает анализ проблемы и ускоряет отладку.

 Однако, будьте осторожны. Функция equal(actual, expected) проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются, как не эквивалентные:

 > assert.equal({}, {})
 Thrown:
 AssertionError [ERR_ASSERTION]: {} == {}
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: {},
 expected: {},
 operator: '=='

 > assert.equal({ key: 'value'  }, { key: 'value'  });
 Thrown:
 AssertionError [ERR_ASSERTION]: { key: 'value'  } == { key: 'value'  }
 generatedMessage: true,
 name: 'AssertionError [ERR_ASSERTION]',
 code: 'ERR_ASSERTION',
 actual: { key: 'value'  },
 expected: { key: 'value'  },
 operator: '=='


 Для сравнения по значению используется ещё одно утверждение: assert.deepEqual(actual, expected). Оно опирается только на содержимое:

 assert.deepEqual({}, {}); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'value' }); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'another value' }); // Boom!

 Для тестирования негативных сценариев предназначены функции assert.notEqual(actual, expected) и assert.notDeepEqual(actual, expected). Они тестируют то, что значения не равны. Эти утверждения используются крайне редко, но знать о них всё равно полезно.

 # Дополнительные материалы
 Asserts https://nodejs.org/api/assert.html
 Chai https://www.chaijs.com/
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции take(items, n), которая возвращает первые n элементов из массива:
 */

take([1, 2, 3], 2); // [1, 2]
take([], 2); // []
take([4, 3], 9); // [4, 3]


// FILE: tests/take.test.js
import assert from 'assert';
import getFunction from '../functions';

const take = getFunction();

assert.deepEqual(take(['one', 'two', 8], 9), ['one', 'two', 8]);
assert.deepEqual(take([1, 2]), [1]);
assert.deepEqual(take(['one', 'two', 'three'], 2), ['one', 'two']);
assert.deepEqual(take([]), []);




// # >>>>>> power-assert <<<<<<#

/**
 У обычных утверждений есть мощная альтернатива: power-assert https://github.com/power-assert-js/power-assert. Эта библиотека добавляет магию в привычный инструмент.

 Вот пример проверки с использованием стандартного модуля assert:
 */

const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

assert(user.name === 'Michel');

// AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:
//  assert(user.name === 'Michel')

/*
    В выводе видно само утверждение и результат проверки. Но непонято, что за объект user и какая у него структура. Для получения этой информации придётся включаться в отладку. Но вместо этого можно воспользоваться библиотекой power-assert:
*/

import assert from 'power-assert'; // !

// Весь код остаётся тем же самым
const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

// Интерфейс библиотеки power-assert на 100% совместим со встроенным модулем assert.
assert(user.name === 'Michel'); // =>

/**
 AssertionError [ERR_ASSERTION]:   # test.js:10

 assert(user.name === 'Michel')
 |    |    |
 |    |    false
 |    "Madonna"
 Object{name:"Madonna",friends:#Array#,email:"madonna@gmail.com"}

 --- [string] 'Michel'
 +++ [string] user.name
 @@ -1,6 +1,7 @@
 M
 -ichel
 +adonna


 Попробуйте остановиться и внимательно изучить этот вывод. Что здесь показано? power-assert облегчает отладку настолько, насколько это вообще физически возможно. Он показывает значение каждого объекта и результат каждой операции, входящей в выражение, переданное в функцию assert. Кроме того, в конце он сравнивает строки и говорит, в чём конкретно было различие между ними.

 Вот ещё один интересный пример из документации:
 */

import assert from 'power-assert';

const ary = [1, 2, 3];
const zero = 0;
const two = 2;

assert(ary.indexOf(zero) === two);

// AssertionError [ERR_ASSERTION]:   # test.js:7
//
//   assert(ary.indexOf(zero) === two)
//          |   |       |     |   |
//          |   |       |     |   2
//          |   -1      0     false
//          [1,2,3]
//
//   [number] two
//   => 2
//   [number] ary.indexOf(zero)
//   => -1

/**
 Впечатляет? Большинство современных фреймворков не выдаёт настолько удобный вывод, насколько это делает power-assert. Хорошая новость в том, что его можно интегрировать с чем угодно.
 */



/**@@@
 tests/indexOf.test.js
 Напишите тесты для функции indexOf(items, value), которая возвращает индекс переданного элемента:
 */

_.indexOf([1, 2, 1, 2], 2); // 1
_.indexOf([2, 'one', 'cat', false], 8); // -1


// FILE: /tests/indexOf.test.js

import assert from 'power-assert';
import getFunction from '../functions';

const indexOf = getFunction();

assert(indexOf(['one', 'two', 8], 'two') === 1);
assert(indexOf([1, 8, 9, 3, 9], 9) === 2);
assert(indexOf([], 9) === -1);




// # >>>>>> Jest <<<<<<#

/**
 Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?

 Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод. С большинством из этих возможностей мы познакомимся далее по курсу. В JavaScript мире наиболее популярен фреймворк Jest, разрабатываемый компанией Facebook. К слову, с помощью него мы тестируем все практики на Хекслете.

 Ниже находится инструкция, в которой мы создадим с нуля npm-проект и добавим в него тесты.
 */

// #@ Настройка и запуск

/**
 Создайте где-нибудь на вашем компьютере директорию с названием hexlet-jest. Зайдите в неё и выполните команду:

 $ hexlet-jest $ npm init

 Ответьте на все вопросы запущенного скрипта инициализации проекта. Убедитесь, что в корне проекта появился файл package.json.

 Теперь добавим немного исходного кода. Создайте файл src/index.js с таким содержимым:
 */

// Эта функция переворачивает переданную строку
export default str => str.split('').reverse().join('');

/*
    Jest — обычный npm-пакет, который локально подключается в разрабатываемый проект. Jest нужен только во время разработки, поэтому лучше установить его в секцию devDependencies:

    # В директории с проектом
    $ hexlet-jest $ npm i --save-dev jest

    По умолчанию Jest не использует Babel, поэтому код с импортами внутри Jest не заработает. Для поддержки Babel нужно установить несколько дополнительных пакетов:

    $ hexlet-jest $ npm i --save-dev babel-jest @babel/core @babel/preset-env

    Далее создайте в корне проекта файл babel.config.js с таким содержимым:
*/

module.exports = {
    presets: [['@babel/preset-env', {targets: {node: 'current'}}]],
};

/**
 После установки этих пакетов и настройки babel.config.js, Jest начнёт использовать Babel при запуске тестов. Никакая конфигурация больше не требуется.

 По умолчанию (но этим можно управлять) Jest ожидает, что тесты находятся в директории __tests__ в корне проекта. Внутри этого каталога, можно создавать любую структуру, Jest найдёт все тесты, которые там лежат. Именование файлов с тестами должно быть таким: <name>.test.js. Где <name>, как правило, это имя соответствует имени модуля, который тестируется.

 Напишем наш первый тест. Создайте файл __tests__/index.test.js со следующими содержимым:
 */

import reverse from '../src';

test('reverse', () => {
    expect(reverse('hello')).toEqual('olleh');
    expect(reverse('')).toEqual('');
});

/**
 Далее мы разберём структуру этого файла, а пока попробуем запустить тест на выполнение:

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms)

 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        1.166s
 Ran all test suites.

 Ура! Тесты прошли успешно.
 */

// #@ Структура

/**
 Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

 Функция test нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms) # название теста


 Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутри Jest, который уже решает как и когда запускать тесты. Это позволяет проводить различные оптимизации например, выполнять тесты параллельно.

 Самое необычное в этом коде — проверки. Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

 > Вызывается функция expect куда передаётся актуальное (фактическое) значение.
 > На результате, возвращаемом функцией expect, вызывается подходящий матчер, например, toEqual.
 */
// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse('hello')).toEqual('olleh');

/**нейших особенностей Jest — то, как он выводит сообщения о проваленных проверках. Попробуйте внести ошибку в исходную функцию и запустите тесты заново:

 hexlet-jest$ npx jest
 FAIL  __tests__/index.test.js
 ✕ reverse (9ms)

 ● reverse

 expect(received).toEqual(expected) // Object.is equality

 Expected: "olleh"
 Received: "o|l|l|e|h"

 3 | test('reverse', () => {
          4 |   const str = 'hello';
        > 5 |   expect(reverse(str)).toEqual('olleh');
            |                        ^
          6 | })
 7 |

 at Object.toEqual (__tests__/index.test.js:5:24)

 Test Suites: 1 failed, 1 total
 Tests:       1 failed, 1 total
 Snapshots:   0 total
 Time:        1.683s
 Ran all test suites.

 В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла с тестами с указанием на конкретную проверку. Это невероятная и очень полезная фишка, которая значительно ускоряет анализ результатов тестирования и помогает в отладке.

 # Дополнительные материалы
 Jest https://jestjs.io/
 Блоки тестов (Describe) https://jestjs.io/docs/ru/api#describename-fn


 ? Как правильно запускать Jest на выполнение?
 > npx jest
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции without(coll, [values]), которая принимает первым параметром массив и возвращает его копию, из которой исключены значения, переданные вторым и последующими параметрами.
 */
_.without([2, 1, 2, 3], 1, 2); // [3]

// FILE: /tests/take.test.js

import getFunction from '../functions';

const without = getFunction();

test('without', () => {
    expect(without([], 3)).toEqual([]);
    expect(without([3, 8, 9, 8, 10], 8, 10)).toEqual([3, 9]);
});




// # >>>>>> Матчеры (Expectations) <<<<<<#

/**
 Существует несколько популярных способов описывать утверждения. Кроме вызова обычных функций, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок.

 Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать (В идеале, на практике всё сложнее). Матчеры заменили собой обычные утверждения на функциях во многих языках:
 */

// Проверка равенства по ссылке
// assert.equal([1, 2], [1, 2])
expect([1, 2]).toBe([1, 2]); // false

// Проверка равенства по значению
// assert.deepEqual([1, 2], [1, 2])
expect([1, 2]).toEqual([1, 2]); // true


/**
 Любой матчер в Jest начинается с функции expect(data), в которую передаются данные на проверку. Затем expect возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. В Jest десятки матчеров для самых разнообразных ситуаций. Такое количество объясняется желанием выдавать максимально точный отчёт о том, что произошло.

 Предположим, что функция возвращает массив и мы хотим проверить его размер. Для этого можно воспользоваться матчером toBe:
 */

const data = [1, 2, 3];
// take берет первые n элементов
// assert.equal(take(data, 2).length, 2)
expect(take(data, 2).length).toBe(2);

// Этот матчер прекрасно справится с задачей. Но в случае ошибки его вывод не слишком информативен:

expect(received).toBe(expected); // Object.is equality

// Expected: 2
// Received: 1

// Поэтому лучше взять специализированный матчер для проверки размера массива:

expect(take(data, 2)).toHaveLength(2);

/**
 Тогда вывод расскажет гораздо больше:

 expect(received).toHaveLength(expected)

 Expected length: 2
 Received length: 1
 Received array:  [1, 2]

 Благодаря тому, что в expect передаётся сам массив, а не его длина, у Jest появляется возможность выводить содержимое массива в случае ошибки. Это, опять же, упрощает отладку.

 Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:
 */

expect(null).toBeNull();

// Проверяет значение на truthy (любое значение, которое приводится к true)
expect(true).toBeTruthy();
// Точное сравнение с true
expect(true).toBe(true);

expect(undefined).toBeUndefined();

// Проверка, что массив содержит элемент
expect([1, 2, 3]).toContain(2);

// Проверка, что строка содержит подстроку
expect('hello, world').toMatch('hello');

// Проверяет, что в объекте есть свойство с определённым значением
expect({ key: 'value' }).toHaveProperty('key', 'value');


// Кроме того, к любому матчеру можно применить модификатор not, который инвертирует поведение матчера:

expect(null).not.toBeNull(); // not null
expect(undefined).not.toBeUndefined(); // not undefined
expect([1, 2, 3]).not.toContain(2); // not contain 2
expect('hello, world').not.toMatch('hello'); // not match hello

// Особняком стоит матчер toMatchObject. Он используется, когда нас в тестах интересует не весь объект, а только какая-то его часть:

const user = {
    firstName: 'tolya',
    lastName: 'petrov',
    age: '33',
};

// Тест пройдёт успешно, так как проверяется только firstName
expect(user).toMatchObject({ firstName: 'tolya' });

/**
 Это далеко не все матчеры, которые есть в Jest. Более того, Jest достаточно гибкий и может расширяться собственными матчерами. На Гитхабе можно найти библиотеки с матчерами для разных ситуаций.

 В целом, вам придётся постоянно заглядывать в документацию, чтобы вспомнить, что там есть. Иначе всё может свестись к использованию toEqual. Пожалуй, это основной недостаток использования матчеров — необходимость помнить про них и правильно применять.

 # Дополнительные материалы
 Матчеры Jest https://jestjs.io/docs/ru/expect
 */


/**@@@
 tests/gt.test.js
 Напишите тесты для функции _.gt(value, other), которая возвращает true в том случае, если value > other, и false в иных случаях.
 */

gt(3, 1); // true
gt(3, 3); // false
gt(1, 3); // false


// FILE: /tests/gt.test.js
import getFunction from '../functions';

const gt = getFunction();

test('gt', () => {
    expect(gt(0, 0)).toBe(false);
    expect(gt(1, 0)).toBe(true);
    expect(gt(1, -3)).toBe(true);
});

// FILE: /functions.js
import _ from 'lodash';

const functions = {
    right1: _.gt,
    wrong1: _.gte,
    wrong2: _.eq,
};

export default () => {
    const name = process.env.FUNCTION_VERSION || 'right1';
    return functions[name];
};




// # >>>>>> Модульные тесты <<<<<<#


/*
    Изученной информации уже достаточно для тестирования в повседневной практике разработки. Перед тем, как погружаться в более сложные темы и возможности Jest, пройдём полный путь тестирования библиотеки, поговорим об организации тестов, хороших и плохих практиках. Это поможет сформировать правильное отношение к тестированию в целом.

    В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: функции, модули, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

    Попробуем протестировать стек. Напомню, что стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. Сам стек, как правило, используется для реализации алгоритмов. Ещё его много в низкоуровневом коде: например, внутри языков программирования или операционных систем.
*/

import makeStack from '../src/stack';

const stack = makeStack();
stack.isEmpty(); // true
stack.push(1); // (1)
stack.push(2); // (2, 1)
stack.push(3); // (3, 2, 1)
stack.isEmpty(); // false
stack.pop(); // 3. В стеке (2, 1)
stack.pop(); // 2. В стеке (1)
stack.pop(); // 1. В стеке пусто
stack.isEmpty(); // true


/**
 Сначала решим организационные вопросы. Если предположить, что реализация стека лежит в файле src/stack.js, то его тест мы положим в файл __tests__/stack.test.js.
 */

// #@ Тестируем основную функциональность

/**
 Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:
 */

import makeStack from '../src/stack.js';

test("stack's main flow", () => {
    const stack = makeStack();
    // Добавляем два элемента в стек и затем извлекаем их
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
    expect(stack.pop()).toEqual('one');
});

/**
 Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

 В интернете можно встретить мнение, что несколько проверок в рамках одного теста это неправильно. Что тесты нужно детализировать максимально подробно и создавать новый тест на каждую проверку.
 */

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
});

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    stack.pop();
    expect(stack.pop()).toEqual('one');
});


// #@ Тестируем дополнительную функциональность

// Следующим тестом будет тест на дополнительные функции стека. К таким у нас относится функция isEmpty(), которая проверяет, пустой ли стек:

test('isEmpty', () => {
    const stack = makeStack();
    expect(stack.isEmpty()).toBe(true);
    stack.push('two');
    expect(stack.isEmpty()).toBe(false);
    stack.pop();
    expect(stack.isEmpty()).toBe(true);
});

/*
    В этом тесте проверяются сразу три ситуации:
    > начальное состояние стека
    > состояние стека после добавления элементов
    > состояние стека после извлечения всех элементов

    В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty() всё равно сломается. Нужно ли пытаться найти все варианты? Не нужно. Тесты не даются бесплатно, каждая написанная строчка кода в проекте — потенциальное место для изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только тогда, когда они критичны для работоспособности.
*/

// #@ Пограничные случаи

/**
 Ну, и последнее, что можно протестировать — поведение функции pop(), когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение, если из него попытались взять элемент, когда тот был пустой. Поэтому здесь подойдёт матчер toThrow().
 */

test('pop in empty stack', () => {
    const stack = makeStack();
    // Вызов метода pop обёрнут в функцию, иначе матчер не сможет перехватить исключение
    1
});

/**
 Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать проект в допустимых рамках забагованности.

 # Дополнительные материалы
 Чек-лист хороших инженерных практик в компаниях https://guides.hexlet.io/check-list-of-engineering-practices/


 > Если обнаружился баг, то сначала надо написать тест и только потом чинить его
 > Тесты не должны зависеть друг от друга
 */

/**@@@
 tests/validator.test.js
 Напишите тесты для класса Validator. Этот класс проверяет корректность данных. Принцип работы валидатора следующий:

 1. С помощью метода addCheck(fn) в него добавляются проверки. Каждая проверка представляет из себя функцию-предикат, которая принимает на вход проверяемое значение и возвращает либо true либо false в зависимости от того, соответствует ли значение требованиям проверки или нет.

 2. С помощью метода isValid(value), пользователь объектов класса Validator проверяет соответствие значения всем добавленным проверкам. Если не было добавлено ни одной проверки, считается, что любое значение верное.
 */

const validator = makeValidator();
validator.isValid('some value'); // true
validator.addCheck((v) => v > 5);
validator.isValid(3); // false
validator.isValid(8); // true
validator.addCheck(/* add more checks */);



// FILE: /__tests__/validator.test.js
import { isNumber } from 'lodash';
import getImpelementation from '../implementations';

const makeValidator = getImpelementation();


test('validator', () => {
    const validator = makeValidator();
    expect(validator.isValid('value')).toBe(true);

    validator.addCheck(isNumber);
    validator.addCheck((v) => v > 10);
    validator.addCheck((v) => v % 2 === 0);

    expect(validator.isValid(false)).toBe(false);
    expect(validator.isValid('string')).toBe(false);
    expect(validator.isValid(8)).toBe(false);
    expect(validator.isValid(11)).toBe(false);

    expect(validator.isValid(12)).toBe(true);
    expect(validator.isValid(100)).toBe(true);
});





// # >>>>>> Подготовка данных <<<<<<#

/**
 Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. Особенно в части начальной подготовки данных. В прошлом уроке каждый тест начинался со строчки: makeStack(). Это ещё не дублирование, но уже шаг в эту сторону. Как правило, реальные тесты сложнее и включают в себя большую подготовительную работу.

 Допустим, мы разрабатываем библиотеку Lodash и хотим протестировать её функции для обработки коллекций:

 > find
 > filter
 > includes
 > и другие (всего их около 20 штук)

 Для работы этих функций нужна заранее подготовленная коллекция. Проще всего придумать одну, которая подойдёт для тестирования большинства или даже всех функций:
 */

import _ from 'lodash';
test('includes', () => {
    // Подготовили коллекцию coll
    const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

    // Используем coll для тестирования
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Теперь представьте, что таких тестов несколько десятков (в реальности их сотни). Код начнёт кочевать из одного места в другое, порождая всё больше и больше копипасты.

 Самый простой способ избежать этого — вынести определение коллекции на уровень модуля, вне тестовых функций:
 */

import _ from 'lodash';

const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

test('includes', () => {
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Это простое решение убирает ненужное дублирование. Однако учтите, оно работает только в рамках одного модуля. Подобную коллекцию всё равно придётся определять в каждом тестовом модуле. И в нашем случае это скорее плюс, а не минус.

 Дело в том, что излишнее обобщение, приводящее к полному устранению дублирования, вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт к поломке большинства тестов, которые завязаны на её структуру, на количество элементов и их значения:
 */

import _ from 'lodash';

const coll = [1, 2, 3];

test('filter', () => {
    // Выбираем только чётные
    expect(_.filter(coll, (v) => v % 2 === 0)).toEqual([2])
});

/**
 Тест выше сломается, если мы добавим в нашу коллекцию чётное число. А коллекцию почти наверняка придётся расширять при добавлении новых тестов (для этой же или других функций).

 Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, после которой обобщение начинает больше мешать, чем помогать.

 Но далеко не всегда можно выносить константы на уровень модуля. В первую очередь это касается динамических данных. Представьте себе такой код:
 */

const now = new Date();

test('first example', () => console.log(now));
test('second example', () => console.log(now));

//  console.log __tests__/index.test.js:3
//    2019-07-08T21:52:27.036Z
//
//  console.log __tests__/index.test.js:4
//    2019-07-08T21:52:27.036Z

/**
 Подвох тут в том, что модуль загружается в память ровно один раз. Это значит, что весь код, определённый на уровне модуля (включая константы), выполняется ровно один раз. В примере константа now определится до запуска всех тестов, и только затем jest начнёт выполнять тесты. И с каждым последующим тестом отставание значения константы now от текущего реального значения "сейчас" будет всё дальше и дальше.

 Почему это может быть проблемой? Код, который работает с понятием "сейчас", может рассчитывать на то, что "сейчас" это почти моментальный снимок данного момента времени. Но в примере выше, сейчас начинает отставать от реального сейчас и чем больше тестов и чем они сложнее, тем большее отставание.

 Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его во внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между загрузкой модуля и отработкой тестов проходит неопределённое время.

 Для решения этой проблемы тестовые фреймворки предоставляют хуки — специальные функции, которые запускаются до или после тестов. Ниже пример того, как создавать дату перед каждым тестом:
 */

let now;
let counter = 0;

// Запускается перед каждым тестом
beforeEach(() => {
    now = new Date();
    counter += 1;
});

test('first example', () => console.log(now, counter));
test('second example', () => console.log(now, counter));

//  console.log __tests__/index.test.js:9
//    2019-07-08T21:53:23.521Z 1
//
//  console.log __tests__/index.test.js:10
//    2019-07-08T21:53:23.525Z 2

/**
 beforeEach(callback) принимает на вход функцию, внутри которой выполняется инициализирующее действие. Оно не обязательно приводит к созданию переменных. Возможно, инициализация заключается в подготовке файловой системы, например, созданию файлов.

 Но если она должна создать данные и сделать их доступными в тестах, то придётся использовать переменные, определённые на уровне модуля. Так как всё, что определяется внутри функций (колбека в нашем случае), остаётся внутри этой функции.

 ? Что нужно учитывать при работе с колбеками Jest?
 > Матчеры должны находиться внутри тестов, а не колбеков Jest
 > Тесты не должны влиять друг на друга. Данные всегда должны возвращаться в исходное значение после каждого теста.

 ? Как обеспечить в тестах доступ к данным, созданным внутри колбеков Jest?
 > Через this
 */

/**@@@
 tests/set.test.js
 Напишите тесты для функции set(obj, path, value), которая возвращает и изменяет (или добавляет) значение в объект по указанному пути. Функция мутирует объект.
 */

const object = { a: [{ b: { c: 3 } }] };

set(object, 'a[0].b.c', 4);
console.log(object.a[0].b.c); // => 4

set(object, ['x', '0', 'y', 'z'], 5);
console.log(object.x[0].y.z); // => 5



// FILE: /__tests__/set.test.js
import { cloneDeep } from 'lodash';
import getFunction from '../functions';

const set = getFunction();

let data;
let dataCopy;

beforeEach(() => {
    data = {
        a: [
            {
                b: {
                    c: 3,
                },
            },
        ],
    };
    dataCopy = cloneDeep(data);
});

test('plain set', () => {
    set(data, 'a', 'value');
    dataCopy.a = 'value';
    expect(data).toEqual(dataCopy);
});

test('nested set', () => {
    set(data, 'a[0].b.c', true);
    dataCopy.a[0].b.c = true;
    expect(data).toEqual(dataCopy);
});

test('set new property', () => {
    set(data, 'a[0].b.d', false);
    dataCopy.a[0].b.d = false;
    expect(data).toEqual(dataCopy);
});




// # >>>>>> Плохие и хорошие практики тестирования <<<<<<#

/**
 Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо. Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности, о которых надо знать. В этом уроке мы пройдёмся по некоторым из них.
 */

// #@ Взаимное влияние тестов

/**
 Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

 Нарушить это правило очень просто. Один тест может создать файл, изменить переменную или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, или наоборот — успешно пройти там, где не должны проходить. Кроме этого, в такой ситуации вводится неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. Например, когда тест запускают изолированно, то он работает, а когда вместе с остальными — падает:
 */

let user;

test('first', () => {
    user = new User();
    // ...
});

test('first', () => {
    // Используется пользователь, которого создал другой тест!
    // Этот тест зависит от того, как работает предыдущий тест,
    // и не может работать без последовательного запуска обоих тестов.
    user.name = 'Petya';
});

/**
 Особенно часто такая ситуация возникает в тестах, активно взаимодействующих с внешней средой: базой данных или файловой системой. Тестирование побочных эффектов имеет свои хитрости и рассматривается в продвинутом курсе по тестированию.
 */

// #@ Тест вне тестов

/**
 Задача beforeEach — готовить данные и среду для тестирования, а задача test — вызывать код, который тестируется, и проводить проверки. Но иногда разработчики переусердствуют:
 */

let result;

beforeEach(() => {
    // Вызывается тестируемый код. Это противоречит идее beforeEach.
    result = sum(5, 9);
});

test('result', () => {
    // Здесь только проверка
    expect(result).toEqual(14);
});

// В этом примере тестируемый код вызывается в beforeEach. Такой подход усложняет анализ тестов, так как переворачивает всё с ног на голову.


// #@ Слишком сильная детализация

/**
 Программисты под влиянием голосов из интернета стремятся максимально разносить код по файлам, модулям и функциям. То же самое наблюдается и в тестах. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка:
 */

test('create user', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.age).toEqual(28);
});

test('create user 2', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.name).toEqual('Mark');
});

/**
 Чаще всего, единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда кода станет по-настоящему много.
 */

// #@ Глубокая вложенность

// Jest позволяет группировать тесты в блоки describe:

describe('User', () => {
    test('should be valid', () => { /* ... */ });
});

/**
 Они помогают структурировать сложные тесты и задать для каждого блока describe свой собственный beforeEach. Хотя такая возможность бывает полезна, но очень легко начать использовать её во вред:
 */

describe('', () => {
    describe('...', () => {
        describe('...', () => {
            test('should be valid', () => { /* ... */ })
        });
    });
});

/**
 Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру. Из-за этого возникают сложности при добавлении новых проверок. Становится непонятно, к чему она относится. Это проблема любых иерархий, которые рассматривают систему только с одной точки зрения.
 */

// #@ Код с тестами писать дольше, чем код без тестов

/**
 Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

 > Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
 > Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
 > Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
 > Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
 > Тесты снижают уровень стресса.


 # Дополнительные материалы
 Начинаем писать тесты правильно https://www.youtube.com/watch?v=zsz8kdi62mE
 */


/**@@
 tests/cart.test.js
 Напишите тесты для класса Cart, представляющего собой покупательскую корзину. Интерфейс:

 1. addItem(good, count) – добавляет в корзину товары и их количество. Товар это объект у которого два свойства: name – имя и price – стоимость.
 2. getItems – возвращает товары в формате [{ good, count }, { good, count }, ...]
 3. getCost – возвращает стоимость корзины. Стоимость корзины высчитывается как сумма всех добавленных товаров с учетом их количества.
 4. getCount – возвращает количество товаров в корзине
 */

const cart = new Cart();
cart.addItem({ name: 'car', price: 3 }, 5);
cart.addItem({ name: 'house', price: 10 }, 2);
cart.getItems().length; // 2
cart.getCost(); // 35


// FILE: /tests/cart.test.js
import getImpelementation from '../implementations';

const Cart = getImpelementation();

test('Cart', () => {
    const cart = new Cart();
    expect(cart.getItems()).toHaveLength(0);

    cart.addItem({ name: 'car', price: 3 }, 5);
    expect(cart.getItems()).toHaveLength(1);
    expect(cart.getCost()).toBe(15);
    expect(cart.getCount()).toBe(5);

    cart.addItem({ name: 'house', price: 10 }, 2);
    expect(cart.getItems()).toHaveLength(2);
    expect(cart.getCost()).toBe(35);
    expect(cart.getCount()).toBe(7);
});




// # >>>>>> Покрытие кода тестами (Code Coverage) <<<<<<#

/**
 С ростом проекта, определить какой код протестирован, а какой нет, становится сложно, хотя подобная потребность возникает регулярно. Обычно это происходит тогда, когда в команде есть разные люди и не все из них ответственно подходят к написанию тестов. В таком случае может страдать качество проекта.

 Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения всех строчек кода, к тем строчкам, которые были задействованы во время выполнения тестов. Например, если в коде есть условная конструкция, и она не проверяется тестами, это значит, что все строки кода, входящие в неё, не будут покрыты.

 В Jest покрытие меряется крайне просто. Достаточно запустить тесты с флагом --coverage:
 $ npx jest --coverage
 PASS  __tests__/half.test.js
 ✓ half (3ms)

 ----------|----------|----------|----------|----------|-------------------|
 File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
 ----------|----------|----------|----------|----------|-------------------|
 All files |    71.43 |      100 |    66.67 |    71.43 |                   |
 half.js  |       60 |      100 |       50 |       60 |             12,13 |
 index.js |      100 |      100 |      100 |      100 |                   |
 ----------|----------|----------|----------|----------|-------------------|
 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        2.236s
 Ran all test suites.


 После выполнения всех тестов, Jest выводит сводную таблицу по каждому файлу. В ней показан процент покрытия кода тестами. В примере выше видно что в файле index.js покрыто 100% кода, а вот в файле half.js только 60%. При этом общее покрытие кода 71.43%. Обратите внимание, что покрытие сильно зависит от того, какие тесты выполнились. Если часть из них упала с ошибками, то Jest покажет намного меньшее покрытие, так как тесты просто не доберутся до всего кода. Поэтому покрытие меряют только тогда, когда все тесты зелёные.

 Эта статистика помогает найти места, где тестов мало. Дальше по ситуации их можно начинать добавлять. Если в проекте тестов не было вообще, то эта статистика начинает быстро расти. А вот дальше, ближе к 90 процентам, придётся бороться за каждую строчку кода.

 Однако, покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. Как правило это тесты на пограничные случаи. В разработке есть хорошая практика: перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, и только затем уже можно починить их.

 Какое покрытие считается допустимым? 100% покрытия выглядит красиво, но добиться его невероятно сложно. И для большинства проектов бессмысленно. Затраченные усилия не окупятся. Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.
 */



// # >>>>>> Разработка через тестирование (TDD) <<<<<<#

/**
 В какой момент лучше писать тесты? Вообще, существует три подхода:
 > Тесты пишутся после кода
 > Тесты пишутся вместе с кодом
 > Тесты пишутся до кода

 В некоторых ситуациях, особого выбора нет. Например, при системном тестировании, когда тест имитирует поведение пользователей и выполняет действия в браузере. Такие тесты пишутся после кода.

 В тестах более низкого уровня, интеграционных и модульных тестах, обычно можно выбирать из вариантов описанных выше. И подход "писать тесты после кода" относится к наименее полезным. Почему?

 Сам процесс написания кода, связан с постоянным запуском кода и проверкой того, что он работает. В самых простых, например, учебных задачах, этот запуск происходит довольно быстро.
 */

// Легко запустить, легко проверить, что результат правильный
capitalize('hello'); // Hello

/**
 В реальном коде подготовка данных для проверки работы кода может занимать значительное время, минуты и десятки минут. С другой стороны, результатом работы проверяемого кода может быть что-то сложное, например, множество записей в базе данных или вывод определённой непростой структуры. Тогда каждый запуск кода на проверку превращается в целое приключение.
 */

// Сложно подготовить данные. Сложно проверить результат работы.
// Загрузка товаров из 1C в базу данных
loadGoodsFrom1c();


/**
 Именно здесь на сцену выходит вариант "писать тесты до кода". У многих начинающих разработчиков, эта фраза вызывает ступор. Как можно писать тесты до того, как был написан код? Оказывается, можно и это даже приятно.

 Допустим мы хотим написать функцию, которая может повторять переданную строчку указанное количество раз:
 */

repeat('$', 3); // $$$

/*
    Мы знаем что, она принимает на вход, мы знаем, какой у неё должен быть выход (спасибо, что ты чистая https://ru.wikipedia.org/wiki/Чистота_функции). Можем ли мы уже написать тесты? Конечно!
*/

test('repeat', () => {
    expect(repeat('$', 3)).toBe('$$$');
});

/**
 Сколько займёт времени написать такой тест у опытного разработчика? Думаю секунд 15, именно столько времени мне понадобилось для кода выше. Зато, теперь для проверки работы этого кода достаточно набрать jest в консоли.

 У тестирования до написания кода есть ещё одно мощное преимущество. Оно заставляет программиста в первую очередь думать о дизайне своего решения, о том, как им будут пользоваться. А не о том, как красиво он реализует всё внутри. Грамотные интерфейсы – залог успеха.

 В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD).

 TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла, где на каждой итерации пишется тест, который не проходит, затем дописывается код, удовлетворяющий данному тесту. После этого всё повторяется. Так шаг за шагом строится приложение.

 Сейчас все по инерции продолжают говорить именно о таком способе. В нём тесты пишутся на все части кода с максимальной детализацией. Этот вид TDD хоть и говорит о важности дизайна, но фокусируется на конкретных функциях и классах приложения вместо цельной картины. Но есть и другое TDD, где тесты на внутренние части не пишутся почти никогда. Подробнее об этом в статье в дополнительных материалах.

 Сам по себе Хекслет, яркий пример того, как тесты пишутся до кода. Абсолютно во всех наших практиках на всех языках, тесты есть, а кода нет :)

 # Дополнительные материалы
 Начинаем писать тесты правильно https://ru.hexlet.io/blog/posts/how-to-test-code
 Начинаем писать тесты правильно (Видео) https://www.youtube.com/watch?v=zsz8kdi62mE
 */



// # >>>>>> Непрерывная интеграция (CI) <<<<<<#

/**
 Теперь, когда мы немного разобрались с тестами, давайте поговорим о культуре их запуска.

 Локальный запуск тестов – персональная ответственность. Хорошие разработчики используют тесты непрерывно во время разработки и обязательно запускают их перед пушем (git push).

 Но этого недостаточно. Там где есть люди, там присутствует человеческий фактор и ошибки. Поэтому даже несмотря на локальный запуск, тесты должны запускаться автоматически на серверах непрерывной интеграции.

 Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозиторий. За этим следит либо специальный сервер либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно для текущего приложения) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это тесты и линтер (проверка оформления кода). Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.

 Немного терминологии и описание процесса. На каждый коммит запускается сборка (build). Во время сборки собирается приложение, устанавливаются зависимости, прогоняются тесты и все остальные проверки. Сборка, завершившаяся без ошибок, считается успешной. Если сборка не проходит, то программист получает уведомление. Дальше он смотрит отчёт и исправляет ошибки.

 Для внедрения непрерывной интеграции есть два пути. Первый, поставить себе на сервер Jenkins или его аналог. Этот вариант требует много ручной работы (плюс поддержка сервера). Он подходит компаниям, в которых очень сложные приложения, или они не хотят допускать утечки кода наружу, или у них настолько много проектов, что свой сервер дешевле чем стороннее решение. Второй путь – воспользоваться сервисом непрерывной интеграции. Таких сервисов десятки, если не сотни. Есть из чего выбрать. Как правило, большинство из них бесплатны для открытых проектов. Одним из первых подобных сервисов был https://travis-ci.com. Он до сих пор остаётся наиболее популярным, особенно среди проектов на Гитхабе.

 Travis CI подключён ко всем открытым проектам Хекслета (пример). Для удобства, он даёт "бейджик", картинку, которая вставляется в файл проекта README.md. Она показывает текущий статус проекта (завершилась ли успешна последняя сборка или нет) и по клику на неё можно попасть в интерфейс самого Travis CI.

 # Дополнительные материалы
 Экстремальное программирование https://ru.hexlet.io/blog/posts/xp
 Среды разработки. Мужики, выкатывай! https://ru.hexlet.io/blog/posts/environment
 */
