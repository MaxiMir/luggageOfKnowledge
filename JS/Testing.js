// ###### JS: Автоматическое тестирование ######

/**
 Код профессиональных разработчиков содержит меньше ошибок, чем код начинающих. Это происходит не потому, что они умнее, внимательнее к деталям или видят код насквозь. Настоящая причина кроется в том, что они пишут тесты.

 Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их на приемлемом уровне. Тесты дают уверенность, что изменения в одной части системы не сломали другие части.

 Однако, тесты нужны не только для проверки работоспособности кода. Существуют и другие автоматизированные виды тестов, например, тесты производительности или тесты на уязвимости.

 Среди разных видов автоматизированных тестов, программисты, в первую очередь, отвечают за функциональные тесты. Эти тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы. Например, регистрация пользователя должна, как это ни странно, регистрировать пользователя. И тесты это подтверждают.

 По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

 > Модульные
 > Интеграционные
 > Системные

 Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты. У программистов на такие тесты должно быть направлено основное внимание. Их всё ещё достаточно просто писать (если экосистема проекта подготовлена к этому) и они охватывают гораздо большую часть системы.

 Наиболее сложные и максимально эффективные — системные тесты. В случае сайтов — это тестирование через браузер. Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. Сложность этих тестов в том, что им приходится опираться на вёрстку сайта, которая часто и непредсказуемо меняется. Кроме того, в браузере невозможно точно определить, когда закончилось одно действие и началось другое (с точки зрения программы). Именно поэтому такие тесты часто ломаются, их сложно писать и поддерживать.

 Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты. Этот курс знакомит с общими принципами тестирования и шаг за шагом проводит через все возникающие во время тестирования задачи.
 */



// #>>>>>> Зачем и как писать тесты? <<<<<<

/**
 Какую главную задачу должны решать тесты? Этот вопрос невероятно важен. Ответ на него даёт понимание того, как правильно писать тесты и как писать их не нужно.

 Представьте, что вы написали функцию capitalize(text), которая делает заглавной первую букву переданной строки:
 */

capitalize('hello'); // 'Hello'


// Вот один из вариантов её реализации:

const capitalize = text => {
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};


/**
 Что мы делаем после создания функции? Проверяем, как она работает. Например, открываем REPL и вызываем функцию с разными аргументами:

 $ node
 Welcome to Node.js v12.4.0.
 > capitalize('hello')
 'Hello'
 > capitalize('how are you')
 > 'How are you'

 Таким нехитрым способом убеждаемся, что функция работает. По крайней мере для тех аргументов, которые мы передали в неё. Если во время проверки заметили ошибки, то исправляем функцию и повторяем всё заново.

 Фактически, весь этот процесс и есть тестирование. Но не автоматическое, а ручное. Задача такого тестирования — убедиться, что код работает как надо. И нам совершенно без разницы, как конкретно реализована эта функция. Это и есть главный ответ на вопрос, заданный в начале урока.

 Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.
 */


// #@ Автоматические тесты

/**
 Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

 Даже если вы не знакомы с исключениями, ничего страшного. В этом курсе достаточно знать две вещи: для чего они нам нужны и какой у них синтаксис. До сих пор в курсах Хекслета вы встречались с ошибками, которые возникают непроизвольно: вызов несуществующей функции, обращение к несуществующей константе и так далее. Но ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. Исключения создаются такой конструкцией:
 */

throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');


// Пример теста:

if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
    // Выбрасываем исключение и завершаем выполнение теста
    throw new Error('Функция работает неверно!');
}

/**
 Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он работает в том же окружении и подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой. Обнаруженные ошибки в тестах исправляются и жизнь продолжается дальше ;)

 В коде, тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:

 src/
 ├── bin
 │   └── hexlet.js
 ├── half.js
 └── index.js
 tests/
 └── half.test.js


 Структура этой директории зависит от того, на базе чего пишутся тесты, например, на базе какого фреймворка. В простых случаях, она отражает структуру исходного кода. Если предположить, что наша функция capitalize(text) определена в файле src/capitalize.js, то её тест лучше поместить в файл tests/capitalize.test.js. Слово test в имени модуля с тестами, используется только для более явного обозначения цели файла.

 Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:

 $ node tests/capitalize.test.js
 # Если все хорошо, код молча выполнится.
 # Если есть ошибка, то будет выведено сообщение об ошибке.
 */


// #@ Как пишутся тесты

/**
 Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые функции, вызывать их с необходимыми аргументами и проверять, что функции возвращают ожидаемые значения.

 Если поменялась сигнатура функции (входные или выходные параметры, её имя), то придётся переписывать тесты. Если сигнатура осталась той же, но поменялись внутренности функции:
 */
const capitalize = (text) => {
    const [firstSymbol, ...restSymbols] = text;

    return `${firstSymbol.toUpperCase()}${restSymbols.join('')}`;
};

/**
 Тогда тесты должны продолжать работать без изменений.

 Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.
 */


// #@ Сколько и какие нужно писать проверки?

/**
 Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически не осуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

 При написании тестов нужно ориентироваться на разнообразие входных данных. У любой функции есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

 > Работа с пустой строкой
 > Обработка null
 > Деление на ноль (в большинстве языков вызывает ошибку)
 > Специфические ситуации для конкретных алгоритмов

 Для capitalize пограничным случаем будет пустая строка:
 */
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

/**
 Добавив тест на пустую строку, мы увидим, что вызов показанной в начале урока функции capitalize завершается с ошибкой. Внутри неё идёт обращение к первому индексу строки без проверки его существования. Исправленная версия кода:
 */

const capitalize = (text) => {
    if (text === '') {
        return '';
    }
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};

/*
    В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария:

    > Функция выполнилась так, что не был выполнен ни один условный блок
    > Функция выполнилась так, что был выполнен только первый условный блок
    > Функция выполнилась так, что был выполнен только второй условный блок
    > Функция выполнилась так, что были выполнены оба условных блока

    Комбинация всех возможных вариантов поведения функции называется цикломатической сложностью. Это число показывает все возможные пути кода внутри функции. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

    Иногда пограничные случаи не связаны с условными конструкциями. Особенно часто такие ситуации встречаются там, где есть вычисления границ слов или массивов. Такой код может работать в большинстве ситуаций, но только в некоторых может давать сбой:
*/



// В этой функции забыли отнять единицу от длины
// Этот код сработает в некоторых ситуациях (когда последний элемент undefined) или в массиве нет элементов
// Но в остальных случаях вернёт неверное значение
const last = (elements) => elements[elements.length];


// #@ Проверка входных данных

/**
 Особняком стоят ошибки типов входных данных. Например, в функцию capitalize можно передать число вместо строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

 Ещё один интересный вопрос. Нужно ли внутри capitalize обрабатывать такие ситуации? Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних уровнях.

 Ответственность за передачу правильных данных в функцию capitalize лежит не на ней, а на коде, который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

 Но даже если ошибка обрабатывается внутри функции, это не значит, что надо бросаться писать тест, покрывающий данную ошибку. Попытка покрывать каждую (особенно ошибочную ситуацию) тестами, выливается в огромное число тестов, которые требуют поддержки и времени на написание. Нужно уметь во время остановиться и двигаться дальше, к покрытию другого или нового кода.
 */

// #@ Собирая всё вместе

//

/*
 В конечном итоге мы получили такую структуру директорий:
    src/
    └── capitalize.js
    tests/
    └── capitalize.test.js

    Содержимое теста:
*/

if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');

/*
    Запуск:

    $ node tests/capitalize.test.js

    Если всё написано правильно, то запуск тестов завершится с выводом строки Все тесты пройдены! Если в тестах или в коде есть ошибка, то сработает исключение и мы увидим сообщение, указывающее на это.
 */


/*
    // FILE: /tests/collection.test.js

    Напишите тесты для функции get(obj, key, defaultValue). Тесты должны быть построены по такому же принципу, как это описывалось в теории урока: проверка через if и исключение в случае провала теста.

    Эта функция извлекает значение из объекта при условии, что ключ существует. В ином случае возвращается defaultValue.
*/

get({ key: 'value' }, 'key'); // 'value'
get({}, 'key', 'defaultValue'); // 'defaultValue'


import getFunction from '../functions';

const get = getFunction();

if (get({ key: 'value' }, 'key') !== 'value') {
    throw new Error('boom!');
}
if (get({}, 'key', 'value') !== 'value') {
    throw new Error('boom!');
}
if (get({ key: 'value' }, 'key', 'default value') !== 'value') {
    throw new Error('boom!');
}



// # >>>>>> Утверждения (Asserts) <<<<<<#

/**
 Каждую проверку, которую мы написали для функции capitalize, в тестировании принято называть утверждением (assert). Утверждения — ключевая часть тестов. Именно они проверяют функциональность кода:
 */

import capitalize from '../src/capitalize';

// Первое утверждение (проверка на пустую строку)
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

// Второе утверждение (проверка на слово)
if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

/**
 Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Node.js поставляется с модулем assert, в котором есть несколько функций, упрощающих написание утверждений:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert(capitalize('') === '');
assert(capitalize('hello') === 'Hello');

/**
 В самом простом случае assert используется как функция, которая проверяет истинность переданного значения. Другими словами, assert(true) означает что всё хорошо, а assert(false) говорит об ошибке. Последний вариант выбрасывает исключение с таким сообщением:

 AssertionError [ERR_ASSERTION]: false == true

 Расшифровка сообщения: "Ожидалось, что значением выражения будет истина, но оказалось, что это ложь". Кроме сообщения, выводится трассировка стека (стектрейс), по которому можно найти сработавшее утверждение.

 Функция assert сделала наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

 С другой стороны, вывод сообщения об ошибке крайне не информативный. Единственный способ понять, что произошло — открывать код с упавшим утверждением (ещё есть вариант передать сообщение об ошибке последним параметром, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий). Это пытаются исправить с помощью специализированных утверждений, заточенных под конкретные ситуации. Например, при сравнении двух значений подходит функция assert.equal(actual, expected). Перепишем код выше:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert.equal(capitalize(''), '');
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize('hello'), 'Hello');

/**
 Вывод таких утверждений значительно понятнее:

 Thrown:
 AssertionError [ERR_ASSERTION]: 'hello' == 'Hello'
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: 'hello',
 expected: 'Hello',
 operator: '=='

 В этом выводе есть не только информация об ошибке, но и данные, которые передавались в утверждение. Такой формат упрощает анализ проблемы и ускоряет отладку.

 Однако, будьте осторожны. Функция equal(actual, expected) проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются, как не эквивалентные:

 > assert.equal({}, {})
 Thrown:
 AssertionError [ERR_ASSERTION]: {} == {}
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: {},
 expected: {},
 operator: '=='

 > assert.equal({ key: 'value'  }, { key: 'value'  });
 Thrown:
 AssertionError [ERR_ASSERTION]: { key: 'value'  } == { key: 'value'  }
 generatedMessage: true,
 name: 'AssertionError [ERR_ASSERTION]',
 code: 'ERR_ASSERTION',
 actual: { key: 'value'  },
 expected: { key: 'value'  },
 operator: '=='


 Для сравнения по значению используется ещё одно утверждение: assert.deepEqual(actual, expected). Оно опирается только на содержимое:

 assert.deepEqual({}, {}); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'value' }); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'another value' }); // Boom!

 Для тестирования негативных сценариев предназначены функции assert.notEqual(actual, expected) и assert.notDeepEqual(actual, expected). Они тестируют то, что значения не равны. Эти утверждения используются крайне редко, но знать о них всё равно полезно.

 # Дополнительные материалы
 Asserts https://nodejs.org/api/assert.html
 Chai https://www.chaijs.com/
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции take(items, n), которая возвращает первые n элементов из массива:
 */

take([1, 2, 3], 2); // [1, 2]
take([], 2); // []
take([4, 3], 9); // [4, 3]


// FILE: tests/take.test.js
import assert from 'assert';
import getFunction from '../functions';

const take = getFunction();

assert.deepEqual(take(['one', 'two', 8], 9), ['one', 'two', 8]);
assert.deepEqual(take([1, 2]), [1]);
assert.deepEqual(take(['one', 'two', 'three'], 2), ['one', 'two']);
assert.deepEqual(take([]), []);




// # >>>>>> power-assert <<<<<<#

/**
 У обычных утверждений есть мощная альтернатива: power-assert https://github.com/power-assert-js/power-assert. Эта библиотека добавляет магию в привычный инструмент.

 Вот пример проверки с использованием стандартного модуля assert:
 */

const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

assert(user.name === 'Michel');

// AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:
//  assert(user.name === 'Michel')

/*
    В выводе видно само утверждение и результат проверки. Но непонято, что за объект user и какая у него структура. Для получения этой информации придётся включаться в отладку. Но вместо этого можно воспользоваться библиотекой power-assert:
*/

import assert from 'power-assert'; // !

// Весь код остаётся тем же самым
const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

// Интерфейс библиотеки power-assert на 100% совместим со встроенным модулем assert.
assert(user.name === 'Michel'); // =>

/**
 AssertionError [ERR_ASSERTION]:   # test.js:10

 assert(user.name === 'Michel')
 |    |    |
 |    |    false
 |    "Madonna"
 Object{name:"Madonna",friends:#Array#,email:"madonna@gmail.com"}

 --- [string] 'Michel'
 +++ [string] user.name
 @@ -1,6 +1,7 @@
 M
 -ichel
 +adonna


 Попробуйте остановиться и внимательно изучить этот вывод. Что здесь показано? power-assert облегчает отладку настолько, насколько это вообще физически возможно. Он показывает значение каждого объекта и результат каждой операции, входящей в выражение, переданное в функцию assert. Кроме того, в конце он сравнивает строки и говорит, в чём конкретно было различие между ними.

 Вот ещё один интересный пример из документации:
 */

import assert from 'power-assert';

const ary = [1, 2, 3];
const zero = 0;
const two = 2;

assert(ary.indexOf(zero) === two);

// AssertionError [ERR_ASSERTION]:   # test.js:7
//
//   assert(ary.indexOf(zero) === two)
//          |   |       |     |   |
//          |   |       |     |   2
//          |   -1      0     false
//          [1,2,3]
//
//   [number] two
//   => 2
//   [number] ary.indexOf(zero)
//   => -1

/**
 Впечатляет? Большинство современных фреймворков не выдаёт настолько удобный вывод, насколько это делает power-assert. Хорошая новость в том, что его можно интегрировать с чем угодно.
 */



/**@@@
 tests/indexOf.test.js
 Напишите тесты для функции indexOf(items, value), которая возвращает индекс переданного элемента:
 */

_.indexOf([1, 2, 1, 2], 2); // 1
_.indexOf([2, 'one', 'cat', false], 8); // -1


// FILE: /tests/indexOf.test.js

import assert from 'power-assert';
import getFunction from '../functions';

const indexOf = getFunction();

assert(indexOf(['one', 'two', 8], 'two') === 1);
assert(indexOf([1, 8, 9, 3, 9], 9) === 2);
assert(indexOf([], 9) === -1);




// # >>>>>> Jest <<<<<<#

/**
 Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?

 Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод. С большинством из этих возможностей мы познакомимся далее по курсу. В JavaScript мире наиболее популярен фреймворк Jest, разрабатываемый компанией Facebook. К слову, с помощью него мы тестируем все практики на Хекслете.

 Ниже находится инструкция, в которой мы создадим с нуля npm-проект и добавим в него тесты.
 */

// #@ Настройка и запуск

/**
 Создайте где-нибудь на вашем компьютере директорию с названием hexlet-jest. Зайдите в неё и выполните команду:

 $ hexlet-jest $ npm init

 Ответьте на все вопросы запущенного скрипта инициализации проекта. Убедитесь, что в корне проекта появился файл package.json.

 Теперь добавим немного исходного кода. Создайте файл src/index.js с таким содержимым:
 */

// Эта функция переворачивает переданную строку
export default str => str.split('').reverse().join('');

/*
    Jest — обычный npm-пакет, который локально подключается в разрабатываемый проект. Jest нужен только во время разработки, поэтому лучше установить его в секцию devDependencies:

    # В директории с проектом
    $ hexlet-jest $ npm i --save-dev jest

    По умолчанию Jest не использует Babel, поэтому код с импортами внутри Jest не заработает. Для поддержки Babel нужно установить несколько дополнительных пакетов:

    $ hexlet-jest $ npm i --save-dev babel-jest @babel/core @babel/preset-env

    Далее создайте в корне проекта файл babel.config.js с таким содержимым:
*/

module.exports = {
    presets: [['@babel/preset-env', {targets: {node: 'current'}}]],
};

/**
 После установки этих пакетов и настройки babel.config.js, Jest начнёт использовать Babel при запуске тестов. Никакая конфигурация больше не требуется.

 По умолчанию (но этим можно управлять) Jest ожидает, что тесты находятся в директории __tests__ в корне проекта. Внутри этого каталога, можно создавать любую структуру, Jest найдёт все тесты, которые там лежат. Именование файлов с тестами должно быть таким: <name>.test.js. Где <name>, как правило, это имя соответствует имени модуля, который тестируется.

 Напишем наш первый тест. Создайте файл __tests__/index.test.js со следующими содержимым:
 */

import reverse from '../src';

test('reverse', () => {
    expect(reverse('hello')).toEqual('olleh');
    expect(reverse('')).toEqual('');
});

/**
 Далее мы разберём структуру этого файла, а пока попробуем запустить тест на выполнение:

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms)

 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        1.166s
 Ran all test suites.

 Ура! Тесты прошли успешно.
 */

// #@ Структура

/**
 Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

 Функция test нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms) # название теста


 Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутри Jest, который уже решает как и когда запускать тесты. Это позволяет проводить различные оптимизации например, выполнять тесты параллельно.

 Самое необычное в этом коде — проверки. Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

 > Вызывается функция expect куда передаётся актуальное (фактическое) значение.
 > На результате, возвращаемом функцией expect, вызывается подходящий матчер, например, toEqual.
 */
// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse('hello')).toEqual('olleh');

/**нейших особенностей Jest — то, как он выводит сообщения о проваленных проверках. Попробуйте внести ошибку в исходную функцию и запустите тесты заново:

 hexlet-jest$ npx jest
 FAIL  __tests__/index.test.js
 ✕ reverse (9ms)

 ● reverse

 expect(received).toEqual(expected) // Object.is equality

 Expected: "olleh"
 Received: "o|l|l|e|h"

 3 | test('reverse', () => {
          4 |   const str = 'hello';
        > 5 |   expect(reverse(str)).toEqual('olleh');
            |                        ^
          6 | })
 7 |

 at Object.toEqual (__tests__/index.test.js:5:24)

 Test Suites: 1 failed, 1 total
 Tests:       1 failed, 1 total
 Snapshots:   0 total
 Time:        1.683s
 Ran all test suites.

 В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла с тестами с указанием на конкретную проверку. Это невероятная и очень полезная фишка, которая значительно ускоряет анализ результатов тестирования и помогает в отладке.

 # Дополнительные материалы
 Jest https://jestjs.io/
 Блоки тестов (Describe) https://jestjs.io/docs/ru/api#describename-fn


 ? Как правильно запускать Jest на выполнение?
 > npx jest
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции without(coll, [values]), которая принимает первым параметром массив и возвращает его копию, из которой исключены значения, переданные вторым и последующими параметрами.
 */
_.without([2, 1, 2, 3], 1, 2); // [3]

// FILE: /tests/take.test.js

import getFunction from '../functions';

const without = getFunction();

test('without', () => {
    expect(without([], 3)).toEqual([]);
    expect(without([3, 8, 9, 8, 10], 8, 10)).toEqual([3, 9]);
});




// # >>>>>> Матчеры (Expectations) <<<<<<#

/**
 Существует несколько популярных способов описывать утверждения. Кроме вызова обычных функций, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок.

 Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать (В идеале, на практике всё сложнее). Матчеры заменили собой обычные утверждения на функциях во многих языках:
 */

// Проверка равенства по ссылке
// assert.equal([1, 2], [1, 2])
expect([1, 2]).toBe([1, 2]); // false

// Проверка равенства по значению
// assert.deepEqual([1, 2], [1, 2])
expect([1, 2]).toEqual([1, 2]); // true


/**
 Любой матчер в Jest начинается с функции expect(data), в которую передаются данные на проверку. Затем expect возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. В Jest десятки матчеров для самых разнообразных ситуаций. Такое количество объясняется желанием выдавать максимально точный отчёт о том, что произошло.

 Предположим, что функция возвращает массив и мы хотим проверить его размер. Для этого можно воспользоваться матчером toBe:
 */

const data = [1, 2, 3];
// take берет первые n элементов
// assert.equal(take(data, 2).length, 2)
expect(take(data, 2).length).toBe(2);

// Этот матчер прекрасно справится с задачей. Но в случае ошибки его вывод не слишком информативен:

expect(received).toBe(expected); // Object.is equality

// Expected: 2
// Received: 1

// Поэтому лучше взять специализированный матчер для проверки размера массива:

expect(take(data, 2)).toHaveLength(2);

/**
 Тогда вывод расскажет гораздо больше:

 expect(received).toHaveLength(expected)

 Expected length: 2
 Received length: 1
 Received array:  [1, 2]

 Благодаря тому, что в expect передаётся сам массив, а не его длина, у Jest появляется возможность выводить содержимое массива в случае ошибки. Это, опять же, упрощает отладку.

 Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:
 */

expect(null).toBeNull();

// Проверяет значение на truthy (любое значение, которое приводится к true)
expect(true).toBeTruthy();
// Точное сравнение с true
expect(true).toBe(true);

expect(undefined).toBeUndefined();

// Проверка, что массив содержит элемент
expect([1, 2, 3]).toContain(2);

// Проверка, что строка содержит подстроку
expect('hello, world').toMatch('hello');

// Проверяет, что в объекте есть свойство с определённым значением
expect({ key: 'value' }).toHaveProperty('key', 'value');


// Кроме того, к любому матчеру можно применить модификатор not, который инвертирует поведение матчера:

expect(null).not.toBeNull(); // not null
expect(undefined).not.toBeUndefined(); // not undefined
expect([1, 2, 3]).not.toContain(2); // not contain 2
expect('hello, world').not.toMatch('hello'); // not match hello

// Особняком стоит матчер toMatchObject. Он используется, когда нас в тестах интересует не весь объект, а только какая-то его часть:

const user = {
    firstName: 'tolya',
    lastName: 'petrov',
    age: '33',
};

// Тест пройдёт успешно, так как проверяется только firstName
expect(user).toMatchObject({ firstName: 'tolya' });

/**
 Это далеко не все матчеры, которые есть в Jest. Более того, Jest достаточно гибкий и может расширяться собственными матчерами. На Гитхабе можно найти библиотеки с матчерами для разных ситуаций.

 В целом, вам придётся постоянно заглядывать в документацию, чтобы вспомнить, что там есть. Иначе всё может свестись к использованию toEqual. Пожалуй, это основной недостаток использования матчеров — необходимость помнить про них и правильно применять.

 # Дополнительные материалы
 Матчеры Jest https://jestjs.io/docs/ru/expect
 */


/**@@@
 tests/gt.test.js
 Напишите тесты для функции _.gt(value, other), которая возвращает true в том случае, если value > other, и false в иных случаях.
 */

gt(3, 1); // true
gt(3, 3); // false
gt(1, 3); // false


// FILE: /tests/gt.test.js
import getFunction from '../functions';

const gt = getFunction();

test('gt', () => {
    expect(gt(0, 0)).toBe(false);
    expect(gt(1, 0)).toBe(true);
    expect(gt(1, -3)).toBe(true);
});

// FILE: /functions.js
import _ from 'lodash';

const functions = {
    right1: _.gt,
    wrong1: _.gte,
    wrong2: _.eq,
};

export default () => {
    const name = process.env.FUNCTION_VERSION || 'right1';
    return functions[name];
};




// # >>>>>> Модульные тесты <<<<<<#


/*
    Изученной информации уже достаточно для тестирования в повседневной практике разработки. Перед тем, как погружаться в более сложные темы и возможности Jest, пройдём полный путь тестирования библиотеки, поговорим об организации тестов, хороших и плохих практиках. Это поможет сформировать правильное отношение к тестированию в целом.

    В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: функции, модули, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

    Попробуем протестировать стек. Напомню, что стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. Сам стек, как правило, используется для реализации алгоритмов. Ещё его много в низкоуровневом коде: например, внутри языков программирования или операционных систем.
*/

import makeStack from '../src/stack';

const stack = makeStack();
stack.isEmpty(); // true
stack.push(1); // (1)
stack.push(2); // (2, 1)
stack.push(3); // (3, 2, 1)
stack.isEmpty(); // false
stack.pop(); // 3. В стеке (2, 1)
stack.pop(); // 2. В стеке (1)
stack.pop(); // 1. В стеке пусто
stack.isEmpty(); // true


/**
 Сначала решим организационные вопросы. Если предположить, что реализация стека лежит в файле src/stack.js, то его тест мы положим в файл __tests__/stack.test.js.
 */

// #@ Тестируем основную функциональность

/**
 Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:
 */

import makeStack from '../src/stack.js';

test("stack's main flow", () => {
    const stack = makeStack();
    // Добавляем два элемента в стек и затем извлекаем их
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
    expect(stack.pop()).toEqual('one');
});

/**
 Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

 В интернете можно встретить мнение, что несколько проверок в рамках одного теста это неправильно. Что тесты нужно детализировать максимально подробно и создавать новый тест на каждую проверку.
 */

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
});

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    stack.pop();
    expect(stack.pop()).toEqual('one');
});


// #@ Тестируем дополнительную функциональность

// Следующим тестом будет тест на дополнительные функции стека. К таким у нас относится функция isEmpty(), которая проверяет, пустой ли стек:

test('isEmpty', () => {
    const stack = makeStack();
    expect(stack.isEmpty()).toBe(true);
    stack.push('two');
    expect(stack.isEmpty()).toBe(false);
    stack.pop();
    expect(stack.isEmpty()).toBe(true);
});

/*
    В этом тесте проверяются сразу три ситуации:
    > начальное состояние стека
    > состояние стека после добавления элементов
    > состояние стека после извлечения всех элементов

    В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty() всё равно сломается. Нужно ли пытаться найти все варианты? Не нужно. Тесты не даются бесплатно, каждая написанная строчка кода в проекте — потенциальное место для изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только тогда, когда они критичны для работоспособности.
*/

// #@ Пограничные случаи

/**
 Ну, и последнее, что можно протестировать — поведение функции pop(), когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение, если из него попытались взять элемент, когда тот был пустой. Поэтому здесь подойдёт матчер toThrow().
 */

test('pop in empty stack', () => {
    const stack = makeStack();
    // Вызов метода pop обёрнут в функцию, иначе матчер не сможет перехватить исключение
    1
});

/**
 Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать проект в допустимых рамках забагованности.

 # Дополнительные материалы
 Чек-лист хороших инженерных практик в компаниях https://guides.hexlet.io/check-list-of-engineering-practices/


 > Если обнаружился баг, то сначала надо написать тест и только потом чинить его
 > Тесты не должны зависеть друг от друга
 */

/**@@@
 tests/validator.test.js
 Напишите тесты для класса Validator. Этот класс проверяет корректность данных. Принцип работы валидатора следующий:

 1. С помощью метода addCheck(fn) в него добавляются проверки. Каждая проверка представляет из себя функцию-предикат, которая принимает на вход проверяемое значение и возвращает либо true либо false в зависимости от того, соответствует ли значение требованиям проверки или нет.

 2. С помощью метода isValid(value), пользователь объектов класса Validator проверяет соответствие значения всем добавленным проверкам. Если не было добавлено ни одной проверки, считается, что любое значение верное.
 */

const validator = makeValidator();
validator.isValid('some value'); // true
validator.addCheck((v) => v > 5);
validator.isValid(3); // false
validator.isValid(8); // true
validator.addCheck(/* add more checks */);



// FILE: /__tests__/validator.test.js
import { isNumber } from 'lodash';
import getImpelementation from '../implementations';

const makeValidator = getImpelementation();


test('validator', () => {
    const validator = makeValidator();
    expect(validator.isValid('value')).toBe(true);

    validator.addCheck(isNumber);
    validator.addCheck((v) => v > 10);
    validator.addCheck((v) => v % 2 === 0);

    expect(validator.isValid(false)).toBe(false);
    expect(validator.isValid('string')).toBe(false);
    expect(validator.isValid(8)).toBe(false);
    expect(validator.isValid(11)).toBe(false);

    expect(validator.isValid(12)).toBe(true);
    expect(validator.isValid(100)).toBe(true);
});





// # >>>>>> Подготовка данных <<<<<<#

/**
 Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. Особенно в части начальной подготовки данных. В прошлом уроке каждый тест начинался со строчки: makeStack(). Это ещё не дублирование, но уже шаг в эту сторону. Как правило, реальные тесты сложнее и включают в себя большую подготовительную работу.

 Допустим, мы разрабатываем библиотеку Lodash и хотим протестировать её функции для обработки коллекций:

 > find
 > filter
 > includes
 > и другие (всего их около 20 штук)

 Для работы этих функций нужна заранее подготовленная коллекция. Проще всего придумать одну, которая подойдёт для тестирования большинства или даже всех функций:
 */

import _ from 'lodash';
test('includes', () => {
    // Подготовили коллекцию coll
    const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

    // Используем coll для тестирования
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Теперь представьте, что таких тестов несколько десятков (в реальности их сотни). Код начнёт кочевать из одного места в другое, порождая всё больше и больше копипасты.

 Самый простой способ избежать этого — вынести определение коллекции на уровень модуля, вне тестовых функций:
 */

import _ from 'lodash';

const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

test('includes', () => {
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Это простое решение убирает ненужное дублирование. Однако учтите, оно работает только в рамках одного модуля. Подобную коллекцию всё равно придётся определять в каждом тестовом модуле. И в нашем случае это скорее плюс, а не минус.

 Дело в том, что излишнее обобщение, приводящее к полному устранению дублирования, вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт к поломке большинства тестов, которые завязаны на её структуру, на количество элементов и их значения:
 */

import _ from 'lodash';

const coll = [1, 2, 3];

test('filter', () => {
    // Выбираем только чётные
    expect(_.filter(coll, (v) => v % 2 === 0)).toEqual([2])
});

/**
 Тест выше сломается, если мы добавим в нашу коллекцию чётное число. А коллекцию почти наверняка придётся расширять при добавлении новых тестов (для этой же или других функций).

 Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, после которой обобщение начинает больше мешать, чем помогать.

 Но далеко не всегда можно выносить константы на уровень модуля. В первую очередь это касается динамических данных. Представьте себе такой код:
 */

const now = new Date();

test('first example', () => console.log(now));
test('second example', () => console.log(now));

//  console.log __tests__/index.test.js:3
//    2019-07-08T21:52:27.036Z
//
//  console.log __tests__/index.test.js:4
//    2019-07-08T21:52:27.036Z

/**
 Подвох тут в том, что модуль загружается в память ровно один раз. Это значит, что весь код, определённый на уровне модуля (включая константы), выполняется ровно один раз. В примере константа now определится до запуска всех тестов, и только затем jest начнёт выполнять тесты. И с каждым последующим тестом отставание значения константы now от текущего реального значения "сейчас" будет всё дальше и дальше.

 Почему это может быть проблемой? Код, который работает с понятием "сейчас", может рассчитывать на то, что "сейчас" это почти моментальный снимок данного момента времени. Но в примере выше, сейчас начинает отставать от реального сейчас и чем больше тестов и чем они сложнее, тем большее отставание.

 Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его во внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между загрузкой модуля и отработкой тестов проходит неопределённое время.

 Для решения этой проблемы тестовые фреймворки предоставляют хуки — специальные функции, которые запускаются до или после тестов. Ниже пример того, как создавать дату перед каждым тестом:
 */

let now;
let counter = 0;

// Запускается перед каждым тестом
beforeEach(() => {
    now = new Date();
    counter += 1;
});

test('first example', () => console.log(now, counter));
test('second example', () => console.log(now, counter));

//  console.log __tests__/index.test.js:9
//    2019-07-08T21:53:23.521Z 1
//
//  console.log __tests__/index.test.js:10
//    2019-07-08T21:53:23.525Z 2

/**
 beforeEach(callback) принимает на вход функцию, внутри которой выполняется инициализирующее действие. Оно не обязательно приводит к созданию переменных. Возможно, инициализация заключается в подготовке файловой системы, например, созданию файлов.

 Но если она должна создать данные и сделать их доступными в тестах, то придётся использовать переменные, определённые на уровне модуля. Так как всё, что определяется внутри функций (колбека в нашем случае), остаётся внутри этой функции.

 ? Что нужно учитывать при работе с колбеками Jest?
 > Матчеры должны находиться внутри тестов, а не колбеков Jest
 > Тесты не должны влиять друг на друга. Данные всегда должны возвращаться в исходное значение после каждого теста.

 ? Как обеспечить в тестах доступ к данным, созданным внутри колбеков Jest?
 > Через this
 */

/**@@@
 tests/set.test.js
 Напишите тесты для функции set(obj, path, value), которая возвращает и изменяет (или добавляет) значение в объект по указанному пути. Функция мутирует объект.
 */

const object = { a: [{ b: { c: 3 } }] };

set(object, 'a[0].b.c', 4);
console.log(object.a[0].b.c); // => 4

set(object, ['x', '0', 'y', 'z'], 5);
console.log(object.x[0].y.z); // => 5



// FILE: /__tests__/set.test.js
import { cloneDeep } from 'lodash';
import getFunction from '../functions';

const set = getFunction();

let data;
let dataCopy;

beforeEach(() => {
    data = {
        a: [
            {
                b: {
                    c: 3,
                },
            },
        ],
    };
    dataCopy = cloneDeep(data);
});

test('plain set', () => {
    set(data, 'a', 'value');
    dataCopy.a = 'value';
    expect(data).toEqual(dataCopy);
});

test('nested set', () => {
    set(data, 'a[0].b.c', true);
    dataCopy.a[0].b.c = true;
    expect(data).toEqual(dataCopy);
});

test('set new property', () => {
    set(data, 'a[0].b.d', false);
    dataCopy.a[0].b.d = false;
    expect(data).toEqual(dataCopy);
});




// # >>>>>> Плохие и хорошие практики тестирования <<<<<<#

/**
 Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо. Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности, о которых надо знать. В этом уроке мы пройдёмся по некоторым из них.
 */

// #@ Взаимное влияние тестов

/**
 Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

 Нарушить это правило очень просто. Один тест может создать файл, изменить переменную или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, или наоборот — успешно пройти там, где не должны проходить. Кроме этого, в такой ситуации вводится неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. Например, когда тест запускают изолированно, то он работает, а когда вместе с остальными — падает:
 */

let user;

test('first', () => {
    user = new User();
    // ...
});

test('first', () => {
    // Используется пользователь, которого создал другой тест!
    // Этот тест зависит от того, как работает предыдущий тест,
    // и не может работать без последовательного запуска обоих тестов.
    user.name = 'Petya';
});

/**
 Особенно часто такая ситуация возникает в тестах, активно взаимодействующих с внешней средой: базой данных или файловой системой. Тестирование побочных эффектов имеет свои хитрости и рассматривается в продвинутом курсе по тестированию.
 */

// #@ Тест вне тестов

/**
 Задача beforeEach — готовить данные и среду для тестирования, а задача test — вызывать код, который тестируется, и проводить проверки. Но иногда разработчики переусердствуют:
 */

let result;

beforeEach(() => {
    // Вызывается тестируемый код. Это противоречит идее beforeEach.
    result = sum(5, 9);
});

test('result', () => {
    // Здесь только проверка
    expect(result).toEqual(14);
});

// В этом примере тестируемый код вызывается в beforeEach. Такой подход усложняет анализ тестов, так как переворачивает всё с ног на голову.


// #@ Слишком сильная детализация

/**
 Программисты под влиянием голосов из интернета стремятся максимально разносить код по файлам, модулям и функциям. То же самое наблюдается и в тестах. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка:
 */

test('create user', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.age).toEqual(28);
});

test('create user 2', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.name).toEqual('Mark');
});

/**
 Чаще всего, единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда кода станет по-настоящему много.
 */

// #@ Глубокая вложенность

// Jest позволяет группировать тесты в блоки describe:

describe('User', () => {
    test('should be valid', () => { /* ... */ });
});

/**
 Они помогают структурировать сложные тесты и задать для каждого блока describe свой собственный beforeEach. Хотя такая возможность бывает полезна, но очень легко начать использовать её во вред:
 */

describe('', () => {
    describe('...', () => {
        describe('...', () => {
            test('should be valid', () => { /* ... */ })
        });
    });
});

/**
 Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру. Из-за этого возникают сложности при добавлении новых проверок. Становится непонятно, к чему она относится. Это проблема любых иерархий, которые рассматривают систему только с одной точки зрения.
 */

// #@ Код с тестами писать дольше, чем код без тестов

/**
 Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

 > Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
 > Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
 > Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
 > Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
 > Тесты снижают уровень стресса.


 # Дополнительные материалы
 Начинаем писать тесты правильно https://www.youtube.com/watch?v=zsz8kdi62mE
 */


/**@@
 tests/cart.test.js
 Напишите тесты для класса Cart, представляющего собой покупательскую корзину. Интерфейс:

 1. addItem(good, count) – добавляет в корзину товары и их количество. Товар это объект у которого два свойства: name – имя и price – стоимость.
 2. getItems – возвращает товары в формате [{ good, count }, { good, count }, ...]
 3. getCost – возвращает стоимость корзины. Стоимость корзины высчитывается как сумма всех добавленных товаров с учетом их количества.
 4. getCount – возвращает количество товаров в корзине
 */

const cart = new Cart();
cart.addItem({ name: 'car', price: 3 }, 5);
cart.addItem({ name: 'house', price: 10 }, 2);
cart.getItems().length; // 2
cart.getCost(); // 35


// FILE: /tests/cart.test.js
import getImpelementation from '../implementations';

const Cart = getImpelementation();

test('Cart', () => {
    const cart = new Cart();
    expect(cart.getItems()).toHaveLength(0);

    cart.addItem({ name: 'car', price: 3 }, 5);
    expect(cart.getItems()).toHaveLength(1);
    expect(cart.getCost()).toBe(15);
    expect(cart.getCount()).toBe(5);

    cart.addItem({ name: 'house', price: 10 }, 2);
    expect(cart.getItems()).toHaveLength(2);
    expect(cart.getCost()).toBe(35);
    expect(cart.getCount()).toBe(7);
});




// # >>>>>> Покрытие кода тестами (Code Coverage) <<<<<<#

/**
 С ростом проекта, определить какой код протестирован, а какой нет, становится сложно, хотя подобная потребность возникает регулярно. Обычно это происходит тогда, когда в команде есть разные люди и не все из них ответственно подходят к написанию тестов. В таком случае может страдать качество проекта.

 Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения всех строчек кода, к тем строчкам, которые были задействованы во время выполнения тестов. Например, если в коде есть условная конструкция, и она не проверяется тестами, это значит, что все строки кода, входящие в неё, не будут покрыты.

 В Jest покрытие меряется крайне просто. Достаточно запустить тесты с флагом --coverage:
 $ npx jest --coverage
 PASS  __tests__/half.test.js
 ✓ half (3ms)

 ----------|----------|----------|----------|----------|-------------------|
 File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
 ----------|----------|----------|----------|----------|-------------------|
 All files |    71.43 |      100 |    66.67 |    71.43 |                   |
 half.js  |       60 |      100 |       50 |       60 |             12,13 |
 index.js |      100 |      100 |      100 |      100 |                   |
 ----------|----------|----------|----------|----------|-------------------|
 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        2.236s
 Ran all test suites.


 После выполнения всех тестов, Jest выводит сводную таблицу по каждому файлу. В ней показан процент покрытия кода тестами. В примере выше видно что в файле index.js покрыто 100% кода, а вот в файле half.js только 60%. При этом общее покрытие кода 71.43%. Обратите внимание, что покрытие сильно зависит от того, какие тесты выполнились. Если часть из них упала с ошибками, то Jest покажет намного меньшее покрытие, так как тесты просто не доберутся до всего кода. Поэтому покрытие меряют только тогда, когда все тесты зелёные.

 Эта статистика помогает найти места, где тестов мало. Дальше по ситуации их можно начинать добавлять. Если в проекте тестов не было вообще, то эта статистика начинает быстро расти. А вот дальше, ближе к 90 процентам, придётся бороться за каждую строчку кода.

 Однако, покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. Как правило это тесты на пограничные случаи. В разработке есть хорошая практика: перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, и только затем уже можно починить их.

 Какое покрытие считается допустимым? 100% покрытия выглядит красиво, но добиться его невероятно сложно. И для большинства проектов бессмысленно. Затраченные усилия не окупятся. Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.
 */



// # >>>>>> Разработка через тестирование (TDD) <<<<<<#

/**
 В какой момент лучше писать тесты? Вообще, существует три подхода:
 > Тесты пишутся после кода
 > Тесты пишутся вместе с кодом
 > Тесты пишутся до кода

 В некоторых ситуациях, особого выбора нет. Например, при системном тестировании, когда тест имитирует поведение пользователей и выполняет действия в браузере. Такие тесты пишутся после кода.

 В тестах более низкого уровня, интеграционных и модульных тестах, обычно можно выбирать из вариантов описанных выше. И подход "писать тесты после кода" относится к наименее полезным. Почему?

 Сам процесс написания кода, связан с постоянным запуском кода и проверкой того, что он работает. В самых простых, например, учебных задачах, этот запуск происходит довольно быстро.
 */

// Легко запустить, легко проверить, что результат правильный
capitalize('hello'); // Hello

/**
 В реальном коде подготовка данных для проверки работы кода может занимать значительное время, минуты и десятки минут. С другой стороны, результатом работы проверяемого кода может быть что-то сложное, например, множество записей в базе данных или вывод определённой непростой структуры. Тогда каждый запуск кода на проверку превращается в целое приключение.
 */

// Сложно подготовить данные. Сложно проверить результат работы.
// Загрузка товаров из 1C в базу данных
loadGoodsFrom1c();


/**
 Именно здесь на сцену выходит вариант "писать тесты до кода". У многих начинающих разработчиков, эта фраза вызывает ступор. Как можно писать тесты до того, как был написан код? Оказывается, можно и это даже приятно.

 Допустим мы хотим написать функцию, которая может повторять переданную строчку указанное количество раз:
 */

repeat('$', 3); // $$$

/*
    Мы знаем что, она принимает на вход, мы знаем, какой у неё должен быть выход (спасибо, что ты чистая https://ru.wikipedia.org/wiki/Чистота_функции). Можем ли мы уже написать тесты? Конечно!
*/

test('repeat', () => {
    expect(repeat('$', 3)).toBe('$$$');
});

/**
 Сколько займёт времени написать такой тест у опытного разработчика? Думаю секунд 15, именно столько времени мне понадобилось для кода выше. Зато, теперь для проверки работы этого кода достаточно набрать jest в консоли.

 У тестирования до написания кода есть ещё одно мощное преимущество. Оно заставляет программиста в первую очередь думать о дизайне своего решения, о том, как им будут пользоваться. А не о том, как красиво он реализует всё внутри. Грамотные интерфейсы – залог успеха.

 В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD).

 TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла, где на каждой итерации пишется тест, который не проходит, затем дописывается код, удовлетворяющий данному тесту. После этого всё повторяется. Так шаг за шагом строится приложение.

 Сейчас все по инерции продолжают говорить именно о таком способе. В нём тесты пишутся на все части кода с максимальной детализацией. Этот вид TDD хоть и говорит о важности дизайна, но фокусируется на конкретных функциях и классах приложения вместо цельной картины. Но есть и другое TDD, где тесты на внутренние части не пишутся почти никогда. Подробнее об этом в статье в дополнительных материалах.

 Сам по себе Хекслет, яркий пример того, как тесты пишутся до кода. Абсолютно во всех наших практиках на всех языках, тесты есть, а кода нет :)

 # Дополнительные материалы
 Начинаем писать тесты правильно https://ru.hexlet.io/blog/posts/how-to-test-code
 Начинаем писать тесты правильно (Видео) https://www.youtube.com/watch?v=zsz8kdi62mE
 */



// # >>>>>> Непрерывная интеграция (CI) <<<<<<#

/**
 Теперь, когда мы немного разобрались с тестами, давайте поговорим о культуре их запуска.

 Локальный запуск тестов – персональная ответственность. Хорошие разработчики используют тесты непрерывно во время разработки и обязательно запускают их перед пушем (git push).

 Но этого недостаточно. Там где есть люди, там присутствует человеческий фактор и ошибки. Поэтому даже несмотря на локальный запуск, тесты должны запускаться автоматически на серверах непрерывной интеграции.

 Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозиторий. За этим следит либо специальный сервер либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно для текущего приложения) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это тесты и линтер (проверка оформления кода). Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.

 Немного терминологии и описание процесса. На каждый коммит запускается сборка (build). Во время сборки собирается приложение, устанавливаются зависимости, прогоняются тесты и все остальные проверки. Сборка, завершившаяся без ошибок, считается успешной. Если сборка не проходит, то программист получает уведомление. Дальше он смотрит отчёт и исправляет ошибки.

 Для внедрения непрерывной интеграции есть два пути. Первый, поставить себе на сервер Jenkins или его аналог. Этот вариант требует много ручной работы (плюс поддержка сервера). Он подходит компаниям, в которых очень сложные приложения, или они не хотят допускать утечки кода наружу, или у них настолько много проектов, что свой сервер дешевле чем стороннее решение. Второй путь – воспользоваться сервисом непрерывной интеграции. Таких сервисов десятки, если не сотни. Есть из чего выбрать. Как правило, большинство из них бесплатны для открытых проектов. Одним из первых подобных сервисов был https://travis-ci.com. Он до сих пор остаётся наиболее популярным, особенно среди проектов на Гитхабе.

 Travis CI подключён ко всем открытым проектам Хекслета (пример). Для удобства, он даёт "бейджик", картинку, которая вставляется в файл проекта README.md. Она показывает текущий статус проекта (завершилась ли успешна последняя сборка или нет) и по клику на неё можно попасть в интерфейс самого Travis CI.

 # Дополнительные материалы
 Экстремальное программирование https://ru.hexlet.io/blog/posts/xp
 Среды разработки. Мужики, выкатывай! https://ru.hexlet.io/blog/posts/environment
 */



// ########### JS: Продвинутое тестирование ############
/**
 Тесты – большая тема со множеством нюансов. Одно дело тестировать чистые функции, другое – приложение, в котором есть взаимодействие с базой данных, отправка запросов по сети, емейлов, в котором используются таймеры и асинхронность. Даже тестирование ошибок обладает своими особенностями.

 При правильной организации таких тестов, стоимость их поддержки остается достаточно низкой, а скорость работы растет. При неправильной же, очень легко попасть в ловушку, когда тесты вроде бы есть, но писать их тяжело, они постоянно ломаются и их приходится часто переписывать.

 Этот курс рассказывает о том, как тестировать сложные ситуации, в которых есть побочные эффекты, асинхронный код, в том числе завязанный на таймеры. Основные темы:

 > Тестирование ошибок. Снепшот тесты.
 > Фикстуры. Организация тестовых данных.
 > Изоляция побочных эффектов. Стабы. Инверсия зависимости.
 > Моки. Тестирование методом черного ящика.
 > Таймеры. Управление временем.
 > Тестирование асинхронного кода.

 #@ Дополнительная литература
 Так как это курс по продвинутому тестированию, то он рассчитывает на определенные знания с вашей стороны. Ниже список того, что может понадобится в разных уроках для их полного понимания:

 async/await https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/async-await/theory_unit
 HTTP https://ru.hexlet.io/courses/http_protocol
 JavaScript Testing Best Practice https://github.com/goldbergyoni/javascript-testing-best-practices
 */



// >>>>>>> Тестирование ошибок <<<<<<<

/**
 Основные тесты, которые нужно писать, это тесты на успешные сценарии работы. Но в некоторых ситуациях код должен возвращать ошибки и их тоже бывает нужно проверять. Под ошибками понимаются ситуации, в которых код бросает исключение. В чем их особенность? Посмотрите на тест:
 */

test('boom!', () => {
    try {
        functionWithException(0);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Этот код пытается протестировать ситуацию, при которой функция functionWithException выбрасывает исключение если ей передать 0. Как вы думаете, этот тест проверит что функция действительно порождает исключение?

 Правильный ответ – нет. Если функция functionWithException не выбросит исключение, то тест пройдет, так как код не попадет в блок catch. Исправить эту ситуацию можно хитрым способом, достаточно добавить заведомо ложное ожидание сразу после вызова функции:
 */

test('boom!', () => {
    try {
        functionWithException(0);
        expect(false).toBe(true);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Смотрится немного странно, но зато работает. Теперь ошибка точно будет отловлена.

 Документация Jest рекомендует другой способ. Jest позволяет указать количество ожиданий, которые должны выполнится в тесте. Если этого не происходит, то Jest рапортует об ошибке:
 */

test('boom!', () => {
    // Количество утверждений, которые должны быть запущены в этом тесте
    expect.assertions(1);
    try {
        functionWithException(0);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Этот способ крайне опасен. Он порождает хрупкие тесты, которые завязаны на то, как они написаны. Если вы захотите добавить новое ожидание, то тест провалится и придется его править. Вам всегда придется следить за тем, чтобы это число было правильным. Не используйте этот подход, чем больше контекстной зависимости, тем сложнее разобраться в коде и проще наделать ошибок.

 И наконец-то мы подобрались к правильному способу. В jest есть матчер, который самостоятельно отлавливает исключение и убеждается что оно было.
 */

test('boom!', () => {
    expect(() => {
        functionWithException(0);
    }).toThrow();
})

/**
 Главная особенность этого матчера в том, что он принимает на вход функцию, которая вызывается внутри. Благодаря этому, он может самостоятельно отследить появление исключения. Этот код не содержит неявного состояния и лишних проверок, он делает ровно то что нужно делать и не требует от нас слишком много. Более того, теоретически возможен тест, в котором делается сразу несколько проверок на различные исключения. Это значительно сложнее провернуть с предыдущими способами.

 Иногда важно не просто поймать исключение, но и убедиться в том, что это ожидаемое исключение. Сделать это можно передав в матчер toThrow() строку, которая должна присутствовать в сообщении исключения.
 */

test('boom!', () => {
    expect(() => {
        functionWithException(0);
    }).toThrow('divide by zero');
})

/**
 Дополнительные материалы
 Снепшоты ошибок https://jestjs.io/docs/en/expect#tothrowerrormatchingsnapshothint
 */



// >>>>>>> Фикстуры <<<<<<<

// Представьте себе функцию, которая принимает на вход HTML в виде строки, извлекает из него все ссылки и возвращает как массив:

// Для тестирования подобной функции, желательно взять HTML близкий к реальному.
// Он хоть и не гарантирует работоспособности функции, но по крайней мере дает хорошее разнообразие по структуре документа.
// HTML взят из нашего проекта cv.hexlet.io
const html = `
<div class="card mb-3"><div class="card-body"><div class="d-flex flex-column flex-sm-row">
<div class="d-flex flex-column mr-4"><div class="text-muted text-center mb-3">
<div class="h2 mb-0 font-weight-lighter">1</div><div class="small">Ответ</div></div>
<div class="text-muted text-center mb-3"><div class="h2 mb-0 font-weight-lighter">7</div>
<div class="small">Просмотров</div></div></div><div><h5 class="card-title">
<a href="/resumes/1">Backend Software Engineer</a></h5><div class="card-text">
<p>Программист-самоучка, избравший путь постоянного самосовершенствования.
Ценю красивый и лаконичный код, люблю функциональное программирование 
(великая троица <code>map</code>, <code>filter</code>, <code>reduce</code>).</p>
<p>Использую JS, Ruby, PHP, Python, Elixir, Clojure в разной степени мастерства.</p>
<p>Восхищаюсь семейством LISP-языков, пишу свой интерпретатор LISP на Elixir.
В настоящий момент углубляюсь в ОС Unix, чтобы в дальнейшем улучшить навыки DevOps.</p>
</div><div class="text-right small"><span class="mr-3 text-muted">12 дней</span>
<a href="/users/6">Улугбек Туйчиев</a></div></div></div></div></div>
`;

const links = extractLinks(html);
console.log(links);
// => ['/resumes/1', '/users/6']

/**
 Кусок HTML в начале теста выглядит страшно. Он большой и состоит из нагромождения тегов. Конечно можно постараться и отформатировать его, но это будет ручная работа. Для любого редактора это просто строка в JavaScript. Но дело не только в форматировании, у такого способа работы с большими кусками данных есть и другие недостатки:

 При обновлениях очень легко допустить ошибку, которую сложно обнаружить визуально. Редактор ничем не сможет помочь.
 Чем больше таких данных в тестах тем сложнее их читать и отделять логику от самих данных.
 Было бы гораздо удобнее, если бы HTML хранился как обычный HTML в своем собственном файле. Это несложно сделать. В таком случае тест будет выглядеть так:
 */

import fs from 'fs';

// Jest поддерживает async/await функции
test('extractLinks', async () => {
    // html находится в файле withLinks.html в директории __fixtures__
    // При чтении текстовых файлов, в конце может добавляться пустая строка.
    // Она удаляется с помощью метода `trim` если нужно
    const html = await fs.readFile(`${__dirname}/../__fixtures__/withLinks.html`, 'utf-8');
    // Теперь с HTML удобно работать и он не загромождает тесты.
    const links = extractLinks(html);
    expect(links).toEqual(['/resumes/1', '/users/6']);
});

/**
 Данные, которые нужны во время запуска тестов, называются фикстурами. Это не обязательно текстовые данные. Фикстурами могут быть картинки, json и xml файлы, записи в базе данных и многое другое. Иногда частью фикстур может быть и код, но это довольно редкая ситуация. Подобные фикстуры нужны при тестировании различных анализаторов кода таких как eslint или babel.

 Обычно фикстуры хранятся в отдельных файлах в своей директории. В Jest для этого рекомендуется создавать директорию __fixtures__ в корне проекта. Затем они читаются и по необходимости используются в тестах.

 Пример:

 $ tree __fixtures__

 ├── after.ini
 ├── after.json
 ├── after.yml
 ├── before.ini
 ├── before.json
 ├── before.yml
 └── result.txt
 */



// >>>>>>> Побочные эффекты <<<<<<<
/**
 Проще всего тестировать код состоящий из чистых функций. Данные на вход, результат на выходе. Никаких неожиданностей, никакого состояния, никакого взаимодействия с внешним миром.
 */

import _ from 'lodash';

expect(_.last([1, 2, 3])).toBe(3);

/**
 Далеко не весь код можно назвать чистым. Без побочных эффектов не обходится ни одна реальная программа. Побочные эффекты резко усложняют тестирование, требуют более глубоких навыков их написания и лучшего понимания того, как организовывать такой код.

 Вот лишь некоторые примеры использования побочных эффектов:

 > Случайные числа
 > HTTP-запросы
 > Отправка писем
 > Взаимодействие с базой данных
 > Взаимодействие с глобальными переменными
 > Чтение и/или запись файлов
 > Оперирование текущим временем
 > В чем заключается сложность? Представьте себе функцию, которая выполняет отправку письма пользователю:
 */

if (sendGreetingEmail(user)) {
    // Вывести на сайте сообщение о том что письмо было отправлено
};

// Вот ее гипотетический тест:

expect(sendGreetingEmail(user)).toBe();

/**
 С этим тестом определенно не все в порядке. Все что мы тут проверяем – то что функция возвращает true, но мы ничего не знаем о том, оправляет ли эта функция письмо и если отправляет то какое? Все ли нормально с этим письмом?

 Но ситуация еще сложнее. Отправлять реальные письма ни в коем случае нельзя. Во-первых это не этично. Во-вторых, даже если отправлять письма на фейковые аккаунты, мы все равно взаимодействуем с внешней системой. Внешние системы это долго, такие тесты будут выполняться значительно больше по времени, чем тесты чистых функций. Кроме того, любое взаимодейстие с внешней средой не детерминировано. Начиная от того, что сеть не надежна и эти тесты могут падать с ошибками без видимой на то причины, заканчивая тем, что за слишком частую отправку писем, почтовая служба может забанить ip адрес с которого идет отправка. И, наконец, это может быть не безопасно.

 И это только отправка писем. С другими побочными эффектами будут другие сложности. И для их решения потребуются другие подходы к организации кода и тестов. В течении нескольких следующих уроков, мы разберем наиболее распространенные примеры побочных эффектов и того как правильно с ними работать.
 */



// >>>>>>> Тестирование кода взаимодействующего с файлами <<<<<<<

/**
 Наиболее типичный побочный эффект – взаимодействие с файлами (файловые операции). В основном это либо чтение файлов, либо запись в них. С чтением разбираться значительно проще, поэтому с него и начнем.

 Чтение файлов
 В большинстве случаев, чтение файлов не доставляет особых проблем. Оно ничего не изменяет и выполняется локально, в отличии от сетевых запросов. Это значит что при наличии необходимого файла и нужных прав, вероятность случайных ошибок крайне низка.

 При тестировании функций читающих файлы должно выполняться ровно одно условие. Функция должна позволять менять путь до файла. В таком случае, достаточно создать файл нужной структуры в фикстурах.
 */

// Функция читает файл со списком пользователей системы и возвращает их имена
// В линуксе это файл /etc/passwd

const userNames = readUserNames();

/**
 В тестах читать /etc/passwd нельзя, потому что содержимое этого файла зависит от окружения в котором запущены тесты. Для тестирования нужно создать файл аналогичной структуры в фикстурах и указать его при запуске функции:
 */

import fs from 'fs';

const getFixturePath = (filename) => `${__dirname}/../__fixtures__/${filename}`;

test('readUserNames' () => {
    // ../__fixtures__/passwd
    const passwdPath = getFixturePath('passwd');
    const userNames = readUserNames(passwdPath);
    expect(userNames).toEqual(/* ожидаемый список */);
});


// # Запись файлов
/**
 С записью файлов уже сложнее. Главная проблема – отсутствие гарантированной идемпотентности. Это значит, что повторный вызов функции записывающей файлы, может вести себя не как первый вызов, например, завершаться с ошибкой, или приводить к другим результатам.
 Почему? Представьте себе, что мы пишем тесты на функцию log(message), которая дописывает все переданные в нее сообщения в файл:
 */

const log = makeLogger('development.log');
await log('first message');
// cat development.log
// first message
await log('second message');
// cat development.log
// first message
// second message

/**
 Это значит что каждый запуск тестов будет немного другим. При первом запуске тестов, создает файл для хранения логов. Затем он начнет заполняться. Это приводит к целой пачке проблем:

 Наверняка внутри этой функции, процесс создания файла это особый случай, который нужно тестировать отдельно. Повторные запуски тестов перестанут проверять эту ситуацию.
 Сложнее написать предсказуемый тест. Придется дополнительно придумывать хитрые схемы, например проверять только последнюю строку в файле. Такой подход понижает качество теста.
 Не особенно критично, но все же, в процессе запуска тестов появляется файл, который постоянно растет в размерах.
 При правильной организации тестов, каждый тест работает в идентичном окружении на каждом запуске. Для этого, например, можно удалять файл после выполнения каждого теста. В Jest есть колбек afterEach который выполняется после каждого теста. Эту задачу можно попробовать решить с его помощью:
 */

import fs from 'fs';

test('log' () => {
    const log = makeLogger('development.log');

    await log('first message');
    const data1 = await fs.readFile('development.log', 'utf-8');
    expect(data1).toEqual(/* ... */)

    await log('second message');
    const data2 = await fs.readFile('development.log', 'utf-8');
    expect(data2).toEqual(/* ... */)
});

afterEach(async () => {
    await fs.unlink('development.log');
});

/**
 В большинстве ситуаций такое решение работает нормально, но все же не во всех. Выполнение кода тестов операция не атомарная. Нет никакой гарантии что колбек afterEach выполнится. Есть много причин, по которым этого может не произойти, начиная от внезапного отключения электроэнергии, заканчивая ошибками в самом Jest.

 Есть только один надежный способ делать очистку – делать это до теста, а не после. В beforeEach. С таким подходом есть только одна небольшая сложность. При первом запуске тестов файла нет. Это значит, что прямой вызов unlink завершится с ошибкой и тесты не смогут выполнится. Чтобы избежать этого:
 */

import _ from 'lodash';

beforeEach(async () => {
    await fs.unlink('development.log').catch(_.noop);
});

/**
 Другой вопрос при записи файлов. Куда их сохранять? Однозначно избегайте записи файлов прямо внутри проекта. Если тестируемый код позволяет сконфигурировать место записи, то используйте системную временную директорию. Ее можно получить через модуль os:
 */


import os from 'os';

console.log(os.tmpdir());

/**
 #@ Виртуальная файловая система (ФС)
 Это еще один способ тестировать код работающий с ФС. С помощью специальной библиотеки, во время тестов, создается виртуальная файловая система. Она автоматически подменяет реальную файловую систему для модуля fs. Это значит, что код функции, которая тестируется, трогать не надо. Эта функция продолжает думать что она работает с реальным диском. Вся конфигурация, при этом, задается снаружи:
 */

import mock from 'mock-fs';

// Конфигурация fs
// Любые операции с этими файлами будут происходить в памяти
// без взаимодействия с реальной файловой системой
mock({
    'path/to/fake/dir': {
        'some-file.txt': 'file content here',
        'empty-dir': {/** empty directory */}
    },
    'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),
    'some/other/path': {/** another empty directory */}
});

await fs.unlink('some-file.txt');

/**
 Этот способ дает идемпотентность из коробки. Вызов функции mock формирует окружение на каждый запуск с нуля. То есть достаточно добавить ее в beforeEach и можно приступать к тестированию.
 */



// >>>>>>> Инверсия зависимостей <<<<<<<

/**
 Далеко не всегда результат работы функции связан с побочным эффектом, как это было в предыдущем уроке. Иногда побочный эффект это просто дополнительное действие, которое скорее мешает протестировать основную логику.

 Представьте себе функцию, которая регистрирует пользователя. Она создает запись в базе данных и отправляет приветственное письмо:
 */

const params = {
    email: 'lala@opa.ru',
    passsword: 'qwerty',
};
registerUser(params);

/**
 Эта функция делает много всего, но главное, что нас волнует – правильная регистрация пользователя. Типичная регистрация сводится к добавлению в базу данных записи о новом пользователе. Именно это и нужно проверять – наличие новой записи в базе данных с правильно заполненными данными. А вот возврат функции нам никак не поможет.

 Как правило, базу данных в тестах не прячут. В веб-фреймворках она доступна в тестовой среде и работает как обычно. Идемпотентность в ней достигается за счет транзакций. Перед тестом она начинается и после теста откатывается. Благодаря этому, каждый тест запускается в идентичном окружении и не важно как он его меняет:
 */

// Гипотетический пример
const ctx = /* connect to db */;
beforeEach(() => ctx.beginTransaction())
test('registerUser', () => {
    const id = registerUser({ name: 'Mike' });
    const user = User.find(id)
    expect(user).toHaveProperty('name', 'Mike');
})
afterEach(() => ctx.rollbackTransaction())

/**
 А вот с отправкой писем все сложнее. Ее точно делать нельзя, но как этого добиться? Посмотрите на то как примерно может выглядеть функция регистрации пользователя:
 */

import sendEmail from './emailSender';
const registerUser = (params) => {
    const user = new User(params);
    if (user.save()) {
        sendEmail('registration', { user });
        return true;
    }
    return false;
}

// Существует несколько подходов позволяющих отключить отправку в тестах. Самый простой, переменная окружения, которая показывает среду выполнения:

// Выполняем этот код только если мы не в тестовой среде
if (process.env.NODE_ENV !== 'test') {
    sendEmail('registration', { user });
}

/**
 Несмотря на простоту использования, такой подход считается плохой практикой. Формально, из-за него происходит нарушение абстракции, код начинает знать о том, где он выполняется. Со временем таких проверок становится все больше и код становится грязнее. Более того, если нам все же надо убедиться что письмо отправляется (с правильными данными!), то мы не сможем этого сделать.

 Следующий способ – поддержка режима тестирования внутри самой библиотеки. Например где-нибудь на этапе инициализации тестов можно сделать так:
 */

// setup.js в jest
import sendEmail from './emailSender';

// У этого подхода много разновидностей, начиная от установки флага,
// заканчивая заменой функций в прототипе.
sendEmail.test = true;

// Теперь в любом другом месте где импортируется и используется функция sendEmail, реальная отправка происходить не будет:

// Ничего не происходит
sendEmail('registration', { user });

/**
 В отличии от первого варианта, прикладной код ни о чем не догадывается
 Это довольно популярное решение. Обычно информация о том, как правильно включить режим тестирования, находится в официальной документации конкретной библиотеки.

 Что делать если используемая библиотека не поддерживает режим тестирования? Существует еще один, наиболее универсальный способ. Он основан на применении инверсии зависимостей. Программу можно изменить так, чтобы она вызывала функцию sendEmail не напрямую, а принимала ее как параметр:
 */

import sendEmail from './emailSender';

// Ставим значение по умолчанию, чтобы не пришлось постоянно указывать функцию
const registerUser = (params, send = sendEmail) => {
    const user = new User(params);
    if (user.save()) {
        send('registration', { user });
        return true;
    }
    return false;
}

// И тест:

const fakeSendEmail = (...args) => {
    /* Например письмо можно вывести в лог для удобства отладки */
};

test('registerUser', () => {
    const id = registerUser({ name: 'Mike' }, fakeSendEmail);
    const user = User.find(id);
    expect(user).toHaveProperty('name', 'Mike');
});

/**
 Такой способ сложнее в реализации, особенно если функция находится глубоко в стеке вызовов. Это значит, что придется прокидывать нужные зависимости через всю цепочку функций сверху вниз. Самих зависимостей может быть много, и чем больше используется инверсия, тем сложнее код. За гибкость приходится платить.

 Теперь плюсы. Ни библиотека, ни код ничего не знают про тесты. Этот способ наиболее гибкий, он позволяет задавать конкретное поведение для конкретной ситуации. В некоторых экосистемах инверсия зависимостей определяет процесс сборки приложения. Особенно в PHP, Java и C# мире.
 */



// >>>>>>> Тестирование HTTP запросов <<<<<<<

/**
 Инверсия зависимостей крайне мощная техника, которая работает не только с функциями, но и с объектами. Рассмотрим ее глубже на примере HTTP запросов и познакомимся с таким понятием как "заглушка" (Stub).

 Предположим что у нас есть функция, которая анализирует приватные репозитории организации на гитхабе и возвращает те, что являются форками:
 */

// Библиотека для работы с github api
import Octokit from '@octokit/rest';

const getPrivateForksNames = async (org) => {
    const client = new Octokit();
    // Возвращает список приватных репозиториев указанной организации
    const { data } = await client.repos
        .listForOrg({
            org,
            type: 'private',
        });
    // Оставляем только имена форков
    return data.filter(repo => repo.fork).map(repo => repo.name);
};

// Давайте ее протестируем. Что мы хотим от этой функции? В первую очередь убедиться что она выполняет свою работу правильно – возвращает массив приватных форков. Идеальный тест выглядел бы так:

test('getPrivateForksNames', async () => {
    const privateForks = await getPrivateForksNames('hexlet');
    expect(privateForks).toEqual([/* массив имен которые мы ожидаем увидеть */]);
});

/**
 К сожалению не все так просто. Внутри функции выполняется HTTP запрос. Прикинем какие проблемы из-за этого могут возникнуть:

 Нестабильная сеть может тормозить выполнение тестов и приводит к "фантомным" ошибкам. Тесты будут иногда проходить иногда нет.
 У сервисов подобных github.com, установлены ограничения на запросы в секунду, в час, день и так далее. Со 100% вероятностью тесты начнут упираться в эти лимиты. Более того, есть шанс что машина с которой идут запросы, будет заблокирована.
 Реальные данные на гитхабе не статичны, они могут и скорее всего будут меняться, что опять же приведет к ошибкам и необходимости править тесты.
 В данном примере, http запрос воспринимается как помеха к тому, чтобы протестировать нашу основную логику. Мы доверяем github.com и его библиотеке @octokit/rest, то есть нам не нужно проверять что она работает правильно (иначе можно свихнуться если не доверять никому).

 HTTP-запрос нужно "выключить" в тестах. Из предыдущего урока мы узнали о нескольких способах выхода из этой ситуации. В данном случае подходит только один – инверсия зависимости. Для этого, добавим вторым аргументом у функции сам клиент Octokit. Это позволит подменить его в тестах:
 */

import Octokit from '@octokit/rest';

// Библиотека передается снаружи и ее можно подменить
const getPrivateForksNames = async (org, client = new Octokit()) => {
    // ...
};
/**
 Нам придется реализовать фейковый (не настоящий) клиент, который ведет себя примерно так же как и реальный Octokit, за исключением того, что он не выполняет сетевых запросов. Так же, нам нужно описать конкретные данные, которые вернет вызов listForOrg. Только в таком случае мы сможем протестировать, что функция getPrivateForksNames работает верно.
 */

// Структура этого класса описывает только ту часть,
// которая необходимо для вызова await client.repos.listForOrg(...)
class OctokitFake {
    // здесь мы описываем желаемые данные, которые вернуться в тесте
    constructor(data) {
        this.data = data;
    }

    repos = {
        listForOrg: () => {
            return Promise.resolve({ data: this.data }); // так как метод асинхронный
        }
    }
}

// И сам тест с использованием этого клиента:

import OctokitFake from '/OctokitFake';

test('getPrivateForksNames', () => {
    const client = new OctokitFake(/* ответ от github, который мы хотим проверить */);
    const privateForks = getPrivateForksNames('org name', client);
    expect(privateForks).toEqual(/* что мы ожидаем основываясь на том что вернул listForOrg */);
});

/**
 В тестировании, для подобных фейковых объектов (или функций), есть специальное название – стаб (stub). Стаб заменяет реальный объект или функцию, позволяя избежать выполнения побочных эффектов или сделать код детерминированным. Стаб не используется для проверки чего либо, он лишь позволяет изолировать ту часть, которая "мешает" тестированию основной логики.
 */



// >>>>>>> Манки патчинг <<<<<<<


// В предыдущем уроке мы тестировали гипотетическую функцию getPrivateForksNames(org) применяя инверсию зависимостей. Вспомним содержимое этой функции в ее исходном виде:

import Octokit from '@octokit/rest';

const getPrivateForksNames = async (org) => {
    const client = new Octokit();
    const { data } = await client.repos
        .listForOrg({
            org,
            type: 'private',
        });
    return data.filter(repo => repo.fork).map(repo => repo.name);
};

/**
В некоторых ситуациях, инверсия подходит идеально, в других из-за нее код становится значительно сложнее и иногда запутаннее, особенно если зависимости требуются где-то глубоко в стеке вызовов. Но есть способ, который позволяет добраться до нужных вызовов и изменить даже без инверсии зависимостей.

Прототипная модель js позволяет менять поведение объектов без прямого доступа к ним. Для этого достаточно заменить методы в прототипе. Такой подход, когда меняется поведение самой программы во время ее работы, называется манки патчингом (monkey patching). Он считается плохой практикой при написании обычного кода в js (в ruby манки патчинг нормальная практика), но он очень популярен и удобен в тестах. Самый известный пример – библиотека nock. С ее помощью перекрывают реальные сетевые запросы.

Эта библиотека работает так. Она берет стандартный модуль ноды http и заменяет внутри него некоторые методы, которые используются разными библиотеками для выполнения HTTP запросов. Причем не просто заменяет, а позволяет гибко настраивать то, какие запросы и как перехватывать, какие возвращать данные, заголовки и коды ответа.
*/

import nock from nock;
import { getPrivateForkNames } from '../src';

test('getPrivateForkNames', async () => {
    nock(/api\.github\.com/)
        .log(console.log) // для удобства отладки, можно удалить если не нужно
        // get – для GET запросов, post – для POST запросов и так далее
        .get(/\/orgs\/hexlet\/repos/)
        .reply(200, [{ fork: true, name: 'one' }, { fork: false, name: 'second' }]);

    const names = await getPrivateForkNames('hexlet');
    expect(names).toEqual(['one']);
});

/**
Цепочка nock(domain).get(uri) задает полный адрес страницы, запрос к которой надо перехватить. Nock анализирует все выполняемые запросы и подменяет только тот, который соответствует данным параметрам. Домен и адрес страницы могут указываться как целиком, так и через регулярное выражение чтобы не писать слишком много.

    Метод reply(code, body, headers) описывает ответ, который нужно вернуть по данному запросу. В самом простом случае достаточно указать код возврата. В нашей же ситуации, кроме кода нужны данные. Именно на этих данных мы и проверяем работу функции getPrivateForkNames.

    У Nock есть метод, запрещающий любые HTTP-запросы из кода: nock.disableNetConnect(). Рекомендуется вызывать его в начале файла с тестами для предотвращения случайных запросов. Помимо этого, он помогает увидеть на какие страницы выполняют запросы сторонние библиотеки. Вот как выглядит вывод после выключения внешних соединений (при условии что не выполнялось подмен запросов):

HttpError: request to https://api.github.com/orgs/hexlet/repos?type=private failed, reason: Nock: Disallowed net connect for "api.github.com:443/orgs/hexlet/repos?type=private"
    Здесь мы рассмотрели только самый базовый вариант использования Nock. У этой библиотеки огромная документация и множество вариантов использования. Полезно периодически ее просматривать в поисках более элегантных путей решения задач тестирования.

    В чем плюсы и минусы такого способа работы?

    Главный плюс, в том что такой способ тестирования практически универасальный. Его можно использовать с любым кодом, без необходимости править сам код. Программа даже не будет догадываться о том что ее тестируют.

    Минус же заключается в том что тестирование "черным ящиком" превращается в тестирование "прозрачным ящиком". Это значит что тест знает про устройство тестируемого кода и зависит от внутренностей. Такое знание делает тесты хрупкими. Функция может измениться без потери работоспособности, но тесты придется переписывать, потому что они завязаны на конкретные значения домена, страниц и формата возвращаемых данных.

    В большинстве ситуаций это не так критично. Поэтому смело используйте Nock в своих проектах, но не забывайте и про другие способы.


    # Дополнительные материалы
    Кассеты для Axios https://github.com/nettofarah/axios-vcr
*/




// >>>>>>> Моки <<<<<<<

/**
В тестировании очень популярен "мокинг". Технически он похож на стабинг и из-за этого их часто путают (специально или намеренно), но, все же, они служат разным целям и используются в разных ситуациях. Разберемся что это такое и когда он нужен.

До этого момента, мы рассматривали побочные эффекты, как помеху к тестированию нашей логики. Для их изоляции использовались стабы, либо прямое выключение логики в тестовой среде. После этого, можно было спокойно проверять правильность работы функции.

В некоторых ситуациях требуется кое-что другое. Не результат работы функции, а то что она выполняет нужное нам действие, например шлет правильный HTTP-запрос с правильными параметрами. Для этого понадобятся моки. Моки проверяют то, как выполняется код.
*/

// # HTTP

import nock from nock;
import { getPrivateForkNames } from '../src';

test('getPrivateForkNames', async () => {
    // Полное название домена
    const scope = nock('https://api.github.com')
        // Полный путь
        .get('/orgs/hexlet/repos/?private=true')
        .reply(200, [{ fork: true, name: 'one' }, { fork: false, name: 'second' }]);

    await getPrivateForkNames('hexlet');
    // Метод `scope.isDone()` возвращает `true` только тогда
    // когда соответствующий запрос был выполнен внутри `getPrivateForkNames`.
    expect(scope.isDone()).toBe(true);
});

/**
Это и называется мокинг. Мок проверяет что какой-то код выполнился определенным образом. Это может быть вызов функции, HTTP-запрос и тому подобное. Задача мока убедиться в том что это произошло и в том как конкретно это произошло, например что в функцию были переданы конкретные параметры.

    Что дает нам такая проверка? В данном случае, мало что. Да, мы убеждаемся, что вызов был, но само по себе это ещё ни о чем не говорит. Так когда же полезны моки?

    Представьте, что мы бы разрабатывали библиотеку @octokit/rest, ту самую, что выполняет запросы к github api. Вся суть этой библиотеки в том, чтобы выполнить правильные запросы с правильными параметрами. Поэтому там нужно обязательно проверять выполнение запросов с указанием точных урлов. Только в таком случае можно быть уверенными что она выполняет верные запросы.

    В этом ключевое отличие мока от стаба. Стаб устраняет побочный эффект, чтобы не мешать проверке результата работы кода, например, возврату данных из функции. Мок фокусируется на том как конкретно работает код, что он делает внутри. При этом, чисто технически мок и стаб создаются одинаково, за исключением того, что на мок вешают ожидания, проверяют вызовы. Это приводит к путанице, потому что часто моками называют стабы. С этим ничего уже не поделать, но про себя всегда пытайтесь понять о чем идет речь, это важно. От этого зависит фокус тестов.
*/

// # Функции

/**
Моки довольно часто используют с функциями (методами). Они могут проверять множество вещей:

Что функция была вызвана и сколько раз она была вызвана
Какие и сколько аргументов было передано в функцию
Предположим что мы хотим протестировать функцию forEach. Она вызывает колбек для каждого элемента коллекции:
*/

[1, 2, 3].forEach((v) => console.log(v)); // или проще [1, 2, 3].forEach(console.log)

/**
Эта функция ничего не возвращает, поэтому напрямую ее не протестировать. Можно попробовать сделать это с помощью моков. Убедимся в том что она вызывает переданный колбек и передает туда нужные значения.

Так как мы изучаем Jest, то для создания моков воспользуемся встроенным механизмом Jest. В других фреймворках могут свои встроенные механизмы. Кроме того, как мы убедились выше, существует специализированные библиотеки для моков и стабов.
*/

test('forEach', () => {
    // Моки функций в jest создаются с помощью функции jest.fn
    // Она возвращает функцию, которая запоминает все свои вызовы и переданные аргументы
    // Потом это используется для проверок
    const callback = jest.fn();

    [1, 2, 3].forEach(callback);

    // Теперь проверяем что она была вызвана с правильными аргументами нужное количество раз
    expect(callback.mock.calls).toHaveLength(3);
    // Первый аргумент первого вызова
    expect(callback.mock.calls[0][0]).toBe(1);
    // Первый аргумент второго вызова
    expect(callback.mock.calls[1][0]).toBe(2);
    // Первый аргумент третьего вызова
    expect(callback.mock.calls[3][0]).toBe(3);
});

/**
С помощью моков мы проверили что функция была вызвана ровно три раза и ей последовательно для каждого вызова передавался новый элемент коллекции. В принципе, можно сказать что этот тест действительно проверяет работоспособность функции forEach. Но можно ли сделать это проще, без мока и без завязки на внутреннее поведение? Оказывается можно. Для этого достаточно использовать замыкание:
*/

test('forEach', () => {
    const result = [];
    const numbers = [1, 2, 3];
    numbers.forEach((x) => result.push(x));
    expect(result).toEqual(numbers);
});


// # Объекты

// Jest позволяет создавать моки и для объектов. Делаются они с помощью той же функции jest.fn(), так как она возвращает конструктор:

const myMock = jest.fn();

const a = new myMock();
const b = {};
const bound = myMock.bind(b);
bound();

console.log(myMock.mock.instances);
// > [ <a>, <b> ]

// Через этот мок можно узнать любую информацию обо всех инстансах:

expect(someMockFunction.mock.instances[0].name).toEqual('test');

// # Преимущества и недостатки

/**
Несмотря на то что существуют ситуации в которых моки нужны, в большинстве ситуаций их нужно избегать. Моки слишком много знают о том как работает код. Любой тест с моками из черного ящика превращается в белый ящик. Повсеместное использование моков приводит к двум вещам:

После рефакторинга приходится переписывать тесты (много тестов!) даже если код работает правильно. Происходит это из-за завязки на то, как конкретно работает код.
Код может перестать работать, но тесты проходят, потому что они сфокусированы не на результатах его работы, а на том как он устроен внутри.
Там где возможно использование реального кода, используйте реальный. Там где возможно убедиться в работе кода без моков, делайте это без моков. Излишний мокинг делает тесты бесполезными, а стоимость их поддержики высокой. Идеальные тесты – тесты методом черного ящика.

#@ Дополнительные материалы
Jest: Mocking functions https://jestjs.io/docs/ru/mock-functions
Mock aren't stub https://martinfowler.com/articles/mocksArentStubs.html
*/



// ######## JS: Полиморфизм #########

/**
ООП – тяжело формализуемое понятие, у которого очень много аспектов. В разные времена под ООП понимали и до сих пор понимают разные вещи. Существует как минимум два вида ООП, одно сформулированное Аланом Кеем, создателем языка SmallTalk, и другое - то, которое про полиморфизм, наследование и инкапсуляцию (Гради Буч). В современном мире, обычно под ООП имеют в виду второе, хотя первое живёт и здравствует во многих языках. Но даже когда мы говорим про второй вид ООП, всё равно разные языки делают акцент на разные возможности. То, что в одних языках считается признаком настоящего ООП, в других неприемлемо.

Если попытаться как-то обобщить и найти самое фундаментальное, то чем обладают все ООП-языки (по Бучу), то скорее всего общей точкой соприкосновения окажется полиморфизм подтипов.

Полиморфизм (подтипов), пожалуй, самая важная отличительная черта современного объектно-ориентированного программирования. Бенджамин Пирс. Автор книги Теория Типов В Языках Программирования.

В этом курсе мы подробно рассмотрим полиморфизм, механизмы его реализации и, самое главное, научимся правильно его применять. Основные темы данного курса:

> Виды полиморфизма: подтипов и параметрический
> Диспетчеризация и её виды.
> Инверсия зависимостей, а с ней и инъекция
> DI-контейнер
> SOLID (SRP, OCP, ISR, DIP)

Кроме того, мы познакомимся с понятием "шаблоны проектирования". Разберём их влияние на структуру кода, и познакомимся с некоторыми популярными:
> Null Object
> Strategy
> Factory

Поговорим о том, когда полиморфизм необходим, а когда он не нужен или даже вреден. Познакомимся с несколькими техниками, позволяющими получить полиморфное поведение без использования объектов. Для этого рассмотрим различные виды диспетчеризации.
*/




// >>>>>>> Параметрический полиморфизм <<<<<<<
/**
Слово "полиморфизм" в зависимости от контекста может означать разные вещи. Когда о полиморфизме говорят программисты на императивных языках, они, как правило, подразумевают "полиморфизм подтипов". В то же время программисты на функциональных языках имеют в виду "параметрический полиморфизм". О последнем и поговорим.

В этом уроке появляется код на Java. Не переживайте, если не понимаете его до конца, наша цель — разобраться с концепциями, а не с Java.

В библиотеке lodash есть функция _.concat(), которая объединяет переданные ей массивы:
*/

_.concat([1], [2, 3, 1]); // [1, 2, 3, 1]
_.concat(['one'], ['two', 'three']); // ['one', 'two', 'three']
_.concat([true], [false, false, true]); // [true, false, false, true]

// Эта функция объединяет любые массивы, независимо от типа данных, содержащихся внутри. Попробуем реализовать её самостоятельно.

// Это немного урезанная версия функции concat, она работает только с двумя аргументами
// каждый из которых – массив
// Функция создаёт новый массив, затем обходит по очереди переданные массивы и добавляет их значения
// во вновь созданный массив. Затем он возвращается наружу.

const concat = (arr1, arr2)
{
    const result = [];
    arr1.forEach((value) => result.push(value));
    arr2.forEach((value) => result.push(value));
    return result;
}

/**
Посмотрите внимательно на этот код. Выполняются ли в нём какие-либо операции над данными внутри массива? Правильный ответ: нет. Эти данные перекладываются из одного массива в другой, но над ними не происходит никаких действий. Наша новая функция concat, также как и исходная _.concat может работать с массивами, содержащими любые типы данных.

Для разработчиков, которые писали только на динамических языках, такое поведение кажется естественным, но в статических языках не всё так просто. Ниже пример определения массивов в Java:
*/

int numbers[] = {3, 1, 2, 5, 4};
String words[] = {"one", "two", "three"};
// В глаза бросается необходимость указывать тип. Для первого массива это int, для второго String. Нельзя создать массив без указания типа его значений. То же самое касается функций, обрабатывающих массивы:

class Main {
    public static void main(String[] args) {
        int[] a = {1, 2, 3, 4};
        int[] b = {4, 16, 1, 2, 3, 22};
        concat(a, b);
    }

    public static int[] concat(int[] arr1, int[] arr2) {
        int[] result = new int[arr1.length + arr2.length];
        int count = 0;

        for (int i = 0; i < arr1.length; i++) {
            result[i] = arr1[i];
            count++;
        }

        for (int j = 0; j < arr2.length; j++) {
            result[count] = arr2[j];
            count++;
        }

        return result;
    }
}

/**
Обратите внимание на сигнатуру метода concat: int[] concat(int[] arr1, int[] arr2). В отличие от варианта на JavaScript, здесь указано что входными параметрами являются массивы чисел. То есть для массива строк эта функция работать не будет. Не будет она работать и для всех остальных типов данных.

    Что это означает на практике? Очень простую и печальную вещь. Нам придётся реализовывать подобную функцию для каждого типа, при том что алгоритм внутри абсолютно идентичен.

    Именно тут нам пригодится параметрический полиморфизм. Статическим языкам приходится вводить в язык специальные конструкции, которые позволяют описывать подобные алгоритмы безотносительно типа параметра. В некоторых языках их называют шаблонами (C++) или дженериками (Java, C#):
*/

class Main {
    public static void main(String[] args) {
        Integer[] a = {1, 2, 3, 4};
        Integer[] b = {4, 16, 1, 2, 3, 22};
        myArrayMerge(a, b);
    }

    public static<T> T[] myArrayMerge(T[] arr1, T[] arr2) {
        T[] result = (T[]) new Object[arr1.length + arr2.length];
        int count = 0;

        for (int i = 0; i < arr1.length; i++) {
            result[i] = arr1[i];
            count++;
        }

        for (int j = 0; j < arr2.length;j++) {
            result[count] = arr2[j];
            count++;
        }

        return result;
    }
}

/**
В этом коде появляется тип T, что как раз и означает возможность использования с любым типом внутри массива. Теперь метод concat работает подобно аналогу из JavaScript.

Параметрический полиморфизм даёт возможность писать обобщённые алгоритмы для составных типов, что в некоторых случаях значительно сокращает количество кода. Иногда за это приходится платить сложностью решения, но для большинства типичных операций сложность растёт не сильно. Это видно и по коду выше.

В динамических языках для реализации обобщённых алгоритмов, параметрический полиморфизм не нужен. Любая коллекция может содержать любые типы данных в любой момент времени. Благодаря этому не требуется вводить дополнительных языковых конструкций и изучать новые концепции.

В литературе использование параметрического полиморфизма часто называется обобщённым программированием.
*/


// >>>>>>> Диспетчеризация по ключу (данные) <<<<<<<

/**
В связке с полиморфизмом постоянно возникает выражение "динамическая диспетчеризация". С самим понятием мы познакомимся позже, а сейчас поговорим про диспетчеризацию в принципе.

Диспетчеризация (от английского dispatch - отсылать, отправлять) - процесс координации каких-либо действий. Например, диспетчер в аэропорту разводит самолёты, диспетчер в службе такси связывает доступного водителя и клиента.

Рассмотрим условный код, в котором выбор ветки исполнения идёт по конкретному значению переменной:
*/

let databaseConfiguration;

if (env === 'development') {
    databaseConfiguration = {
        adapter: 'sqlite',
    };
} else if (env === 'production') {
    databaseConfiguration = {
        adapter: 'postgresql',
    };
}

/**
Во всех проектах существует понятие "среда", это то окружение, в котором происходит запуск проекта. Во время разработки код запускают в среде разработчика, её традиционно называют development. Среда, в которой приложение работает по-настоящему, называется production. В зависимости от среды, приложения по разному стартуют, конфигурируются и даже работают, например в разных средах могут использоваться разные базы данных.

Код выше как раз типичный пример того, как меняется конфигурация в зависимости от среды. Процесс выбора можно назвать процессом диспетчеризации.

Статичная условная конструкция, в которой диспетчеризация идёт по строкам, легко заменяется на свитч. Так код становится понятнее и проще:
*/

let databaseConfiguration;

switch (env) {
    case 'development':
        databaseConfiguration = {
            adapter: 'sqlite',
        };
        break;
    case 'production':
        databaseConfiguration = {
            adapter: 'postgresql',
        };
        break;
}


// Хотя кода и стало чуть больше, switch сам по себе более явно описывает процесс диспетчеризации. Но можно пойти ещё дальше и сделать диспетчеризацию по ключу ассоциативного массива:

const databaseSettingsByEnv = {
    development: {
        adapter: 'sqlite',
    },
    production: {
        adapter: 'postgresql',
    },
};

const databaseConfiguration = databaseSettingsByEnv[env];


// Значение по умолчанию легко добавить через оператор ||:

const databaseConfiguration = databaseSettingsByEnv[env] || { adapter: 'memory' };

// Либо через _.get
// const databaseConfiguration = _.get(databaseSettingsByEnv, env, { adapter: 'memory' });

/**
Этот вариант лучше предыдущих двух сразу по нескольким причинам. Во-первых, он короче, во-вторых, он гибче. Условные конструкции это статичный код, который нельзя поменять без переписывания самой программы в отличие от последнего варианта. А вот данные это совсем другое дело. Для удобства их часто кладут в файлы конфигурации, которые используют формат JSON или YAML, например:

development:
    adapter: sqlite

production:
    adapter: postgresql

При таком подходе легко добавить новое поведение без изменения самого кода приложения. Его мощь особенно чувствуется в ситуациях, когда обработкой занимается не наш код, а код библиотеки или фреймворка. Ведь мы не можем просто взять, открыть исходники и поправить их.
*/

/**@@
html.js
Реализуйте и экспортируйте по умолчанию функцию getLinks(tags), которая принимает на вход список тегов, находит среди них теги a, link и img, а затем извлекает ссылки и возвращает список ссылок. Теги подаются на вход в виде массива, где каждый элемент это тег. Тег имеет следующую структуру:

    name - имя тега.
    href или src - атрибуты. Атрибуты зависят от тега: img - src, a - href, link - href.
*/

import getLinks from './html.js';

const tags = [
    { name: 'img', src: 'hexlet.io/assets/logo.png' },
    { name: 'div' },
    { name: 'link', href: 'hexlet.io/assets/style.css' },
    { name: 'h1' },
];

const links = getLinks(tags);

// [
//   'hexlet.io/assets/logo.png',
//   'hexlet.io/assets/style.css'
// ];


const mapping = {
    a: 'href',
    img: 'src',
    link: 'href',
};

const getLinks = (tags) => {
    const filteredTags = tags.filter((tag) => mapping[tag.name]);
    const paths = filteredTags.map((tag) => tag[mapping[tag.name]]);

    return paths;
};

export default getLinks;



// >>>>>>> Диспетчеризация по ключу (функции) <<<<<<<

/**
Диспетчеризация по ключу ассоциативного массива мощнее чем кажется на первый взгляд. Далеко не всегда достаточно выбирать разные данные, иногда приходится выполнять другой код.

Предположим что нам надо сформировать массив с фамилиями наших пользователей. Главное условие – для девушек берётся девичья фамилия.

Реализуем эту задачу, используя старый добрый if:
*/

const lastNames = users.map((user) => {
    if (user.gender === 'female') {
        return user.maidenName;
    }
    return user.lastName;
});

// Теперь решим эту задачу с помощью диспетчеризации по ключам объекта, но в отличие от предыдущего урока, в значениях у нас будут функции:

// Определяем key-value, где ключ это пол, а значение это функция, возвращающая нужное значение для пола

const mapping = {
    female: (user) => user.maidenName,
    male: (user) => user.lastName,
};

// Выбираем нужную функцию по названию пола и вызываем её
// Внутрь функции передается пользователь

const lastNames = users.map((user) => mapping[user.gender](user));

/**
В некоторых ситуациях такой вариант решения задачи лучше. В нём явно прослеживаются зависимости, особенно если их становится много. Кроме того, конфигурация данными позволяет вынести их в другое место и расширять поведение без переписывания кода, который использует эти данные.

Ещё один пример – парсинг данных в зависимости от их типа:
*/

import yaml from 'js-yaml';

const mapping = {
    yml: yaml.safeLoad,
    json: JSON.parse
};

const parse = (type, data) => mapping[type](data);

/**
Дополнительные материалы
Пример использования диспетчеризации по ключу в проектах Хекслета https://github.com/Hexlet/hexlet-exercise-kit/blob/master/import-documentation/src/index.js#L15
*/


/**@@
html.js
Реализуйте и экспортируйте по умолчанию функцию stringify(tag), которая принимает на вход тег и возвращает его текстовое представление. Например:
*/

import stringify from './html';

const tag = {
    name: 'hr',
    class: 'px-3',
    id: 'myid',
    tagType: 'single',
};
const html = stringify(tag); // <hr class="px-3" id="myid">

const tag = {
    name: 'div',
    tagType: 'pair',
    body: 'text2',
    id: 'wow',
};
const html = stringify(tag); // <div id="wow">text2</div>

/**
Внутри структуры тега есть три специальных ключа:

name - имя тега
tagType - тип тега, определяет его парность (pair) или одиночность (single)
body - тело тега, используется для парных тегов
*/


const buildAttrs = (tag) => {
    const excluded = ['name', 'tagType', 'body'];

    return Object.keys(tag)
        .filter((attr) => !excluded.includes(attr))
        .map((attr) => ` ${attr}="${tag[attr]}"`)
        .join('');
};

const mapping = {
    single: (tag) => {
        const attrs = buildAttrs(tag);
        return `<${tag.name}${attrs}>`;
    },
    pair: (tag) => {
        const attrs = buildAttrs(tag);
        return `<${tag.name}${attrs}>${tag.body}</${tag.name}>`;
    },
};

const stringify = (tag) => {
    const build = mapping[tag.tagType];
    return build(tag);
};

export default stringify;




// >>>>>>> Диспетчеризация по имени файла <<<<<<<

/**
Ещё один интересный приём – диспетчеризация по имени файла.

    В некоторых системах принято иметь не один файл с разными ключами для конфигурации, а разные файлы, относящиеся к разным средам. Например:

configs/
database.development.json
database.production.json
database.test.json
Где-то в исходниках должен быть код, который выбирает какой файл загружать. Ниже код использует диспетчеризацию по ключу:
*/

import fs from 'fs';

const configFileNamesByEnv = {
    development: 'database.development.json',
    production: 'database.production.json',
    test: 'database.test.json',
};

const filename = configFileNamesByEnv[env];
const raw = fs.readFileSync(filename);
const config = JSON.parse(raw);

// Нетрудно заметить, что имея название среды запуска, можно составить подходящее имя файла. Так и сделаем:

const filename = `database.${env}.json`;
const raw = fs.readFileSync(filename);
const config = JSON.parse(raw);

// Код стал намного короче и больше не требует изменения при расширении.

/**@@
DatabaseConfigLoader.js
Реализуйте и экспортируйте по умолчанию класс DatabaseConfigLoader, который отвечает за загрузку конфигурации для базы данных. У класса следующий интерфейс:

    Конструктор - принимает на вход путь, по которому нужно искать конфигурацию
load(env) - метод, который грузит конфигурацию для конкретной среды окружения. Он загружает файл database.${env}.json, парсит его и возвращает результат наружу.
*/

const pathToConfigs = path.join(__dirname, '__fixtures__');
const loader = new DatabaseConfigLoader(pathToConfigs);
const config = loader.load('production'); // loading database.production.json

// {
//   host: 'google.com',
//   username: 'postgres',
// };

/**
В этом классе и конфигурации реализована поддержка расширения. Если в загружаемом конфиге есть ключ extend, то нужно загрузить конфигурацию с этим именем (он соответствует env). Далее конфигурации мержатся между собой так, что приоритет имеет загруженный раньше. Более подробный пример посмотрите в тестах.

Подсказки
Для чтения файла используйте соответствующую синхронную функцию из модуля fs.
*/

import fs from 'fs';
import path from 'path';
import _ from 'lodash';

export default class {
    constructor(pathToConfigs) {
        this.pathToConfigs = pathToConfigs;
    }

    load(env) {
        const fileName = `database.${env}.json`;
        const filePath = path.join(this.pathToConfigs, fileName);
        const raw = fs.readFileSync(filePath);
        const config = JSON.parse(raw);

        if (!config.extend) {
            return config;
        }

        const newEnv = config.extend;
        const configWithoutExtend = _.omit(config, 'extend');

        return { ...this.load(newEnv), ...configWithoutExtend };
    }
}




// >>>>>>> Полиморфизм (утиная типизация) <<<<<<<
/**
Начнём знакомство с полиморфизмом подтипов с задачки. Представьте себе функцию, которая проверяет, есть ли комментарии у статьи или топика (вопросы пользователей Хекслета под уроками и проектами). Статья в коде представлена объектом класса Article, а топик – Topic.
*/

const hasComments = (commentable) => {
    // Если это статья
    if (commentable instanceof Article) {
        return commentable.getArticleComments().length > 0;
        // Если это топик
    } else if (commentable instanceof Topic) {
        return commentable.getTopicComments().length > 0;
    }
}

class Article {
    // some code

    getArticleComments() {
        return this.comments;
    }
}

class Topic
{
    // some code

    public getTopicsComments()
    {
        return this.comments;
    }
}

// Article.first() - метод, который возвращает первую статью из базы данных
const article = Article.first();
console.log(hasComments(article));

/**
С подобным кодом мы уже сталкивались ранее. Каждый новый тип, потребует от нас добавления кода в эту условную конструкцию. Его можно заменить на диспетчеризацию по ключу, но особенно лучше не станет. Всё равно придётся описывать поведение для каждого класса в дополнении к тому, что поведение и так описано внутри каждого класса. Но можно сделать кое-что лучше. Достаточно согласовать интерфейс всех типов и договориться о том, что метод для извлечения комментариев будет называться getComments(). Тогда код станет таким:
*/

const hasComments = (commentable) => commentable.getComments().length > 0;

const article = Article.first();
console.log(hasComments(article));

const topic = Topic.first();
console.log(hasComments(topic));

/**
    Теперь функцию hasComments(commentable) можно вызывать с любым объектом, имеющим метод getComments() с необходимой сигнатурой. Эта функция не поменяется даже при добавлении нового класса, содержащего такой же метод.

        Способность функции, обрабатывать объекты разных типов одинаковым образом, называется полиморфизмом подтипов (почему подтипов, мы разберёмся в следующих уроках, но это не про наследование), а сама функция – полиморфной функцией.

        Как видно из кода выше, для реализации такого полиморфизма, в JavaScript не нужно наследование и интерфейсы. В миру такой подход называют "утиной типизацией". Если что-то ходит как утка и крякает как утка, то это утка.

        Технически, самое простое и понятное что делает полиморфизм подтипов (для клиентского кода) – убирает условные конструкции. Любую условную конструкцию можно заменить полиморфизмом и любую полиморфную функцию можно заменить ифами. Другими словами, полиморфизм подтипов не является неотъемлемой частью разработки, код можно писать и без него. С другой стороны, иногда встречаются ситуации, в которых он здорово помогает, но не сказать что это происходит постоянно.

        В чем разница между параметрическим и полиморфизмом подтипов? В первом случае, реализуется общий алгоритм для контейнера (например массива), который содержит значение или значения типа T. Этот алгоритм не зависит от T и для любых T выполняется идентично. Во втором, алгоритм построен вокруг самого объекта и использует его методы. В полиморфизме подтипов, полиморфная функция работает только с теми объектами, которые имеют необходимые для реализации алгоритма методы.
*/


/**@@
FileKV.js
В программировании, для некоторых задач распространены key-value базы данных. Внешне они работают по принципу ассоциативных массивов, но живут как отдельные программы и умеют делать много полезных штук: например, сохранять данные на диск, переносить данные между машинами в сети и тому подобное.

В этой задаче реализована подобная база данных в виде класса FileKV, который сохраняет свои данные на диске в указанном файле. Она имеет следующий интерфейс:
*/

import FileKV from '../FileKV';

const map = new FileKV('/path/to/dbfile');
// Получение значения по ключу
map.get('key'); // 'value'
map.get('unkonwnkey'); // null
// Получение значения и дефолт
map.get('unkonwnkey', 'default value'); // 'default value'
// Установка и обновление ключа
map.set('key2', 'value2');
map.get('key2'); // 'value2'
// Удаление ключа
map.unset('key2');
map.get('key2'); // null
map.set('key', 'value');
// Возврат всех данных из базы
map.toObject(); // { key: 'value' }

/**
В целях тестирования бывает полезно иметь реализацию такой базы данных, которая хранит данные в памяти, а не во внешнем хранилище. Это позволяет легко сбрасывать состояние между тестами и не замедлять их.

InMemoryKV.js
Реализуйте и экспортируйте по умолчанию класс InMemoryKV, который представляет собой in-memory key-value хранилище. Данные внутри него хранятся в обычном объекте. Интерфейс этого класса совпадает с FileKV за исключением конструктора. Конструктор InMemoryKV принимает на вход объект, который становится начальным значением базы данных.
*/

import InMemoryKV from '../InMemoryKV';

const map = new InMemoryKV({ key: 10 });
map.get('key'); // 10

/**
keyValueFunctions.js
Реализуйте и экспортируйте по умолчанию функцию swapKeyValue, которая принимает на вход объект базы данных и меняет в нём ключи и значения местами.

swapKeyValue — полиморфная функция, она может работать с любой реализацией key-value, имеющей такой же интерфейс.
*/

import InMemoryKV from '../InMemoryKV';
import swapKeyValue from '../keyValueFunctions';

const map = new InMemoryKV({ key: 10 });
map.set('key2', 'value2');
swapKeyValue(map);
map.get('key'); // null
map.get(10); // 'key'
map.get('value2'); // 'key2'


// FILE: InMemoryKV.js
import _ from 'lodash';

class InMemoryKV {
    constructor(initial = {}) {
        this.map = _.cloneDeep(initial);
    }

    set(key, value) {
        this.map = { ...this.map, [key]: value };
    }

    unset(key) {
        this.map = _.omit(this.map, key);
    }

    get(key, defaultValue = null) {
        return _.get(this.map, key, defaultValue);
    }

    toObject() {
        return this.map;
    }
}

export default InMemoryKV;

// FILE: keyValueFunctions.js

const swapKeyValue = (map) => {
    const data = map.toObject();
    Object.entries(data).forEach(([key, value]) => {
        map.unset(key);
        map.set(value, key);
    });
};

export default swapKeyValue;



// >>>>>>> Null Object Pattern <<<<<<<
/**
На сайтах, у которых есть аутентификация, внутри присутствует понятие "текущий пользователь". Это тот пользователь который аутентифицировался через форму (или вошёл через социальную сеть). Текущий пользователь активно используется для вывода различных блоков информации, например, чтобы отобразить блок этого пользователя. Подобный код обычно выглядит так:
*/
// где-то в воображаемом шаблоне articles/index.html.slim
if isAuthenticated && currentUser.hasArticles()
    each article in currentUser.getArticles()
    // тут выводим статьи

/**
Обратите внимание на проверку существования пользователя. Если её не сделать, то код упадёт с ошибкой, потому что вызывается метод hasArticles() у null (так как пользователь отсутствует если он не залогинился****). Когда этих проверок одна-две, то ничего страшного, но если их десятки и больше, то код быстро захламляется. Кроме того, такую проверку очень легко забыть вставить.

        Можно ли решить эту задачу каким-то другим способом? Оказывается можно. Достаточно использовать полиморфизм подтипов. Для этого создаётся класс описывающий пользователя не прошедшего аутентификацию, например, Guest. Затем в него добавляются все необходимые методы, для которых мы хотим получить полиморфное поведение.
*/

class Guest
{
    hasArticles() {
        return false;
    }

    getArticles() {
        return [];
    }
}

/**
Большинство этих методов возвращает false либо пустые списки, так как у этого пользователя ничего нет. Зачем тогда он нужен? Всё очень просто, теперь клиентский код, всегда рассчитывает на существование пользователя, ему больше не нужно проверять аутентификацию:
*/
if currentUser.hasArticles()
    each article in currentUser.getArticles()
    // тут выводим статьи

/**
Условные конструкции уйдут по всем шаблонам, но остаётся вопрос. А где и как происходит сам процесс создания нашего пользователя? И вот здесь останется тот единственный if, благодаря которому произойдёт создание правильного объекта. Это происходит на этапе обработки входящего запроса, и конкретное место зависит от используемого фреймворка. Код в этом месте выглядит примерно так:
*/

const fetchCurrentUser = (req) => {
    const userId = req.session.userId;
    // Если id есть в сессии, то выбираем пользователя из базы, иначе возвращаем гостя
    return userId ? User.find(userId) : new Guest();
};

/**
    У такого способа использования полиморфизма есть особое название: шаблон проектирования "null object". Он часто используется внутри фреймворков и иногда встречается в прикладном коде. На Хекслете таких мест как минимум 3. Например, в классе Guest у нас десятки методов. Вот его содержимое (не полностью):
*/
// # Код на руби, но он прост как две копейки
/*
class Guest
    def id
    nil
    end

    def avatar
    nil
    end

    def github_account
    false
    end

    def has_passed_at_least_one_project?
        false
        end

    def city
    ''
    end

    def seeking_job?
        true
        end

    def mentor?
        false
        end

    def locale?
        nil
        end

    def guest?
        true
        end

    def current_subscription_object
    FreeSubscription.new(self)
    end

    def to_s
    'guest'
    end

    def topics_count
    0
    end
    end
*/

/**@@
На Хекслете доступ к курсам оформляется через подписку. Подписка, это отдельная сущность, которая хранит в себе информацию о самой подписке, когда она началась, сколько продолжается, оплачена ли и так далее. Типичная проверка на наличие подписки (а значит доступ к платному контенту) выглядит так:

// Эти примеры сильно упрощены, к тому же Хекслет написан на Rails
// но для демонстрации идеи такая реализация подойдет
*/

user.getCurrentSubscription().hasPremiumAccess();
user.getCurrentSubscription().hasProfessionalAccess();

// Но не у всех пользователей есть подписка, на Хекслете есть и большая бесплатная часть. Так как подписка может отсутствовать, в коде придется делать так:

if (user.getCurrentSubscription() && user.getCurrentSubscription().hasPremiumAccess()) {
    // есть преимум доступ, показываем что-то особенное
}

// Чтобы избежать постоянных проверок на существование подписки, мы внедрили Null Object. Теперь подписка есть всегда и достаточно написать:

if (user.getCurrentSubscription().hasProfessionalAccess()) {
    // есть профессиональный доступ, показываем что-то особенное
}

/**
FakeSubscription.js
Реализуйте и экспортируйте по умолчанию класс FakeSubscription, который повторяет интерфейс класса Subscription за исключением конструктора. В конструктор FakeSubscription принимает пользователя. Если пользователь администратор user.isAdmin(), то все доступы разрешены, если нет – то запрещены.

User.js
Допишите конструктор пользователя, так, чтобы внутри устанавливалась реальная подписка если она передана снаружи и создавалась фейковая в ином случае.
*/

import Subscription from '../Subscription';
import User from '../User';

const user1 = new User('vasya@email.com', new Subscription('premium'));
user1.getCurrentSubscription().hasPremiumAccess(); // true
user1.getCurrentSubscription().hasProfessionalAccess(); // false

const user2 = new User('vasya@email.com', new Subscription('professional'));
user2.getCurrentSubscription().hasPremiumAccess(); // false
user2.getCurrentSubscription().hasProfessionalAccess(); // true

// Внутри создается фейковая, потому что подписка не передается
const user3 = new User('vasya@email.com');
user3.getCurrentSubscription().hasPremiumAccess(); // false
user3.getCurrentSubscription().hasProfessionalAccess(); // false

const user4 = new User('rakhim@hexlet.io'); // администратор, проверяется по емейлу
user4.getCurrentSubscription().hasPremiumAccess(); // true
user4.getCurrentSubscription().hasProfessionalAccess(); // true


// FILE: FakeSubscription.js
class FakeSubscription {
    constructor(user) {
        this.user = user;
    }

    hasProfessionalAccess() {
        return this.user.isAdmin();
    }

    hasPremiumAccess() {
        return this.user.isAdmin();
    }
}

export default FakeSubscription;

// FILE: User.js

import FakeSubscription from './FakeSubscription';

class User {
    constructor(email, currentSubscription = null) {
        this.email = email;

        this.currentSubscription = currentSubscription || new FakeSubscription(this);

    }

    getCurrentSubscription() {
        return this.currentSubscription;
    }

    isAdmin() {
        return this.email === 'rakhim@hexlet.io';
    }
}

export default User;




// >>>>>>> Код, который убивает полиморфизм <<<<<<<

    Формирование объектов
    Посмотрите на функцию ниже и скажите, является ли она полиморфной?

    const sayHiByEmail = (user) => {
        const sender = new EmailSender();
        // Отправляем email пользователю
        sender.send(user.getEmail(), 'hi!');
    };
    С одной стороны да, пользователь передаётся снаружи и у нас есть возможность его подменить, передав туда объект другого класса. С другой стороны, внутри функции явно используется класс EmailSender и его подменить не получится без переписывания самого кода.

        Этот код демонстрирует простую, но важную идею. Полиморфизм подтипов возможен тогда, когда объект попадает в функцию снаружи, а не конструируется прямо внутри неё.

        Честно говоря, объект можно создавать и внутри функции, но в таком случае имя класса должно формироваться (или получаться) динамически. Этот приём мы рассмотрим позже, в уроке про метапрограммирование.

        Проверка типов
    Ещё один пример с подвохом. Есть ли полиморфизм в коде ниже?

    const sayHi = (user) => {
        if (user instanceof User) {
            console.log(`Hello, ${user}!`);
        } else if (user instanceof Guest) {
            console.log('Hello, guest!');
        } else {
            console.log('Who you are?');
        }
    };
    В данном примере, вроде бы, всё нормально, объект передаётся снаружи, но есть одна загвоздка. Внутри функции явно проверяется тип, а это значит, что поведение определяется не типом, а сама функция решает как себя вести. Более того, функция жёстко связана с теми типами, которые определены внутри неё и её придётся переписывать при их изменении. И как результат – отсутствие полиморфизма подтипов.

        Проверка типа иногда встречается и её можно использовать к месту, чтобы не усложнять код, но чаще, она говорит о плохом дизайне. Такой код, можно сказать, не соответствует ООП в современном его понимании.

        Для решения задачи выше, есть несколько подходов:

        Перенос логики внутрь самих классов. Тогда код функции превратится в такой: user.sayHi(). С этим подходом нужно быть осторожным, так как легко получить божественный объект. Гораздо чаще нужно применять другой подход.
        Понадобится добавить новый интерфейс в виде методов isUser и isGuest.

        const sayHi = (user) => {
        if (user.isUser()) {
            console.log(`Hello, ${user}!`);
        } else if (user.isGuest()) {
            console.log('Hello, guest!');
        } else {
            console.log('Who you are?');
        }
    };
    И хотя кода меньше не стало, всё же это полиморфизм подтипов. Код завязан на методы, а не на типы. Изменение структуры классов не коснётся этой функции если сама логика останется той же.



        @@@@@
    helpers.js
    Реализуйте и экспортируйте по умолчанию функцию getGreeting(user), которая возвращает приветствие для пользователя. Это приветствие показывается пользователю на сайте. Если пользователь гость, то выводится "Nice to meet you Guest!", если не гость, то "Hello <Имя>!", где "<Имя>" это имя реального пользователя.

        В этой задаче, способ решения остается на ваше усмотрение. Используйте знания полученные в этом курсе.

        import Guest from '../Guest';
import User from '../User';
import getGreeting from '../helpers';

    const guest = new Guest();
    getGreeting(guest); // 'Nice to meet you Guest!'

    const user = new User('Petr');
    getGreeting(user); // 'Hello Petr!'



// FILE: Guest.js:

class Guest {
    constructor() {
        // BEGIN (write your solution here)
        this.type = 'guest';
        // END
        this.name = 'Guest';
    }

    getName() {
        return this.name;
    }

    // BEGIN (write your solution here)
    getTypeName() {
        return this.type;
    }
    // END
}

export default Guest;


// FILE: User.js:
class User {
    constructor(name) {
        // BEGIN (write your solution here)
        this.type = 'user';
        // END
        this.name = name;
    }

    getName() {
        return this.name;
    }

    // BEGIN (write your solution here)
    getTypeName() {
        return this.type;
    }
    // END
}

export default User;


// FILE: helpers.js:

export default (someUser) => {
        const mapping = {
            guest: (guest) => `Nice to meet you ${guest.getName()}!`,
            user: (user) => `Hello ${user.getName()}!`,
        };

        return mapping[someUser.getTypeName()](someUser);
    };



// >>>>>>> Инверсия зависимостей <<<<<<<

/**
Каждый раз, когда внутри функции создаётся объект, появляется зависимость функции от класса этого объекта. Другими словами функция жёстко завязана на работу в паре с конкретным классом. Есть формальный способ, позволяющий легко проверить насколько ваш код завязан в узел. Возьмите любую функцию и мысленно представьте что вы переносите её в другой проект. Сколько за собой она потянет зависимостей (а те в свою очередь свои зависимости)? Если перенос функции потребует переноса большого количества кода, то говорят что в коде высокая связанность.

Для развязки кода придуман даже специальный термин: Принцип Инверсии Зависимостей. Ещё он известен как DIP из SOLID. Вот его формулировка:

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
В зависимости от языка, в эти фразы вкладывается немного разный смысл. В общем и целом, они говорят о том, что не нужно завязываться на конкретную реализацию класса. Создание объектов в том месте где они используются, связывает нас с классом этих объектов без возможности его подменить. Правильный подход, с точки зрения этого принципа, инвертировать зависимости, то есть не работать с классами напрямую, а получать объекты нужных классов снаружи, например, через параметры функции.

Кроме того, DIP говорит о завязке на интерфейсы вместо классов в сигнатурах функций. Об этом мы поговорим позже, когда закончим с основными понятиями.

Было:
*/

const doSomething = () => {
    const logger = new Logger();
    // some code
};

// Стало:

const doSomething = (logger) => {
    // some code
};

/**
В докладах на тему DIP, докладчики любят, в качестве аналогии, приводить принцип Голливуда: Не надо нам звонить, мы сами вас наберём. Под этим имеется в виду, что не нужно пользоваться классами напрямую, а вместо этого получать готовые объекты как внешнюю зависимость.

Нужно ли всегда придерживаться этого принципа? Откровенно говоря, код целиком построенный в таком стиле становится излишне абстрактным и сложным для понимания. В программировании нет серебряных пуль и в каждой конкретной ситуации нужно смотреть на условия и решаемую задачу. Если подмена реализации нужна, то делаем её, если нет – то работаем напрямую.

Почти всегда, когда речь идёт про инверсию зависимостей, рядом появляется термин "инъекция зависимостей". В то время как DIP говорит о модульности, инъекция зависимостей говорит о конкретных способах её достижения. О том каким образом можно передать зависимости в код использующий их. Всего есть три способа инъектировать зависимости:

Передать их как аргументы функций или методов. Именно этот способ мы использовали до сих пор.

doSomethingUsefull(new Logger());
Через конструктор в тех ситуациях где используются объекты.
*/

const app = new Application(new Logger());

// Через сеттеры. По возможности лучше этот способ не использовать. Он связан с мутацией объектов и нарушением целостности (подробнее было в курсе по объектно-ориентированному дизайну).

const app = new Application();
app.setLogger(new Logger());

/**
Как видите, за громким термином скрывается очень простая штука – передача параметров. С другой стороны, термины позволяют понять больше смысла без необходимости знать дополнительный контекст. Главное не увлекаться, а то можно превратиться в архитектурных астронавтов.
*/


/**@@
Создайте полноценное консольное приложение, которое показывает текущую погоду в городе. Оно работает так:

$ npx babel-node bin/weather.js berlin
Temperature in berlin: 26C

Это консольное приложение обращается внутри себя к сервису погоды. Сервис погоды расположен на localhost:8080. Информацию по городу можно извлечь сделав GET запрос на урл /api/v2/cities/<имя города>. Данные от сервиса возвращаются в виде json: { "name": "<имя города>", temperature: "<температура>" }.

src\WeatherService.js
Реализуйте логику работы сервиса. Сделайте так, чтобы http-клиент не был зашит внутри класса, используйте инъекцию зависимостей для проброса клиента во внутрь.

То как выполнять http-запросы через axios можно подсмотреть в его документации.

bin/weather.js
Реализуйте код, вызывающий сервис и печатающий на экран ожидаемую строку. Для извлечения города из аргументов командной строки, воспользуйтесь свойством argv глобального объекта process. Первый аргумент (передаваемое имя города) находится под индексом 2. Посмотреть описание и пример можно в документации.

Подсказки
Попробуйте ответить на вопросы:

    Сервис погоды это абстракция данных или нет?
    Кто отвечает за формирование текста, который мы ожидаем на выходе?
    Что должен вернуть метод lookup(cityName)?
    Может ли bin содержать определения?
*/

// FILE: WeatherService.js
import { resolve } from 'url';

class WeatherService {
    apiUrl = 'http://localhost:8080/api/v2/';

    constructor(httpClient) {
        this.httpClient = httpClient;
    }

    async lookUp(cityName) {
        const url = resolve(this.apiUrl, `cities/${cityName}`);
        const response = await this.httpClient.get(url);
        return JSON.parse(response.data);
    }
}

export default WeatherService;


// FILE: bin/weather.js

import axios from 'axios';
import WeatheService from '../WeatherService';

const weather = new WeatheService(axios);
const cityName = process.argv[2];

weather.lookUp(cityName).then((data) => {
    const message = `Temperature in ${data.name}: ${data.temperature}C`;
    console.log(message);
});



// >>>>>>> Стратегия (Паттерн) <<<<<<<

/**
    Закрепим пройденную теорию на одном практическом примере, показывающем типичное применение полиморфизма подтипов.

        Представьте себе задачу расчёта стоимости туристической страховки. Эта страховка, которую желательно купить при выезде за границу, на случай внезапных болезней или травм.

        Сумма страховки зависит от большого числа факторов. Некоторые из факторов могут влиять на сам процесс подсчёта стоимости, то есть они изменяют не значения в формуле подсчёта, а саму формулу.

        Конкретно в случае страховок, скорее всего есть одна большая формула, куда подставляются значения и вычисление происходит за один заход. Для нас сейчас главное сама концепция, а не точное знание внутренностей страхового бизнеса.

        Если решать эту задачу в лоб, то она будет выглядеть как большое месиво вычислений со множеством условных конструкций. Со временем такой код становится крайне тяжёлым для восприятия из-за большого числа состояний, которые надо удерживать в голове.
*/

// Примеры с потолка
if (age < 18) {
    let cost = salary * age;

    if (country === 'uganda') {
    cost = cost / 2;
    }
} else if (age >= 18 && age < 24) {
    // ...
}

/**
Можно ли как-то сделать код понятнее и проще для восприятия? Иногда да. Из всех факторов участвующих в расчёте, нужно попытаться найти те, которые влияют на вычисление глобально. Они проявляются как глобальный if на верхнем уровне. Предположим, что в случае страховки это возраст. То есть считаем что возраст определяет формулу расчёта стоимости страховки. Следующим шагом смотрим на ветки в этой условной конструкции и то, какие диапазоны там указаны. Допустим такую картину:

До 18
От 18 до 24
От 24 до 65
Старше 65

Обратите внимание на важную деталь. Выше мы договорились, что каждая возрастная группа, определяет алгоритм расчёта стоимости страховки. То есть они между собой независимы, хотя и сам процесс вычисления местами может быть схож (и будет скорее всего).

Теперь делаем переход от логической структуры к коду. Каждая возрастная группа - класс, отвечающий за вычисления стоимости для этой группы:
*/

class LessThan18 {
    // Параметры, это те самые факторы, по которым строится вычисление
    calculate(params) {
        // тут считаем и возвращаем результат
    }
}

// Имя конечно так себе, в реальном коде стоит придумать что-нибудь говорящее
class MoreThan18AndLessThan24 {
    // Структура параметров должна 100% совпадать с остальными классами,
    // так как только в этом случае возможен полиморфизм
    calculate(params) {
        // тут считаем и возвращаем результат
    }
}

// Остальные классы
/**
Главное, что мы получили - разделили процесс вычисления на независимые блоки кода, которые проще для восприятия. Каждый такой класс называется стратегией (вычисления). Очень важно то, что стратегия не является абстракцией, объектом с состоянием и временем жизни. Поэтому данные передаются не в конструктор, а в сам метод (вспомните курс объектно-ориентированный дизайн). По сути, это обычная функция (вычисление), которая упакована в класс только с одной целью — получить полиморфизм подтипов. Всё тоже самое можно сделать (и код будет проще) используя диспетчеризацию функций по ключам.

Дальше возникает вопрос, а каким образом и где выбрать правильную реализацию, с которой нужно работать? Вариантов здесь несколько. Выбор реализации может быть делегирован внешнему коду, то есть если мы применяем инверсию зависимостей, то работаем уже с готовой стратегией:
*/

calculateCost(strategy, params) {
    strategy.calculate(params);
}

/**
Пока мы только ушли от проблемы, но не решили её. В любом случае, где-то будет код, который содержит либо условную конструкцию, либо реализует один из способов диспетчеризации, которые мы разобрали в предыдущих уроках. В самом простом случае этот код будет выглядеть так:
*/

chooseCostInsuranceStrategy(user) {
    if (user.getAge() < 18) {
        return new LessThan18();
    } else if (/* ... */) {
        // some code
    }
}

strategy = chooseCostInsuranceStrategy(user);
strategy.calculate(params);

/**
    Как видно по примерам выше, кода с использованием стратегии будет больше (но не так много если используется диспетчеризация функций по ключам в ассоциативном массиве). Это касается фактически всех ситуаций, в которых задействован полиморфизм подтипов в JavaScript. Это цена, которую придётся заплатить за разделение, упрощающее расширение кода и уменьшающее его сложность. С другой стороны, очень легко попасть в ловушку и, наоборот, сделать сложность кода выше, чем оно было до внедрения полиморфизма подтипов. Этот полиморфизм делает код многословным и излишне абстрактным, если применять его налево и направо. А расширение нужно не так часто, как об этом говорят. Более того, инвертировать зависимости можно по ходу действия, когда в этом появляется необходимость.
*/

/**@@
TicTacToe – известная игра в крестики нолики, на поле 3x3. В этом задании, вам предстоит реализовать данную игру. Основной движок игры находится в файле ticTacToe.js. В директории strategies находится код, который отвечает за поведение AI (искусственный интелект!). В зависимости от выбранного уровня игры, включается либо Easy стратегия, либо Normal.

Задание специально построено так, чтобы предоставить вам максимальную свободу в организации кода. Результат будет хорошей лакмусовой бумажкой, по которой можно оценить насколько архитектурная тема была понята.

TicTacToe.js
Реализуйте класс TicTacToe, который представляет собой игру крестики-нолики. Принцип его работы описан в коде ниже:
*/

// По умолчанию выбран easy уровень. Его можно изменить, передав в конструктор строку 'normal'
const game = new TicTacToe();

// Если переданы аргументы, то ходит игрок. Первый аргумент – строка, второй – столбец.
game.go(1, 1);
// Ход компьютера
game.go();

game.go(0, 1);
game.go();

// Метод go возвращает true если текущий ход победный и false в ином случае
const isWinner = game.go(2, 1); // true

/**
strategies/Easy.js
Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно слева направо и сверху вниз (начиная с левого верхнего угла). Как только она встречает свободное поле, то вставляет туда значение.

strategies/Normal.js
Реализуйте стратегию, которая пытается заполнить поля, пробегаясь построчно слева направо и снизу вверх (начиная с левого нижнего угла). Как только она встречает свободное поле, то вставляет туда значение.

Подсказки
Нумерация строк и столбцов игрового поля должна начинаться с левого верхнего угла.
*/

// FILE: TicTacToe.js

/* eslint-disable class-methods-use-this */

import Easy from './strategies/Easy';
import Normal from './strategies/Normal';

class TicTacToe {
    mapLevelToStrategy = {
        easy: Easy,
        normal: Normal,
    };

    constructor(level = 'easy') {
        this.strategy = new this.mapLevelToStrategy[level]();
        this.field = [
            Array(3).fill(null),
            Array(3).fill(null),
            Array(3).fill(null),
        ];
    }

    getField() {
        return this.field;
    }

    go(row = null, col = null) {
        if (row === null || col === null) {
            const [autoRow, autoCol] = this.strategy.getNextStep(this.field);
            this.field[autoRow][autoCol] = 'AI';
            return this.isWinner('AI');
        }

        this.field[row][col] = 'Player';
        return this.isWinner('Player');
    }

    isWinner(type) {
        if (this.field.find((row) => this.populatedByOnePlayer(row, type))) {
            return true;
        }

        for (let i = 0; i < 3; i += 1) {
            if (this.populatedByOnePlayer(this.field.map((el) => el[i]), type)) {
                return true;
            }
        }

        const diagonal1 = [this.field[0][0], this.field[1][1], this.field[2][2]];
        if (this.populatedByOnePlayer(diagonal1, type)) {
            return true;
        }

        const diagonal2 = [this.field[2][0], this.field[1][1], this.field[0][2]];
        if (this.populatedByOnePlayer(diagonal2, type)) {
            return true;
        }

        return false;
    }

    populatedByOnePlayer(row, type) {
        return row.every((value) => value === type);
    }
}

export default TicTacToe;


// FILE: strategies/Easy.js

class Easy {
    getNextStep(field) {
        return field.reduce((acc, row, i) => {
            const j = row.indexOf(null);
            if (acc.length === 0 && j !== -1) {
                return [i, j];
            }
            return acc;
        }, []);
    }
}

export default Easy;


// FILE: strategies/Normal.js

class Normal {
    getNextStep(field) {
        return field.reduceRight((acc, row, i) => {
            const j = row.indexOf(null);
            if (acc.length === 0 && j !== -1) {
                return [i, j];
            }
            return acc;
        }, []);
    }
}

export default Normal;



// >>>>>>> Фабрика (Паттерн) <<<<<<<

/**
    Применение полиморфизма подтипов не убирает условные конструкции полностью (кроме некоторых случаев диспетчеризации, например по ключу или по имени файла). Чаще условная конструкция остаётся одна, только на уровне выбора подходящей реализации, а вот затем эта реализация используется внутри полиморфной функции прямым способом без условий. В прошлом уроке мы рассмотрели пример функции, которая выбирает необходимую реализацию стратегии на основе возраста пользователя и возвращает её наружу.
*/

const chooseCostInsuranceStrategy = (user) => {
    if (user.getAge() < 18) {
        return new LessThan18();
    } else if (/* ... */) {
        // some code
    }
}

/**
Функция, которая: выбирает нужный класс, создаёт объект и возвращает его наружу, называется фабрикой (более точно фабричным методом). Громкое имя для очень простой штуки. Фабрика может быть реализована любым способом включая всё что разбиралось в этом курсе.

В общем случае фабрикой называют всё подряд, что создаёт объект или коллекции объектов. Причём не обязательно разных классов, класс может быть и один, но сам процесс создания, включает в себя какие-то предварительные вычисления. В реальных проектах фабрики могут быть достаточно большими.

Фабрики часто реализуются как классы с одним статическим методом – factory. Сами фабрики объектами не делают (иногда таки делают), так как это не абстракция данных, а подменять их смысла нет, иначе получится подмена подменятора.
*/

export default class {
    static factory(/* параметры */) {
        // код фабрики
    }
}


// # Диспетчеризация класса

// JavaScript позволяет создавать объекты, используя ссылку на класс

const className = Application;
const app = new className();

// Такой синтаксис открывает широкий простор для диспетчеризации. Например, в некоторых ситуациях получится уйти от условных конструкций вообще:

import ManagerPolicy from './policies/ManagerPolicy';
import WorkerPolicy from './policies/WorkerPolicy';

// Policy – обычно это имя используют для авторизации, то есть системы проверки прав доступа
const mapping = {
    manager: ManagerPolicy,
    worker: WorkerPolicy,
};

const getUserPolicy = (user) => {
    const className = mapping[user.getType()];
    return new className();
};


@@@@
    ConfigFactory.js
    Создайте фабрику, которая принимает на вход путь до файла конфигурации в формате либо json либо yaml и возвращает объект класса Config. Конструктор класса Config принимает на вход объект с данными, полученными из конфигурационных файлов и предоставляет к нему доступ с помощью метода getValue.

        import path from 'path';
import ConfigFactory from '../ConfigFactory';

    const filePath = path.join(__dirname, '__fixtures__', 'test.yml');
    const config = ConfigFactory.factory(filePath);
    config.getValue('key'); // value
    console.log(config.constructor.name); // Config
    Учтите что файлы формата YAML могут иметь разные расширения: yaml и yml. Фабрика должна работать с обоими.

        parsers/JsonParser.js
    Реализуйте класс, отвечающий за парсинг json. Используйте внутри JSON.parse.

        parsers/YamlParser.js
    Реализуйте класс, отвечающий за парсинг yaml. Для парсинга используется сторонний компонент js-yaml. Используйте метод safeLoad.

        Подсказки
    Получить расширение файла можно с помощью path.extname
    Для чтения файлов используйте fs.readFileSync

// FILE: ConfigFactory.js:
import path from 'path';
import fs from 'fs';
import JsonParser from './parsers/JsonParser';
import YamlParser from './parsers/YamlParser';
import Config from './Config';

export default class ConfigFactory {
    static factory(filePath) {
        const mapping = {
            yaml: YamlParser,
            yml: YamlParser,
            json: JsonParser,
        };

        const fileExtension = path.extname(filePath).replace('.', '');
        const parser = new mapping[fileExtension]();
d
        const rawData = fs.readFileSync(filePath).toString();
        const data = parser.parse(rawData);

        return new Config(data);
    }
}

// FILE: parsers/JsonParser.js:
export default class JsonParser {
    parse(data) {
        return JSON.parse(data);
    }
}

// FILE: parsers/YamlParser.js:
export default class YamlParser {
    parse(data) {
        return yaml.safeLoad(data);
    }
}



// >>>>>>> Шаблоны проектирования (Паттерны) <<<<<<<

    Паттерн проектирования – подход к решению какой-то типовой задачи. Ранее мы уже рассмотрели некоторые из них, начиная от разных видов диспетчеризации, заканчивая Стратегией и Фабрикой. Этих паттернов очень много, каждый день придумываются новые, и даже каждый программист имеет какие-то свои паттерны для своих задач.

        Паттерны, в общем, не связаны с понятием ООП, но именно в ООП их любят структурировать и описывать. Поэтому эта тема особенно распространена в языках с классовой структурой, например Java, C# или PHP. И большинство этих паттернов сводится к тому, как правильно применять полиморфизм подтипов в разных ситуациях. Вот только некоторые из широко известных, которые опираются на полиморфизм:

        Адаптер
    Стратегия
    Абстрактная фабрика
    Мост
    Композит
    Декоратор
    Посредник
    Цепочка ответственности
    Наблюдатель
    Состояние
    Шаблонный метод
    Посетитель
    Некоторые из них связаны с абстракцией и имеют внутреннее состояние, другие – обычные функции, упакованные в классы только ради полиморфизма (но могли бы быть реализованы и обычными функциями, которые диспетчеризуются разными способами).

    В мире ООП паттернов, их основным источником считается книга Приёмы объектно-ориентированного проектирования. Паттерны проектирования. В ней действительно описано много полезных подходов, но будьте осторожны. Учтите следующие моменты:

        Примеры в книге описаны на языке C++ и имеют более сложную реализацию, чем это нужно в динамических языках.
        Многие паттерны рождаются вследствие ограничений конкретного языка, например паттерн Команда. В JavaScript это естественный способ писать код и для этого не нужны классы.
        Не все паттерны описанные в этой книге, так уж важны для веб-разработчиков. Вероятность того, что вам придётся когда-то иметь дело с абстрактной фабрикой, крайне низка.
        Самих паттернов намного больше чем указано в этой книге. Паттерны это не догма, всё течёт, всё развивается.
        Полиморфизм в паттернах или Паттерн создания Паттернов
    Большая часть паттернов, которая связана с полиморфизмом, строится по одному и тому же принципу. Зная его, вы сможете самостоятельно принимать правильные решения, даже не зная про паттерн для данной ситуации. Ключевая идея состоит в том, что берётся всё множество вариантов поведения и на каждый создаётся свой собственный класс.

        Например в Стратегии, количество классов-стратегий совпадает с количеством разных способов вычисления. Если их будет пять, то придётся создать пять классов. По крайней мере в классовых языках. В языках, где предпочитают функции, будет создано пять разных функций и это всё равно будет Стратегия.

        Антипаттерны
    Раз есть паттерны, значит и существуют антипаттерны, это типовые ошибки, которые совершают программисты. Многие из них имеют вполне конкретные, часто шуточные, названия: "паблик морозов" или "божественный объект". Самое удивительное, что подходы считавшиеся раньше паттернами, иногда перетекают в раздел антипаттернов. Самый яркий пример это паттерн "Одиночка (Singleton)" – объект который может существовать только в единственном экземпляре. Как показала жизнь, это плохо почти всегда. Кроме того, код с синглтонами крайне сложно тестировать.

        Обучение паттернам
    Новичков, которые начитались статей и наслушались старших товарищей, очень волнует вопрос изучения паттернов. Нужно ли их учить? Сколько их учить? По каким книгам и так далее.

        Попробуем разобраться. Как показывает практика, про паттерны все говорят, но мало кто действительно прочитал и понял их и может разумно применять. Причин этому несколько. Во-первых, крайне сложно осознать паттерн не столкнувшись с реальной проблемой, которую он решает. Во-вторых, настоящее понимание паттернов завязано на те вещи, которые мы разбирали на протяжении всей профессии: именование (оно чертовски важно), менеджмент состояния, побочные эффекты, абстракции, расширяемость, полиморфизм подтипов. Без понимания этих вещей, попытка использовать паттерны, почти наверняка, превратится в культ карго. Причём из всего списка выше, паттерны, по эффекту оказываемому на код, находятся на последнем месте.

        Важно понимать что паттерны это не причина, а следствие. Остерегайтесь мышления в стиле "вот есть паттерн, как его натянуть на ситуацию". Сначала нужно понять ситуацию, а потом возникнет паттерн. И совершенно нормально, что первые годы разработки (а у кого-то и больше), задачи будут решаться так как получается. Обучение происходит через ошибки и неправильные решения, этого не надо бояться и избегать. Главное это последовательное улучшение, а здесь помогут книги и наставники (на работе или в сети). О том как лучше читать книги, в том числе по паттернам, мы писали в статье.


        @@@@
    В этом задании будем работать с классами, которые представляют теги HTML. Метод render(), позволяет получить текстовое представление тега:

        import InputTag from '../tags/InputTag';

    const tag = new InputTag('submit', 'Save');
    tag->render(); // <input type="submit" value="Save">
    Предположим, что эта система нужна для генерации разных кусков верстки, которая может быть очень разнообразной. Попробуйте ответить на вопрос, сколько понадобится классов для представления всех возможных комбинаций тегов?

        Если создавать по классу на каждый возможный вариант верстки, то классов будет бесконечно много и смысла в такой реализации очень мало. Но вместо этого лучше использовать композицию. Создать класс для каждого индивидуального тега (в html5 их около 100 штук), а затем путем комбинирования получить все возможные варианты верстки.

        tags/LabelTag.js
    Реализуйте класс LabelTag, который умеет оборачивать другие теги:

        import InputTag from '../tags/inputTag';
import LabelTag from '../tags/labelTag';

    const inputTag = new InputTag('submit', 'Save');
    const labelTag = new LabelTag('Press Submit', inputTag);
    labelTag->render();
// <label>
//   Press Submit
//   <input type="submit" value="Save">
// </label>


export default class LabelTag {
    constructor(text, child) {
        this.text = text;
        this.child = child;
    }

    render() {
        return `<label>${this.text}${this.child}</label>`;
    }

    toString() {
        return this.render();
    }
}




// >>>>>>> Объектная композиция <<<<<<<

    В этом уроке, описывается система, которая помогает правильно организовывать код построенный на классах.

        В языках, где ООП построено без инкапсуляции, подобные проблемы решаются проще и возникают реже. Если хочется узнать как это бывает, попробуйте пописать код на Clojure или Elixir.

        Предположим что мы делаем сайт имеющий механизм аутентификации. После её выполнения, пользователю выводится приветствие, которое строится по разному в зависимости от возраста пользователя. Если пользователю не исполнилось 18, то пишется одно, всем остальным — другое.

        В данном случае, реализация в лоб, через if, будет лучшим решением задачи. Но в этом уроке мы отрабатываем использование полиморфизма в рамках классовой модели, поэтому пойдём другим путём. Сама задача специально упрощена, чтобы не тратить время на её анализ

    Первый порыв у многих разработчиков ввести два типа (интерфейса и класса): Under18 и Above18. Дальше в каждом из классов, которые реализуют эти интерфейсы добавить по методу getGreetingMessage(). В итоге мы получили полиморфизм подтипов:

// Где-то в шаблоне
// Правильный класс для пользователя выбирается на момент начала обработки http-запроса -.
        = user.getGreetingMessage()
    Это решение хоть и работает, но ведёт не по тому пути. Сегодня у нас до 18 и после, потом появится отдельное поведение для тех кто старше 65. Всё станет ещё хуже, когда кроме этих разделений, появится дополнительное разделение на девушек и парней. В таком случае мы получим большое число комбинаций, под каждую из которых придётся создать отдельный класс пользователя:

        девушки старше 18
    девушки младше 18
    парни старше 18
    парни младше 18
...
    В книжках по паттернам любят приводить пример с разделением средств передвижения по типам: плавающие, летающие и ездящие. А потом, внезапно оказывается, что некоторые одновременно и плавают и ездят.

        Теперь попробуем ответить на вопрос, почему эту задачу не надо решать подтипами в любом случае. Сам по себе, пользователь, это сущность взятая из нашей предметной области. Предметная область и вывод текста на экран, это совершенно разные вещи. Второе относится к логике приложения, но не бизнес-логике. Если об этом не задумываться, то в конце концов настанет момент, когда внутри пользователя окажется вообще всё что только происходит на сайте, ведь оно всё так или иначе связано с самим пользователем. И мы получим божественный объект.

        Правильное решение основано на композиции, подходе при котором создаются классы под конкретные задачи. Начнём сначала. В нашей задаче есть две ситуации: пользователи до 18 лет и пользователи старше. Создадим интерфейс GreetingMessage с методом getGreetingMessage и реализуем его в двух классах, один GreetingForUnder18 и другой GreetingForAbove18. В каждом из них, будет тот вывод, который нужен для конкретного пользователя.

        Как пользователь будет взаимодействовать с объектами этих классов? Варианта два, либо мы передаём его в конструктор, либо в сам метод getGreetingMessage. Что правильнее? Всегда пытайтесь понять, имеем ли мы дело с абстракцией данных или нет. С самим пользователем всё понятно. Пользователь это абстракция данных, у него есть уникальность (все пользователи отличаются) и время жизни. А вот вывод сообщения, это операция без состояния. Само наличие класса и объекта для него обусловлено желанием получить полиморфизм подтипов и ничем более. Поэтому в данном примере лучше передавать пользователя через метод:

// Где-то в шаблоне
        = greeting.getGreetingMessage(user)
    За кадром остался вопрос выбора и создания соответствующего объекта. За это отвечает фабрика, которая вызывается где-то до формирования вывода из шаблона.

        const buildGreetingObject = (user) => {
        if (user.getAge() < 18) {
            return new GreetingForUnder18();
        } else {
            return new GreetingForAbove18();
        }
    }
    Главное в этой схеме, то что пользователь остался пользователем. Он по-прежнему отвечает только за логику ядра приложения. Даже если добавятся новые условия вывода сообщения и наши два класса превратятся в 10 классов (потому что 10 вариантов вывода в зависимости от разных параметров), то это никак не повлияет на пользователя.

        Что ещё более важно, при появлении новых задач, не связанных с выводом сообщения, пользователь по-прежнему не будет затронут. Например, мы захотим отправлять письма разным пользователям после регистрации. В зависимости от количества видов писем, будет создано такое же количество классов, реализующих интерфейс RegistrationEmailText. Принцип работы останется таким же. Фабрика, выбор нужного типа в начале процесса регистрации и полиморфное поведение при отправке письма.

        Внимательный читатель заметит, что результат подозрительно похож на стратегию. Как ни странно, это и есть стратегия.

        В итоге, в коде появляется большое количество небольших интерфейсов (типов) и множество классов их реализующих. Количество классов, реализующих конкретный интерфейс, равно количеству возможных вариантов поведения. Большинство объектов этих классов не имеют своего состояния и нужны для организации полиморфного кода.

        Стоит ли так писать код? Иногда да, но чаще нет. Слепое следование ООП, делает код сложнее и тяжелее, там где подходит простая функция или условная конструкция, начинают вырастать параллельные иерархии классов. В примерах выше это хорошо прослеживается. Задача, которая может быть реализована десятью строчками, решается многими десятками строчек и четырьмя файлами (фабрика, классы и интерфейс). А программист знакомый с абстрактными классами и наследованием, наворотит ещё больше файлов.

        Обычно, получаемая сложность оправдывается расширяемостью, но это так не работает. Расширяемость нужно добавлять тогда когда нужно и только туда куда нужно. Другой вопрос, что сам способ организации кода через композицию объектов, является краеугольным камнем при организации кода построенного на классах. При этом надо чётко отслеживать, где у нас абстракция данных, а где действия без состояния, представленные объектами.




        @@@@
    Адаптер – популярный шаблон проектирования. Он используется тогда, когда нужно использовать код, не поддерживающий необходимый интерфейс. В такой ситуации, создается "обертка" над необходимым кодом, которая поддерживает нужный интерфейс. Это очень похоже на адаптеры электронных устройств в реальной жизни.

        В текущем задании, есть код отвечающий за генерацию паролей, он находится в классе PasswordBuilder. Для генерации паролей, этот класс использует внешний объект.

        Суть данного задания, внедрить в эту систему внешнюю библиотеку.

        Обратите внимание на то, что задача решается не через исправление кода самой библиотеки, а за счет создания адаптера, благодаря которому соединяется код задания и код библиотеки.

        PasswordGeneratorAdapter.js
    Реализуйте класс PasswordGeneratorAdapter, который представляет собой адаптер к пакету generate-password.

        import PasswordBuilder from '../PasswordBuilder';
import PasswordGeneratorAdapter from '../PasswordGeneratorAdapter';

    const builder = new PasswordBuilder(new PasswordGeneratorAdapter());

// Первый параметр длина пароля (setLength в генераторе)
// Второй, набор опций
// Для настройки генератора смотрите официальную документацию https://github.com/brendanashworth/generate-password
    const passwordInfo = builder.buildPassword(10, ['upperCase', 'numbers']);
// {
//    password: '9G/y{JYY',
//    digest: 'aee5e4e6a6cc1fdd77e5669ee49cbcd3ff7e1803',
// }
    Вторым параметром в buildPassword передается набор опций:

        uppercase
    numbers
    symbols
    Каждая из этих опций, соответствует опциям внутри библиотеки generate-password.



        import generator from 'generate-password';

export default class PasswordGeneratorAdapter {
    constructor() {
        this.options = {
            symbols: false,
            numbers: false,
            uppercase: false,
        };
    }

    generatePassword(length, options) {
        options.forEach((option) => {
            this.options[option] = true;
        });
        this.options.length = length;

        return generator.generate(this.options);
    }
}