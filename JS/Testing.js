// ###### JS: Автоматическое тестирование ######

/**
 Код профессиональных разработчиков содержит меньше ошибок, чем код начинающих. Это происходит не потому, что они умнее, внимательнее к деталям или видят код насквозь. Настоящая причина кроется в том, что они пишут тесты.

 Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их на приемлемом уровне. Тесты дают уверенность, что изменения в одной части системы не сломали другие части.

 Однако, тесты нужны не только для проверки работоспособности кода. Существуют и другие автоматизированные виды тестов, например, тесты производительности или тесты на уязвимости.

 Среди разных видов автоматизированных тестов, программисты, в первую очередь, отвечают за функциональные тесты. Эти тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы. Например, регистрация пользователя должна, как это ни странно, регистрировать пользователя. И тесты это подтверждают.

 По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

 > Модульные
 > Интеграционные
 > Системные

 Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты. У программистов на такие тесты должно быть направлено основное внимание. Их всё ещё достаточно просто писать (если экосистема проекта подготовлена к этому) и они охватывают гораздо большую часть системы.

 Наиболее сложные и максимально эффективные — системные тесты. В случае сайтов — это тестирование через браузер. Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. Сложность этих тестов в том, что им приходится опираться на вёрстку сайта, которая часто и непредсказуемо меняется. Кроме того, в браузере невозможно точно определить, когда закончилось одно действие и началось другое (с точки зрения программы). Именно поэтому такие тесты часто ломаются, их сложно писать и поддерживать.

 Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты. Этот курс знакомит с общими принципами тестирования и шаг за шагом проводит через все возникающие во время тестирования задачи.
 */



// #>>>>>> Зачем и как писать тесты? <<<<<<

/**
 Какую главную задачу должны решать тесты? Этот вопрос невероятно важен. Ответ на него даёт понимание того, как правильно писать тесты и как писать их не нужно.

 Представьте, что вы написали функцию capitalize(text), которая делает заглавной первую букву переданной строки:
 */

capitalize('hello'); // 'Hello'


// Вот один из вариантов её реализации:

const capitalize = text => {
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};


/**
 Что мы делаем после создания функции? Проверяем, как она работает. Например, открываем REPL и вызываем функцию с разными аргументами:

 $ node
 Welcome to Node.js v12.4.0.
 > capitalize('hello')
 'Hello'
 > capitalize('how are you')
 > 'How are you'

 Таким нехитрым способом убеждаемся, что функция работает. По крайней мере для тех аргументов, которые мы передали в неё. Если во время проверки заметили ошибки, то исправляем функцию и повторяем всё заново.

 Фактически, весь этот процесс и есть тестирование. Но не автоматическое, а ручное. Задача такого тестирования — убедиться, что код работает как надо. И нам совершенно без разницы, как конкретно реализована эта функция. Это и есть главный ответ на вопрос, заданный в начале урока.

 Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.
 */


// #@ Автоматические тесты

/**
 Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

 Даже если вы не знакомы с исключениями, ничего страшного. В этом курсе достаточно знать две вещи: для чего они нам нужны и какой у них синтаксис. До сих пор в курсах Хекслета вы встречались с ошибками, которые возникают непроизвольно: вызов несуществующей функции, обращение к несуществующей константе и так далее. Но ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. Исключения создаются такой конструкцией:
 */

throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');


// Пример теста:

if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
    // Выбрасываем исключение и завершаем выполнение теста
    throw new Error('Функция работает неверно!');
}

/**
 Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он работает в том же окружении и подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой. Обнаруженные ошибки в тестах исправляются и жизнь продолжается дальше ;)

 В коде, тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:

 src/
 ├── bin
 │   └── hexlet.js
 ├── half.js
 └── index.js
 tests/
 └── half.test.js


 Структура этой директории зависит от того, на базе чего пишутся тесты, например, на базе какого фреймворка. В простых случаях, она отражает структуру исходного кода. Если предположить, что наша функция capitalize(text) определена в файле src/capitalize.js, то её тест лучше поместить в файл tests/capitalize.test.js. Слово test в имени модуля с тестами, используется только для более явного обозначения цели файла.

 Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:

 $ node tests/capitalize.test.js
 # Если все хорошо, код молча выполнится.
 # Если есть ошибка, то будет выведено сообщение об ошибке.
 */


// #@ Как пишутся тесты

/**
 Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые функции, вызывать их с необходимыми аргументами и проверять, что функции возвращают ожидаемые значения.

 Если поменялась сигнатура функции (входные или выходные параметры, её имя), то придётся переписывать тесты. Если сигнатура осталась той же, но поменялись внутренности функции:
 */
const capitalize = (text) => {
    const [firstSymbol, ...restSymbols] = text;

    return `${firstSymbol.toUpperCase()}${restSymbols.join('')}`;
};

/**
 Тогда тесты должны продолжать работать без изменений.

 Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.
 */


// #@ Сколько и какие нужно писать проверки?

/**
 Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически не осуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

 При написании тестов нужно ориентироваться на разнообразие входных данных. У любой функции есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

 > Работа с пустой строкой
 > Обработка null
 > Деление на ноль (в большинстве языков вызывает ошибку)
 > Специфические ситуации для конкретных алгоритмов

 Для capitalize пограничным случаем будет пустая строка:
 */
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

/**
 Добавив тест на пустую строку, мы увидим, что вызов показанной в начале урока функции capitalize завершается с ошибкой. Внутри неё идёт обращение к первому индексу строки без проверки его существования. Исправленная версия кода:
 */

const capitalize = (text) => {
    if (text === '') {
        return '';
    }
    const firstSymbol = text[0].toUpperCase();
    const restSymbols = text.slice(1);
    return `${firstSymbol}${restSymbols}`;
};

/*
    В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария:

    > Функция выполнилась так, что не был выполнен ни один условный блок
    > Функция выполнилась так, что был выполнен только первый условный блок
    > Функция выполнилась так, что был выполнен только второй условный блок
    > Функция выполнилась так, что были выполнены оба условных блока

    Комбинация всех возможных вариантов поведения функции называется цикломатической сложностью. Это число показывает все возможные пути кода внутри функции. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

    Иногда пограничные случаи не связаны с условными конструкциями. Особенно часто такие ситуации встречаются там, где есть вычисления границ слов или массивов. Такой код может работать в большинстве ситуаций, но только в некоторых может давать сбой:
*/



// В этой функции забыли отнять единицу от длины
// Этот код сработает в некоторых ситуациях (когда последний элемент undefined) или в массиве нет элементов
// Но в остальных случаях вернёт неверное значение
const last = (elements) => elements[elements.length];


// #@ Проверка входных данных

/**
 Особняком стоят ошибки типов входных данных. Например, в функцию capitalize можно передать число вместо строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

 Ещё один интересный вопрос. Нужно ли внутри capitalize обрабатывать такие ситуации? Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних уровнях.

 Ответственность за передачу правильных данных в функцию capitalize лежит не на ней, а на коде, который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

 Но даже если ошибка обрабатывается внутри функции, это не значит, что надо бросаться писать тест, покрывающий данную ошибку. Попытка покрывать каждую (особенно ошибочную ситуацию) тестами, выливается в огромное число тестов, которые требуют поддержки и времени на написание. Нужно уметь во время остановиться и двигаться дальше, к покрытию другого или нового кода.
 */

// #@ Собирая всё вместе

//

/*
 В конечном итоге мы получили такую структуру директорий:
    src/
    └── capitalize.js
    tests/
    └── capitalize.test.js

    Содержимое теста:
*/

if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');

/*
    Запуск:

    $ node tests/capitalize.test.js

    Если всё написано правильно, то запуск тестов завершится с выводом строки Все тесты пройдены! Если в тестах или в коде есть ошибка, то сработает исключение и мы увидим сообщение, указывающее на это.
 */


/*
    // FILE: /tests/collection.test.js

    Напишите тесты для функции get(obj, key, defaultValue). Тесты должны быть построены по такому же принципу, как это описывалось в теории урока: проверка через if и исключение в случае провала теста.

    Эта функция извлекает значение из объекта при условии, что ключ существует. В ином случае возвращается defaultValue.
*/

get({ key: 'value' }, 'key'); // 'value'
get({}, 'key', 'defaultValue'); // 'defaultValue'


import getFunction from '../functions';

const get = getFunction();

if (get({ key: 'value' }, 'key') !== 'value') {
    throw new Error('boom!');
}
if (get({}, 'key', 'value') !== 'value') {
    throw new Error('boom!');
}
if (get({ key: 'value' }, 'key', 'default value') !== 'value') {
    throw new Error('boom!');
}



// # >>>>>> Утверждения (Asserts) <<<<<<#

/**
 Каждую проверку, которую мы написали для функции capitalize, в тестировании принято называть утверждением (assert). Утверждения — ключевая часть тестов. Именно они проверяют функциональность кода:
 */

import capitalize from '../src/capitalize';

// Первое утверждение (проверка на пустую строку)
if (capitalize('') !== '') {
    throw new Error('Функция работает неверно!');
}

// Второе утверждение (проверка на слово)
if (capitalize('hello') !== 'Hello') {
    throw new Error('Функция работает неверно!');
}

/**
 Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Node.js поставляется с модулем assert, в котором есть несколько функций, упрощающих написание утверждений:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert(capitalize('') === '');
assert(capitalize('hello') === 'Hello');

/**
 В самом простом случае assert используется как функция, которая проверяет истинность переданного значения. Другими словами, assert(true) означает что всё хорошо, а assert(false) говорит об ошибке. Последний вариант выбрасывает исключение с таким сообщением:

 AssertionError [ERR_ASSERTION]: false == true

 Расшифровка сообщения: "Ожидалось, что значением выражения будет истина, но оказалось, что это ложь". Кроме сообщения, выводится трассировка стека (стектрейс), по которому можно найти сработавшее утверждение.

 Функция assert сделала наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

 С другой стороны, вывод сообщения об ошибке крайне не информативный. Единственный способ понять, что произошло — открывать код с упавшим утверждением (ещё есть вариант передать сообщение об ошибке последним параметром, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий). Это пытаются исправить с помощью специализированных утверждений, заточенных под конкретные ситуации. Например, при сравнении двух значений подходит функция assert.equal(actual, expected). Перепишем код выше:
 */

import assert from 'assert';
import capitalize from '../src/capitalize';

// Проверка сменилась с отрицательной на положительную
assert.equal(capitalize(''), '');
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize('hello'), 'Hello');

/**
 Вывод таких утверждений значительно понятнее:

 Thrown:
 AssertionError [ERR_ASSERTION]: 'hello' == 'Hello'
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: 'hello',
 expected: 'Hello',
 operator: '=='

 В этом выводе есть не только информация об ошибке, но и данные, которые передавались в утверждение. Такой формат упрощает анализ проблемы и ускоряет отладку.

 Однако, будьте осторожны. Функция equal(actual, expected) проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются, как не эквивалентные:

 > assert.equal({}, {})
 Thrown:
 AssertionError [ERR_ASSERTION]: {} == {}
 generatedMessage: true,
 code: 'ERR_ASSERTION',
 actual: {},
 expected: {},
 operator: '=='

 > assert.equal({ key: 'value'  }, { key: 'value'  });
 Thrown:
 AssertionError [ERR_ASSERTION]: { key: 'value'  } == { key: 'value'  }
 generatedMessage: true,
 name: 'AssertionError [ERR_ASSERTION]',
 code: 'ERR_ASSERTION',
 actual: { key: 'value'  },
 expected: { key: 'value'  },
 operator: '=='


 Для сравнения по значению используется ещё одно утверждение: assert.deepEqual(actual, expected). Оно опирается только на содержимое:

 assert.deepEqual({}, {}); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'value' }); // всё ок
 assert.deepEqual({ key: 'value' }, { key: 'another value' }); // Boom!

 Для тестирования негативных сценариев предназначены функции assert.notEqual(actual, expected) и assert.notDeepEqual(actual, expected). Они тестируют то, что значения не равны. Эти утверждения используются крайне редко, но знать о них всё равно полезно.

 # Дополнительные материалы
 Asserts https://nodejs.org/api/assert.html
 Chai https://www.chaijs.com/
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции take(items, n), которая возвращает первые n элементов из массива:
 */

take([1, 2, 3], 2); // [1, 2]
take([], 2); // []
take([4, 3], 9); // [4, 3]


// FILE: tests/take.test.js
import assert from 'assert';
import getFunction from '../functions';

const take = getFunction();

assert.deepEqual(take(['one', 'two', 8], 9), ['one', 'two', 8]);
assert.deepEqual(take([1, 2]), [1]);
assert.deepEqual(take(['one', 'two', 'three'], 2), ['one', 'two']);
assert.deepEqual(take([]), []);




// # >>>>>> power-assert <<<<<<#

/**
 У обычных утверждений есть мощная альтернатива: power-assert https://github.com/power-assert-js/power-assert. Эта библиотека добавляет магию в привычный инструмент.

 Вот пример проверки с использованием стандартного модуля assert:
 */

const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

assert(user.name === 'Michel');

// AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:
//  assert(user.name === 'Michel')

/*
    В выводе видно само утверждение и результат проверки. Но непонято, что за объект user и какая у него структура. Для получения этой информации придётся включаться в отладку. Но вместо этого можно воспользоваться библиотекой power-assert:
*/

import assert from 'power-assert'; // !

// Весь код остаётся тем же самым
const user = {
    name: 'Madonna',
    friends: ['Kate', 'Michel'],
    email: 'madonna@gmail.com',
};

// Интерфейс библиотеки power-assert на 100% совместим со встроенным модулем assert.
assert(user.name === 'Michel'); // =>

/**
 AssertionError [ERR_ASSERTION]:   # test.js:10

 assert(user.name === 'Michel')
 |    |    |
 |    |    false
 |    "Madonna"
 Object{name:"Madonna",friends:#Array#,email:"madonna@gmail.com"}

 --- [string] 'Michel'
 +++ [string] user.name
 @@ -1,6 +1,7 @@
 M
 -ichel
 +adonna


 Попробуйте остановиться и внимательно изучить этот вывод. Что здесь показано? power-assert облегчает отладку настолько, насколько это вообще физически возможно. Он показывает значение каждого объекта и результат каждой операции, входящей в выражение, переданное в функцию assert. Кроме того, в конце он сравнивает строки и говорит, в чём конкретно было различие между ними.

 Вот ещё один интересный пример из документации:
 */

import assert from 'power-assert';

const ary = [1, 2, 3];
const zero = 0;
const two = 2;

assert(ary.indexOf(zero) === two);

// AssertionError [ERR_ASSERTION]:   # test.js:7
//
//   assert(ary.indexOf(zero) === two)
//          |   |       |     |   |
//          |   |       |     |   2
//          |   -1      0     false
//          [1,2,3]
//
//   [number] two
//   => 2
//   [number] ary.indexOf(zero)
//   => -1

/**
 Впечатляет? Большинство современных фреймворков не выдаёт настолько удобный вывод, насколько это делает power-assert. Хорошая новость в том, что его можно интегрировать с чем угодно.
 */



/**@@@
 tests/indexOf.test.js
 Напишите тесты для функции indexOf(items, value), которая возвращает индекс переданного элемента:
 */

_.indexOf([1, 2, 1, 2], 2); // 1
_.indexOf([2, 'one', 'cat', false], 8); // -1


// FILE: /tests/indexOf.test.js

import assert from 'power-assert';
import getFunction from '../functions';

const indexOf = getFunction();

assert(indexOf(['one', 'two', 8], 'two') === 1);
assert(indexOf([1, 8, 9, 3, 9], 9) === 2);
assert(indexOf([], 9) === -1);




// # >>>>>> Jest <<<<<<#

/**
 Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?

 Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод. С большинством из этих возможностей мы познакомимся далее по курсу. В JavaScript мире наиболее популярен фреймворк Jest, разрабатываемый компанией Facebook. К слову, с помощью него мы тестируем все практики на Хекслете.

 Ниже находится инструкция, в которой мы создадим с нуля npm-проект и добавим в него тесты.
 */

// #@ Настройка и запуск

/**
 Создайте где-нибудь на вашем компьютере директорию с названием hexlet-jest. Зайдите в неё и выполните команду:

 $ hexlet-jest $ npm init

 Ответьте на все вопросы запущенного скрипта инициализации проекта. Убедитесь, что в корне проекта появился файл package.json.

 Теперь добавим немного исходного кода. Создайте файл src/index.js с таким содержимым:
 */

// Эта функция переворачивает переданную строку
export default str => str.split('').reverse().join('');

/*
    Jest — обычный npm-пакет, который локально подключается в разрабатываемый проект. Jest нужен только во время разработки, поэтому лучше установить его в секцию devDependencies:

    # В директории с проектом
    $ hexlet-jest $ npm i --save-dev jest

    По умолчанию Jest не использует Babel, поэтому код с импортами внутри Jest не заработает. Для поддержки Babel нужно установить несколько дополнительных пакетов:

    $ hexlet-jest $ npm i --save-dev babel-jest @babel/core @babel/preset-env

    Далее создайте в корне проекта файл babel.config.js с таким содержимым:
*/

module.exports = {
    presets: [['@babel/preset-env', {targets: {node: 'current'}}]],
};

/**
 После установки этих пакетов и настройки babel.config.js, Jest начнёт использовать Babel при запуске тестов. Никакая конфигурация больше не требуется.

 По умолчанию (но этим можно управлять) Jest ожидает, что тесты находятся в директории __tests__ в корне проекта. Внутри этого каталога, можно создавать любую структуру, Jest найдёт все тесты, которые там лежат. Именование файлов с тестами должно быть таким: <name>.test.js. Где <name>, как правило, это имя соответствует имени модуля, который тестируется.

 Напишем наш первый тест. Создайте файл __tests__/index.test.js со следующими содержимым:
 */

import reverse from '../src';

test('reverse', () => {
    expect(reverse('hello')).toEqual('olleh');
    expect(reverse('')).toEqual('');
});

/**
 Далее мы разберём структуру этого файла, а пока попробуем запустить тест на выполнение:

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms)

 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        1.166s
 Ran all test suites.

 Ура! Тесты прошли успешно.
 */

// #@ Структура

/**
 Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

 Функция test нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

 hexlet-jest $ npx jest
 PASS  __tests__/index.test.js
 ✓ reverse (11ms) # название теста


 Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутри Jest, который уже решает как и когда запускать тесты. Это позволяет проводить различные оптимизации например, выполнять тесты параллельно.

 Самое необычное в этом коде — проверки. Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

 > Вызывается функция expect куда передаётся актуальное (фактическое) значение.
 > На результате, возвращаемом функцией expect, вызывается подходящий матчер, например, toEqual.
 */
// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse('hello')).toEqual('olleh');

/**нейших особенностей Jest — то, как он выводит сообщения о проваленных проверках. Попробуйте внести ошибку в исходную функцию и запустите тесты заново:

 hexlet-jest$ npx jest
 FAIL  __tests__/index.test.js
 ✕ reverse (9ms)

 ● reverse

 expect(received).toEqual(expected) // Object.is equality

 Expected: "olleh"
 Received: "o|l|l|e|h"

 3 | test('reverse', () => {
          4 |   const str = 'hello';
        > 5 |   expect(reverse(str)).toEqual('olleh');
            |                        ^
          6 | })
 7 |

 at Object.toEqual (__tests__/index.test.js:5:24)

 Test Suites: 1 failed, 1 total
 Tests:       1 failed, 1 total
 Snapshots:   0 total
 Time:        1.683s
 Ran all test suites.

 В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла с тестами с указанием на конкретную проверку. Это невероятная и очень полезная фишка, которая значительно ускоряет анализ результатов тестирования и помогает в отладке.

 # Дополнительные материалы
 Jest https://jestjs.io/
 Блоки тестов (Describe) https://jestjs.io/docs/ru/api#describename-fn


 ? Как правильно запускать Jest на выполнение?
 > npx jest
 */


/**@@@
 tests/take.test.js
 Напишите тесты для функции without(coll, [values]), которая принимает первым параметром массив и возвращает его копию, из которой исключены значения, переданные вторым и последующими параметрами.
 */
_.without([2, 1, 2, 3], 1, 2); // [3]

// FILE: /tests/take.test.js

import getFunction from '../functions';

const without = getFunction();

test('without', () => {
    expect(without([], 3)).toEqual([]);
    expect(without([3, 8, 9, 8, 10], 8, 10)).toEqual([3, 9]);
});




// # >>>>>> Матчеры (Expectations) <<<<<<#

/**
 Существует несколько популярных способов описывать утверждения. Кроме вызова обычных функций, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок.

 Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать (В идеале, на практике всё сложнее). Матчеры заменили собой обычные утверждения на функциях во многих языках:
 */

// Проверка равенства по ссылке
// assert.equal([1, 2], [1, 2])
expect([1, 2]).toBe([1, 2]); // false

// Проверка равенства по значению
// assert.deepEqual([1, 2], [1, 2])
expect([1, 2]).toEqual([1, 2]); // true


/**
 Любой матчер в Jest начинается с функции expect(data), в которую передаются данные на проверку. Затем expect возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. В Jest десятки матчеров для самых разнообразных ситуаций. Такое количество объясняется желанием выдавать максимально точный отчёт о том, что произошло.

 Предположим, что функция возвращает массив и мы хотим проверить его размер. Для этого можно воспользоваться матчером toBe:
 */

const data = [1, 2, 3];
// take берет первые n элементов
// assert.equal(take(data, 2).length, 2)
expect(take(data, 2).length).toBe(2);

// Этот матчер прекрасно справится с задачей. Но в случае ошибки его вывод не слишком информативен:

expect(received).toBe(expected); // Object.is equality

// Expected: 2
// Received: 1

// Поэтому лучше взять специализированный матчер для проверки размера массива:

expect(take(data, 2)).toHaveLength(2);

/**
 Тогда вывод расскажет гораздо больше:

 expect(received).toHaveLength(expected)

 Expected length: 2
 Received length: 1
 Received array:  [1, 2]

 Благодаря тому, что в expect передаётся сам массив, а не его длина, у Jest появляется возможность выводить содержимое массива в случае ошибки. Это, опять же, упрощает отладку.

 Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:
 */

expect(null).toBeNull();

// Проверяет значение на truthy (любое значение, которое приводится к true)
expect(true).toBeTruthy();
// Точное сравнение с true
expect(true).toBe(true);

expect(undefined).toBeUndefined();

// Проверка, что массив содержит элемент
expect([1, 2, 3]).toContain(2);

// Проверка, что строка содержит подстроку
expect('hello, world').toMatch('hello');

// Проверяет, что в объекте есть свойство с определённым значением
expect({ key: 'value' }).toHaveProperty('key', 'value');


// Кроме того, к любому матчеру можно применить модификатор not, который инвертирует поведение матчера:

expect(null).not.toBeNull(); // not null
expect(undefined).not.toBeUndefined(); // not undefined
expect([1, 2, 3]).not.toContain(2); // not contain 2
expect('hello, world').not.toMatch('hello'); // not match hello

// Особняком стоит матчер toMatchObject. Он используется, когда нас в тестах интересует не весь объект, а только какая-то его часть:

const user = {
    firstName: 'tolya',
    lastName: 'petrov',
    age: '33',
};

// Тест пройдёт успешно, так как проверяется только firstName
expect(user).toMatchObject({ firstName: 'tolya' });

/**
 Это далеко не все матчеры, которые есть в Jest. Более того, Jest достаточно гибкий и может расширяться собственными матчерами. На Гитхабе можно найти библиотеки с матчерами для разных ситуаций.

 В целом, вам придётся постоянно заглядывать в документацию, чтобы вспомнить, что там есть. Иначе всё может свестись к использованию toEqual. Пожалуй, это основной недостаток использования матчеров — необходимость помнить про них и правильно применять.

 # Дополнительные материалы
 Матчеры Jest https://jestjs.io/docs/ru/expect
 */


/**@@@
 tests/gt.test.js
 Напишите тесты для функции _.gt(value, other), которая возвращает true в том случае, если value > other, и false в иных случаях.
 */

gt(3, 1); // true
gt(3, 3); // false
gt(1, 3); // false


// FILE: /tests/gt.test.js
import getFunction from '../functions';

const gt = getFunction();

test('gt', () => {
    expect(gt(0, 0)).toBe(false);
    expect(gt(1, 0)).toBe(true);
    expect(gt(1, -3)).toBe(true);
});

// FILE: /functions.js
import _ from 'lodash';

const functions = {
    right1: _.gt,
    wrong1: _.gte,
    wrong2: _.eq,
};

export default () => {
    const name = process.env.FUNCTION_VERSION || 'right1';
    return functions[name];
};




// # >>>>>> Модульные тесты <<<<<<#


/*
    Изученной информации уже достаточно для тестирования в повседневной практике разработки. Перед тем, как погружаться в более сложные темы и возможности Jest, пройдём полный путь тестирования библиотеки, поговорим об организации тестов, хороших и плохих практиках. Это поможет сформировать правильное отношение к тестированию в целом.

    В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: функции, модули, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

    Попробуем протестировать стек. Напомню, что стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. Сам стек, как правило, используется для реализации алгоритмов. Ещё его много в низкоуровневом коде: например, внутри языков программирования или операционных систем.
*/

import makeStack from '../src/stack';

const stack = makeStack();
stack.isEmpty(); // true
stack.push(1); // (1)
stack.push(2); // (2, 1)
stack.push(3); // (3, 2, 1)
stack.isEmpty(); // false
stack.pop(); // 3. В стеке (2, 1)
stack.pop(); // 2. В стеке (1)
stack.pop(); // 1. В стеке пусто
stack.isEmpty(); // true


/**
 Сначала решим организационные вопросы. Если предположить, что реализация стека лежит в файле src/stack.js, то его тест мы положим в файл __tests__/stack.test.js.
 */

// #@ Тестируем основную функциональность

/**
 Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:
 */

import makeStack from '../src/stack.js';

test("stack's main flow", () => {
    const stack = makeStack();
    // Добавляем два элемента в стек и затем извлекаем их
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
    expect(stack.pop()).toEqual('one');
});

/**
 Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

 В интернете можно встретить мнение, что несколько проверок в рамках одного теста это неправильно. Что тесты нужно детализировать максимально подробно и создавать новый тест на каждую проверку.
 */

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    expect(stack.pop()).toEqual('two');
});

test("stack's main flow", () => {
    const stack = makeStack();
    stack.push('one');
    stack.push('two');
    stack.pop();
    expect(stack.pop()).toEqual('one');
});


// #@ Тестируем дополнительную функциональность

// Следующим тестом будет тест на дополнительные функции стека. К таким у нас относится функция isEmpty(), которая проверяет, пустой ли стек:

test('isEmpty', () => {
    const stack = makeStack();
    expect(stack.isEmpty()).toBe(true);
    stack.push('two');
    expect(stack.isEmpty()).toBe(false);
    stack.pop();
    expect(stack.isEmpty()).toBe(true);
});

/*
    В этом тесте проверяются сразу три ситуации:
    > начальное состояние стека
    > состояние стека после добавления элементов
    > состояние стека после извлечения всех элементов

    В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty() всё равно сломается. Нужно ли пытаться найти все варианты? Не нужно. Тесты не даются бесплатно, каждая написанная строчка кода в проекте — потенциальное место для изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только тогда, когда они критичны для работоспособности.
*/

// #@ Пограничные случаи

/**
 Ну, и последнее, что можно протестировать — поведение функции pop(), когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение, если из него попытались взять элемент, когда тот был пустой. Поэтому здесь подойдёт матчер toThrow().
 */

test('pop in empty stack', () => {
    const stack = makeStack();
    // Вызов метода pop обёрнут в функцию, иначе матчер не сможет перехватить исключение
    1
});

/**
 Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать проект в допустимых рамках забагованности.

 # Дополнительные материалы
 Чек-лист хороших инженерных практик в компаниях https://guides.hexlet.io/check-list-of-engineering-practices/


 > Если обнаружился баг, то сначала надо написать тест и только потом чинить его
 > Тесты не должны зависеть друг от друга
 */

/**@@@
 tests/validator.test.js
 Напишите тесты для класса Validator. Этот класс проверяет корректность данных. Принцип работы валидатора следующий:

 1. С помощью метода addCheck(fn) в него добавляются проверки. Каждая проверка представляет из себя функцию-предикат, которая принимает на вход проверяемое значение и возвращает либо true либо false в зависимости от того, соответствует ли значение требованиям проверки или нет.

 2. С помощью метода isValid(value), пользователь объектов класса Validator проверяет соответствие значения всем добавленным проверкам. Если не было добавлено ни одной проверки, считается, что любое значение верное.
 */

const validator = makeValidator();
validator.isValid('some value'); // true
validator.addCheck((v) => v > 5);
validator.isValid(3); // false
validator.isValid(8); // true
validator.addCheck(/* add more checks */);



// FILE: /__tests__/validator.test.js
import { isNumber } from 'lodash';
import getImpelementation from '../implementations';

const makeValidator = getImpelementation();


test('validator', () => {
    const validator = makeValidator();
    expect(validator.isValid('value')).toBe(true);

    validator.addCheck(isNumber);
    validator.addCheck((v) => v > 10);
    validator.addCheck((v) => v % 2 === 0);

    expect(validator.isValid(false)).toBe(false);
    expect(validator.isValid('string')).toBe(false);
    expect(validator.isValid(8)).toBe(false);
    expect(validator.isValid(11)).toBe(false);

    expect(validator.isValid(12)).toBe(true);
    expect(validator.isValid(100)).toBe(true);
});





// # >>>>>> Подготовка данных <<<<<<#

/**
 Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. Особенно в части начальной подготовки данных. В прошлом уроке каждый тест начинался со строчки: makeStack(). Это ещё не дублирование, но уже шаг в эту сторону. Как правило, реальные тесты сложнее и включают в себя большую подготовительную работу.

 Допустим, мы разрабатываем библиотеку Lodash и хотим протестировать её функции для обработки коллекций:

 > find
 > filter
 > includes
 > и другие (всего их около 20 штук)

 Для работы этих функций нужна заранее подготовленная коллекция. Проще всего придумать одну, которая подойдёт для тестирования большинства или даже всех функций:
 */

import _ from 'lodash';
test('includes', () => {
    // Подготовили коллекцию coll
    const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

    // Используем coll для тестирования
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Теперь представьте, что таких тестов несколько десятков (в реальности их сотни). Код начнёт кочевать из одного места в другое, порождая всё больше и больше копипасты.

 Самый простой способ избежать этого — вынести определение коллекции на уровень модуля, вне тестовых функций:
 */

import _ from 'lodash';

const coll = ['One', true, 3, 10, 'cat', {}, '', 10, false];

test('includes', () => {
    expect(_.includes(coll, 3)).toBe(true);
    expect(_.includes(coll, 11)).toBe(false);
});


/**
 Это простое решение убирает ненужное дублирование. Однако учтите, оно работает только в рамках одного модуля. Подобную коллекцию всё равно придётся определять в каждом тестовом модуле. И в нашем случае это скорее плюс, а не минус.

 Дело в том, что излишнее обобщение, приводящее к полному устранению дублирования, вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт к поломке большинства тестов, которые завязаны на её структуру, на количество элементов и их значения:
 */

import _ from 'lodash';

const coll = [1, 2, 3];

test('filter', () => {
    // Выбираем только чётные
    expect(_.filter(coll, (v) => v % 2 === 0)).toEqual([2])
});

/**
 Тест выше сломается, если мы добавим в нашу коллекцию чётное число. А коллекцию почти наверняка придётся расширять при добавлении новых тестов (для этой же или других функций).

 Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, после которой обобщение начинает больше мешать, чем помогать.

 Но далеко не всегда можно выносить константы на уровень модуля. В первую очередь это касается динамических данных. Представьте себе такой код:
 */

const now = new Date();

test('first example', () => console.log(now));
test('second example', () => console.log(now));

//  console.log __tests__/index.test.js:3
//    2019-07-08T21:52:27.036Z
//
//  console.log __tests__/index.test.js:4
//    2019-07-08T21:52:27.036Z

/**
 Подвох тут в том, что модуль загружается в память ровно один раз. Это значит, что весь код, определённый на уровне модуля (включая константы), выполняется ровно один раз. В примере константа now определится до запуска всех тестов, и только затем jest начнёт выполнять тесты. И с каждым последующим тестом отставание значения константы now от текущего реального значения "сейчас" будет всё дальше и дальше.

 Почему это может быть проблемой? Код, который работает с понятием "сейчас", может рассчитывать на то, что "сейчас" это почти моментальный снимок данного момента времени. Но в примере выше, сейчас начинает отставать от реального сейчас и чем больше тестов и чем они сложнее, тем большее отставание.

 Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его во внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между загрузкой модуля и отработкой тестов проходит неопределённое время.

 Для решения этой проблемы тестовые фреймворки предоставляют хуки — специальные функции, которые запускаются до или после тестов. Ниже пример того, как создавать дату перед каждым тестом:
 */

let now;
let counter = 0;

// Запускается перед каждым тестом
beforeEach(() => {
    now = new Date();
    counter += 1;
});

test('first example', () => console.log(now, counter));
test('second example', () => console.log(now, counter));

//  console.log __tests__/index.test.js:9
//    2019-07-08T21:53:23.521Z 1
//
//  console.log __tests__/index.test.js:10
//    2019-07-08T21:53:23.525Z 2

/**
 beforeEach(callback) принимает на вход функцию, внутри которой выполняется инициализирующее действие. Оно не обязательно приводит к созданию переменных. Возможно, инициализация заключается в подготовке файловой системы, например, созданию файлов.

 Но если она должна создать данные и сделать их доступными в тестах, то придётся использовать переменные, определённые на уровне модуля. Так как всё, что определяется внутри функций (колбека в нашем случае), остаётся внутри этой функции.

 ? Что нужно учитывать при работе с колбеками Jest?
 > Матчеры должны находиться внутри тестов, а не колбеков Jest
 > Тесты не должны влиять друг на друга. Данные всегда должны возвращаться в исходное значение после каждого теста.

 ? Как обеспечить в тестах доступ к данным, созданным внутри колбеков Jest?
 > Через this
 */

/**@@@
 tests/set.test.js
 Напишите тесты для функции set(obj, path, value), которая возвращает и изменяет (или добавляет) значение в объект по указанному пути. Функция мутирует объект.
 */

const object = { a: [{ b: { c: 3 } }] };

set(object, 'a[0].b.c', 4);
console.log(object.a[0].b.c); // => 4

set(object, ['x', '0', 'y', 'z'], 5);
console.log(object.x[0].y.z); // => 5



// FILE: /__tests__/set.test.js
import { cloneDeep } from 'lodash';
import getFunction from '../functions';

const set = getFunction();

let data;
let dataCopy;

beforeEach(() => {
    data = {
        a: [
            {
                b: {
                    c: 3,
                },
            },
        ],
    };
    dataCopy = cloneDeep(data);
});

test('plain set', () => {
    set(data, 'a', 'value');
    dataCopy.a = 'value';
    expect(data).toEqual(dataCopy);
});

test('nested set', () => {
    set(data, 'a[0].b.c', true);
    dataCopy.a[0].b.c = true;
    expect(data).toEqual(dataCopy);
});

test('set new property', () => {
    set(data, 'a[0].b.d', false);
    dataCopy.a[0].b.d = false;
    expect(data).toEqual(dataCopy);
});




// # >>>>>> Плохие и хорошие практики тестирования <<<<<<#

/**
 Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо. Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности, о которых надо знать. В этом уроке мы пройдёмся по некоторым из них.
 */

// #@ Взаимное влияние тестов

/**
 Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

 Нарушить это правило очень просто. Один тест может создать файл, изменить переменную или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, или наоборот — успешно пройти там, где не должны проходить. Кроме этого, в такой ситуации вводится неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. Например, когда тест запускают изолированно, то он работает, а когда вместе с остальными — падает:
 */

let user;

test('first', () => {
    user = new User();
    // ...
});

test('first', () => {
    // Используется пользователь, которого создал другой тест!
    // Этот тест зависит от того, как работает предыдущий тест,
    // и не может работать без последовательного запуска обоих тестов.
    user.name = 'Petya';
});

/**
 Особенно часто такая ситуация возникает в тестах, активно взаимодействующих с внешней средой: базой данных или файловой системой. Тестирование побочных эффектов имеет свои хитрости и рассматривается в продвинутом курсе по тестированию.
 */

// #@ Тест вне тестов

/**
 Задача beforeEach — готовить данные и среду для тестирования, а задача test — вызывать код, который тестируется, и проводить проверки. Но иногда разработчики переусердствуют:
 */

let result;

beforeEach(() => {
    // Вызывается тестируемый код. Это противоречит идее beforeEach.
    result = sum(5, 9);
});

test('result', () => {
    // Здесь только проверка
    expect(result).toEqual(14);
});

// В этом примере тестируемый код вызывается в beforeEach. Такой подход усложняет анализ тестов, так как переворачивает всё с ног на голову.


// #@ Слишком сильная детализация

/**
 Программисты под влиянием голосов из интернета стремятся максимально разносить код по файлам, модулям и функциям. То же самое наблюдается и в тестах. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка:
 */

test('create user', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.age).toEqual(28);
});

test('create user 2', () => {
    const user = new User();
    // Код, добавляющий пользователя в базу данных
    expect(user.name).toEqual('Mark');
});

/**
 Чаще всего, единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда кода станет по-настоящему много.
 */

// #@ Глубокая вложенность

// Jest позволяет группировать тесты в блоки describe:

describe('User', () => {
    test('should be valid', () => { /* ... */ });
});

/**
 Они помогают структурировать сложные тесты и задать для каждого блока describe свой собственный beforeEach. Хотя такая возможность бывает полезна, но очень легко начать использовать её во вред:
 */

describe('', () => {
    describe('...', () => {
        describe('...', () => {
            test('should be valid', () => { /* ... */ })
        });
    });
});

/**
 Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру. Из-за этого возникают сложности при добавлении новых проверок. Становится непонятно, к чему она относится. Это проблема любых иерархий, которые рассматривают систему только с одной точки зрения.
 */

// #@ Код с тестами писать дольше, чем код без тестов

/**
 Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

 > Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
 > Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
 > Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
 > Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
 > Тесты снижают уровень стресса.


 # Дополнительные материалы
 Начинаем писать тесты правильно https://www.youtube.com/watch?v=zsz8kdi62mE
 */


/**@@
 tests/cart.test.js
 Напишите тесты для класса Cart, представляющего собой покупательскую корзину. Интерфейс:

 1. addItem(good, count) – добавляет в корзину товары и их количество. Товар это объект у которого два свойства: name – имя и price – стоимость.
 2. getItems – возвращает товары в формате [{ good, count }, { good, count }, ...]
 3. getCost – возвращает стоимость корзины. Стоимость корзины высчитывается как сумма всех добавленных товаров с учетом их количества.
 4. getCount – возвращает количество товаров в корзине
 */

const cart = new Cart();
cart.addItem({ name: 'car', price: 3 }, 5);
cart.addItem({ name: 'house', price: 10 }, 2);
cart.getItems().length; // 2
cart.getCost(); // 35


// FILE: /tests/cart.test.js
import getImpelementation from '../implementations';

const Cart = getImpelementation();

test('Cart', () => {
    const cart = new Cart();
    expect(cart.getItems()).toHaveLength(0);

    cart.addItem({ name: 'car', price: 3 }, 5);
    expect(cart.getItems()).toHaveLength(1);
    expect(cart.getCost()).toBe(15);
    expect(cart.getCount()).toBe(5);

    cart.addItem({ name: 'house', price: 10 }, 2);
    expect(cart.getItems()).toHaveLength(2);
    expect(cart.getCost()).toBe(35);
    expect(cart.getCount()).toBe(7);
});




// # >>>>>> Покрытие кода тестами (Code Coverage) <<<<<<#

/**
 С ростом проекта, определить какой код протестирован, а какой нет, становится сложно, хотя подобная потребность возникает регулярно. Обычно это происходит тогда, когда в команде есть разные люди и не все из них ответственно подходят к написанию тестов. В таком случае может страдать качество проекта.

 Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения всех строчек кода, к тем строчкам, которые были задействованы во время выполнения тестов. Например, если в коде есть условная конструкция, и она не проверяется тестами, это значит, что все строки кода, входящие в неё, не будут покрыты.

 В Jest покрытие меряется крайне просто. Достаточно запустить тесты с флагом --coverage:
 $ npx jest --coverage
 PASS  __tests__/half.test.js
 ✓ half (3ms)

 ----------|----------|----------|----------|----------|-------------------|
 File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
 ----------|----------|----------|----------|----------|-------------------|
 All files |    71.43 |      100 |    66.67 |    71.43 |                   |
 half.js  |       60 |      100 |       50 |       60 |             12,13 |
 index.js |      100 |      100 |      100 |      100 |                   |
 ----------|----------|----------|----------|----------|-------------------|
 Test Suites: 1 passed, 1 total
 Tests:       1 passed, 1 total
 Snapshots:   0 total
 Time:        2.236s
 Ran all test suites.


 После выполнения всех тестов, Jest выводит сводную таблицу по каждому файлу. В ней показан процент покрытия кода тестами. В примере выше видно что в файле index.js покрыто 100% кода, а вот в файле half.js только 60%. При этом общее покрытие кода 71.43%. Обратите внимание, что покрытие сильно зависит от того, какие тесты выполнились. Если часть из них упала с ошибками, то Jest покажет намного меньшее покрытие, так как тесты просто не доберутся до всего кода. Поэтому покрытие меряют только тогда, когда все тесты зелёные.

 Эта статистика помогает найти места, где тестов мало. Дальше по ситуации их можно начинать добавлять. Если в проекте тестов не было вообще, то эта статистика начинает быстро расти. А вот дальше, ближе к 90 процентам, придётся бороться за каждую строчку кода.

 Однако, покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. Как правило это тесты на пограничные случаи. В разработке есть хорошая практика: перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, и только затем уже можно починить их.

 Какое покрытие считается допустимым? 100% покрытия выглядит красиво, но добиться его невероятно сложно. И для большинства проектов бессмысленно. Затраченные усилия не окупятся. Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.
 */



// # >>>>>> Разработка через тестирование (TDD) <<<<<<#

/**
 В какой момент лучше писать тесты? Вообще, существует три подхода:
 > Тесты пишутся после кода
 > Тесты пишутся вместе с кодом
 > Тесты пишутся до кода

 В некоторых ситуациях, особого выбора нет. Например, при системном тестировании, когда тест имитирует поведение пользователей и выполняет действия в браузере. Такие тесты пишутся после кода.

 В тестах более низкого уровня, интеграционных и модульных тестах, обычно можно выбирать из вариантов описанных выше. И подход "писать тесты после кода" относится к наименее полезным. Почему?

 Сам процесс написания кода, связан с постоянным запуском кода и проверкой того, что он работает. В самых простых, например, учебных задачах, этот запуск происходит довольно быстро.
 */

// Легко запустить, легко проверить, что результат правильный
capitalize('hello'); // Hello

/**
 В реальном коде подготовка данных для проверки работы кода может занимать значительное время, минуты и десятки минут. С другой стороны, результатом работы проверяемого кода может быть что-то сложное, например, множество записей в базе данных или вывод определённой непростой структуры. Тогда каждый запуск кода на проверку превращается в целое приключение.
 */

// Сложно подготовить данные. Сложно проверить результат работы.
// Загрузка товаров из 1C в базу данных
loadGoodsFrom1c();


/**
 Именно здесь на сцену выходит вариант "писать тесты до кода". У многих начинающих разработчиков, эта фраза вызывает ступор. Как можно писать тесты до того, как был написан код? Оказывается, можно и это даже приятно.

 Допустим мы хотим написать функцию, которая может повторять переданную строчку указанное количество раз:
 */

repeat('$', 3); // $$$

/*
    Мы знаем что, она принимает на вход, мы знаем, какой у неё должен быть выход (спасибо, что ты чистая https://ru.wikipedia.org/wiki/Чистота_функции). Можем ли мы уже написать тесты? Конечно!
*/

test('repeat', () => {
    expect(repeat('$', 3)).toBe('$$$');
});

/**
 Сколько займёт времени написать такой тест у опытного разработчика? Думаю секунд 15, именно столько времени мне понадобилось для кода выше. Зато, теперь для проверки работы этого кода достаточно набрать jest в консоли.

 У тестирования до написания кода есть ещё одно мощное преимущество. Оно заставляет программиста в первую очередь думать о дизайне своего решения, о том, как им будут пользоваться. А не о том, как красиво он реализует всё внутри. Грамотные интерфейсы – залог успеха.

 В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD).

 TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла, где на каждой итерации пишется тест, который не проходит, затем дописывается код, удовлетворяющий данному тесту. После этого всё повторяется. Так шаг за шагом строится приложение.

 Сейчас все по инерции продолжают говорить именно о таком способе. В нём тесты пишутся на все части кода с максимальной детализацией. Этот вид TDD хоть и говорит о важности дизайна, но фокусируется на конкретных функциях и классах приложения вместо цельной картины. Но есть и другое TDD, где тесты на внутренние части не пишутся почти никогда. Подробнее об этом в статье в дополнительных материалах.

 Сам по себе Хекслет, яркий пример того, как тесты пишутся до кода. Абсолютно во всех наших практиках на всех языках, тесты есть, а кода нет :)

 # Дополнительные материалы
 Начинаем писать тесты правильно https://ru.hexlet.io/blog/posts/how-to-test-code
 Начинаем писать тесты правильно (Видео) https://www.youtube.com/watch?v=zsz8kdi62mE
 */



// # >>>>>> Непрерывная интеграция (CI) <<<<<<#

/**
 Теперь, когда мы немного разобрались с тестами, давайте поговорим о культуре их запуска.

 Локальный запуск тестов – персональная ответственность. Хорошие разработчики используют тесты непрерывно во время разработки и обязательно запускают их перед пушем (git push).

 Но этого недостаточно. Там где есть люди, там присутствует человеческий фактор и ошибки. Поэтому даже несмотря на локальный запуск, тесты должны запускаться автоматически на серверах непрерывной интеграции.

 Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозиторий. За этим следит либо специальный сервер либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно для текущего приложения) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это тесты и линтер (проверка оформления кода). Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.

 Немного терминологии и описание процесса. На каждый коммит запускается сборка (build). Во время сборки собирается приложение, устанавливаются зависимости, прогоняются тесты и все остальные проверки. Сборка, завершившаяся без ошибок, считается успешной. Если сборка не проходит, то программист получает уведомление. Дальше он смотрит отчёт и исправляет ошибки.

 Для внедрения непрерывной интеграции есть два пути. Первый, поставить себе на сервер Jenkins или его аналог. Этот вариант требует много ручной работы (плюс поддержка сервера). Он подходит компаниям, в которых очень сложные приложения, или они не хотят допускать утечки кода наружу, или у них настолько много проектов, что свой сервер дешевле чем стороннее решение. Второй путь – воспользоваться сервисом непрерывной интеграции. Таких сервисов десятки, если не сотни. Есть из чего выбрать. Как правило, большинство из них бесплатны для открытых проектов. Одним из первых подобных сервисов был https://travis-ci.com. Он до сих пор остаётся наиболее популярным, особенно среди проектов на Гитхабе.

 Travis CI подключён ко всем открытым проектам Хекслета (пример). Для удобства, он даёт "бейджик", картинку, которая вставляется в файл проекта README.md. Она показывает текущий статус проекта (завершилась ли успешна последняя сборка или нет) и по клику на неё можно попасть в интерфейс самого Travis CI.

 # Дополнительные материалы
 Экстремальное программирование https://ru.hexlet.io/blog/posts/xp
 Среды разработки. Мужики, выкатывай! https://ru.hexlet.io/blog/posts/environment
 */



// ########### JS: Продвинутое тестирование ############
/**
 Тесты – большая тема со множеством нюансов. Одно дело тестировать чистые функции, другое – приложение, в котором есть взаимодействие с базой данных, отправка запросов по сети, емейлов, в котором используются таймеры и асинхронность. Даже тестирование ошибок обладает своими особенностями.

 При правильной организации таких тестов, стоимость их поддержки остается достаточно низкой, а скорость работы растет. При неправильной же, очень легко попасть в ловушку, когда тесты вроде бы есть, но писать их тяжело, они постоянно ломаются и их приходится часто переписывать.

 Этот курс рассказывает о том, как тестировать сложные ситуации, в которых есть побочные эффекты, асинхронный код, в том числе завязанный на таймеры. Основные темы:

 > Тестирование ошибок. Снепшот тесты.
 > Фикстуры. Организация тестовых данных.
 > Изоляция побочных эффектов. Стабы. Инверсия зависимости.
 > Моки. Тестирование методом черного ящика.
 > Таймеры. Управление временем.
 > Тестирование асинхронного кода.

 #@ Дополнительная литература
 Так как это курс по продвинутому тестированию, то он рассчитывает на определенные знания с вашей стороны. Ниже список того, что может понадобится в разных уроках для их полного понимания:

 async/await https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/async-await/theory_unit
 HTTP https://ru.hexlet.io/courses/http_protocol
 JavaScript Testing Best Practice https://github.com/goldbergyoni/javascript-testing-best-practices
 */



// >>>>>>> Тестирование ошибок <<<<<<<

/**
 Основные тесты, которые нужно писать, это тесты на успешные сценарии работы. Но в некоторых ситуациях код должен возвращать ошибки и их тоже бывает нужно проверять. Под ошибками понимаются ситуации, в которых код бросает исключение. В чем их особенность? Посмотрите на тест:
 */

test('boom!', () => {
    try {
        functionWithException(0);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Этот код пытается протестировать ситуацию, при которой функция functionWithException выбрасывает исключение если ей передать 0. Как вы думаете, этот тест проверит что функция действительно порождает исключение?

 Правильный ответ – нет. Если функция functionWithException не выбросит исключение, то тест пройдет, так как код не попадет в блок catch. Исправить эту ситуацию можно хитрым способом, достаточно добавить заведомо ложное ожидание сразу после вызова функции:
 */

test('boom!', () => {
    try {
        functionWithException(0);
        expect(false).toBe(true);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Смотрится немного странно, но зато работает. Теперь ошибка точно будет отловлена.

 Документация Jest рекомендует другой способ. Jest позволяет указать количество ожиданий, которые должны выполнится в тесте. Если этого не происходит, то Jest рапортует об ошибке:
 */

test('boom!', () => {
    // Количество утверждений, которые должны быть запущены в этом тесте
    expect.assertions(1);
    try {
        functionWithException(0);
    } catch (e) {
        expect(e).not.toBeNull();
    }
})

/**
 Этот способ крайне опасен. Он порождает хрупкие тесты, которые завязаны на то, как они написаны. Если вы захотите добавить новое ожидание, то тест провалится и придется его править. Вам всегда придется следить за тем, чтобы это число было правильным. Не используйте этот подход, чем больше контекстной зависимости, тем сложнее разобраться в коде и проще наделать ошибок.

 И наконец-то мы подобрались к правильному способу. В jest есть матчер, который самостоятельно отлавливает исключение и убеждается что оно было.
 */

test('boom!', () => {
    expect(() => {
        functionWithException(0);
    }).toThrow();
})

/**
 Главная особенность этого матчера в том, что он принимает на вход функцию, которая вызывается внутри. Благодаря этому, он может самостоятельно отследить появление исключения. Этот код не содержит неявного состояния и лишних проверок, он делает ровно то что нужно делать и не требует от нас слишком много. Более того, теоретически возможен тест, в котором делается сразу несколько проверок на различные исключения. Это значительно сложнее провернуть с предыдущими способами.

 Иногда важно не просто поймать исключение, но и убедиться в том, что это ожидаемое исключение. Сделать это можно передав в матчер toThrow() строку, которая должна присутствовать в сообщении исключения.
 */

test('boom!', () => {
    expect(() => {
        functionWithException(0);
    }).toThrow('divide by zero');
})

/**
 Дополнительные материалы
 Снепшоты ошибок https://jestjs.io/docs/en/expect#tothrowerrormatchingsnapshothint
 */



// >>>>>>> Фикстуры <<<<<<<

// Представьте себе функцию, которая принимает на вход HTML в виде строки, извлекает из него все ссылки и возвращает как массив:

// Для тестирования подобной функции, желательно взять HTML близкий к реальному.
// Он хоть и не гарантирует работоспособности функции, но по крайней мере дает хорошее разнообразие по структуре документа.
// HTML взят из нашего проекта cv.hexlet.io
const html = `
<div class="card mb-3"><div class="card-body"><div class="d-flex flex-column flex-sm-row">
<div class="d-flex flex-column mr-4"><div class="text-muted text-center mb-3">
<div class="h2 mb-0 font-weight-lighter">1</div><div class="small">Ответ</div></div>
<div class="text-muted text-center mb-3"><div class="h2 mb-0 font-weight-lighter">7</div>
<div class="small">Просмотров</div></div></div><div><h5 class="card-title">
<a href="/resumes/1">Backend Software Engineer</a></h5><div class="card-text">
<p>Программист-самоучка, избравший путь постоянного самосовершенствования.
Ценю красивый и лаконичный код, люблю функциональное программирование 
(великая троица <code>map</code>, <code>filter</code>, <code>reduce</code>).</p>
<p>Использую JS, Ruby, PHP, Python, Elixir, Clojure в разной степени мастерства.</p>
<p>Восхищаюсь семейством LISP-языков, пишу свой интерпретатор LISP на Elixir.
В настоящий момент углубляюсь в ОС Unix, чтобы в дальнейшем улучшить навыки DevOps.</p>
</div><div class="text-right small"><span class="mr-3 text-muted">12 дней</span>
<a href="/users/6">Улугбек Туйчиев</a></div></div></div></div></div>
`;

const links = extractLinks(html);
console.log(links);
// => ['/resumes/1', '/users/6']

/**
 Кусок HTML в начале теста выглядит страшно. Он большой и состоит из нагромождения тегов. Конечно можно постараться и отформатировать его, но это будет ручная работа. Для любого редактора это просто строка в JavaScript. Но дело не только в форматировании, у такого способа работы с большими кусками данных есть и другие недостатки:

 При обновлениях очень легко допустить ошибку, которую сложно обнаружить визуально. Редактор ничем не сможет помочь.
 Чем больше таких данных в тестах тем сложнее их читать и отделять логику от самих данных.
 Было бы гораздо удобнее, если бы HTML хранился как обычный HTML в своем собственном файле. Это несложно сделать. В таком случае тест будет выглядеть так:
 */

import fs from 'fs';

// Jest поддерживает async/await функции
test('extractLinks', async () => {
    // html находится в файле withLinks.html в директории __fixtures__
    // При чтении текстовых файлов, в конце может добавляться пустая строка.
    // Она удаляется с помощью метода `trim` если нужно
    const html = await fs.readFile(`${__dirname}/../__fixtures__/withLinks.html`, 'utf-8');
    // Теперь с HTML удобно работать и он не загромождает тесты.
    const links = extractLinks(html);
    expect(links).toEqual(['/resumes/1', '/users/6']);
});

/**
 Данные, которые нужны во время запуска тестов, называются фикстурами. Это не обязательно текстовые данные. Фикстурами могут быть картинки, json и xml файлы, записи в базе данных и многое другое. Иногда частью фикстур может быть и код, но это довольно редкая ситуация. Подобные фикстуры нужны при тестировании различных анализаторов кода таких как eslint или babel.

 Обычно фикстуры хранятся в отдельных файлах в своей директории. В Jest для этого рекомендуется создавать директорию __fixtures__ в корне проекта. Затем они читаются и по необходимости используются в тестах.

 Пример:

 $ tree __fixtures__

 ├── after.ini
 ├── after.json
 ├── after.yml
 ├── before.ini
 ├── before.json
 ├── before.yml
 └── result.txt
 */



// >>>>>>> Побочные эффекты <<<<<<<
/**
 Проще всего тестировать код состоящий из чистых функций. Данные на вход, результат на выходе. Никаких неожиданностей, никакого состояния, никакого взаимодействия с внешним миром.
 */

import _ from 'lodash';

expect(_.last([1, 2, 3])).toBe(3);

/**
 Далеко не весь код можно назвать чистым. Без побочных эффектов не обходится ни одна реальная программа. Побочные эффекты резко усложняют тестирование, требуют более глубоких навыков их написания и лучшего понимания того, как организовывать такой код.

 Вот лишь некоторые примеры использования побочных эффектов:

 > Случайные числа
 > HTTP-запросы
 > Отправка писем
 > Взаимодействие с базой данных
 > Взаимодействие с глобальными переменными
 > Чтение и/или запись файлов
 > Оперирование текущим временем
 > В чем заключается сложность? Представьте себе функцию, которая выполняет отправку письма пользователю:
 */

if (sendGreetingEmail(user)) {
    // Вывести на сайте сообщение о том что письмо было отправлено
};

// Вот ее гипотетический тест:

expect(sendGreetingEmail(user)).toBe();

/**
 С этим тестом определенно не все в порядке. Все что мы тут проверяем – то что функция возвращает true, но мы ничего не знаем о том, оправляет ли эта функция письмо и если отправляет то какое? Все ли нормально с этим письмом?

 Но ситуация еще сложнее. Отправлять реальные письма ни в коем случае нельзя. Во-первых это не этично. Во-вторых, даже если отправлять письма на фейковые аккаунты, мы все равно взаимодействуем с внешней системой. Внешние системы это долго, такие тесты будут выполняться значительно больше по времени, чем тесты чистых функций. Кроме того, любое взаимодейстие с внешней средой не детерминировано. Начиная от того, что сеть не надежна и эти тесты могут падать с ошибками без видимой на то причины, заканчивая тем, что за слишком частую отправку писем, почтовая служба может забанить ip адрес с которого идет отправка. И, наконец, это может быть не безопасно.

 И это только отправка писем. С другими побочными эффектами будут другие сложности. И для их решения потребуются другие подходы к организации кода и тестов. В течении нескольких следующих уроков, мы разберем наиболее распространенные примеры побочных эффектов и того как правильно с ними работать.
 */



// >>>>>>> Тестирование кода взаимодействующего с файлами <<<<<<<

/**
 Наиболее типичный побочный эффект – взаимодействие с файлами (файловые операции). В основном это либо чтение файлов, либо запись в них. С чтением разбираться значительно проще, поэтому с него и начнем.

 Чтение файлов
 В большинстве случаев, чтение файлов не доставляет особых проблем. Оно ничего не изменяет и выполняется локально, в отличии от сетевых запросов. Это значит что при наличии необходимого файла и нужных прав, вероятность случайных ошибок крайне низка.

 При тестировании функций читающих файлы должно выполняться ровно одно условие. Функция должна позволять менять путь до файла. В таком случае, достаточно создать файл нужной структуры в фикстурах.
 */

// Функция читает файл со списком пользователей системы и возвращает их имена
// В линуксе это файл /etc/passwd

const userNames = readUserNames();

/**
 В тестах читать /etc/passwd нельзя, потому что содержимое этого файла зависит от окружения в котором запущены тесты. Для тестирования нужно создать файл аналогичной структуры в фикстурах и указать его при запуске функции:
 */

import fs from 'fs';

const getFixturePath = (filename) => `${__dirname}/../__fixtures__/${filename}`;

test('readUserNames' () => {
    // ../__fixtures__/passwd
    const passwdPath = getFixturePath('passwd');
    const userNames = readUserNames(passwdPath);
    expect(userNames).toEqual(/* ожидаемый список */);
});


// # Запись файлов
/**
 С записью файлов уже сложнее. Главная проблема – отсутствие гарантированной идемпотентности. Это значит, что повторный вызов функции записывающей файлы, может вести себя не как первый вызов, например, завершаться с ошибкой, или приводить к другим результатам.
 Почему? Представьте себе, что мы пишем тесты на функцию log(message), которая дописывает все переданные в нее сообщения в файл:
 */

const log = makeLogger('development.log');
await log('first message');
// cat development.log
// first message
await log('second message');
// cat development.log
// first message
// second message

/**
 Это значит что каждый запуск тестов будет немного другим. При первом запуске тестов, создает файл для хранения логов. Затем он начнет заполняться. Это приводит к целой пачке проблем:

 Наверняка внутри этой функции, процесс создания файла это особый случай, который нужно тестировать отдельно. Повторные запуски тестов перестанут проверять эту ситуацию.
 Сложнее написать предсказуемый тест. Придется дополнительно придумывать хитрые схемы, например проверять только последнюю строку в файле. Такой подход понижает качество теста.
 Не особенно критично, но все же, в процессе запуска тестов появляется файл, который постоянно растет в размерах.
 При правильной организации тестов, каждый тест работает в идентичном окружении на каждом запуске. Для этого, например, можно удалять файл после выполнения каждого теста. В Jest есть колбек afterEach который выполняется после каждого теста. Эту задачу можно попробовать решить с его помощью:
 */

import fs from 'fs';

test('log' () => {
    const log = makeLogger('development.log');

    await log('first message');
    const data1 = await fs.readFile('development.log', 'utf-8');
    expect(data1).toEqual(/* ... */)

    await log('second message');
    const data2 = await fs.readFile('development.log', 'utf-8');
    expect(data2).toEqual(/* ... */)
});

afterEach(async () => {
    await fs.unlink('development.log');
});

/**
 В большинстве ситуаций такое решение работает нормально, но все же не во всех. Выполнение кода тестов операция не атомарная. Нет никакой гарантии что колбек afterEach выполнится. Есть много причин, по которым этого может не произойти, начиная от внезапного отключения электроэнергии, заканчивая ошибками в самом Jest.

 Есть только один надежный способ делать очистку – делать это до теста, а не после. В beforeEach. С таким подходом есть только одна небольшая сложность. При первом запуске тестов файла нет. Это значит, что прямой вызов unlink завершится с ошибкой и тесты не смогут выполнится. Чтобы избежать этого:
 */

import _ from 'lodash';

beforeEach(async () => {
    await fs.unlink('development.log').catch(_.noop);
});

/**
 Другой вопрос при записи файлов. Куда их сохранять? Однозначно избегайте записи файлов прямо внутри проекта. Если тестируемый код позволяет сконфигурировать место записи, то используйте системную временную директорию. Ее можно получить через модуль os:
 */


import os from 'os';

console.log(os.tmpdir());

/**
 #@ Виртуальная файловая система (ФС)
 Это еще один способ тестировать код работающий с ФС. С помощью специальной библиотеки, во время тестов, создается виртуальная файловая система. Она автоматически подменяет реальную файловую систему для модуля fs. Это значит, что код функции, которая тестируется, трогать не надо. Эта функция продолжает думать что она работает с реальным диском. Вся конфигурация, при этом, задается снаружи:
 */

import mock from 'mock-fs';

// Конфигурация fs
// Любые операции с этими файлами будут происходить в памяти
// без взаимодействия с реальной файловой системой
mock({
    'path/to/fake/dir': {
        'some-file.txt': 'file content here',
        'empty-dir': {/** empty directory */}
    },
    'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),
    'some/other/path': {/** another empty directory */}
});

await fs.unlink('some-file.txt');

/**
 Этот способ дает идемпотентность из коробки. Вызов функции mock формирует окружение на каждый запуск с нуля. То есть достаточно добавить ее в beforeEach и можно приступать к тестированию.
 */



// >>>>>>> Инверсия зависимостей <<<<<<<

/**
 Далеко не всегда результат работы функции связан с побочным эффектом, как это было в предыдущем уроке. Иногда побочный эффект это просто дополнительное действие, которое скорее мешает протестировать основную логику.

 Представьте себе функцию, которая регистрирует пользователя. Она создает запись в базе данных и отправляет приветственное письмо:
 */

const params = {
    email: 'lala@opa.ru',
    passsword: 'qwerty',
};
registerUser(params);

/**
 Эта функция делает много всего, но главное, что нас волнует – правильная регистрация пользователя. Типичная регистрация сводится к добавлению в базу данных записи о новом пользователе. Именно это и нужно проверять – наличие новой записи в базе данных с правильно заполненными данными. А вот возврат функции нам никак не поможет.

 Как правило, базу данных в тестах не прячут. В веб-фреймворках она доступна в тестовой среде и работает как обычно. Идемпотентность в ней достигается за счет транзакций. Перед тестом она начинается и после теста откатывается. Благодаря этому, каждый тест запускается в идентичном окружении и не важно как он его меняет:
 */

// Гипотетический пример
const ctx = /* connect to db */;
beforeEach(() => ctx.beginTransaction())
test('registerUser', () => {
    const id = registerUser({ name: 'Mike' });
    const user = User.find(id)
    expect(user).toHaveProperty('name', 'Mike');
})
afterEach(() => ctx.rollbackTransaction())

/**
 А вот с отправкой писем все сложнее. Ее точно делать нельзя, но как этого добиться? Посмотрите на то как примерно может выглядеть функция регистрации пользователя:
 */

import sendEmail from './emailSender';
const registerUser = (params) => {
    const user = new User(params);
    if (user.save()) {
        sendEmail('registration', { user });
        return true;
    }
    return false;
}

// Существует несколько подходов позволяющих отключить отправку в тестах. Самый простой, переменная окружения, которая показывает среду выполнения:

// Выполняем этот код только если мы не в тестовой среде
if (process.env.NODE_ENV !== 'test') {
    sendEmail('registration', { user });
}

/**
 Несмотря на простоту использования, такой подход считается плохой практикой. Формально, из-за него происходит нарушение абстракции, код начинает знать о том, где он выполняется. Со временем таких проверок становится все больше и код становится грязнее. Более того, если нам все же надо убедиться что письмо отправляется (с правильными данными!), то мы не сможем этого сделать.

 Следующий способ – поддержка режима тестирования внутри самой библиотеки. Например где-нибудь на этапе инициализации тестов можно сделать так:
 */

// setup.js в jest
import sendEmail from './emailSender';

// У этого подхода много разновидностей, начиная от установки флага,
// заканчивая заменой функций в прототипе.
sendEmail.test = true;

// Теперь в любом другом месте где импортируется и используется функция sendEmail, реальная отправка происходить не будет:

// Ничего не происходит
sendEmail('registration', { user });

/**
 В отличии от первого варианта, прикладной код ни о чем не догадывается
 Это довольно популярное решение. Обычно информация о том, как правильно включить режим тестирования, находится в официальной документации конкретной библиотеки.

 Что делать если используемая библиотека не поддерживает режим тестирования? Существует еще один, наиболее универсальный способ. Он основан на применении инверсии зависимостей. Программу можно изменить так, чтобы она вызывала функцию sendEmail не напрямую, а принимала ее как параметр:
 */

import sendEmail from './emailSender';

// Ставим значение по умолчанию, чтобы не пришлось постоянно указывать функцию
const registerUser = (params, send = sendEmail) => {
    const user = new User(params);
    if (user.save()) {
        send('registration', { user });
        return true;
    }
    return false;
}

// И тест:

const fakeSendEmail = (...args) => {
    /* Например письмо можно вывести в лог для удобства отладки */
};

test('registerUser', () => {
    const id = registerUser({ name: 'Mike' }, fakeSendEmail);
    const user = User.find(id);
    expect(user).toHaveProperty('name', 'Mike');
});

/**
 Такой способ сложнее в реализации, особенно если функция находится глубоко в стеке вызовов. Это значит, что придется прокидывать нужные зависимости через всю цепочку функций сверху вниз. Самих зависимостей может быть много, и чем больше используется инверсия, тем сложнее код. За гибкость приходится платить.

 Теперь плюсы. Ни библиотека, ни код ничего не знают про тесты. Этот способ наиболее гибкий, он позволяет задавать конкретное поведение для конкретной ситуации. В некоторых экосистемах инверсия зависимостей определяет процесс сборки приложения. Особенно в PHP, Java и C# мире.
 */



// >>>>>>> Тестирование HTTP запросов <<<<<<<

/**
 Инверсия зависимостей крайне мощная техника, которая работает не только с функциями, но и с объектами. Рассмотрим ее глубже на примере HTTP запросов и познакомимся с таким понятием как "заглушка" (Stub).

 Предположим что у нас есть функция, которая анализирует приватные репозитории организации на гитхабе и возвращает те, что являются форками:
 */

// Библиотека для работы с github api
import Octokit from '@octokit/rest';

const getPrivateForksNames = async (org) => {
    const client = new Octokit();
    // Возвращает список приватных репозиториев указанной организации
    const { data } = await client.repos
        .listForOrg({
            org,
            type: 'private',
        });
    // Оставляем только имена форков
    return data.filter(repo => repo.fork).map(repo => repo.name);
};

// Давайте ее протестируем. Что мы хотим от этой функции? В первую очередь убедиться что она выполняет свою работу правильно – возвращает массив приватных форков. Идеальный тест выглядел бы так:

test('getPrivateForksNames', async () => {
    const privateForks = await getPrivateForksNames('hexlet');
    expect(privateForks).toEqual([/* массив имен которые мы ожидаем увидеть */]);
});

/**
 К сожалению не все так просто. Внутри функции выполняется HTTP запрос. Прикинем какие проблемы из-за этого могут возникнуть:

 Нестабильная сеть может тормозить выполнение тестов и приводит к "фантомным" ошибкам. Тесты будут иногда проходить иногда нет.
 У сервисов подобных github.com, установлены ограничения на запросы в секунду, в час, день и так далее. Со 100% вероятностью тесты начнут упираться в эти лимиты. Более того, есть шанс что машина с которой идут запросы, будет заблокирована.
 Реальные данные на гитхабе не статичны, они могут и скорее всего будут меняться, что опять же приведет к ошибкам и необходимости править тесты.
 В данном примере, http запрос воспринимается как помеха к тому, чтобы протестировать нашу основную логику. Мы доверяем github.com и его библиотеке @octokit/rest, то есть нам не нужно проверять что она работает правильно (иначе можно свихнуться если не доверять никому).

 HTTP-запрос нужно "выключить" в тестах. Из предыдущего урока мы узнали о нескольких способах выхода из этой ситуации. В данном случае подходит только один – инверсия зависимости. Для этого, добавим вторым аргументом у функции сам клиент Octokit. Это позволит подменить его в тестах:
 */

import Octokit from '@octokit/rest';

// Библиотека передается снаружи и ее можно подменить
const getPrivateForksNames = async (org, client = new Octokit()) => {
    // ...
};
/**
 Нам придется реализовать фейковый (не настоящий) клиент, который ведет себя примерно так же как и реальный Octokit, за исключением того, что он не выполняет сетевых запросов. Так же, нам нужно описать конкретные данные, которые вернет вызов listForOrg. Только в таком случае мы сможем протестировать, что функция getPrivateForksNames работает верно.
 */

// Структура этого класса описывает только ту часть,
// которая необходимо для вызова await client.repos.listForOrg(...)
class OctokitFake {
    // здесь мы описываем желаемые данные, которые вернуться в тесте
    constructor(data) {
        this.data = data;
    }

    repos = {
        listForOrg: () => {
            return Promise.resolve({ data: this.data }); // так как метод асинхронный
        }
    }
}

// И сам тест с использованием этого клиента:

import OctokitFake from '/OctokitFake';

test('getPrivateForksNames', () => {
    const client = new OctokitFake(/* ответ от github, который мы хотим проверить */);
    const privateForks = getPrivateForksNames('org name', client);
    expect(privateForks).toEqual(/* что мы ожидаем основываясь на том что вернул listForOrg */);
});

/**
 В тестировании, для подобных фейковых объектов (или функций), есть специальное название – стаб (stub). Стаб заменяет реальный объект или функцию, позволяя избежать выполнения побочных эффектов или сделать код детерминированным. Стаб не используется для проверки чего либо, он лишь позволяет изолировать ту часть, которая "мешает" тестированию основной логики.
 */



// >>>>>>> Манки патчинг <<<<<<<


// В предыдущем уроке мы тестировали гипотетическую функцию getPrivateForksNames(org) применяя инверсию зависимостей. Вспомним содержимое этой функции в ее исходном виде:

import Octokit from '@octokit/rest';

const getPrivateForksNames = async (org) => {
    const client = new Octokit();
    const { data } = await client.repos
        .listForOrg({
            org,
            type: 'private',
        });
    return data.filter(repo => repo.fork).map(repo => repo.name);
};

/**
В некоторых ситуациях, инверсия подходит идеально, в других из-за нее код становится значительно сложнее и иногда запутаннее, особенно если зависимости требуются где-то глубоко в стеке вызовов. Но есть способ, который позволяет добраться до нужных вызовов и изменить даже без инверсии зависимостей.

Прототипная модель js позволяет менять поведение объектов без прямого доступа к ним. Для этого достаточно заменить методы в прототипе. Такой подход, когда меняется поведение самой программы во время ее работы, называется манки патчингом (monkey patching). Он считается плохой практикой при написании обычного кода в js (в ruby манки патчинг нормальная практика), но он очень популярен и удобен в тестах. Самый известный пример – библиотека nock. С ее помощью перекрывают реальные сетевые запросы.

Эта библиотека работает так. Она берет стандартный модуль ноды http и заменяет внутри него некоторые методы, которые используются разными библиотеками для выполнения HTTP запросов. Причем не просто заменяет, а позволяет гибко настраивать то, какие запросы и как перехватывать, какие возвращать данные, заголовки и коды ответа.
*/

import nock from nock;
import { getPrivateForkNames } from '../src';

test('getPrivateForkNames', async () => {
    nock(/api\.github\.com/)
        .log(console.log) // для удобства отладки, можно удалить если не нужно
        // get – для GET запросов, post – для POST запросов и так далее
        .get(/\/orgs\/hexlet\/repos/)
        .reply(200, [{ fork: true, name: 'one' }, { fork: false, name: 'second' }]);

    const names = await getPrivateForkNames('hexlet');
    expect(names).toEqual(['one']);
});

/**
Цепочка nock(domain).get(uri) задает полный адрес страницы, запрос к которой надо перехватить. Nock анализирует все выполняемые запросы и подменяет только тот, который соответствует данным параметрам. Домен и адрес страницы могут указываться как целиком, так и через регулярное выражение чтобы не писать слишком много.

    Метод reply(code, body, headers) описывает ответ, который нужно вернуть по данному запросу. В самом простом случае достаточно указать код возврата. В нашей же ситуации, кроме кода нужны данные. Именно на этих данных мы и проверяем работу функции getPrivateForkNames.

    У Nock есть метод, запрещающий любые HTTP-запросы из кода: nock.disableNetConnect(). Рекомендуется вызывать его в начале файла с тестами для предотвращения случайных запросов. Помимо этого, он помогает увидеть на какие страницы выполняют запросы сторонние библиотеки. Вот как выглядит вывод после выключения внешних соединений (при условии что не выполнялось подмен запросов):

HttpError: request to https://api.github.com/orgs/hexlet/repos?type=private failed, reason: Nock: Disallowed net connect for "api.github.com:443/orgs/hexlet/repos?type=private"
    Здесь мы рассмотрели только самый базовый вариант использования Nock. У этой библиотеки огромная документация и множество вариантов использования. Полезно периодически ее просматривать в поисках более элегантных путей решения задач тестирования.

    В чем плюсы и минусы такого способа работы?

    Главный плюс, в том что такой способ тестирования практически универасальный. Его можно использовать с любым кодом, без необходимости править сам код. Программа даже не будет догадываться о том что ее тестируют.

    Минус же заключается в том что тестирование "черным ящиком" превращается в тестирование "прозрачным ящиком". Это значит что тест знает про устройство тестируемого кода и зависит от внутренностей. Такое знание делает тесты хрупкими. Функция может измениться без потери работоспособности, но тесты придется переписывать, потому что они завязаны на конкретные значения домена, страниц и формата возвращаемых данных.

    В большинстве ситуаций это не так критично. Поэтому смело используйте Nock в своих проектах, но не забывайте и про другие способы.


    # Дополнительные материалы
    Кассеты для Axios https://github.com/nettofarah/axios-vcr
*/




// >>>>>>> Моки <<<<<<<

/**
В тестировании очень популярен "мокинг". Технически он похож на стабинг и из-за этого их часто путают (специально или намеренно), но, все же, они служат разным целям и используются в разных ситуациях. Разберемся что это такое и когда он нужен.

До этого момента, мы рассматривали побочные эффекты, как помеху к тестированию нашей логики. Для их изоляции использовались стабы, либо прямое выключение логики в тестовой среде. После этого, можно было спокойно проверять правильность работы функции.

В некоторых ситуациях требуется кое-что другое. Не результат работы функции, а то что она выполняет нужное нам действие, например шлет правильный HTTP-запрос с правильными параметрами. Для этого понадобятся моки. Моки проверяют то, как выполняется код.
*/

// # HTTP

import nock from nock;
import { getPrivateForkNames } from '../src';

test('getPrivateForkNames', async () => {
    // Полное название домена
    const scope = nock('https://api.github.com')
        // Полный путь
        .get('/orgs/hexlet/repos/?private=true')
        .reply(200, [{ fork: true, name: 'one' }, { fork: false, name: 'second' }]);

    await getPrivateForkNames('hexlet');
    // Метод `scope.isDone()` возвращает `true` только тогда
    // когда соответствующий запрос был выполнен внутри `getPrivateForkNames`.
    expect(scope.isDone()).toBe(true);
});

/**
Это и называется мокинг. Мок проверяет что какой-то код выполнился определенным образом. Это может быть вызов функции, HTTP-запрос и тому подобное. Задача мока убедиться в том что это произошло и в том как конкретно это произошло, например что в функцию были переданы конкретные параметры.

    Что дает нам такая проверка? В данном случае, мало что. Да, мы убеждаемся, что вызов был, но само по себе это ещё ни о чем не говорит. Так когда же полезны моки?

    Представьте, что мы бы разрабатывали библиотеку @octokit/rest, ту самую, что выполняет запросы к github api. Вся суть этой библиотеки в том, чтобы выполнить правильные запросы с правильными параметрами. Поэтому там нужно обязательно проверять выполнение запросов с указанием точных урлов. Только в таком случае можно быть уверенными что она выполняет верные запросы.

    В этом ключевое отличие мока от стаба. Стаб устраняет побочный эффект, чтобы не мешать проверке результата работы кода, например, возврату данных из функции. Мок фокусируется на том как конкретно работает код, что он делает внутри. При этом, чисто технически мок и стаб создаются одинаково, за исключением того, что на мок вешают ожидания, проверяют вызовы. Это приводит к путанице, потому что часто моками называют стабы. С этим ничего уже не поделать, но про себя всегда пытайтесь понять о чем идет речь, это важно. От этого зависит фокус тестов.
*/

// # Функции

/**
Моки довольно часто используют с функциями (методами). Они могут проверять множество вещей:

Что функция была вызвана и сколько раз она была вызвана
Какие и сколько аргументов было передано в функцию
Предположим что мы хотим протестировать функцию forEach. Она вызывает колбек для каждого элемента коллекции:
*/

[1, 2, 3].forEach((v) => console.log(v)); // или проще [1, 2, 3].forEach(console.log)

/**
Эта функция ничего не возвращает, поэтому напрямую ее не протестировать. Можно попробовать сделать это с помощью моков. Убедимся в том что она вызывает переданный колбек и передает туда нужные значения.

Так как мы изучаем Jest, то для создания моков воспользуемся встроенным механизмом Jest. В других фреймворках могут свои встроенные механизмы. Кроме того, как мы убедились выше, существует специализированные библиотеки для моков и стабов.
*/

test('forEach', () => {
    // Моки функций в jest создаются с помощью функции jest.fn
    // Она возвращает функцию, которая запоминает все свои вызовы и переданные аргументы
    // Потом это используется для проверок
    const callback = jest.fn();

    [1, 2, 3].forEach(callback);

    // Теперь проверяем что она была вызвана с правильными аргументами нужное количество раз
    expect(callback.mock.calls).toHaveLength(3);
    // Первый аргумент первого вызова
    expect(callback.mock.calls[0][0]).toBe(1);
    // Первый аргумент второго вызова
    expect(callback.mock.calls[1][0]).toBe(2);
    // Первый аргумент третьего вызова
    expect(callback.mock.calls[3][0]).toBe(3);
});

/**
С помощью моков мы проверили что функция была вызвана ровно три раза и ей последовательно для каждого вызова передавался новый элемент коллекции. В принципе, можно сказать что этот тест действительно проверяет работоспособность функции forEach. Но можно ли сделать это проще, без мока и без завязки на внутреннее поведение? Оказывается можно. Для этого достаточно использовать замыкание:
*/

test('forEach', () => {
    const result = [];
    const numbers = [1, 2, 3];
    numbers.forEach((x) => result.push(x));
    expect(result).toEqual(numbers);
});


// # Объекты

// Jest позволяет создавать моки и для объектов. Делаются они с помощью той же функции jest.fn(), так как она возвращает конструктор:

const myMock = jest.fn();

const a = new myMock();
const b = {};
const bound = myMock.bind(b);
bound();

console.log(myMock.mock.instances);
// > [ <a>, <b> ]

// Через этот мок можно узнать любую информацию обо всех инстансах:

expect(someMockFunction.mock.instances[0].name).toEqual('test');

// # Преимущества и недостатки

/**
Несмотря на то что существуют ситуации в которых моки нужны, в большинстве ситуаций их нужно избегать. Моки слишком много знают о том как работает код. Любой тест с моками из черного ящика превращается в белый ящик. Повсеместное использование моков приводит к двум вещам:

После рефакторинга приходится переписывать тесты (много тестов!) даже если код работает правильно. Происходит это из-за завязки на то, как конкретно работает код.
Код может перестать работать, но тесты проходят, потому что они сфокусированы не на результатах его работы, а на том как он устроен внутри.
Там где возможно использование реального кода, используйте реальный. Там где возможно убедиться в работе кода без моков, делайте это без моков. Излишний мокинг делает тесты бесполезными, а стоимость их поддержики высокой. Идеальные тесты – тесты методом черного ящика.

#@ Дополнительные материалы
Jest: Mocking functions https://jestjs.io/docs/ru/mock-functions
Mock aren't stub https://martinfowler.com/articles/mocksArentStubs.html
*/