/** TCP/IP */
// IP - протокол для доставки по адресу сетевых пакетов;
// TCP - протокол для установления надежного соединения и передачи данных;

/** HTTP - HyperText Transfer Protocol */
/*
протокол передачи данных через TCP/IP-соединения

HTTP/2 кодирует запросы / ответы и разделяет их на более мелкие пакеты информации,
что значительно повышает гибкость передачи данных.
*/

/** HTTPS - HyperText Transfer Protocol Secure*/
/*
HTTP + упаковка передаваемых данных в криптографический протокол SSL или TLS.
Для HTTPS-соединений обычно используется TCP-порт 443.
*/

/** Веб-сокеты */
// стандарт двусторонней связи с сервером по TCP-соединению.
const socket = new WebSocket("ws://javascript.ru/ws");
// wss:// - c кодировкой трафика + большая вероятность соединения
// send - для отправки | onopen | onmessage| onclose | onerror

/** После ввода адреса в браузере */
/*
> Поиск IP адреса сайта:
Запрашивает IP в DNS(Domain Name System), если не нашел в:
* истории подключений браузера
* в операционной системе
* в кэше роутера

> Установка TCP соединения через систему "трёх рукопожатий":
Браузер отправляет специальный запрос на установку соединения с сервером (SYN-пакет)
Сервер в ответ отправляет запрос с подтверждением получения SYN-пакета — (SYN/ACK-пакет).
    В конце устройство пользователя при получении SYN/ACK-пакета отправляет пакет с подтверждением(ACK-пакет).

> Сервер обрабатывает запрос:
Веб-сервер(nginx или Apache, ...) перенаправляет запрос к программе обработчику (PHP, Ruby, ...), она изучает содержимое запроса и собирает ответ

> Сервер отправляет ответ браузеру
В ответе как правило контент для отображения страницы, способах кэширования, файлы cookie, и тд

> Браузер обрабатывает полученный ответ и «рисует» веб-страницу:
Браузер распаковывает полученный ответ и постепенно начинает рендерить полученный контент, а затем последовательно проверяет все теги и отправляет GET запросы для получения картинок, файлов, скриптов и таблицы стилей
*/

/** TYPES */
/*
> boolean
> integer
> BigInt
> string
> null
> undefined
> object
> Symbol
*/

/** LIFECYCLE HOOKS REACT (OLD SCHOOL) */
/*
> componentWillMount - перед рендерингом, в основном для настройки компонента
> render - процесс рендеринга
> componentDidMount - уведомляет, про то, что компонент соединен с DOM деревом
> componentWillReceiveProps - уведомляет, про то, что приходят новые входящие свойства в компонент
> shouldComponentUpdate - решает, нужно ли делать ре-рендеринг
> componentWillUpdate - уведомляет, что компонент будет обновлен
> componentDidUpdate - уведомляет, что компонент был обновлен
> componentWillUnmount - используется для удаления слушателей и очистки компонента. Вызывается перед удалением компонента
*/

/** TESTS */
/*
> Подходы:
* TDD - Test Driven Development написание тестов, а потом на основании написанных тестов - создание логики;
* BDD - Behavior Driven Development TDD + описание тестировщиком или бизнес аналитоком пользовательских сценариев;
> Типы:
* End-to-End (E2E) - проверяется работа всего приложения или фактически описанные раннее бизнес кейсы;
* Integration Testing - проверка взаимодействия созданного модуля с другими;
* Unit Testing - проверка логики инкапсулированного модуля (или юнита);
*/

/** SOLID */
/*
> SINGLE RESPONSIBILITY PRINCIPLE / Принцип единой ответственности:
объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.
-> уменьшает количество модулей, которые надо изменить при изменении требований;

> OPEN-CLOSED PRINCIPLE / Принцип открытости и закрытости:
модули надо проектировать так, чтобы их нельзя было менять, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.
-> побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
-> делает внесение изменений безопасным и относительно дешёвым.

> LISKOV SUBSTITUTION PRINCIPLE / Принцип разделения интерфейса:
классы-наследники не должны противоречить базовому классу. Например, они не могут предоставлять интерфейс ýже базового.
Поведение наследников должно быть ожидаемым для функций, которые используют базовый класс.

-> вводит ограничения и правила наследования объектов, чтобы их потомки не противоречили базовому поведению;
-> помогает избегать дублирования, выделять общую для нескольких модулей функциональность в общий интерфейс;

> INTERFACE SEGREGATION PRINCIPLE / Принцип разделения интерфейса:
помогает проектировать интерфейсы так, чтобы изменения затрагивали только те модули, на функциональность которых они действительно влияют.
Чаще всего это заставляет интерфейсы дробить (разделять).

-> помогает бороться с наследованием или реализацией ненужной функциональности;
-> даёт возможность спроектировать модули так, чтобы их затрагивали изменения только тех интерфейсов, которые они действительно реализуют;
-> снижает сцепление модулей;

> DEPENDENCY INVERSION PRINCIPLE / Принцип инверсии зависимостей:
Низкоуровневые содержат утилитарную функциональность: обращение к БД, запросы к серверу, рендеринг DOM-элементов на странице.

Высокоуровневые содержат сложную, более абстрактную бизнес-логику.
Они достаточно абстрактны, чтобы их можно было переиспользовать в разных проектах: авторизация пользователей, валидация форм, отправка уведомлений.

Высокоуровневые модули не должны зависеть от низкоуровневых; оба типа должны зависеть от абстракций.
 Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

-> вводит правила и ограничения для зависимости одних модулей от других;
-> снижает сцепление (степень взаимозависимости разных модулей) модулей;
*/


