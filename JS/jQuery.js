<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> // подключение через Google

jQuery(); // единственная глобальная функция <-> $()

$(); // может встречаться в других фреймворках JS. Поэтому:
$j = jQuery.noConflict();// удалить псевдоним '$' из глобального пространства имен. Чтобы код с $ необходимо его передать вначале: jQuery(function( $ ) {...});
$j( 'p' ).css({ 'font-size': '5px' });

jQuery( '.main_items' ); // селектор по классу
jQuery( '#head' ); // селектор по id
jQuery( 'p', '.nav' ); // 2-й параметр - селектор родителя
jQuery( 'p' ); // селектор по тегу

jQuery(document.ready(function() { // <-> jQuery(function( $ ) {...}); - наиболее часто используется. ready() - событие - документ полностью загружен 
	alert( 'Страница загружена' );
})); 

var h5 = jQuery( '<h5>Hello!</h5>' ); // возвращает объект с HTML разметкой для послед. работы. !Функция не добавляет разметку и не добавляется на страницу
alert( h5 ); // => object Object

$( 'p', '.nav' ).append( h5 ); // append() -  добавляет контент внутрь выбранных элементов в конец, после имеющихся


////////////////////// Базовые селекторы  ////////////////////// 

$( "*" ); // Все элементы
$( '*' ).css({ 'border':'2px solid black' }); // css() - метод для задания стилей для элемента
$( '*', '.main_nav' ).css({ 'border':'2px solid black' }); // задать рамку для всех дочерних элементов .main_nav

$( '.class' ); // элементы с классом class
$( '.main_nav.clearfix' ); // элементы с несколькими классами
$( '.main_nav .item' ); // элементы .item вложенные в .main_nav
$( '#id' ); // элемент с индентификатором id
$( 'span' ); // элементы с заданным именем тега
$( '.main_nav, .footer, span' );  // выбор множества


////////////////////// Селекторы иерархии  ////////////////////// 

$( '.container > .row' ); // элементы row, которые являются непосредственными потомками элементов container

$( '.parent + .next' ); // элемент next, который следует непосредственно за элементом parent (один уровень вложенности)

$( '.parent ~ .next' ); // элементы next, которые следуют за элементами из parent (один уровень вложенности)

var obj = $( 'div.grid_12 ~ div' );
alert( obj[0] ); // Объект JS - 1 элемент выборки  => HTMLDivElement
for (v in obj) {
	document.write( 'string' + v + ' - <strong>' + obj[v] + '</strong><br>' ); // в свойствах объекта есть методы JQuery
}
// <->
for (var i = 0; i < obj.length; i++) {
	test.get(i).style.color = "red"; 
}



////////////////////// Селекторы по атрибутам  ////////////////////// 

$( '[name]' ); // элементы содержащие атрибут name
$( '[src]' ); 
$( '[class]' );
$('img["alt"]');

$( '[name = value]' ); // элементы, у которых значение атрибута name совпадает с value

$( '[name != value]' ); // элементы, у которых значение атрибута name не совпадает с value

$( '[name ^= value]' ); // элементы, у которых значение атрибута name начинается с value

$( '[class $= value]' ); // элементы, у которых значение атрибута class заканчивается на value

$( '[name *= value]' ); // элементы, у которых значение атрибута name содержит подстроку value

$( '[name ~= value]' ); // элементы, у которых значение атрибута name содержит слово(т.е отделено пробелом) value

$( '[name |= value]' ); // элементы, у которых значение атрибута name имеют префикс value (равен value или имеет вид value-*)
$( '[class|=full]' ); // => '.full...' или '.full-...'

$( '[class|=full], [name], [data-type="submit hello"]' ); // элементы, соответсвующие всем заданным условиям на атрибуты одновременно. Если 1 слово ковычки можно не ставить, т.е data-type=submit


////////////////////// Селекторы по фильтру  ////////////////////// 

$( 'input[name=name]' ).focus(); // сфокусировать на поле input[name=name]

":focus" // элемент, находящийся в фокусе

":first" // первый найденный элемент <-> .eq(0)
$( 'input:first' );

":last" // последний найденный элемент <->

":eq()" // элемент под заданным номером. Индексация с 0. Если < 0, отсчет с конца

":not(selector)" // все найденные элементы, кроме указанных в selector
$( 'input:not(input:eq(2))' );

":even" // элементы с четными номерами позиций

":odd" // элементы с нечетными номерами позиций

":gt(n)" // элементы c индексом > n

":lt(n)" // элементы c индексом < n

":header" // элементы, явл. заголовками

":hidden" // невидимые элементы
$( 'input:hidden' ).attr( 'type', 'text' ); // задание атрибутов

":visible" // видимые элементы

":lang(language)" // элементы, в которых указаны языки содержимого

$( ":root" ) // корневой элемент документа - <html>


////////////////////// Фильтры дочерних элементов  ////////////////////// 

//!!! nth - индексация начинается с 1

":first-child" // первые дочерние элементы
$( 'p:first-child' );

":last-child" // последние дочерние элементы

":nth-child()" // элементы с определенным порядком
$( 'p:nth-child(even)' ); // четные дочерние элементы
$( 'p:nth-child(2n+1)' ); // 1,3,5,..

":nth-child-last()" // (четные/нечетные под опред. индексом)

":only-child" // единственные по типу потомки в родительских категориях

":only-of-type" // единственные потомки, заданного селектора

":first-of-type" // первые потомки заданного селектора
$( 'p:first-of-type' );

":last-of-type" // последние потомки заданного селектора

":nth-first-of-type" // дочерние элементы заданного селектора
$( 'p:nth-of-type(1)' ); // один элемент этого типа

":nth-last-of-type" // c определ. порядком


////////////////////// Фильтры по содержимому  ////////////////////// 

":contains(text)" // элементы с заданным текстом
$( 'span:contains("hello" )' );

":empty" // пустые элементы

":has(selector)" // элементы, которые содержат элемент из selector
$( "div:has(i, span)" );

":parent" // непустые элементы



////////////////////// Фильтры элементов форм  ////////////////////// 

":button" // элементы с тегом button или типом button 
":radio" // радио-кнопки
":checkbox" // элементы чек-боксы(checkbox)
":text" // текстовые поля
":password" // поля ввода пароля
":file" // поля загрузки файлов
":submit" // кнопки отправки формы
":reset" // кнопки очистки формы
":image" // изображения для отправки формы
":input" // элементы формы (input, textarea или button)
":selected" // выбранные элементы со статусом selected
":focus" // элементы находящиеся в фокусе
":checked" // выбранные элементы (со статусом checked)
":enabled" // активные элементы формы (со статусом enabled)
":disabled" // активные элементы формы (со статусом disabled)


////////////////////// Работа со стилями и атрибутами ////////////////////// 

attr() // возвращает/изменяет значение атрибута
removeAttr() // удаляет атрибут у выбранных элементов 

addClass() // добавляет класс к выбранным элементам на странице
removeClass() // удаляет класс(ы) у элементов на странице

toggleClass() // изменяет наличие класса(ов) у элементов на противоположное
img.toggleClass( 'redClass', true ); // при true - только добавление, без удаления
img.toggleClass(function(  index, className ) { // работа с коллекцией элементов
	if ( className == 'redClass' ) {
		return 'greenClass';
	} else if ( className == 'redClass greenClass' ) { // функция удалит оба класса
		return '';
	}
	return 'redClass';
});

hasClass( 'foo' ) // проверяет наличие заданного класса хотя бы у одного из выбранных элементов

val() // возвращает/изменяет значение атрибута value

$( 'input' ).val(function( ind,v ) { // => в атрибут val будет записан порядковый номер элемента 
	return ind;
}); 



<button onClick='func();'>
jQuery(function( $ ) {
	function func() {
		var img = $( '.img_container > img' );
		
		if ( img.attr( 'src' ) == 'images/1.jpg' ) { // => возвращает содержимое атрибута 'src'
			//img.attr( 'src', 'images/car.jpg' ); // меняем значение атрибута 'src' 		
			img.attr( 'src', function( ind,v ) { // ind - порядковый номер эл-та в выборке. Код функции будет выполнен для каждого эл-та в отбельности
				return 'images/car.jpg';
			});
		} else {
			img.attr( 'src', 'images/1.jpg' ); // меняем значение атрибута 'src'
		}
		img.toggleClass( 'redClass greenClass' ); // передача нескольких классов
	}	
});




////////////////////// Работа с параметрами и стилями ////////////////////// 

css(); // Возвращает/изменяет CSS параметры
$( 'img' ).css( 'width', 100);
$( 'img' ).css({ // с помощью литерал объекта
	'width': 100,
	'height': 50,
	'marginBottom': 10
}); 

$( 'img' ).css( 'width' ); // => 100px
$( 'input' ).css( 'borderWidth', function( ind, v ) {
	return ind * 2;
});

height(); // возвращает/изменяет высоту элемента без учета внутр. и внешн. отступа. Работает только с первым элементом в выборке
$( 'img' ).height( 300 );

innerHeight(); // высота элемента вместе с учетом внутреннего оступа.

outerHeight(); // высота элемента вместе с учетом внутреннего оступа и толщины рамки
outerHeight( true ); // -//- если true + внешний отступ

width(); // возвращает/изменяет ширину элемента без учета внутр. и внешн. отступа. Работает только с первым элементом в выборке

innerWidth(); // ширина элемента вместе с учетом внутреннего оступа.

outerWidth(); // ширина элемента вместе с учетом внутреннего оступа и толщины рамки
outerWidth(true); // -//- если true + внешний отступ

position(); // возвращает/изменяет позицию элемента относительно ближайшего родителя, у которого задан тип позиционирования (relative/absolute/fixed)

.offset(); // возвращает кооридинаты выбранного элемента относительно начала страницы
$( 'img' ).offset().left; // позиция от левого края страницы
$( 'img' ).offset().top; // позиция от верхнего края страницы
$( 'img' ).offset({ left:200, top:50 }); // изменение позиционирования элемента

scrollTop(); // возвращает/изменяет величину вертикального скролла
scrollLeft() // возвращает/изменяет величину горизонтального скролла
$( document ).scrollTop( 1000 ); // document - текущая html страница. Перемещает горизонтальную полосу прокрутки


////////////////////// Добавление содержимого ////////////////////// 

.html() // возвращает/изменяет html-содержимое элементов на странице
.text() // возвращает/изменяет текст, находящийся в элементах на странице
	
.append()  // добавляет заданное содержимое в конец элементов на странице
.appendTo() 
$( selector ).append( content )
$( content ).appendTo( selector )

.prepend() // добавляет заданное содержимое в начало элементов на странице
.prependTo()
$( selector ).prepend( content )
$( content ).prependTo( selector )

.after() // добавляет заданное содержимое после элемента на странице
.insertAfter()
$( selector ).after( content )
$( content ).insertAfter( selector )

.before() // добавляет заданное содержимое перед элементом на странице
.insertBefore()
$( selector ).before( content )
$( content ).insertBefore( selector )

.wrap() // окружает элементы на странице заданными html-элементами. Оборачивает каждый элемент выборки
$( ".inner" ).wrap(function() {
  return "<div class='" + $( this ).text() + "'></div>";
});

.wrapInner(); // обертывает содержимое выбранных элементов заданными html-элементами. Таким образом получается, что все выбранные объекты "обертываются изнутри".

.wrapAll() // оборачивает все элементы
$( ".inner" ).wrapAll( "<div class='new'></div>" );

unwrap() // удаляет родительские элементы, при этом их содержимое остается на месте

jQuery(function( $ ) {
	var html = $( 'section_main' ).html(); //	возвращает html содержимое элемента(ов)
	var html = $( 'section_main' ).html( '<p>SSSS</p>' ); // меняем содержимое элемента(ов)
	var html = $( 'section_main' ).html(function( ind, oldVal ) { // ind - индекс эл-та, oldVal - тек. содержимое элементами
		if ( ind % 2 == 0 ) {
			return oldVal.toUpperCase();
		}
	}); 


	var text = $( 'section_main' ).text(); //	возвращает текстовое содержимое элемента(ов)
	var text = $( 'section_main' ).text( text + 'SSSS' ); // заменяет текстовое содержимое элемента(ов) на: текущее + 'SSSS'

	var form = $( '#contact-form fieldset label:first-child' ).clone(); // clone() - копирование текущего элемента
	var count = $( '#contact-form fieldset label' ).size(); // size() - возвращает кол-во элементов в выборке

	form.find( 'span' ).text( 'Field - ' + (count + 1)); //  find() - поиск потомков внутри каждого элемента в текущей выборке с фильтрацией по селектору, объекту jQuery или элементу.
	form.find( 'input' ).attr( 'name', 'field' + (count + 1));
	
	$( '#contact-form fieldset' ).append( form );
	// <->
	form.append( '#contact-form fieldset' );


	$( '.sf-menu' ).append(function( ind,oldVal ) {
		if ( ind % 2 == 0 ) {
			return oldVal.toUpperCase();
		}
	});

	$( '.sf-menu li' ).wrap( '<div class='new'></div>' );
});


////////////////////// Удаление содержимого ////////////////////// 

detach() // удаляет элементы на странице
remove() // удаляет элементы на странице

$( '.sf-menu li' ).remove(); // удаляем все li в .sf-menu
$( '.sf-menu li' ).remove( '.current' );  // удаляем все li c классом .current в .sf-menu

var p = $( '.label.massage' ).remove(); // сохраняем удаленный элемент. записи о привязанных обработчиках событий этого эл-та удаляются. ! С detach() остаются
$( '#content-form fieldset' ).append( p );

empty(); // удаляет содержимое элементов на странице
$( '.sf-menu li' ).empty(); 


////////////////////// Методы анимационных эффектов ////////////////////// 

.hide(); // скрывает/показывает (display: none) элементы на странице за счет плавного изменения его размера и прозрачности
.show(); 

.toggle(); // показывает или скрывает выбранные элементы

.slideUp(); // разворачивает/сворачивает элементы на 
.slideDown(); // странице за счет плавного изменения высоты элементов
.slideToggle(); // поочередно разворачивает/сворачивает элементы на странице
.slideToggle(900);

.fadeIn(); // скрывает/показывает (opacity: 0) элементы на странице 
.fadeOut(); // за счет плавного изменения прозрачности

.fadeTo(); // плавно изменяет прозрачность элементов.
.fadeTo( 1000, 0.5 ); // продолжительность анимации (1с.) / задание прозрачности
.fadeToggle(); // поочередно скрывает/показывает элементы на странице

.animate(); // выполняет анимацию, созданную пользователем

.queque(); // представляет/изменяет очередь функций
.clearQueue(); // очищает очередь функций
.dequeue(); // начинает выполнение след. функции в очереди

.stop(); // останавливает выполнение текущей анимации

.delay(); // приостанавливает выполнение след. анимаций на заданное время

var animTime = 900;
var modal = $( '#modalDiv' );
var oldDiv = null;

$(function() {
	if ( oldDiv ) {
		oldDiv.css('opacity', 1);
	}
	$('.someDiv').on('click', function( e ) {
		var jthis = $(this);
		modal.css({
			'top': jthis.offset().top,
			'left': jthis.offset().left,
			'width': jthis.width(),
			'height': jthis.height(),
			'color': jthis.css('background-color'),
			'opacity': 1,
			'display': 'block'
		});
		jthis.css('opacity': 0);
		
		n = 0; // шаги
		
		modal
			.animate({ 'height', 400, 'width', 400 }, {
				duration: 1000,
				queque: false, // выполнение сразу без очереди
				specialEasing: {
					height: 'linear', 
					width: 'swing' // начало - разгон, под конец торможение
				},
				complete: function() { // функция запускается после завершения анимации
					console.log('Animation Complete!');
				}, 
				step: function() { // функция запускается после каждого шага анимации
					console.log(n++); // => 99 
					if (n == 100) { modal.stop(); } // остановить текущии анимации
				}
			})
			.animate({ 'top': (window.innerHeight - 400) / 2,
						  'left': (window.innerWidth - 400) / 2 
						}, 1000 );
		
//		modal.css( 'top', (window.innerHeight - modal.height()) / 2 ); // выравнивание модального окна по горизонтали
//		modal.css( 'left', (window.innerWidth - modal.width()) / 2 ); // выравнивание модального окна по вертикали
//		modal.css( 'background-color', $( e.target ).css( 'background-color' )); // e.target - элемент, по которому совершен клик
//		modal.fadeIn(animTime);
		oldDiv = jthis;
	});
	
	$( '#modalDiv' ).on('click', function() {
		$( this ).fadeOut(animTime);
	});
});
	
jQuery(function( $ ) {		
	function func() {
		var img = $( '.grid_4 img' );
		img.hide();
		img.hide( 1000 ); // скрыть с анимацией в 1с.
		img.hide( 'slow' ); // <-> .hide(600);
		img.hide( 'normal' ); // <-> .hide(400);
		img.hide( 'fast' ); // <-> .hide(200);

		if ( img.css( 'display' ) !== 'none' ) {
			img.hide( 'fast', function() { // ф-я выполняется после заврешения анимац. действий
				var text = $( '<p style="margin:100px" id="mytext">Some T</p>' );
				text.insertAfter($( this )).hide().show( 1000 ); // анимация скрыть-показать. в this - текущий элемент img	
			});
		} else {
			$( '#mytext' ).hide( 500, 'linear', function() { // динамика выполнения анимаций: 'linear' - равномерно, 'swing' - по умолч. с небольшим ускорением. Есть и др. 
				img.show( 1000 ); 
				$( this ).remove();
			});	
	}

	--

	img.hide({ 
		duration: 1000, // время выполнения анимац. действий. Принимает в параметры и строковые значения, например 'fast'
		easing: 'linear', // динамика выполнения анимаций
		complite: function() { // ф-я после выполнения всех анимац. действий

		}

		queque: false // принадлежность данного метода к определенной очереди. false - мгновенно выполняется, не попадая в очередь. Имя очереди, например 'move' - присваивается к очереди под этим именем, по умолч. присвается к очереди 'fx'.
	});

	--

	img.fadeTo( 100, 0.5 ); // изменение прозрачности. 2-й параметр прозрачность - [0,1]

	--

	// Слайдер:
	var slidWrap = $( '.slide-wrap' );
	var slideWidth = $( '.slide-item' ).outerWidth(); // ширина элемента вместе с учетом внутреннего оступа и толщины рамки
	var scrollSlider = sliderWrap.position().left - slideWidth; // на сколько необходимо сместить пред. изображение, чтобы показать след.

	function sl() {
		slidWrap.animate({ // плавно применяет указанные css правила
			'left': scrollSlider
		}, 1000, 'linear', function() {
			slidWrap.find( '.slide-item:first' )
					.appendTo( slideWrap ); // перемещаем изображение в конец слайдера
					.parent().css({ 'left': 0 }) // возвращаемся к его родителю и убираем отступ
		}); 
	}

	setInterval( sl, 2000 );

	--

	$( '.grid_12 h2' )
		.hide( 1000 )
		.fadeIn( 500 )
		.delay( 3000 ) // задержка между выполнениями анимац. эффектов
		.text( 'Some Text' ) // ! не аним. эффекты применяются сразу (*)
		.queque(function() { // позволяет добавить опред. функцию в очередь. 1-й параметр имя очереди, по умолчанию 'fx'
			$( this ).text( 'Some Text' ); // примениться по порядку (*)
			$( this ).dequeue(); // запускает на исполнение след. в очереди элемент
		}) 
		.animate({ 'fontSize': '100px' })
		.slideUp(300)
		.show(200);

	--

	$( 'grid_12 h2' ) // Все пользовательские очереди необходимо запускать вручную
		.queque( 'myque', function() {
			$( this ).animate({ 'fonSize': '100px' });
			$( this ).dequeue( 'myque' ); // запускает на исполнение след. в очереди элемент
		});	
		.delay( 1000, 'myque' ) // имя очереди для которой пауза
		.queque( 'myque', function() {
			$( this ).text( 'ZZZZZZZZZZZZ' );
			$( this ).dequeue( 'myque' ); // запускает на исполнение след. в очереди элемент
		});
		.queque( 'myque', function() {
			$( this ).hide(700).show(700);
			$( this ).dequeue( 'myque' ); // запускает на исполнение след. в очереди элемент
		});

};



////////////////////// События мыши ////////////////////// 

.click() // устанавливает обработчик `клика` мышью по элементу, либо, запускает это событие
.dbclick() // устанавливает обработчик двойного `клика` по элементу, либо, запускает это событие

.hover() // устанавливает обработчик двух событий: появления/исчезновения курсора над элементом

.mousedown() // устанавливает обработчик нажатия кнопки мыши, либо, запускает это событие
.mouseup() // устанавливает обработчик поднятия кнопки мыши, либо, запускает это событие

.mouseenter() // устанавливает обработчик появления курсора в области элемента, либо, запускает это событие. Появление этого события, отработано лучше, чем стандратного mouseover. Не обладает св-вом `всплытия`
.mouseleave() // устанавливает обработчик выхода курсора из области элемента, либо, запускает это событие. Появление этого события, отработано лучше, чем стандратного mouseout. Не имеет обладает св-вом `всплытия`

.mousemove() // устанавливает обработчик движения курсора в области элемента, либо, запускает это событие

.mouseover() // устанавливает обработчик появления курсора в области элемента, либо, запускает это событие. Обладает св-вом `всплытия`
.mouseout() // устанавливает обработчик выхода курсора из области элемента, либо, запускает это событие. Обладает св-вом `всплытия`

.toggle() // ! Устарел. поочередно выполняет одну из двух или более заданных функций, в ответ на `клик` по элементу. 

$(function() { // <-> jQuery(function( $ ) {
	$( '.sf-menu li:has("ul" )' ).mouseenter({ a:'hello',b:'world' }, function( event ) { // в {} можно передать необ. параметры. event - объект event object - текущее событие
		alert(event.data.a); // => hello
		$( '.sf-menu li ul' ).stop().fadeIn( 300 ); // при наведении показывается список. stop() - для отмены пред. запущенных анимаций (для корректного показа тек. анимации).
	});

	$( '.sf-menu li:has("ul" )' ).mouseleave(function() {
		$( '.sf-menu li ul' ).stop().fadeOut( 300 ); // при наведении скрывается список. stop() - для отмены пред. запущенных анимаций (для корректного показа тек. анимации).
	});

	// <->

	$( '.sf-menu li:has("ul" )' ).hover(
		function() {
			$( '.sf-menu li ul' ).stop().fadeIn( 300 );	
		},
		function() {
			$( '.sf-menu li ul' ).stop().fadeOut( 300 );
		}
	);

	// <->

	$( '.sf-menu li:has("ul" )' ).hover(
		function() { // функция для обработки 2-х событий
			$( '.sf-menu li ul' ).stop().fadeToggle( 300 );	// поочередно скрывает/показывает элементы на странице
		}
	);

	--

	$( 'header h2' ).mousemove(function( event ) {
		$( 'grid_7' ).text( event.pageX + '|' + event.pageY ); // .pageX - координата курсора по оси X, pageY - по оси Y
	});

	-- 

	$( '.sf-menu li ul li' ).click(function( event ) {
		event.preventDefault(); // отменяем стандартное поведение
		$( 'header h2' ).append( 'Click' );
		$( this ).parent().fadeOut( 300 ); // $( this ) - объект, на котором сработало событие
	});
});


////////////////////// События клавиатуры //////////////////////

.keydown() // устанавливает обработчик перехода клавиши клавиатуры в нажатое состояние, либо, запускает это событие
.keyup() // устанавливает обработчик возвращение клавиши клавиатуры в ненажатое состояние, либо, запускает это событие
.keypress() // устанавливает обработчик ввода символа с клавиатуры, либо, запускает это событие

$( 'input[name=name]' ).keydown(function( event ) {
	alert(event.which); // .which - свойство код нажатой клавиши => 75
});

$( 'input[name=name]' ).keyup(function( event ) {
	alert(event.which); // .which - код символа => 1040
	var email = $( 'input[<name></name>=email]' );
	email.val($( this ).val()); // вводимые символы дублируются в другую область
});


////////////////////// События формы //////////////////////

.focus() // устанавливает обработчик получения фокуса, либо, запускает это событие. Событие не `всплывает`
.blur() // устанавливает обработчик потери фокуса, либо, запускает это событие. Событие не `всплывает`
.focusin() // устанавливает обработчик получения фокуса самим элементом или одним из его дочерних. Событие `всплывает`
.focusout() // устанавливает обработчик потери фокуса самим элементом или одним из его дочерних. Событие `всплывает`
.select() // устанавливает обработчик выделения текста, либо, запускает это событие
.submit() // устанавливает обработчик отправки формы, либо, запускает это событие
.change() // устанавливает обработчик изменения элемента формы, либо, запускает это событие. Сработает когда элемент потеряет фокус

$( 'input[name=name]' ).focus({}, function() { // фокус на элементе
	$( this ).val( 'Введите текст' );
});

$( 'input[name=name]' ).blur({}, function() { // потеря фокуса
	alert( 'Закончили?' );
});

$( 'input[name=name]' ).select(function() {
	alert( 'Выбран элемент' );
});

$( '.form' ).submit(function( e ) {
	e.preventDefault(); // форма не будет отправляться
	alert( $( 'input[name=name]' ).val() );
});


////////////////////// События загрузки страницы  ////////////////////// 

.ready() // устанавливает обработчик готовности дерева DOM
.load() // устанавливает обработчик завершения загрузки элемента
.unload() // устанавливает обработчик ухода со страницы (при переходе по ссылке, закрытии браузера и т.д.)

jQuery(document.ready(function() {})); // <-> jQuery(function( $ ) {...}); <-> $(function() {...});
$( 'h2' ).load(function() {});
$( window ).unload(function() {}); // метод - не кроссбраузерный


////////////////////// События браузера  ////////////////////// 

.error() // устанавливает обработчик ошибки при загрузке элементов(например, отстутствие необходимой картинки на сервере)
.resize() // устанавливает обработчик изменения размеров окна браузера, либо, запускает это событие
.scroll() // устанавливает обработчик `прокрутки` элементов документа, либо, запускает это событие

$( 'img' ).error(function() {});
$(window).resize(function() {}); // в () функция-обработчик

$(function(){  
	// один обработчик на 2 события:
	$( window ).on("resize scroll", {user: 'Max Min'}, function( e ) { // ! лучше везде использовать on. Если заменить .on на .one - события обработаются 1 раз.
		$( '#resize-text' ).text( "Width: " + window.innerWidth + ", Height: " + window.innerHeight );
		$( '#scroll-text' ).text( "Position Y: " + window.scrollY ;
	});

	// обработчики отдельно:
	$( window ).on({
		resize: function() {
			$( '#resize-text' ).text("Width: " + window.innerWidth + ", Height: " + window.innerHeight);	
		},
		scroll: function(e) { // ! e - необходимо указать для .data
			$( '#scroll-text' ).text("Position Y: " + window.scrollY);
			console.log(e.data.user);
		}
	}, {user: 'Max Min'}); // данные для передачи в функцию-обработчик
});

/*
<div id='scroll' style='left: 90%; top: 90%; opacity: 0.6; width: 100px; height: 30px; background-color: gray; display: none'>UP</div>
*/

$(function() {
	$( window ).scroll(function() { // функция поднимает скролл вверх, при клике на появл. элемент
		if ( $( this ).scrollTop() > 500 ) { // .scrollTop() - на сколько px передвинули скролл
			$( '#scroll' ).fadeIn( 500 ); // показываем скрытый элемент
		}
	});
	
	$( '#scroll' ).click(function() {
		$( window ).scrollTop( 0 ); // поднимаем вверх скролл
	});
};

--

$( '.sf-menu li' ).click(function( e ) { 
	e.preventDefault(); // отмена стандратного поведения элемента
	$( 'sf-menu' ).append( '<li><a href="index-2.php">Item2</a></li>' ); // при клике на исходные ссылки меню добавляется новый элемент меню. !Но при клике на новые элементы меню событие клик не срабатывает (*).
});

// (*) метод on поддерживает делегированную обработку событий. Событие вешается на родителя элемента:

$( '.sf-menu' ).on( 'click','li', function( e ) { // обработчики для нескольких событий, указываются через ' '. 'li' - селектор
	e.preventDefault(); // отмена стандартного поведения элемента
	$( 'sf-menu' ).append( '<li><a href="index-2.php">Item2</a></li>' );
}); // !При клике на новые элементы меню, событие клик срабатывает (*).

$( '.sf-menu' ).off(); // удаляем ранее зарегистрированный(е) обработчик(и)
$( '.sf-menu' ).off('resize'); // удаляем определенный обработчик	

--

$( '.sf-menu' ).on( 'click.my','li', function() {}); // .my - указываем пространство имен

--

$( '.sf-menu' ).bind( 'click', { }, function() {}); // аналог .on(). Не поддерживает делегированную обработку событий. УСТАРЕЛ (с вер.1.7) И УДАЛЕН (с вер. 1.9)!
$( '.sf-menu li' ).inbind(); // удаление обработчиков событий зарегистрированных с помощью спец. методов(.click() и т.д.) и .bind(), .one()

--

$( '.sf-menu' ).live(); // устанавливает обработчик событий для выбранного элемента. Поддерживает делегированную обработку событий. УСТАРЕЛ (с вер.1.7) И УДАЛЕН (с вер. 1.9)!
$( '.sf-menu' ).die(); // удаление обработчиков событий зарегистрированных с помощью live()

--

$( '.sf-menu' ).delegate( 'li', 'click', {}, function() {}); // метод - делегированная обработка событий. УСТАРЕЛ!
$( '.sf-menu' ).undelegate(); // удаление обработчиков событий зарегистрированных с помощью delegate()

-- 

$( '.sf-menu li' ).one( 'click', function() {}); // событие обработается только 1 раз для 1 элемента

--

$( '.sf-menu li' ).trigger( 'click' ); // вызывает событие у выбранных элементов, что приводит к запуску обработчиков этого события

$( '.sf-menu li' ).on( 'myEvent', function() {}); // регистрация пользовательского события
$( '.sf-menu li' ).trigger( 'myEvent' ); // инициализация пользовательского события
//или можно так:
$( '.sf-menu li' ).click(function() {
	$( this ).trigger( 'myEvent' );
});
$( '.sf-menu li' ).triggerHandler( 'click' ); // позволяет выполнить код функции-обработчика конкретного события без инициализации данного события


////////////////////// Методы работы с набором выбранных элементов ////////////////////// 

.children() // находит все дочерние элементы у выбранных элементов. При необходимости, можно указать селектор для фильтрации
.closest() // находит ближайший, соответсвующий заданному селектору элемент, из числа следующих: сам выбранный элемент, его родитель, его  прародитель, и т.д. до начала дерева DOM
.find() // находит элементы по заданному селектору, внутри выбранных элементов
.next() // находит элементы, которые лежат непосредственно после каждого из выбранных элементов
.nextAll() // находит все элементы, которые лежат после каждого из выбранных элементов 
.nextUntil() // находит элементы, которые лежат каждого из выбранных, но не дальше элемента, удолетв. заданному селектору
.prev() // находит элементы, которые лежат непосредственно до каждого из выбранных элементов
.prevAll() // находит все элементы, которые лежат до каждого из выбранных 
.offsetParent() // возвращает ближайшего предка с позиционированием, отличным от static 
.parent() // находит родительские элементы у всех выбранных элементов
.parents() // находит всех предков у выбранных элементов,т.е. не только прямых родителей, но и прародителей, прапрародителей и тд., до начала дерева DOM - тега html
.parentsUntil() // находит предков, как и .parents, но прекращает поиск перед элементом, удолетворяющим заданному селектору(не попадает в выборку).
.siblings() // находит все соседние элементы (под соседними понимаются элементы с общим родителем), при этом сами выбранные элементы в результат не включаются.

$(function() {
	$( 'ul' ).children( '.current' ).css({ 'border':'1px solid red' }); // устанавливаем для li c классом .current рамку
	$( '.el-2' ).closest( 'p' ).css({ 'border':'1px solid red' }); // сам эл-т p.el-2  попадет в выборку 
	$( '.el-2' ).closest( 'div' ).css({'border':'1px solid red'}); // у p.el-2 родитель тег div, он и попадет в выборку

	$( 'ul' ).css({ 'border':'1px solid red'}).find( 'li.current' ).remove(); // задаем стили и удаляем выбранный элемент

	$( 'label.name' ).next().next(); // метод можно использователь несколько раз. в () - можно указать селектор

	$( 'label.name' ).nextUntil( 'label.message' );

	$( 'li.current' ).parents( 'grid_12' ); 
});


////////////////////// Методы фильтрации ////////////////////// 

.eq() // возвращает элемент, идущий под заданным номером в наборе выбранных элементов
.filter() // фильтрует набор выбранных элементов с помощью заданного селектора или функции
.first() // возвращает первый элемент в наборе
.has() //  фильтрует набор выбранных элементов, оставляя те, которые имеют потомков, соотвествующих селектору
.is() //  проверяет, содержится ли в наборе, хотя бы один элемент, удолетворяющий заданному селектору
.last() // возвращает последний элемент в наборе
.not() // возвращает элементы, не соответсвующие заданным условиям
.slice() // возвращает элемнеты с индексами из определенной области (например, от 0 до 5)

$(function() {
	$( '.address' ).eq( 1 ); //  2-й элемент выборки
	$( '.address' ).eq( -1 ); // последний элемент выборки

	$( 'li' ).filter(function( ind, val ) { // код функции будет вызываться для каждого эл-та выборки
		return $( this ).attr( 'class' ) == 'current;'; // true -> данный элемент будет включент в выборку, иначе будет исключен из выборки
		// или
		return ind % 2 == 0; 
	});

	$( 'div' ).has( '.mini-items' ); // выбирает все элементы, которые имеют один или более элемент, содержащийся внутри них. 
}

$( 'span' ).parent().not( 'div, h1' ); // выборка родителей span, всех кроме div,h1
$( 'span' ).parent().not(function( ind ) { 
	return $( this ).is( 'h2' ); // если h2 - элемент будет исключен
// если возвращается true - элемент не попадает в выборку
// если возвращается false - элемент попадает в выборку
});

if ( $( 'section' ).is( '.mini-items' )) {}; // => возвращает булево значение
$( 'section' ).is( $( '.mini-items' ) ); // jQuery выборка

$( 'div' ).slice( 4 ); // выбрать элементы из выборки начиная и включая элемент с индексом 4
$( 'div' ).slice( 4, 8 ); // выбрать элементы из выборки начиная и включая элемент с индексом 4 до 8(не входит)

 
////////////////////// Методы обработки выборки ////////////////////// 

.each() // вызывает заданную функцию для каждого элемента набора
.map() // вызывает заданную функцию для каждого элемента набора, и в итоге создает новый набор из значений, возвращенных этой функцией

// сохраняем ширину картинок в массив:
var widths = [];
$( 'img' ).each(function( ind, elem ) { // elem <-> $( this )
	widths.push($(elem).width()); // push() - добавляет элемент в конец массива
});

var result = $( 'li' ).map(function( ind, elem ) {
	return $(elem).text();
});

result.get(); // get() - конвертация из объекта в массив

$( 'li' ).add( '.address', 'section_main' ); // добавление элементов c классом .address из .section_main в выборку

$( "div" )
	.find( "span" )
	.css( "background-color","yellow" )
	.andSelf()
	.css( "border": "1px solid red" ); // добавляет предыдущий набор jQuery к текущему в пределах одной цепочки команд и возвращает объединенный набор. Теперь объединим текущий объект jQuery с предыдущим и установим красную границу вокруг всех элементов <div> и элементов <span> внутри них.

$( 'grid_7' ).children().each(function() { // текст в div .grid_7 метод children() проигнорирует
	alert( $( this ).text() );
});	
// а здесь нет:
$( 'grid_7' ).contents().each(function() {}); // contents - возвращает все дочерние элементы выбранных элементов, а также текстовое содержимое и комментарии

$( 'li' ).parent().css({'border':'1px solid red'}).end().css({'border':'1px solid black'}); // возвращает предыдущий набор элементов


////////////////////// AJAX /////////////////////////////////////

$( '#ajax' ).ajaxSend(function( e, XHR, obj ) { alert( 'send' ) }); // XHR - чистый XMLHttpRequest. Функция-обработчик вызывается перед отправкой запроса

$( '#ajax' ).ajaxСomplete(function( e, XHR, obj ) { alert( 'complete' ) }); // функция-обработчик вызывается после завершения запроса

$( '#ajax' ).ajaxSuccess(function( e, XHR, obj ) {alert( 'success' )}); // функция-обработчик вызывается после удачного завершения запроса

$( '#ajax' ).ajaxError(function( e, XHR, obj ) {alert( 'error' )}); // функция-обработчик вызывается после неудачного завершения запроса


$( '.btn' ).click(function( e ) {
	e.preventDefault();
	$( '#ajax' ).html( '<span>Отправка</span>' ).fadeIn( 1000, function() { // #ajax - пустой блок div	
		var result = 'name=' + $( 'input[name=name]' ).val() + 'email=' + $( 'input[name=email]' ).val() + 'sibject=' +  $( 'input[name=sibject]' ).val() + 'text=' + $( 'textarea[name=text]' ).val();
		// <->
		var result = $( '#contact-form' ).serializeArray(); /* возвращает массив объектов, содержащий данные элементов формы:
			[
			  { name : "имяПоля1",
				value : "значение1" },
			  { name : "имяПоля2",
				value : "значение2" },
			  ...
			]
		*/	
		$( '#contact-form' ).serialize(); // предназначен для сериализации данных формы в строку запроса: имяПоля1=значение1&имяПоля2=значение2...
		$.param(result); // $.param - преобразует объект/массив/массив объектов в строку, которая соответвует формату передачи данных через URL
		
		$.ajaxSetup { // метод для задания будущих параметров запроса для отправки на сервер
			url: 'server.php',
			type: 'POST',
			dataType: 'json', // в каком формате ожидается получение данных от сервера. Другие варианты: xml/script/html
			context: document.getElementById( 'ajax' ), // содержимое будет записано в this (*)
			beforeSend: function( jqXHR ) { // функция будет вызвана перед отправкой AJAX запроса на сервер. Применяется как правило для модификации заголовков перед отправкой
			},	
			cashe: false, // false - запрет на кеширование осуществляемого запроса на сервер. При GET к запросу добавляется текущая метка времени
			complete: function( jqXHR, status ) { // функция вызывается после завершения AJAX запроса, после функции success или error
				alert(status); // в случае удачного запроса => success, в случае ошибки => error
 			},
			contentType: 'application/x-www-form-urlencoded; charset=UTF-8', // формат данных для отправки на сервер. Другой вариант: текст - 'text/plain'
			headers: { // набор дополнительных заголовков для отправки
				'header':'some text'
			},
			processData: true, // true - все отправляемые на сервер данные преобразовываются в строку
			timeOut: 2000, // время ожидания ответа от сервера. Если указанное время будет превышено, то запрос будет завершен с ошибкой
			success: function( data, status, jqXHR ) { // ф-я выполняется в случае удачного завершения запроса к серверу. 1-й аргумент - ответ от сервера, 2-й - статус запроса, 3-й  - JQuery XMLHttpRequest
				$( this ).find( 'span' ).fadeOut( 300, function() { // (*)
					$( this ).text( 'добавлено' ).fadeIn( 300 );	
				});

				$( this ).delay( 1000 ).fadeOut( 1000, function() { // пауза в 1сек и скрытие элемента
						$( '.grid_5' ).append( '<h3>'+data.name+'</h3>'+'<p>'+data.text+'</p>' );
				}); 
			},
			error: function() {
				
			}
		}
		
		$.ajax({
			data: result
		});
		
		var jqXHR = $.get( 'server.php', result, function( data,status,jqXHR ) {}, 'json' ); /* запрос методом GET. 
			1-й аргумент - путь к скрипту-обработчику,
			2-й аргумент - отправляемые данные, 
			3-й аргумент пользовательская callback-функция, которая будет вызвана после ответа сервера, 
			4-й - тип данных ожидаемых от сервера. 
			data - данные возвращемые сервером, status - статус выполнения запроса. 
			Метод возвращает объект jQuery XMLHttpRequest */
		jqXHR.done(function() {}); // функция-обработчик выполняется в случае успешного выполнения запроса к серверу
		jqXHR.fail(function() {}); // функция-обработчик выполняется в случае ошибочного выполнения запроса к серверу
		jqXHR.always(function() {}); // функция-обработчик выполняется в любом случае
		jqXHR.then( function() {}, function( data ) {} ); // 1 функция-обработчик выполняется в случае успешного выполнения запроса к серверу, 2 - в случае ошибочного
		
		var jqXHR = $.post( 'server.php', result, function( data, status, jqXHR ) {}, 'json' ); // запрос методом POST
		
		var jqXHR = $.getJSON( 'server.php', result, function( data,status,jqXHR ) {} ) // запрос JSON данных у сервера методом GET
		// <->
		$.ajax({
			url: 'server.php',
			dataType: 'json',
			data: result,
			success: function( data, status, jqXHR ) {}	
		});
		
		var jqXHR = $.getScript( 'server.php', function( data,status,jqXHR) {}) // запрос скрипта(например, echo 'alert("HI!" )' ) у сервера методом GET
		
		$( 'grid_5' ).load( 'server.php', result, function( data,status,jqXHR ) {}, 'json' ); // загружает данные с сервера (html) и вставляет в указанный элемент.
	});
});

// Файл: server.php

<?php

$db = new mysqli('localhost', 'root', '', 'jquery');

if ($mysqli->connect_error) {
    die( 'Ошибка подключения (' . $mysqli->connect_errno . ') '
            . $mysqli->connect_error);
}

if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	$data = $_POST;
	$sql = "INSERT INTO `messages` (`name`,`email`,`subject`,`message`) VALUES ( '".$data['name']."', '".$data['email']."', '".$data['subject']."', '".$data['text']."' )";
	$db->query($sql);
	echo json_encode($data);
	exit();
} else {
	echo json_encode($_GET);
	exit();
}


////////////////////// УТИЛИТЫ /////////////////////////////////////

$(function() { 
	var el = document.getElementById( 'stuck_container' ); 
	
	if ( $.contains( document.body, el )) { // проверяет на содержание в 1-ом аргументе 2-го аргумента.
		$(el).css({ 'border':'1px solid red' }); // JS->JQuery элемент
	}
	
	--
	
	var ul = $( '.sf-menu' );
	$.data( ul, 'data', 'Hello World!' ); // метод позволяет хранить данные, привязанные к определенному элементу
	console.log($.data(ul, 'data' )); // => Hello World!
	
	
	var nums = {
		one: 10,
		two: 20
	}
	
	$.data(ul, 'data', nums); 
	$.data(ul, 'data' ).one // => 10;
	$.data(ul, 'data' ).two // => 20;
	
	$.removeData(ul); // удаляет все данные, привязанные к определенному элементу
	$.removeData(ul, data); // удаляет данные по ключу, привязанные к определенному элементу
	
	--
	
	var arr = ['one', 'two', 'three'];
	$.each(arr, function( ind,val) { // метод позволяет описать функцию, которая выполнится для каждого элемента массива/объекта. Возвращает исходный массив/объекта
		console.log(ind + '-' + val);
	});
	
	--
	
	var object1 = {
		one: 10,
		two: 20,
		three: {
			val1: 'Hello',
			val2: 'world',
			val3: '!'	
		}
	};
	
	var object2 = {
		one: 100,
		four: 'string',
		three: {
			val1: 'Ben',
			val2: 'Bob'
		}
	};
	
	var result = $.extend(object1, object2); // метод объединяет содержимое 2-х или более объектов. Возвращает 1-й исходный объект, при результат операции записывается в 1-й переданный объект
	
	JSON.stringify(result); // приведение в строку формата JSON => {'one':100, 'two':20,'three':{'val1':'Ben','val2':'Bob'},'four':'string'}
	
	var result = $.extend(true, object1, object2); // false - по умолч., при true - рекурсивное объединение объектов
		
	--
	
	var newVar = 50; // локальная переменная
	console.log(newVar); // => 50
	$.globalEval( 'newVar="Hello world!; alert(newVar);"' ); // а здесь глобальная => Hello world! Выполняет скрипт в глобальной области видимости
	console.log(newVar); // => 50
	
	
	--
	
	var arr = [1,2,3,4,5,6,7,8,9,10];
	
	function func(el, ind) {
		if ( el == 4 || ind == 2) {
			return false;
		} else {
			return true;
		}
	}
	
	var newArr = $.grap(arr, func); // ищет в заданном массиве элементы, удовлетворяющие условиям фильтрующей функции. Возвращает массив с найденными элементами (в исходный массив изменения не вносятся). => [1,2,5,6,7,8,9,10];
	
	$.grap(arr, func, true); // вернет те ячейки, для которых функция вернула false => [3,4]

	--	

	var arr = [1, 'Bob', 'Ben'];
	$.inArray( 'Bob', arr); // ищет заданный элемент в массиве. Возвращает индекс этого элемента или -1 в случае его отсутствия => 1

	--
	
	$.isArray(arr); // проверяет, является ли заданный элемент массивом => true
	
	--
	
	$.isEmptyObject(arr); // позволяет узнать является ли переданный объект пустым => false
	
	--
	
	$.isFunction(func); // проверяет, является ли заданный элемент функцией => true 
	
	--
	
	$.isNumeric( 'hello' ); // проверяет, является ли заданный элемент числом или может быть к нему приведен => false
	
	--
	
	$.isPlainObject({'one':'hello'}); // проверяет, является ли заданный элемент пользовательским объектом (создан через {} или new Object()) => true
	
	--
	
	$.isWindow(window); // проверяет, является ли заданный элемент объект типом Window => true
	
	--
	
	var obj = $( '.sf-menu li' ).length; // возвращает кол-во элементов в выборке =>  5
	var arr = $.makeArray(obj); // Конвертирует массивоподобные объекты, в массивы => [object HTMLLIElement].[object HTMLLIElement].[object HTMLLIElement].
	arr.reverse(); // обратная сортировка массива
	$(arr).appendTo($( '.sf-menu' )); // выборку добавляем обратно
	
	--
	
	var obj = $( '.sf-menu li' );
	var arr = $.map( obj, function( el, ind ) { // выполняет заданную функцию для каждого элемента массива или каждого поля объекта в отдельности. Значения, полученные в результате выполнения этой функции помещаются в новый массив и возвращаются как результат работы функции. 
		if ( $( el ).hasClass( 'current' ) {
			return el;
		}
	}); // => {li.current}
	
	--
	
	var obj1 = $( 'p' );
	var obj2 = $( 'li' );
	$.merge( obj1, obj2 ); // объединяет содержимое двух массивов. Результат объединения записывается в первый из этих массивов (он же будет возвращен в качестве результата выполнения функции).
	
	--
	
	$( 'a' ).click( $.noop() ); // пустая функция (т. е. которая ничего не делает). Может быть использована в случаях, когда по каким-либо причинам нужно установить пустые функции обратного вызова (callback)
	
	--
	
	var obj = $.parseJSON( '{ "name":"Jorn" }' ); // конвертирует строку с json-данными в javascript-объект.
	obj.name; // => Jorn 
	
	--
	
	var str = '<li><a href="#">Hi!</a></li>';
	var html = $.parseHTML( str ); // преобразует переданную строку с HTML-кодом в массив DOM-узлов самого верхнего уровня. Пробелы в начале и конце строки тоже будут преобразованы в текстовые узлы. Чтобы этого избежать можно воспользоваться функцией $.trim().
	$( '.sf-menu' ).append(html);
	
	--
	
	var obj1 = {
		name: 'user',
		test: function( event) {
			console.log( 'Объект1 - ' + this.name); 
		}
	}
	
	var obj2 = {
		name: 'Ben',
		test: function( event) {
			console.log( 'Объект2 - ' + this.name); // => Объект2 - user
		}
	}
	
	$( '.message' ).on( 'click', $.proxy( obj1, 'test' )); // возвращает функцию с измененным контекстом this => Объект1 - user
	$( '.message' ).on( 'click', $.proxy( obj2, 'test' )); // => Объект2 - Ben
	$( '.message' ).on( 'click', $.proxy( obj2, 'test' )).on( 'click', $.proxy(obj2.text, obj2)).on( 'click', $.proxy(obj2.text, obj1) ); // => 
	/*
	Объект2 - Ben
	Объект2 - Ben
	Объект2 - user
	
	Метод jQuery.proxy() может выполнять празличные действия, в зависимости от количества передаваемых аргументов:

	jQuery.proxy( function, context )
	jQuery.proxy( context, name )
	jQuery.proxy( function, context, additionalArguments )
	jQuery.proxy( context, name, additionalArguments )
	где

	function - функция, контекст которой должен быть изменен.
	context - объект, на который должен указывать контекст ( this ).
	name - строка, имя метода чей контекст должен быть изменён (должен быть свойством объекта контекста).
	additionalArguments - любое число аргументов, для передачи в качестве аргументов функции.
	*/
	
	// обработка события при клике выполниться только 1 раз
	var obj1 = {
		name: 'user',
		test: function( event ) {
			console.log( 'Объект1 - ' + this.name ); 
			$( '.message' ).off( 'click', this.test); // удаляем ранее зарегистрированный обработчик
		}
	}
	
	$( '.message' ).on( 'click', $.proxy( obj1, 'test' ));
	
	--
	
	$.trim( '     Hello World       ' ); // удаляет символы пробелов, табов и переносов строк из начала и конца строки => Hello World
	
	--
	
	$.now(); // <-> new Date().gateTime() возвращает количество миллисекунд с начала эпохи UNIX => 1476999670122
	
	--
	
	$.type({}); // возвращает тип данных => object
	
	--
	
	$( '.btn' ).click(function( e) {
		e.preventDefault();
		var myCall = $.CallBacks(); // накопитель будущего функционала - организовывает наборы функций обратного вызова /****/
		myCall = $.CallBacks( 'once' ); // объект вызывает на исполнение функции, привязанные к нему только 1 раз
		myCall = $.CallBacks( 'memory' ); // объект callbacks будет запоминать все совершенные вызовы. При добавлении в callbacks новых функций, они будут тотчас выполняться в контексте запомненных ранее вызовов
		myCall = $.CallBacks( 'unique' );	// одну и ту же функцию нельзя будет включать в один callbacks более одного раза.
		myCall = $.CallBacks( 'stopOnFalse' ); // если один из функций-участников callbacks вернет false, то оставшиеся функции вызваны не будут
		// можно указывать несколько флагов через ' '
		
		$( '#ajax' ).html( '<span>Отправка</span>' ).fadeIn( 1000, function() { // #ajax - пустой блок div
				
			// ...
			
			success: function( data, status, jqXHR)  { // ф-я выполняется в случае удачного завершения запроса к серверу. 1-й аргумент - ответ от сервера, 2-й - статус запроса, 3-й  - JQuery XMLHttpRequest	
				if ( data.action ) { 
					myCall.add( fAction ); // метод add добавляет определенную функцию в данный объект
				}
				
				if ( $( '#check' ).prop( 'checked' )) { 
					myCall.add(fAlert);
				}
				
				var quest = window.confirm( 'Активировать?' ); 
				
				if ( confirm) {
					myCall.add(fQuest);
				}
				
				myCall.fire(); // вызываем добаленные функции
				myCall.fire(10); // вызываем добаленные функции с подстановкой переданного аргумента во все функции
				
				myCall.empty(); // удалялет все привязанные функции
				myCall.remove(fAction); // удаляет заданную функцию из объекта
			}
		
			function fAction(val1) {
				alert( 'Функция1 - ' + val1);
			}
			
			function fAlert(val1) {
				alert( 'Функция2 - ' + val1);
			}
			
			function fQuest(val1) {
				alert( 'Функция3 - ' + val1);
			}
});

// В server.php прописываем условие:

if ( $data['name'] == 'Ben' ) { 
	$data['action'] = true;
}

setTimeout("$( 'p.test' ),get(0).style.color = 'green'", 2000); // через 2 секунды изменить цвет.
		
		
$('<p>Test</p> 123 >'); // > - для сохранения текста после тега p
$('<img', { // атрибуты:
	src: 'img/1.jpg', 
	alt: 'logo',
	title: 'logo',
	click: function( e ) { // функция-обработчик для создаваемого элемента
		$( this ).toggleClass( 'selectedImg' );
	}
	// <-> 
	on: {
		click: function(e) {
			$( this ).toggleClass( 'selectedImg' );
		}
	}	
})
.css({
	'padding': '10px',
	'border': '1px solid black'
})
.appendTo('body');
		
		
////////////////////// Plugins /////////////////////////////////////
		
// Folder: jquery.npoll:
// File: jquery.npoll.js (самописный плагин)
;(function($) { // создаем замыкание, в которое помещаем код плагина
	var defaults = {
		question: 'Какая Ваша любимая JS библиотека?',
		url: '', 
		buttonText: 'Ответить!',
		categories: ['jQuery', 'YUI', 'Dojo'],
		containerClass: 'npoll',
		formClass: 'npoll-form',
		buttonClass: 'npoll-submit'
	};
	
	function Npoll(element, options) {
		this.config = $.extend({}, defaults, options); // расширяет исходный объект, дополняя его свойствами объектов источников
		this.element = element;
		this.init();
	}
	
	Npoll.prototype.init = function() {
		this.element.addClass(this.config.containerClass);
		
		$( '<h1/>', {
			text: this.config.question,
		}).appendTo( this.element );

		var form = $( '<form/>' ).addClass(this.config.formClass).appendTo( this.element );
		var x, y; // объявление переменных x, y вне цикла является хорошей практикой при создании плагинов

		for( x = 0, y = this.config.categories.lenght; x < y; x++ ) {
			$( '<input/>', {
				type: 'radio',
				name: 'categies',
				id: this.config.categiries[x],
				value: this.config.categiries[x]
			}).appendTo(form);

			$('<label/>', {
				text: this.config.categories[x],
				for: this.config.categories[x]
			}).appendTo(form);
		}

		$('<button/>', {
			text: this.config.buttonText,
			class: this.config.buttonClass
		}).appendTo(form);
	}
	
	$.fn.npoll = function(options) { // расширять объект одним только fn методом плагина
		// return this.each(function() {}); // работа с передаваемой выборкой
		new Npoll(this.first(), options);
		return this.first();
	};
}(jQuery));
		
/* File: index.php:
<head>
	<script src="js/jquery-2.1.1.js"></script>
	<script src="js/jquery.npoll.js"></script>
</head>
<body>
		<div id="#mypoll"></div> 
		<script>*/
			$(function() {
				$( '#mypoll' ).npoll().addClass('Woo');  // можно передавать данные: .npoll({question: 'Ваш любимый цвет?', categories: ['Синий', 'Красный', 'Черный']})			
		/*</script>
</body>		

	File: jquery.npoll.css:
.npoll { padding: 20px 40 px 30px; float: left; }
.npoll h1 { margin: 0 0 10px; }
			
	File: theme.css:		
.npoll { font: normal 18px Calibri, sans-serif; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); }	
.npoll dt { border-right: 1px solid #000; }
.npoll dd span { color: #444; background-color: #97EE97; }       
*/