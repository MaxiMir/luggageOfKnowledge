<?
/*
React is a javascript library for building user interfaces

Так характеризуют Реакт его создатели, разработчики компании Facebook. Появившись в 2013 году, Реакт быстро стал набирать обороты и получил широчайшее распространение. На момент создания курса на Гитхабе у проекта более 70 тысяч звезд.

Секрет успеха в том, что Реакт позволил под другим углом посмотреть на процесс создания интерфейсов. Он резко снизил порог входа и сложность получаемых решений. Причем не только по сравнению с ручной работой с ДОМом, но и по сравнению со многими фреймворками.

И хотя Реакт как библиотеку для отрисовки можно встраивать в существующий технологический стек там, где это имеет смысл, он так же способен взять на себя полное управление фронтендом. Правда, в данном случае для эффективной работы придется подключить еще некоторые ключевые дополнения, такие как redux и react-router.

Фундаментальная идея, лежащая в основе работы Реакта, оказалась настолько мощной, что ее расширили далеко за рамки браузера. С Реактом можно работать как на сервере (server-side rendering), так и на мобильных платформах (React Native). Вы не ослышались: сейчас на языке JavaScript можно создавать приложения под мобильные платформы, которые работают почти так же эффективно, как и нативные приложения. Такую ситуацию, когда один подход используется для реализации разных задач (сайт, мобильные приложения) называется "Learn once, Write anywere".

# CodePen
Самый простой способ попрактиковаться с Реактом – это сервис codepen. После регистрации вы сможете создать pen — изолированную среду разработки, подключив туда Реакт. Результаты кода отображаются там же, в соседней панели.

Сodepen позволяет вставлять пены прямо в свой сайт, чем я и буду пользоваться для демонстрации. Вы можете не только проанализировать такой код, но запустить и даже поправить его.

# create-react-app

Разработчики в Фейсбуке, понимая как сложно настроить с нуля экосистему для старта фронтенд проектов, создали проект под названием create-react-app. Это npm-библиотека, которая позволяет стартануть с нулевой конфигурацией:
*/
$ npm install -g create-react-app

$ create-react-app my-app
$ cd my-app/
$ npm start

/*
Дальше просто открывайте localhost:3000 и наслаждайтесь.

# babel-preset-react
Если вы все же решитесь делать все самостоятельно, то не забудьте подключить пресет (preset) babel-preset-react к вашей конфигурации Babel. Реакт расширяет JS и не может работать с Babel без этого пресета.

# Курс

На протяжении всего курса мы будем создавать маленькие и не очень маленькие компоненты Бутстрапа. Если вы еще не знакомы с ним, то прочитайте наш гайд по Бутстрапу https://guides.hexlet.io/bootstrap/. В любом случае в каждой задаче будет подробно описано какой компонент использовать и как он должен выглядеть.

# Отладка
Так как Реакт отрабатывает на фронтенде, то и ошибки будут появляться там же. Не забывайте всегда держать открытой консоль (например, в developer tools в Хроме) и внимательно читать все, что там написано. Большая часть ошибок будет выводиться именно там.

Также не забудьте поставить React Developer Tools. Это расширение для браузера, которое дает очень удобную панель для анализа происходящего с Реактом в вашем приложении. 
*/


>>>>>> Компоненты <<<<<<

/*
Сразу начнем с примера, который будем разбирать в течение урока:
*/

// HTML
<div id="react-root"></div>


// Babel
class Hello extends React.Component {
  render() {
    return <div>Hello!</div>;
  }
}

const mountNode = document.getElementById('react-root');
ReactDOM.render(<Hello />, mountNode);

/*
Центральное понятие в Реакте - компонент. Более того, это единственная сущность, которую он содержит. Вся остальная функциональность построена вокруг компонентов.

В примере выше создан компонент, который добавляет в DOM на странице <div>Hello!</div>.

Вот как выглядит получившийся html:
*/

<div id="react-root">
  <div>Hello!</div>
</div>

/*
# Импорты

CodePen импортирует Реакт автоматически (его нужно указать в подключаемых библиотеках), но в своем коде импорты пропускать нельзя:
*/
import React from 'react';
import ReactDOM from 'react-dom';


/*
Из кода и импортов видно, что для работы с Реактом нужно две библиотеки: сам Реакт и ReactDOM. Причина наличия двух зависимостей достаточно проста. Сама библиотека React не связана с DOM напрямую и используется не только в браузере. Поэтому отрисовка конкретно для DOM вынесена в отдельный пакет ReactDOM.

# Компонент
*/
// FILE: Hello.jsx:
export default class Hello extends React.Component {
  render() {
    return <div>Hello</div>;
  }
}

/*
# Очевидные тезисы

1. Компонент Реакта – это класс, который наследуется от класса React.Component (как мы увидим позже, это не единственный способ создать компонент).
2. Функция render возвращает нечто (обсудим позже), что будет отрисовано в браузере. Класс-компонент без функции render существовать не может, это его интерфейс.

Экспорт класса по умолчанию задан не спроста. В JS принято создавать один класс на файл. В отличие от обычных классов, Реакт-компоненты имеют расширение JSX, а значит компонент, определенный выше, должен лежать в файле с именем Hello.jsx.

Обратите внимание: класс все равно проименован, хотя это и не обязательно в случае дефолтного экспорта. Мы действительно можем его не именовать, но тогда в React Dev Tools будет тяжело понять, что же отрисовал React, так как любой безымянный компонент отображается как <ReactComponent>. Поэтому возьмем себе за правило всегда давать компонентам имена.


# Неочевидные тезисы

Самое поразительное происходит в этой строчке:
*/
<div>Hello</div>;

/*
Здравый смысл подсказывает, что такая запись синтаксически невозможна в JS. И он будет прав. То, что вы видите, называется JSX и является расширением языка (добавляется с помощью Babel). Кардинальное решение для фреймворка, не правда ли? В процессе вы поймете, что это не такая уж и плохая идея.


Главное сейчас запомнить то, что в конечном итоге любой компонент Реакта возвращает кусок DOM (на самом деле – virtual DOM).

Кстати, div – это тоже компонент Реакта, только встроенный. Отличить встроенные компоненты от самописных очень легко. Встроенные всегда начинаются с маленькой буквы, а те, которые не являются частью Реакта, должны начинаться с большой.

Хорошим стилем считается давать расширение .jsx для всех файлов, которые содержат JSX, независимо от того, создается ли компонент в этом файле или нет.


# Mount
*/

const mountNode = document.getElementById('react-root');
ReactDOM.render(<Hello />, mountNode);

/*
Созданный компонент (класс компонента) сам по себе ничего не делает. Чтобы насладиться результатом его работы нужно произвести так называемое монтирование. То есть указать Реакту, куда его вставить в DOM.

Для этой задачи обязательно требуется реальная DOM-нода (узел), к которой и производится монтирование строчкой:
*/
ReactDOM.render(<Hello />, mountNode);

/*
Первым параметром передается наш компонент в синтаксисе jsx, а вторым та самая нода. Подходящей нодой может быть любой узел внутри body. Как правило, если у нас не SPA, то React используется в виде виджетов, подключаемых на странице в разных местах. Причем на одной странице может быть сразу несколько виджетов. Например, на Хекслете все фронтенд-элементы – это как раз виджеты.

# JSX
JSX – это xml-like расширение js, созданное специально для задач Реакта. React из коробки поставляется с набором компонентов, которые полностью повторяют html. По большей части синтаксис и структура jsx и html совпадают, но есть некоторые важные различия:

1. Так как это xml-like синтаксис, одиночные теги в jsx должны быть закрыты: <hr />.
2. Вместо атрибута class в jsx используется имя свойства в DOM: className.

Так же как и в html, из компонентов можно строить композиции, например такую:
*/

const vdom = (
  <div className="card">
    <div className="card-body">
      <h4 className="card-title">Card title</h4>
      <p className="card-text">my text</p>
      <a href="#" className="btn btn-primary">Go somewhere</a>
    </div>
  </div>
);

/*
И это все валидный код на JS с подключенным расширением для jsx.

То, что каждый компонент Реакта возвращает кусок DOM, является следствием его фундаментальной идеи и архитектуры. В одном из уроков мы рассмотрим эту идею подробнее и я уверен вы проникнитесь ей. Но почему понадобилось вводить jsx?

Нужно понимать, что jsx – расширение языка, а значит это именно код, а не html. А раз jsx транслируется в код, то, следовательно, мы могли бы сразу писать этот код. Верно? Верно, но не совсем:
*/

React.createElement(
  "div",
  { className: "card" },
  React.createElement(
    "div",
    { className: "card-body" },
    React.createElement(
      "h4",
      { className: "card-title" },
      "Card title"
    ),
    React.createElement(
      "p",
      { className: "card-text" },
      "my text"
    ),
    React.createElement(
      "a",
      { href: "#", className: "btn btn-primary" },
      "Go somewhere"
    )
  )
);

/*
Пример кода выше – это как раз то, как бы выглядели функции render компонентов на Реакте. Причем данный пример очень тривиальный и не содержит логику. Если бы у нас появились условные конструкции, то этот код перешел бы все разумные пределы по сложности анализа. К сожалению, или к счастью, собирать древовидные структуры в коде (а DOM – это дерево) – занятие очень тяжелое и беспощадное. Надеюсь, теперь стало чуть понятнее, зачем нужен jsx, и что jsx – это не верстка (как думают некоторые).

Ну и последнее. Так как любой jsx в итоге превращается в вызовы React.createElement, то нужно следить за тем, чтобы Реакт был импортирован: import React from 'react'.
*/


/**@@@
src/Card.jsx
Реализуйте компонент Card, возвращающий следующий jsx:
*/
<div className="card">
  <div className="card-body">
    <h4 className="card-title">Card title</h4>
    <p className="card-text">Some quick example text to build on the card</p>
    <button type="button" className="btn btn-primary">Go somewhere</button>
  </div>
</div>


/*
src/index.jsx
Импортируйте Card.jsx и отрисуйте компонент внутри dom элемента с id равным container

Подсказки
Описание Card https://getbootstrap.com/docs/4.0/components/card/
*/

// FILE: /app/src/Card.js:
import React from 'react';

export default class Card extends React.Component {
  render() {
    return (
      <div className="card">
        <div className="card-body">
          <h4 className="card-title">Card title</h4>
          <p className="card-text">Some quick example text to build on the card</p>
          <button type="button" className="btn btn-primary">Go somewhere</button>
        </div>
      </div>
    );
  }
}
// FILE: /app/src/index.jsx:
import ReactDOM from 'react-dom';
import React from 'react';
import Card from './Card';

ReactDOM.render(
  <Card />,
  document.getElementById('container'),
);

// FILE: /app/public/index.html:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
  </head>
  <body>
    <div id="container" class="container m-3"></div>
    <script src="/vendors~main.js" ></script>
    <script src="/main.js" ></script>
  </body>
</html>
