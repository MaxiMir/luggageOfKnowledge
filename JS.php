<?

############## JS ##############

// repl.it

>>>>> Guard Expression <<<<<<<

/*
Одни функции устроены сложнее других. Иногда так происходит в силу объективных причин (необходимая сложность). Иногда — в силу особенностей писавшего её программиста (случайная сложность). И хотя нельзя однозначно описать эту сложность, существуют способы, позволяющие хотя бы частично её оценить.

# Цикломатическая сложность
Цикломатическая сложность — это структурная, или топологическая, мера сложности компьютерной программы, разработанная Томасом Дж. Маккейбом в 1976 году.

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только один маршрут через код.

Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один, если условие оператора if имеет значение true, и один — если false.

Такую оценку можно применять как в целом к программе, так и к отдельным функциям.
*/

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);

abs(10); // => 10
abs(-3); // => 3

/*
В примере выше у функции sum цикломатическая сложность равна единице, а у функции abs — двойке, так как она содержит ветвление, а значит два независимых пути выполнения.

Чем больше возможных путей выполнения, тем сложнее функцию понять, отладить и модифицировать. Очевидно, что, с одной стороны, функции нужно дробить, а с другой — описывать логику программы так, чтобы не появлялись лишние пути. Даже опытные разработчики часто сталкиваются с этой проблемой.

Линтеры многих языков измеряют показатель сложности и сигнализируют, если он, скажем, больше 5 для одной функции.

# Guard Expression
Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:
*/

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

/*
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.
*/

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

/*
Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.

/**
Реализуйте и экспортируйте по умолчанию функцию isPalindrome с использованием рекурсии.

Примеры использования:
import isPalindrome from './isPalindrome';

isPalindrome('radar'); // => true
isPalindrome('a');     // => true
isPalindrome('abs');   // => false
**/

// file: App/isPalindrome.js: 

#1:
const isPalindrome = (string) => {
  if (string.length <= 1) {
    return true;
  }

  const firstSymbol = string[0];
  const lastSymbol = string[string.length - 1];

  if (firstSymbol !== lastSymbol) {
    return false;
  }

  const stringWithoutFirstAndLastSymbols = string.substr(1, string.length - 2);

  return isPalindrome(stringWithoutFirstAndLastSymbols);
};

export default isPalindrome;

# 2:

const isPalindrome = (str) => {
  let length = str.length,
    center = length % 2 == 0 ? length / 2 : Math.ceil(length / 2) - 1;  

  if (length <= 1) {
    return true;
  } else {
    for (let i = 0; i < center; i++) {
      if (str[i] !== str[length - 1 - i]) {
        return false;
      }
    }   
  }
  return true;
}

export default isPalindrome;


## TESTS:

// file: __tests__/isPalindrome.test.js:

import isPalindrome from '../isPalindrome';

test('isPalindrome', () => {
  expect(isPalindrome('a')).toBe(true);
  expect(isPalindrome('aa')).toBe(true);
  expect(isPalindrome('404')).toBe(true);
  expect(isPalindrome('abba')).toBe(true);
  expect(isPalindrome('radar')).toBe(true);
  expect(isPalindrome('absba')).toBe(true);
  expect(isPalindrome('aibohphobia')).toBe(true);

  expect(isPalindrome('abaoba')).toBe(false);
  expect(isPalindrome('aashgkhdj')).toBe(false);
  expect(isPalindrome('palindrome')).toBe(false);
  expect(isPalindrome('aibohapohobia')).toBe(false);
});



>>>>> Параметры по умолчанию <<<<<<< 

// Опишем функцию greeting, которая печатает на экран приветствие:

const greeting = name => console.log(`Hi, ${name}!`);

greeting('John');
// => Hi, John!

// Но что произойдёт, если при вызове функции передать ей меньшее число аргументов, чем у неё установлено параметров? Давайте посмотрим:

greeting();
// => Hi, undefined!

// Правило здесь простое: параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined. Проиллюстрируем это подробнее на примере функции, которая принимает на вход три параметра и распечатывает их значения:

const foo = (a, b, c) => {
  const output = `a - ${a}; b - ${b}, c - ${c}`;
  console.log(output);
};

foo('I', 'am', 'here');
// a - I; b - am, c - here

foo('I', 'am');
// a - I; b - am, c - undefined

foo('I');
// a - I; b - undefined, c - undefined

foo();
// a - undefined; b - undefined, c - undefined

/* 
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.

Допустим, мы хотим, чтобы при вызове функции greeting без параметров, она выводила сообщение Hi, anonymous!.

Тогда мы можем реализовать её следующим образом:
*/

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

// Однако, JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:

const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);

greeting();
// => Hi, anonymous!

//Работает он следующим образом. Если параметр не передан, то подставляется значение по умолчанию (то, что справа от оператора =). Если параметр передан, то переприсваивания не происходит. Параметр будет равен тому значению, которое было фактически передано в функцию.

const pow = (base, exp = 2) => base ** exp;

pow(5); // => 25
pow(5, 2); // => 25
pow(5, 1); // => 5

// Кроме того, в значениях по умолчанию можно использовать идентификаторы:

const f = (x = Math.PI) => {};

// И даже вызовы функций:

const f = (x, y = Math.sqrt(x)) => {};


const getSum = (a = 10, b = 2 * a, c = 3 * b) => a + b + c;
const result = getSum(); // <-> 10 + 20 + 60 => 90
const result = getSum(2); // <-> 2 + 4 + 12 => 18
const result = getSum(2, 3); // <-> 2 + 3 + 9 => 14
const result = getSum(2, 3, 4); // <-> 2 + 3 + 4 => 9


const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`); // интерполяция - работает только со строками в бэктиках.

/*
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования.

Примечание
В этом уроке мы рассмотрели случай, когда в функцию передаётся меньше параметров, чем она ожидает. У вас может возникнуть вопрос, что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?

Ответ: ничего не произойдёт они будут просто проигнорированы.

Дополнительные материалы
Default function parameters https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters

/**
Реализуйте и экспортируйте по умолчанию функцию substr, которая возвращает подстроку из переданной строки. Подстрокой называется любая выбранная часть строки. Например для строки hello можно выделить следующие подстроки: ello, llo, o, el и множество других. Функция принимает на вход три параметра:

Строка.
Начальный индекс. Значение по умолчанию: 0.
Длина подстроки. Значение по умолчанию: длина всей строки.
substr('abba', 0, 1);    // => a
substr('abba', 1, 2);    // => bb
substr('abba', -10, 2);  // => ab
substr('abba', -1, 100); // => abba
substr('abba', -1, -1);  // => a
substr('abba', 1, -10);  // => b
substr('abba', 1, 10);   // => bba
substr('abba', 1, 0);    // => ''
substr('abba', 100, 3);  // => ''
По умолчанию, то есть если не переданы дополнительные параметры, возвращается сама строка:

substr('');     // => ''
substr('abba'); // => abba
У этой функции множество вариантов поведения:

Если переданная длина отрицательная, то внутри она становится единицей
Если переданная длина равна нулю, то возвращается пустая строка
Если конечный индекс (переданная длина + начальный индекс - 1) выходит за границу строки, то берется подстрока от начального индекса до конца строки.

substr('abba', 1, 10);   // => bba
Конечный индекс 1 + 10. Он выходит за границу строки, так как длина строки 4 символа. Поэтому возвращается подстрока, от начального индекса 1 и до конца строки.

Если начальный индекс отрицательный, то внутри он становится нулем

Если начальный индекс выходит за границу слова справа, то всегда возвращается пустая строка

Для реализации этой функции, используйте подход, который называется "нормализация". Он заключается в том, что перед тем как делать вычисления, данные приводятся к виду, с которым удобно работать. Например, длина строки для substr может иметь следующие неудобные значения:

Отрицательное число
Число, выходящее за границу строки
Индекс + Длина выходят за границу строки
В каждой из этих ситуаций длину строки можно изменить на такое значение, которое будет удобно для обработки сразу всех возможных случаев. Если число отрицательное, то длина становится равной единице (из условия), если оно выходит за границу строки, то его нужно сделать равным длине строки. В последнем случае длина должна стать числом Длина Строки - Индекс. После этих манипуляций процесс взятия подстроки становится универсальным и не содержащим условия.
**/

// file: app/substr.js



## TESTS:

// file: app/__tests__/substr.test.js:

import substr from '../substr';

test('substr', () => {
  expect(substr('')).toEqual('');
  expect(substr('abba', 4, -10)).toEqual('');
  expect(substr('abba')).toEqual('abba');
  expect(substr('abba', 1, 0)).toEqual('');
  expect(substr('abba', 0, 1)).toEqual('a');
  expect(substr('abba', 1, 2)).toEqual('bb');
  expect(substr('abba', -10, 2)).toEqual('ab');
  expect(substr('abba', -1, 100)).toEqual('abba');
  expect(substr('abba', -1, -1)).toEqual('a');
  expect(substr('abba', 1, -10)).toEqual('b');
  expect(substr('abba', 1, 10)).toEqual('bba');
});



>>>>> Выполнение функций <<<<<

/*
Вспомним несколько важных понятий из прошлого курса:

Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

Выражения — вычисляются.
Инструкции — исполняются.

К выражениям относятся:
 * Вызов функции
 * Арифметические и логические операции
 * Тернарный оператор
 * и другие

К инструкциям относятся:
 * for
 * while
 * break
 * return
 * if
 * и другие

Необходимо знать разницу между ними — это позволит лучше понимать, как могут взаимодействовать друг с другом различные конструкции языка.

Возьмем условный оператор if. В некоторых языках он представлен инструкцией, в некоторых — выражением. Посмотрите на код ниже и подумайте, возможно ли такое в JavaScript и почему:
*/
const value = if (something) {
    one
  } else {
    two
  };

/*
Такой код в JavaScript невозможен только по одной простой причине: if — это инструкция, а не выражение.

Но такой код возможен и часто используется в языках вроде Ruby или Python. Зачем же нужен if, если есть тернарный оператор, который как раз и является выражением?

Дело вот в чем. Если бы if был выражением, то тернарный оператор стал бы попросту не нужен, несмотря на то, что он является более лаконичной заменой if. Но и тернарный оператор бывает неудобен в тех ситуациях, когда вычисление слишком большое и не помещается в одну строку, а его результат должен быть записан в одну и ту же константу или переменную в каждой из веток. В такой ситуации как раз пригодился бы if как выражение.

Этот пример ярко иллюстрирует тот факт, что конструкции языка, представленные выражением, делают язык гибче, а решения с их использованием делают код лаконичнее. Другими словами, язык становится выразительнее. Кроме описанного выше, у выражений есть еще одно огромное преимущество: они могут комбинироваться друг с другом и вкладываться друг в друга.

Ниже я продемонстрирую варианты комбинирования выражений, но с акцентом на функции:

# Арифметические операции
*/
const r1 = 5;
const r2 = 5 + 8;
const r3 = 5 + 8 - Math.PI;
const r4 = 5 + 8 - Math.PI * Math.sqrt(16);
const r5 = f1() + f2() * f3();

/*
Вопросы могут возникнуть только в последней строчке. Насколько это допустимо? Вызов функции — это выражение, возвращающее результат, так что этот код допустим на 100%. Если функция вернет значение, неподходящее для сложения, то может возникнуть ошибка, но это будет логическая ошибка, а не синтаксическая.

Примечание: предополагается, что используемые в примерах этого урока функции и константы (например, f2 или isEditing) ранее где-то были определены. Их определение мы убрали из примеров, чтобы не отвлекать от главного.

# Логические операции

Все то же самое можно делать и с логическими выражениями:
*/

const r1 = true;
const r2 = true || false;
const r3 = true || false && isEditing;
const r4 = true || false && isEditing || isEmpty(data);
const r5 = f1() || f2() && f3();

/*
Из-за слабой типизации подобный код работать будет вообще всегда, даже если функции возвращают не true или false, но пользоваться этим не стоит. 

# Аргументы

А теперь чуть более сложный пример. Когда мы вызываем функцию, то в аргументах ожидается выражение: func(<expression>, <expression>, ...). А из этого следует, что мы можем сделать так:
*/

const r1 = f();
const r2 = f(5);
const r3 = f(5 + Math.PI);
const r4 = f(5 + Math.PI - cube(number));
const r5 = f(f1(f2(n3, f3(n1, n2))), f4());

/*
Пройдемся по примеру выше. f(f1(f2(n3, f3(n1, n2))), f4()) содержит в аргументах два выражения:

1. f4()
2. f1(f2(n3, f3(n1, n2)))
  этот вызов содержит один аргумент — вызов функции: f2(n3, f3(n1, n2)),
    который в свою очередь содержит два аргумента: n3 и вызов функции f3(n1, n2).

#  Порядок выполнения

Осталось понять, в какой последовательности происходят эти вызовы. JavaScript считается энергичным языком, то есть языком с аппликативным порядком вычисления, а это значит, что аргументы вычисляются до того, как попадают внутрь функций.    
*/

const f1 = () => console.log('called f1');
const f2 = () => console.log('called f2');
const f3 = () => console.log('called f3');
const f4 = () => console.log('called f4');
const f5 = () => console.log('called f5');
const f6 = () => console.log('called f6');

f1( f2(f4(), f5()), f3(f6()) );

// called f4
// called f5
// called f2
// called f6
// called f3
// called f1

// Как видно, вычисление идет с самого глубокого уровня слева направо.


/**
Модуль tags содержит набор функций, позволяющих генерировать HTML с помощью функций.
*/

table(
  tr(td('one'), td('two')),
  tr(td('three'), td('four'))
);

/*
В результате вызовов возвращается вот такой HTML:

<table>
  <tr>
    <td>one</td>
    <td>two</td>
  </tr>
  <tr>
    <td>three</td>
    <td>four</td>
  </tr>
</table>
buildHtml.js
Реализуйте и экспортируйте по умолчанию функцию buildHtml, простой вызов которой:
*/

buildHtml();

/*
создаёт и возвращает следующий HTML:

<table>
  <tr>
    <td>lang</td>
    <td>comment</td>
  </tr>
  <tr>
    <td>php</td>
    <td>statements</td>
  </tr>
  <tr>
    <td>clojure</td>
    <td>expressions</td>
  </tr>
</table>

// file: buildHtml.js
**/


import { table, tr, td } from './tags';

export default () => table(
  tr(td('lang'), td('comment')),
  tr(td('php'), td('statements')),
  tr(td('clojure'), td('expressions')),
);

# TESTS

// app/__tests__/buildHtml.test.js 

import { html } from 'js-beautify';
import buildHtml from '../buildHtml';

test('htmlBuilder', () => {
  expect(html(buildHtml())).toMatchSnapshot();
});


// app/__tests__/__snapshots__/buildHtml.test.js.snap 

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`htmlBuilder 1`] = `
"<table>
    <tr>
        <td>lang</td>
        <td>comment</td>
    </tr>
    <tr>
        <td>php</td>
        <td>statements</td>
    </tr>
    <tr>
        <td>clojure</td>
        <td>expressions</td>
    </tr>
</table>"
`;



>>>>>  Объекты первого класса <<<<<

/*
Продолжая тему предыдущего урока, познакомимся с понятием "first-class citizen" или "объекты первого класса".

Объектами первого класса в контексте конкретного языка программирования называются элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идет обо всем, что может быть данными. Самые простые типы данных — это числа и строки. Как вы потом увидите, все остальные типы данных также являются объектами первого класса.

А теперь посмотрите внимательно на этот код: const x = () => console.log('hey'). Ничего необычного, вы видели и писали подобное множество раз. Если вы считаете, что в этом коде создается функция x, на самом деле это не так. Здесь происходят следующие две операции:

1. Создание функции: () => console.log('hey')
2. Создание константы со значением в виде функции: const x =

Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: () => {}. Это пустая функция с пустым телом, которая не делает ничего. Присваивать ее константе или нет — вопрос отдельный. Вполне допустимо написать и выполнить подобную программу: (a, b) => a + b;.

Из примеров выше можно сделать вывод, что функция — тоже данные, ведь ее можно присвоить константе. Рассмотрим это утверждение на практике:
*/

const identity = v => v; // функция: v => v, константа: identity
console.log(identity(10)); // => 10

const z = identity;
console.log(z === identity); // => true

const x = 5;
console.log(z(x) === identity(x)); // => true

/*
Главный вывод, который можно сделать из кода выше, заключается в том, что определение функции (не вызов!) — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать ее без создания промежуточной константы:
*/

// Определяем функцию v = v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

/*
Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нем создается функция, принимающая на вход другую функцию v и вызывающая ее внутри с аргументом 'run'.

Попробуем усложнить:
*/
identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

/*
Первым идет пример вызова функции по идентификатору, а во втором примере я заменил идентификатор на определение функции, сделав подстановку. Результат получился тот же самый. Еще раз посмотрите на этот шаблон (<тут определение функции>)(). Попробуйте самостоятельно разобрать пример ниже:
*/

((a, b) => a + b)(3, 2); // => 5
// const sum = (a, b) => a + b;
// sum(3, 2); // => 5

// Теперь попробуем использовать функции как данные:

const sqrt = identity(Math.sqrt);
console.log(sqrt === Math.sqrt); // true
sqrt(4); // => 2

/*
В первой строчке вызывается функция identity, в которую передается Math.sqrt. Результатом этого вызова будет все та же функция Math.sqrt.

Здесь мы видим сразу два новых аспекта: передача функции как аргумента и возврат функции как значения. Функции, которые принимают на вход другие функции или возвращают другие функции, называются функциями высшего порядка. В функциональных языках большинство задач, связанных с обработкой данных, работают именно через них. JavaScript в этом смысле ведет себя точно также.

В следующем примере внутрь функции передается другая функция, определяемая в аргументах. В комментариях показан альтернативный способ через создание константы с функцией.
*/

const sum = identity((a, b) => a + b);
sum(3, 5); // => 8

// const f = (a, b) => a + b;
// const sum = identity(f);
// sum(3, 5); // => 8

/*
Подобная передача функций в функции с определением прямо в аргументах встречается повсеместно в реальном коде. Как правило, те функции, которые передаются в аргументах, нужны только здесь и сейчас.

Возникает вопрос: есть ли имя у функций, определенных подобным образом? Имени нет даже у такой функции const f = () => {}. Мы просто связали константу с функцией, но сама функция ничего про константу не знает. Звучит слегка безумно, но это так. Ведь мы можем взять и связать эту функцию уже с другой константой. По этой причине такие функции часто называют анонимными. Другое распространенное название — лямбда-функция. Своим названием лямбда-функция обязана лямбда-исчислению (математическая формальная система, легшая в основу языков семейства lisp). Только в отличие от языков программирования, "лямбды" в лямбда-исчислении — всегда функции от одного аргумента, поэтому общее с функциями из js у них, в первую очередь, анонимность, и то, что они являются объектами первого класса.

Попробуем сделать что-нибудь полезное. Иногда встречается задача, в рамках которой нужно применить одну и ту же функцию несколько раз, например, так: Math.sqrt(Math.sqrt(16)). Создав функцию высшего порядка, можно упростить эту задачу. Рассмотрим пример с двойным применением одноаргументной функции:
*/

const callTwice = (f, arg) => f(f(arg));

callTwice(Math.sqrt, 16); // => 2
callTwice(x => x ** 2, 3); // => 81
// const f = x => x ** 2;
// f(f(3));

// callTwice применяет переданную функцию к своему аргументу два раза. Если расписать подробнее, то происходит следующее:

const res1 = f(arg);
const res2 = f(res1);
return res2;

const result = ((a, b) => a ** b)(5, 2); // функции можно вызывать сразу после определения.

// Все функции в языке JavaScript являются объектами первого класса.

/**
Реализуйте и экспортируйте по умолчанию функцию apply, которая принимает на вход три параметра:

Количество раз, которое нужно применить функцию к аргументу (ряд последовательных вызовов, где каждому следующему вызову передается аргумент, являющийся результатом предыдущего вызова функции; см. примеры ниже)
Функцию для применения
Аргумент для применения
*/

apply(0, Math.sqrt, 4); // => 4
apply(1, Math.sqrt, 4); // => 2

// Math.sqrt(Math.sqrt(16));
apply(2, Math.sqrt, 16); // => 2
// Math.sqrt(Math.sqrt(Math.sqrt(256)));
apply(3, Math.sqrt, 256); // => 2

apply(1, v => v ** 2, 3); // => 9
apply(5, v => v + 10, 3); // => 53

// file: app/apply.js 

const apply = (count, fn, value) =>
  (count === 0 ? value : apply(count - 1, fn, fn(value)));

export default apply;


## TEST

// file: app/__tests__/apply.js 

import apply from '../apply';

test('apply', () => {
  expect(apply(0, Math.sqrt, 4)).toBe(4);
  expect(apply(1, Math.sqrt, 4)).toBe(2);
  expect(apply(2, Math.sqrt, 16)).toBe(2);

  expect(apply(1, v => v ** 2, 3)).toBe(9);
  expect(apply(5, v => v + 10, 3)).toBe(53);
});



>>>>> Лексическое окружение (LexicalEnvironment) <<<<<

/*
Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь LexicalEnvironment (лексическое окружение), привязанный к этому вызову. Все определения констант, переменных и прочего внутри функции автоматически записываются в словарь. Имя определения (идентификатор, то есть имя константы, переменной и так далее) становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и т.д. Лексическое окружение — это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.

В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.
*/

const showWarning = (field) => {
  // LexicalEnvironment = { field: 'email' }
  const warning = `verify your ${field}, please`;
  // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
  console.log(warning);
}

showWarning('email'); // => verify your email, please

/*
Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.

В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.

Из этого поведения есть исключение — возврат функции. В следующем уроке мы рассмотрим связанный с ним механизм так называемых «замыканий». 

Окружение есть не только у функций. Любой идентификатор, определенный на уровне модуля, попадает в лексическое окружение модуля. Кроме того, существует и глобальное окружение. Благодаря ему мы с легкостью используем в JS такие функции, как console.log или Math.sqrt, даже особо не задумываясь, откуда они берутся.
*/

const number = 5;
const square = () => number ** 2;
square(); // => 25

/*
Такой код работает — и это для нас не секрет, но как он вяжется с механизмом окружений? А вот как: интерпретатор производит поиск значения идентификатора не только в локальном лексическом окружении (в том, где используется идентификатор), но и во внешнем окружении. Поиск начинается с локального окружения, и если в нём не найден нужный идентификатор, то просмотр идет дальше, вплоть до уровня модуля, а затем и до глобального уровня.

Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена (а не вызвана!). Если разбить пример выше на два файла, то разница станет очевидной.

Так сработает:
*/

// module1.js
const number = 5;
export const square = () => number ** 2;

// module2.js
import { square } from './module1';
square(); // => 25
А так нет:

// module1.js
export const square = () => number ** 2;

// module2.js
import { square } from './module1';

const number = 5;
square(); // => ReferenceError: number is not defined

/*
Если подумать логически, так и должно быть. Представьте: если бы сработал второй вариант, то автоматически это бы означало, что вы можете случайно создать имя переменной, совпадающее с именем переменной внутри функции, написанной другим человеком. Как при этом будет работать код — предположить невозможно.

Попробуйте самостоятельно ответить на вопрос: сработает ли такой код, в котором константа определена позже её использования внутри функции?
*/

const square = () => number ** 2;
const number = 5;

square(); // => 25

/*
Ответ: сработает.

Окружение — это не «всё, что было объявлено до функции, в которой я использую эти объявления». Не важно, что number появился позже использования внутри функции. Главное, что вызов функции square происходит позже определения number, а значит к этому времени идентификатор уже был добавлен в окружение, внутри которого была создана функция square.

# Переменные
Когда мы работаем с константами, всё просто. Нет изменений — нет проблем. В случае с переменными ситуация становится сложнее.
*/

const square = () => number ** 2;

let number = 5;
square(); // => 25

number = 3;
square(); // => 9

/*
Изменение переменной следует читать как «изменение значения ключа в окружении». Соответственно, обращение к number всегда вернет последнее присвоенное значение. Завязка на переменные, описанная в коде выше, должна восприниматься как абсолютное зло. Она порождает неявные зависимости, сложный код и отладку. Функция автоматически перестает быть чистой, так как начинает зависеть от внешнего контекста.

# Вложенные функции
*/

const factorial = (n) => {
  const iter = (counter, acc) => {
    if (counter > n) {
      return acc;
    }
    return iter(counter + 1, counter * acc);
  };

  return iter(1, 1);
};

factorial(5); // => 120

/*
В этом коде реализовано вычисление факториала с применением итеративного процесса. Внутри функции factorial определяется внутренняя функция iter, которая накапливает аккумулятор, вызываясь рекурсивно. Условие выхода из рекурсии — попытка посчитать число большее, чем нужно.

В этой проверке используется переменная n, которая явно в iter не передавалась. Но благодаря тому, как работают окружения, любые функции (в том числе и вложенные), определенные внутри factorial, имеют к ней доступ. Как видно из кода, n используется как константа, а значит такое использование абсолютно безопасно.

# Перекрытие (Shadowing)

Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем. Причем не важно, что это: аргумент функции, константа или переменная.
*/
const f = (coll) => {
  const iter(item, coll) => {
    // using coll
  }
  // ...
}

/*
Несмотря на то, что сам код остается рабочим, перекрытие больше не позволяет обратиться к идентификатору из внешнего окружения, ведь поиск всегда происходит сначала в локальном окружении, а уже затем во внешних. Но еще большей проблемой является то, что такой код сложнее в анализе. Глядя на него недостаточно видеть имена, нужно также учитывать их контекст, так как одно и то же имя на разных строках может означать разные вещи. Если запустить линтер для подобного кода, то он укажет на перекрытие как на плохую практику программирования. Подробнее об этом можно прочитать в правилах Eslint https://eslint.org/docs/rules/no-shadow.


Когда внутри функции создается локальное окружение?
> Во время вызова

Когда функция запоминает внешнее окружение?
> Во время определения



/**
Реализуйте функцию reverse, переворачивающую строку. В этот раз, используя итеративный процесс. Работа функции основана на двух принципах.
**/

// file: app/reverse.js

export default (str) => {
  const lastIndex = str.length - 1;
  // BEGIN (write your solution here)
  const iter = (index, acc) => {
    if (index > lastIndex) {
      return acc;
    }
    return iter(index + 1, `${str[index]}${acc}`);
  };
  // END
  return iter(0, '');
};


## TESTS

// file: app/__tests__/reverse.test.js:

import reverse from '../reverse';

test('reverse', () => {
  expect(reverse('')).toBe('');
  expect(reverse('z')).toBe('z');
  expect(reverse('zz')).toBe('zz');
  expect(reverse('zza')).toBe('azz');
  expect(reverse('qwerty')).toBe('ytrewq');
});


>>>>> Возврат функций из функций <<<<< 

const identity = v => v;
identity('wow'); // => wow

const sum = identity((a, b) => a + b);
sum(1, 8); // => 9

/*
Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций. Мы даже можем определить функцию внутри другой функции и вернуть её наружу. И в этом нет ничего удивительного. Константы можно создавать где угодно.
*/

const generateSumFinder = () => {
  const sum = (a, b) => a + b;     // создали функцию
  return sum;                      // и вернули её
};

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа


/*
Можно даже обойтись без промежуточного создания константы:
вызвали функцию, которая возвращает функцию, и тут же вызвали возвращенную функцию
*/

generateSumFinder()(1, 5);    // => 6
// ((a, b) => a + b)(1, 5)

/*
Всегда, когда видите подобные вызовы f()()(), знайте: функции возвращаются!
Теперь посмотрим, как еще можно описать функцию generateSumFinder:
*/

// предыдущий вариант для сравнения
// const generateSumFinder = () => {
//   const sum = (a, b) => a + b;
//   return sum;
// };

// новый вариант

const generateSumFinder = () => (a, b) => a + b;

// Для понятности можно расставить скобки:

const generateSumFinder = () => ((a, b) => a + b);

/*
Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:
*/

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

sum(1)(3)(5); // => 9

/*
Ту же функцию можно представить другим способом, вынеся каждую функцию в свою собственную константу. Этот способ полезен как мысленный эксперимент, чтобы понять где заканчивается одна и начинается другая функция, но сам по себе он не заработает, потому что теряется замыкание.
*/

const inner1 = z => x + y + z;
const inner2 = y => inner1;
const sum = x => inner2;

/*
Попробуем последовательно пройтись по вызовам функции выше, чтобы понять, как получается результат. После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.
*/

sum(1)(3)(5); // => 9

const sum1 = x => y => z => x + y + z;

// sum(1);
const sum2 = y => z => 1 + y + z; // inner2

// sum(1)(3)
const sum3 = z => 1 + 3 + z; // inner1

// sum(1)(3)(5)
const sum4 = 1 + 3 + 5; // => 9

/*
Как видно выше, sum1, sum2 и sum3 — это функции, а sum4 уже число, так как были вызваны все внутренние функции.
Давайте распишем все функции:
*/

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));

/*
Функция sum принимает x и возвращает функцию, которая
  принимает y и возвращает функцию, которая
    принимает z и возвращает функцию, которая
      возвращает сумму x + y + z

Попробуем развить идею функции callTwice из предыдущего урока. Напишем функцию generate, которая не применяет функцию сразу, а генерирует новую.      
*/

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));

/*
Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:

Создадим функцию f1. Она будет той функцией, которую вернет generate если передать ей функцию Math.sqrt (она вычисляет квадратный корень числа).

Получается, f1 — это функция, которая принимает число и возвращает корень корня — Math.sqrt(Math.sqrt(x)):
*/

const f1 = generate(Math.sqrt);
f1(16); // => 2
// generate(Math.sqrt)(16);

/*
Ещё пример: передадим в функцию generate новую функцию на ходу, без предварительного создания. Переданная функция возводит число в квадрат.
*/

const f2 = generate(x => x ** 2);
f2(4); // => 256
// generate(x => x ** 2)(4);

/*
Теперь функция f2 возводит число в квадрат два раза: (42)2.

Функция generate имеет такое имя не просто так. Дело в том, что возврат функции порождает каждый раз новую функцию при каждом вызове, даже если тела этих функций совпадают:
*/

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false

/*
Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию. 
Запомнить довольно просто, если вы где-то слышите или читаете что происходит генерация функций, значит кто-то их возвращает.

# Замыкание
Работа практически всех описанных примеров базировалась на одном интересном свойстве, которое называется «замыкание». 
*/

const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);

/*
Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.


Функция, которая была возвращена из generateDouble, называется замыканием. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

В СИКП дается прекрасный пример на понимание замыканий. Представьте себе, что мы проектируем систему, в которой нужно запомнить пароль пользователя, а потом проверять его, когда пользователь будет заново заходить. Можно смоделировать функцию savePassword, которая принимает на вход пароль и возвращает предикат, то есть функцию, возвращающую true или false, для его проверки. Посмотрите, как это выглядит:
*/

const secret = 'qwerty';
// Возвращается предикат.
const isCorrectPassword = savePassword(secret);

// Теперь можно проверять
console.log(isCorrectPassword('wrong password')); // => false
console.log(isCorrectPassword('qwerty')); // => true

// А вот как выглядит код функции savePassword:

const savePassword = password => passwordForCheck => password === passwordForCheck;

/*
# Возврат функций в реальном мире (Debug)
Логгирование — неотъемлемая часть разработки. Для понимания того, что происходит внутри кода, используют специальные библиотеки, с помощью которых можно логгировать (выводить) информацию о проходящих внутри процессах, например в файл. Типичный лог веб-сервера, обрабатывающего HTTP запросы выглядит так:
*/

[  DEBUG] [2015-11-19 19:02:30.836222] accept: HTTP/1.1 GET - / - 200, 4238
[   INFO] [2015-11-19 19:02:32.106331] config: server has reload its config in 200 ms
[WARNING] [2015-11-19 19:03:12.176262] accept: HTTP/1.1 GET - /info - 404, 829
[  ERROR] [2015-11-19 19:03:12.002127] accept: HTTP/1.1 GET - /info - 503, 829

/*
В js самой популярной библиотекой для логгирования считается Debug. 

Обратите внимание на левую часть каждой строки. Debug для каждой выводимой строчки использует так называемый неймспейс, некоторую строчку, которая указывает принадлежность выводимой строчки к определенной подсистеме или части кода. Он используется для фильтрации, когда логов становится много. Другими словами, можно указать "выводи сообщения только для http". А вот как это работает:
*/

import debug from 'debug';

const logHttp = debug('http');
const logHandler = debug('handler');

logHttp('hello!');
logHttp('i am from http');

logHandler('hello from handler!');
logHandler('i am from handler');

// Что приведет к такому выводу:

http hello! +0ms
http i am from http +2ms
handler hello from handler! +0ms
handler i am from handler +1ms

// Получается, что импортированный debug — это функция, которая принимает на вход неймспейс в виде строки и возвращает другую функцию, которая уже используется для логгирования.

/**
Во многих языках программирования существует интересная функция flip. Её необычность заключается в том, что единственная цель этой функции — это преобразовать другую функцию так, чтобы порядок её аргументов был обратным.

Например, у нас может быть функция pow, которая возводит первый аргумент в степень второго. flip вернет нам новую функцию, у которой первый аргумент — это степень, а второй — это число, которое нужно возводить в эту степень.

Эта функция бывает очень полезна при активной работе с функциями высшего порядка, она часто упрощает возможность комбинировать функции между собой.

Реализуйте и экспортируйте по умолчанию функцию flip. Данная версия flip работает только с функциями от двух аргументов.
**/

// subtraction
const sub = (a, b) => a - b;
const reverseSub = flip(sub);

sub(5, 3); // 2
reverseSub(5, 3); // -2

// exponentiation
const wop = flip(Math.pow);

Math.pow(1, 2); // 1
wop(1, 2); // 2

Math.pow(3, 2); // 9
wop(3, 2); // 8


// file: app/flip.js
#1
const flip = (f) => (...args) => { // 
  const revArgs = args.reverse();
  return f(...revArgs);  
};


#2

const flip = (f) => (a, b) => f(b,a);

export default: flip;


// file: app/__tests__/flip.test.js

import flip from '../flip';

test('reverseSub', () => {
  const sub = (a, b) => a - b;
  const reverseSub = flip(sub);
  expect(reverseSub(1, 2)).toBe(1);
  expect(reverseSub(5, 3)).toBe(-2);
});

test('wop', () => {
  const wop = flip((a, b) => a ** b);
  expect(wop(1, 2)).toBe(2);
  expect(wop(3, 2)).toBe(8);
});



>>>>> Частичное применение <<<<<

/*
Частичное применение функций, техника основанная на возможности возвращать функции из других функций. Допустим у нас есть функция sum суммирующая три числа.
*/

const sum = (a, b, c) => a + b + c;
sum(4, 3, 1); // 8
sum(1, 1, 1); // 3

/*
Частичное применение позволяет на основе старой функции, создать новую, которая "частично применена". Для начала вспомним что такое применение функции. Математики никогда не говорят что функция вызывается с некоторыми аргументами, вместо этого они говорят что функция была применена к этим аргументам. В примере выше функция sum была применена к трем аргументам 4, 3 и 1. Такое применение можно назвать полным, то есть в функцию было передано столько аргументов сколько и ожидалось. Здесь возникает вопрос, а можно было по другому? Да можно.

Частичное применение, техника которую проще всего объяснить в отрыве от языков программирования, на языке близком к математике (для простоты назову его Ha). Представьте что наша функция выше, имеет вот такое определение:

-- Слева имя функции, затем идет список параметров
-- разделенных пробелами и после знака => тело функции
*/
sum a b c => a + b + c

/*
А ее вызов выглядит так:
-- Скобок и запятых нет, но это равносильно sum(4, 3, 1) в js
*/

sum 4 3 1 -- 8
sum 1 1 1 -- 3

/*
Ha необычный язык, если внутри него вызвать функцию с неполным набором параметров, то в отличии от js он не вызовет саму функцию (или не упадет с ошибкой как во многих других языках). Он вернет новую функцию, которая "частично применена".

-- sum2 новая функция, полученная частичным применением функции sum к числу четыре
-- Применение "частичное" потому что в функцию sum передается только один параметр, а не три
*/

sum2 = sum 4
sum2 1 1 -- 6
sum2 3 2 -- 9

/*
Другими словами, такой вызов создает новую функцию, которая работает точно так же как и исходная, но, при этом, часть ее аргументов как будто уже подставлены. То есть наш вызов sum2 1 1 в действительности приведет к вызову sum 4 1 1. Этот трюк работает с любым количеством аргументов. Посмотрите на частичное применение двух аргументов:
*/

sum3 = sum 1 1
-- sum3 принимает только один аргумент
sum3 2 -- 4
sum3 1 -- 3

/*
Арифметика аргументов очень простая. Если исходная функция принимала 3 параметра, то после частичного применения одного параметра, новая функция будет принимать на вход два параметра (2 + 1 = 3), если частично применились два параметра, то новая функция принимает на вход 1 параметр. А можно ли частично применить три параметра для функции которая принимает на вход 3 параметра? Конечно нет, ведь это будет обычный вызов функции со всеми параметрами. Довольно несложно догадаться как выглядело бы определение функций sum2 и sum3 если бы мы их описали явно:
*/

sum a b c => a + b + c
sum2 b c => 4 + b + c
sum3 c => 1 + 1 + c

// Ha настолько необычный язык, что позволяет частично применять то что уже было частично применено:

-- Создаем первую функцию с 3 - 1 аргументами
sum4 = sum 2
-- Создаем вторую функцию с 2 - 1 аргументами
sum5 = sum4 3
-- Вызываем то что получилось. В реальности вычисляется 2 + 3 + 1
sum5 1 -- 6
sum5 4 -- 9

// В js эта возможность не встроена прямо в сам язык, но ее можно реализовать с помощью дополнительной функции:

const sum = (a, b, c) => a + b + c;

// Берем исходную функцию sum и отдаем ее в функцию partialApply

const sumWithFour = partialApply(sum, 4);
sumWithFour(3, 1); // 8
sumWithFour(10, 3); // 17

const sumWithFourAndTwo = partialApply(sumWithFour, 2);
sumWithFourAndTwo(3); // 9

/*
Функция partialApply принимает на вход исходную функцию и параметры которые нужно применить, а возвращает новую, частично примененную функцию.

Вот как может выглядеть реализация partialApply для функций от трёх аргументов (таких как sum):
*/

const partialApply = (fn, arg1) => (arg2, arg3) => fn(arg1, arg2, arg3);

/*
Немного примеров из реальности. Предположим, что мы пишем программу, вычисляющую зарплату людей разных специальностей по всему миру. Для этого используется функция getAverageSalary.
*/

const salary1 = getAverageSalary('programmer', 'spain');
const salary2 = getAverageSalary('programmer', 'russia');
const salary3 = getAverageSalary('programmer', 'usa');

/*
Первым параметром функция принимает на вход название профессии, вторым — страну, на выходе — годовая зарплата. Все довольно примитивно, но часть данных дублируется. Вычисляется зарплата программистов в разных странах, что приводит к постоянному вызову функции с первым параметром programmer. В этом нет ничего криминального, но существует способ устранить подобное повторение. Убрать с помощью введения дополнительной константы.
*/

const job = 'programmer'
const salary1 = getAverageSalary(job, 'spain');
const salary2 = getAverageSalary(job, 'russia');
const salary3 = getAverageSalary(job, 'usa');

/*
Название профессии больше не повторяется, но нам по-прежнему приходится подставлять его в каждый вывод. Здесь на помощь приходит так называемое частичное применение функции.
*/

const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Принцип действия частичного применения функции основан на генерации (в нашем случае с помощью функции partialApply) новой функции оборачивающей старую, причем так, что она принимает на вход меньшее количество аргументов. Для нашей задачи мы применили один аргумент, но это не обязательно. Применять можно любое число аргументов исходной функции (но, естественно, не все, ведь в таком случае мы получим обычный вызов функции). И хотя пример выше выглядит слегка искусственным, в реальной жизни этот прием применяется часто. Причем нередко частично применяется больше одного аргумента за раз.

Тело функции getProgrammersSalaryByCountry выглядит предсказуемо. Внутри вызывается исходная функция с подставленным в аргумент значением.
*/

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);

// А partialApply для функций от двух аргументов, реализуется способом очень похожим на реализацию flip.

const partialApply = (fn, arg1) => arg2 => fn(arg1, arg2);

/*
То есть функция partialApply возвращает (генерирует) функцию, которая внутри себя замыкает два параметра: fn и arg1.

Частичное применение для JS — практически как воздух для живых организмов. Из-за асинхронной природы JS часто бывают ситуации, когда одни параметры функции задаются в одном месте, а другие в другом, так как они становятся доступны только после выполнения асинхронной операции. Поскольку вы еще не обладаете достаточными знаниями для понимания соответствующего кода, я не буду приводить более сложных примеров, чтобы не сбивать вас с толку, но уверяю, что в дальнейших курсах все, что изучалось здесь, будет использоваться на полную катушку.

Возможно ли частичное применение без замыкания?
> Нет. Частичное применение подразумевает запоминание аргументов функции/


/**
Реализуйте и экспортируйте по умолчанию функцию partialApply. Эта функция умеет частично применять один (второй) аргумент у переданной функции:
**/

const pow = (a, b) => a ** b;
const f1 = partialApply(pow, 2);
f1(1); // => 1
f1(10); // => 100

const f2 = partialApply((a, b) => a * b, 5);
f2(2); // => 10
f2(5); // => 25


// file: app/partialApply.js:

export default (f, second) => first => f(first, second);

export default partialApply;


## TESTS:

// file: app/__tests__/partialApply.test.js:

import partialApply from '../partialApply';

test('partialApply', () => {
  const f1 = partialApply((a, b) => a ** b, 2);
  expect(f1(1)).toBe(1);
  expect(f1(10)).toBe(100);

  const f2 = partialApply((a, b) => a * b, 5);
  expect(f2(2)).toBe(10);
  expect(f2(5)).toBe(25);
});


>>>>> Каррирование <<<<<

/*
Каррирование — очень интересная техника, позволяющая сильно упростить использование частичного применения на практике. Многие путают эти понятия, но, как вы увидите далее, они обозначают совершенно разные вещи.

В предыдущем уроке нам приходилось писать функцию-обертку для применения.
*/

const getProgrammersSalaryByCountry =
  country => getAverageSalary('programmer', country);

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Eсли бы наша функция getAverageSalary была каррирована, то все было бы значительно проще. Каррирование — это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.

Предположим, что у нас есть функция const sum = (a, b, c) => a + b + c, которая складывает три числа. Тогда ее каррированная версия будет выглядеть так: const sum2 = a => b => c => a + b + c, а использование таким: sum2(5)(10)(-2). То же самое, разложенное по функциям:
*/

const sum2 = (a) => {
  return (b) => {
    return (c) => {
      return a + b + c;
    };
  };
};

/*
Посмотрите внимательно на определение a => b => c => a + b + c. Эта запись очень краткая и одновременно очень емкая. Суммарное количество функций считается очень легко, оно равно сумме всех стрелок =>. Для лучшего понимания можно добавить скобки a => (b => (c => a + b + c)). Для каждого определения функции все, что находится справа от стрелки, является ее телом, каким бы сложным оно не было. Поначалу такая запись может помочь понять, как друг в друга вложены функции, но со временем, когда вы привыкните к обычной записи, она будет больше мешать.

С другой стороны, если нам нужно каррировать существующую функцию без ее реализации, то делается это так: const sum2 = a => b => c => originalSum(a, b, c). То есть создается цепочка вложенных функций, в которой количество вложений равно количеству аргументов исходной функции и в конце которой происходит вызов оригинальной функции.

Разберем происходящее по шагам.
*/

const sum = a => b => c => a + b + c;
const sum1 = sum(10); // sum1 = b => c => 10 + b + c
const sum2 = sum1(3); // sum2 = c => 10 + 3 + c
const result = sum2(0); // result = 10 + 3 + 0
console.log(result); // 13

/*
То же самое происходит и при таком вызове: sum(10)(3)(0), разница только в том, что вызовы происходят без создания промежуточных констант.

И задача для самоконтроля. Сколько раз нужно вызвать цепочку функций const greeting = () => () => () => () => console.log('Hey!'), чтобы дойти до конца? Обязательно попробуйте прямо сейчас выполнить это задание на repl.it.

Теперь вернемся к нашей функции расчета зарплаты в ее каррированном виде. Представим, что теперь у нас в распоряжении две вложенных функции от одного аргумента: const getAverageSalary = job => country => /* body */:

const salary1 = getAverageSalary('programmer')('spain');
const salary2 = getAverageSalary('programmer')('russia');
const salary3 = getAverageSalary('programmer')('usa');

// Попробуем частично применить:

const getProgrammersSalaryByCountry = getAverageSalary('programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

/*
Применение в реальной жизни

В функциональных языках, подобных haskell, вопросов об использовании каррированных функций просто не встает. Они там используются постоянно, начиная с самых азов. Это одна из причин, почему стоит учить подобные языки, даже если вы не будете писать на них программы. В императивных языках такое происходит значительно реже, но не в JS. JS по своей сути очень близок к функциональным языкам. Изначально он должен был быть написан на Scheme, языке из семейства Lisp, и функции в нем занимают центральное место. Каррирование используется в различных библиотеках и иногда является их ключевой "фичей", как, например, здесь: https://github.com/substantial/updeep.

/**
Удивительно, но факт — условные конструкции можно реализовать самостоятельно с использованием одних лишь каррированных функций.

В этой практике мы реализуем упрощённую версию, имитирующую работу условной конструкции if.

Экспортируйте тройку True, False, If, используя только функции, внутри которых только функции ;) То есть нельзя пользоваться встроенными в язык if, а также true и false. Сами функции должны быть каррированы.

Пример использования:
**/

import { If, True, False } from './logic';

If(True)('one')('two');  // one
If(False)('one')('two'); // two

/*
Подсказки
Общая схема работы функций такова:
*/

If(func)('one')('two'); // ?

/*
То есть, в итоге должно вернуться то или иное значение, в зависимости от того, какая функция передана на вход If.
Если функции If была передана True, то выражение ниже вернёт значение аргумента первого вызова (one):
*/

const ConditionFunction = If(True);
ConditionFunction('one')('two'); // one

// Если функции If была передана False, то выражение ниже вернёт значение аргумента второго вызова (two):

const ConditionFunction = If(False);
ConditionFunction('one')('two'); // two


// file: app/logic.js 


# TESTS:

import { If, True, False } from '../logic';

test('Boolean', () => {
  expect(If(True)('fo')('bar')).toBe('fo');
  expect(If(False)('foo')('ba')).toBe('ba');
  expect(True()()).toBeUndefined();
  expect(False()()).toBeUndefined();
});


/**
Реализуйте и экспортируйте по умолчанию каррированую версию функции, которая принимает на вход три строки и возвращает новую строчку составленную из трех входных.
**/
// исходная версия
concat('a', 'bc', 'f'); // => abcf

// каррированая версия
concat('a')('bc')('f'); // => abcf


// file: app/concat.js

export default str1 => str2 => str3 => `${str1}${str2}${str3}`;


// file: app/__tests__/compose.test.js

import concat from '../concat';

test('compose', () => {
  expect(concat('')('')('')).toBe('');
  expect(concat('a')('bc')('f')).toBe('abcf');
});

/**
Реализуйте и экспортируйте по умолчанию функцию compose, которая принимает на вход две других одноаргументных функции и возвращает новую функцию. Эта новая функция также принимает на вход один параметр и при вызове применяет его последовательно к переданным функциям в обратном порядке.

Примеры ниже помогут понять, как должна работать функция:
**/

const f = compose(Math.sqrt, Math.abs);
f(-4); // => 2

compose(v => v, v => v)(10); // => 10
compose(v => v + 2, v => v)(10); // => 12
compose(v => v, v => v - 2)(10); // => 8
compose(v => v ** 2, v => v - 2)(2); // => 0
compose(v => v - 2, v => v ** 2)(2); // => 2


// file: app/compose.js:

export default (f, g) => x => f(g(x));

# TESTS:

// file: app/__tests__/compose.test.js:

import compose from '../compose';

test('compose', () => {
  expect(compose(v => v, v => v)(10)).toBe(10);
  expect(compose(v => v + 2, v => v)(10)).toBe(12);
  expect(compose(v => v, v => v - 2)(10)).toBe(8);
  expect(compose(v => v ** 2, v => v - 2)(2)).toBe(0);
  expect(compose(v => v - 2, v => v ** 2)(2)).toBe(2);
});


/** 
Числа Черча
В 30-х годах прошлого века перед математиками встала так называемая проблема разрешения (Entscheidungsproblem), сформулированная Давидом Гильбертом. Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение. Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? Ответ был найден двумя великими учёными того времени Алонзо Чёрчем и Аланом Тьюрингом. Они показали (первый — с помощью изобретённого им λ-исчисления, а второй — теории машины Тьюринга), что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима.

Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики. Пока в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…

В основе лямбда-исчисления лежит понятие, известное ныне каждому программисту, — анонимная функция. В нём нет встроенных констант, элементарных операторов, чисел, арифметических операций, условных выражений, циклов и т. п. — только функции, только хардкор. Потому что лямбда-исчисление — это не язык программирования, а формальный аппарат, способный определить в своих терминах любую языковую конструкцию или алгоритм. В этом смысле оно созвучно машине Тьюринга, только соответствует функциональной парадигме, а не императивной.

Как уже говорилось ранее, в чистом бестиповом лямбда-исчислении отсутствует всё, кроме функций. Так что даже такие элементарные вещи, как числа или булевы значения необходимо реализовывать самим. Точнее, надо создать некие активные сущности, которые будут вести себя подобно необходимым нам объектам. И, естественно, процесс кодирования будет заключаться в написании соответствующих функций.

Натуральные числа реализованные посредством лямбда-исчисления, называются числами Черча, и являются отличной разминкой для мозга. В основе реализации по-прежнему будут лежать функции, ведущие себя в заданном контексте подобно единице, двойке и т.д. Собственно, это одна из особенностей лямбда-исчисления: сущности, записанные в его терминах, не обладают самодостаточностью, поскольку воплощают поведение того или иного объекта.

Реализуйте число Zero и операцию Succ (увеличение на единицу). Не забудьте про экспорт.
Пример:
*/

const two = Succ(Succ(Zero));

// Немного хитрый способ трансформировать число черча в обычное представление.
// Откровенно говоря, устройство самих чисел еще хитрее ;)

two(x => x + 1)(0); // 2

const four = Succ(Succ(two));
four(x => x + 1)(0); // 4


// file: app/numerals.js:

const Zero = 0;
const Succ = (num) => num + 1;

## TESTS:

// file: app/__tests__/numerals.test.js

import { Zero, Succ } from '../numerals';

it('numerals', () => {
  const two = Succ(Succ(Zero));
  expect(two(x => x + 1)(0)).toBe(2);

  const four = Succ(Succ(two));
  expect(four(x => x + 1)(0)).toBe(4);

  expect(four(two(x => x + 1))(0)).toBe(8);
});



########### JS: Настройка окружения ###########

// Ubuntu
$ curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash -
$ sudo apt install -y nodejs

/*
Теперь убедимся в том, что Node.js поставлена и работает. Вероятно, в некоторых операционных системах понадобится перезапустить терминал или даже перезагрузиться.
Проверяем:
*/

$ node -v
v10.0.0

/*
Версия, которую вы увидите, должна быть не ниже 8.

Если все прошло удачно, самое время повыполнять код на js. Node.js поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для ее запуска достаточно набрать node:
*/

$ node
>

/*
Если все прошло успешно, то REPL выведет приглашение для ввода инструкций: >. Попробуйте поиграться с ним. Наберите любое арифметическое выражение, например, 1 + 3 и нажмите Enter. Обратите внимание на то, что нет необходимости использовать console.log. REPL автоматически распечатывает последний вычисленный результат.

Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:
*/

$ node
> a = 5
5
> b = 10
10
> a + b
15

/*
Чтобы выйти из REPL, нужно либо набрать .exit и нажать Enter, либо два раза нажать CTRL + C

Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях когда репла недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением js, например, index.js, а затем запустить:
*/
// file: index.js
console.log('hello!');

$ node index.js
hello!

/*
# NVM
Совсем другой способ установки Node.js — утилита nvm. Кроме установки любых версий Node.js, она позволяет удобно переключаться между версиями. Это может понадобится, когда вы одновременно работаете над двумя проектами, требующими разные версии Node.js.


# ECMAScript

Основа js — язык ECMAScript. ECMAScript — это встраиваемый, расширяемый, не имеющий средств ввода-вывода (то есть он не может писать и читать файлы) язык программирования, используемый в качестве основы для построения других скриптовых языков. По сути, он существует только на бумаге. Стандартизирован международной организацией ECMA в спецификации ECMA-262. js основан на ECMAScript, но расширяет его. Кстати, js не единственный язык, расширяющий ECMAScript. Кроме него также используются JScript и ActionScript.

Интересно, что сам по себе ECMAScript никакого отношения ни к браузерам, ни к вебу не имеет. Несмотря на это, сам ECMAScript развивается и имеет не одну версию, которая также называется стандартом:

es3
es5.1
strict mode
ECMAScript 2015 (es6)
es7 ?

# JavaScript

JavaScript — динамический, слабо типизированный, интерпретируемый язык программирования. Разберем эти слова по отдельности.
*/

$ node
> 3 + '8ha'
'38ha'
> '8ha' * 3
NaN
> true + 1
2



>>>>> NPM <<<<<

/*
Ключевая задача, которую решает npm — управление зависимостями.

В npm используются следующие понятия:

* Пакет (Package) — библиотека, которую мы пишем или используем в проекте как зависимость.
* Репозиторий (Registry) — хранилище пакетов npm. Каждый желающий может опубликовать пакет в npm registry, потратив буквально минуту, а остальные смогут его использовать. В хранилище на текущий момент сотни тысяч пакетов и их количество стремительно растет. Исходный код пакетов, как правило, хранится на гитхабе. Несмотря на это, пакеты в npm никак не связаны с git и github.
* Публикация — процесс выкладки новой версии пакета в репозиторий.

# Глобальная установка пакетов
Многие пакеты в npm представляют из себя законченные программы. Их можно установить и запустить как обычную утилиту командной строки. Попробуем установить утилиту sloc, которая умеет считать количество строк кода в указанной папке. Инструкция по установке обычно находится на странице репозитория https://github.com/flosse/sloc в гитхабе.
*/

$ sudo npm install -g sloc

# Создайте файл index.js и добавьте туда любой код (например, печать на экран)
# Затем вызовите программу sloc, используя терминал. Для этого перейдите в директорию, содержающую этот файл, и выполните команду:

$ sloc index.js
/*
---------- Result ------------

            Physical :  2
              Source :  2
             Comment :  0
 Single-line comment :  0
       Block comment :  0
               Mixed :  0
               Empty :  0
               To Do :  0

Number of files read :  1

------------------------------

# Проект

npm работает таким образом, что объединяет понятия «проект» (то есть приложение или application) и «пакет» в одно целое. Считается, что проект, в отличие от пакета, это конечный продукт, который никуда не публикуется. Если компания делает сайт на Node.js, то этот сайт сам по себе хранится в приватном репозитории и никуда не утекает, хотя и использует публичные зависимости. Но с точки зрения npm разницы между проектом и пакетом нет. Причем проект может быть любых размеров. Даже если ваше приложение состоит из 3 строчек кода и использует зависимости, вам понадобится работать с ним как с полноценным проектом. Сначала необходимо выполнить команду npm init в той папке, где вы собираетесь писать код. С этого момента эта папка будет корневой для проекта.
*/
$ npm init

/*
создаст файл package.json =>
{
  "name": "My Super Project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

Воспользуйтесь валидаторами JSON для проверки верности своего файла: jsonlint.com

# Зависимости

В файл package.json можно добавить две секции: dependencies и devDependencies. В них необходимо указать пакеты, от которых зависит проект. Две секции понадобилось для разделения тех зависимостей, которые нужны при использовании библиотеки и тех, которые нужны только для тестирования и локальной разработки. Например, тесты при использовании пакета совершенно ни к чему, поэтому их зависимости можно смело описывать в devDependencies.

Предположим, что наш пакет зависит от библиотеки lodash. Это очень популярная библиотека на JS, содержащая сотни полезных функций на все случаи жизни.
Процесс установки:
*/
$ npm install --save lodash

/*
Секция dependencies теперь выглядит примерно так:
"dependencies": {
  "lodash": "^4.2.1"
}

Точно таким же способом ставятся последующие зависимости. Если зависимость должна оказаться в devDependencies, то команда установки меняется так:
*/

$ npm install --save-dev jest


// Использование установленных зависимостей:
import { union } from 'lodash';

/*
Обратите внимание на то, как написано слово lodash. Перед ним нет ./, именно так Node.js понимает, что это внешняя зависимость, а не файл, лежащий рядом. Если зависимость была установлена, то все должно заработать, иначе код упадет с ошибкой. Node.js ищет подобные зависимости сначала в локальной папке node_modules, затем в той, куда устанавливаются пакеты глобально. Важно никогда не полагаться на глобально установленные пакеты. Все, что используется в проекте, должно быть явно описано в package.json и установлено локально.

К сожалению, на текущем этапе код, указанный выше, не будет работать в любом случае. Связано это с тем, что Node.js напрямую не поддерживает синтаксис импортов и для их использования нужно подключить пакет Babel. Подробно об этом в другом уроке.

Сами зависимости не хранятся в git-репозитории и должны быть добавлены в .gitignore:
*/

// .gitignore
node_modules

/*
Если вы клонировали репозиторий с гитхаба, папка node_modules будет отсутствовать, как и пакеты в ней. Первое, что нужно сделать в этом случае — выполнить команду npm install. Эта команда, запущенная без аргументов, выполняет установку тех пакетов, которые указаны в файле package.json. Она запускается в разных случаях: если вы удалили папку node_modules и хотите снова ее восстановить или если вы только что клонировали репозиторий. Установка пакетов — идемпотентная операция, поэтому ее можно запускать сколько угодно раз, не боясь что-либо сломать.

# Пакет

Все, что описывалось выше для проекта, так же применимо и для пакета. Единственное ключевое отличие стоит в том, что пакет нужно опубликовать, если вы хотите, чтобы другие могли им пользоваться. Для этого обязательно нужно изменить версию, указанную в package.json, так как нельзя опубликовать уже опубликованную версию. Тот код, который был опубликован, не может изменяться, ведь на него завязываются другие. Затем нужно выполнить одну-единственную команду в той же папке, в которой лежит package.json вашего пакета:
*/

$ npm publish

/*
Для успешной публикации должны выполниться два условия:

Имя пакета уникально. Если оно не уникально, то пакет опубликован не будет.
Вы зарегистрированы на сайте https://www.npmjs.com/
Ниже пример вывода успешной публикации пакета:
*/

$ npm publish

> nodejs-package@0.0.2 prepublishOnly .
> npm run build


> nodejs-package@0.0.2 build /Users/mokevnin/projects/nodejs-package
> NODE_ENV=production babel src --out-dir dist --source-maps inline

src/bin/hexlet.js -> dist/bin/hexlet.js
src/half.js -> dist/half.js
src/index.js -> dist/index.js
+ nodejs-package@0.0.2

/*
Вывод может быть довольно большим. Главное, что здесь не видно явных ошибок и в конце такая строчка: + nodejs-package@0.0.2. Она сигнализирует о том, что пакет с именем nodejs-package был добавлен в npm репозиторий под версией 0.0.2. Как только публикация пройдет, ваш пакет автоматически станет доступным для установки. Убедиться в этом можно следующим образом:
*/

$ sudo npm install -g nodejs-package
Password:
npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
npm WARN deprecated graceful-fs@1.2.3: graceful-fs v3.0.0 and before will fail on node releases >= v7.0. Please update to graceful-fs@^4.0.0 as soon as possible. Use 'npm ls graceful-fs' to find it in the tree.
/usr/local/bin/hexlet -> /usr/local/lib/node_modules/nodejs-package/dist/bin/hexlet.js
+ nodejs-package@0.0.2
added 187 packages in 16.11s

/*
Как видите, в конце снова появляется строчка + nodejs-package@0.0.2, но теперь она означает что пакет nodejs-package версии 0.0.2 был установлен.

И для полноты картины еще два способа найти нужный пакет и убедиться что он есть в npm репозитории:

Поискать на сайте https://www.npmjs.com/
Выполнить команду npm info nodejs-package. Если вы увидите информацию о пакете, то все хорошо. В противном случае возникнет ошибка.
Остается вопрос правильной нумерации новых версий пакетов. Для этого был придуман стандарт, названный SEMVER. Его описание занимает буквально пару страниц на русском языке. Обязательно ознакомьтесь.

Дополнительные материалы
NPM https://www.npmjs.com/
Документация NPM https://docs.npmjs.com/


В чём разница между секциями dependencies и devDependencies в структуре конфигурационного файла package.json?
> Секцию dependencies необходимо использовать для описания зависимостей, которые будут нужны при использовании программы, а devDependencies только для тестирования и локальной разработки.


Как правильно использовать установленную библиотеку (например hexlet-pairs) в файле с кодом?
*/
> import { cons, car, cdr } from 'hexlet-pairs';



############################### JS: DOM API ###############################   

/*
Большое количество языков либо созданы поверх js либо позволяют транслировать свой код в js. 
К таким языкам относятся: clojurescript, typescript, kotlin, java, elm.

#  JavaScript в браузере


<html>
  <body>
    <script>
      const greeting = 'hello, world!';
      alert(greeting);
    </script>
  </body>
</html>

alert, confirm и prompt - эти функции присутствуют только в браузерах и недоступны в серверных версиях js. Это первый пример, когда мы видим как браузер "расширяет" js, добавляя туда новые возможности. Но не возможности самого языка, язык-то как раз остается тем же, а возможности по взаимодействию со средой.
*/


>>>>> JavaScript в браузере <<<<<

/*
# Внешние скрипты

Инлайн скриптинг, как правило, используется для небольших кусков кода, или для вызова кода, загруженного из внешних скриптов. Загружаются внешние скрипты следующим образом:

<body>
<html>
  <head>
    <script src="/assets/application.js"></script>
  </head>
  <body>
  </body>
</html>

Довольно часто можно увидеть подобный вариант загрузки:

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/core.js"></script>

В примере выше, файл грузится с CDN (https://ru.wikipedia.org/wiki/Content_Delivery_Network), что может давать определенные преимущества в скорости загрузки.

# Скорость
В зависимости от того, в каком месте документа появляются теги script, вы можете наблюдать серьезные изменения как в скорости отрисовки сайта, так и в скорости загрузки.

# Server (Nodejs) vs Client (Browser)

В браузере отсутствует множество тех вещей, с которыми мы привыкли иметь дело работая в серверном окружении. Среди них:

# Стандартная библиотека
Про библиотеку (https://nodejs.org/api/modules.html) можно забыть. Из коробки никаких assert, events, net, http, url и всего остального. Для любой простейшей задачи придется подключать библиотеку из npm.

# Модули
До недавнего времени, модульной системы в браузерах не существовало. Сейчас она появляется, но пока только в экспериментальном варианте.

На текущий момент, любой загруженный код, работает в глобальной области видимости. Такое поведение привело к большому количеству обходных маневров используемых повсеместно для ручной изоляции кусков js друг от друга.

<html>
  <body>
    <script>
      const greeting = 'hello, world!';
    </script>
    <script>
      alert(greeting);
    </script>
  </body>
</html>

Самый распространенный способ изоляции называется Immediately-Invoked Function Expression. Его принцип действия крайне прост: весь код, который должен быть выполнен в браузере, заворачивается в анонимную функцию, которая сразу же вызывается:
*/

(function() {
 // some code…
})();


/*
Как вы позже увидите, современные системы сборки избавляют нас от необходимости делать такие манипуляции руками. Мы можем продолжать использовать привычный и полноценный javascript.

Версии и движки
Еще один существенный недостаток js в браузере в том, что реализация js в разных браузерах отличается и иногда весьма существенно. Более того, даже разные версии одного и того же браузера могут отличаться катастрофически. Причем, эту проблему решить невозможно, она является следствием самой природы фронтенда. У каждого пользователя будет стоять тот браузер, который ему нравится, той версии, до которой он не забыл обновиться.

Сборка
К счастью, современный мир фронтенда смог выкрутиться из этой ситуации. Мы по прежнему можем пользоваться всеми (почти) современными фишками js, включая систему модулей. Возможно это благодаря babel с одной стороны и сборщиками, подобными webpack, с другой. Ну и нельзя не упомянуть про полифиллы, которым будет посвящен отдельный урок.

Принцип работы этой связки заключается в том, что сборщик по определенным правилам собирает все наши ресурсы (css, fonts, images) и файлы с кодом, пропускает их через обработчики, например, babel и на выходе мы получаем файлы, готовые к использованию в браузере.


Безопасность
Во всех браузерах поддерживается механизм под названием cookies, который мы изучали в курсе по протоколу http. Этот механизм играет центральную роль в реализации такой вещи, как аутентификация. После того, как сайт вас опознал, он выставляет специальную сессионную куку и на основе нее определяет залогинены вы на сайте или нет.

Как вы, возможно, помните, js позволяет обращаться к вашим кукам. Это автоматически означает, что если злоумышленнику удастся разместить произвольный код на странице сайта, то он сможет прочитать вашу сессионную куку и передать ее в нужное место. Так легко и беззаботно уводятся сессии и пользователи внезапно оказываются без своего аккаунта. Ни антивирус, ни фаервол в такой ситуации ничем помочь не смогут.

Внедрение произвольного кода на сайт называется XSS (Cross-Site Scripting) и является популярным способом атаки, кроме него так же распространен CSRF (Cross-Site Request Forgery).
*/


>>>>> Глобальный объект Window <<<<<


/*
Если в консоли браузера выполнить команду console.log(this), то на экран будет выведен некий Window.

Window — это глобальный объект, то есть доступный из любого места всегда. Он не является частью js и предоставляется браузерами. Как правило, к нему обращаются по имени window, так как this из-за позднего связывания указывает на него не всегда.

Обратите внимание на то, что функция alert находится в объекте window. Другими словами, когда мы вызываем функцию alert, то в действительности происходит вызов window.alert. Более того, все глобальные объекты js тоже принадлежат window.
*/
window.console.log('hey');
window.Math.abs(5);

/*
# Объектная модель браузера
Это набор глобальных объектов, управляющих поведением браузера. Все они так же находятся внутри window. Разберем некоторые из них.

# Navigator
Предоставляет информацию о браузере, такую как версию, название, используемую локаль, доступные права, подключенные плагины.

# Location
Позволяет управлять адресной строкой. Например, вот так можно инициировать загрузку другой страницы:
*/

location.href = "https://hexlet.io";

/*
# History
С помощью этого объекта можно перемещаться по истории переходов, а так же формировать ее в тех ситуациях, когда не происходит реального переход по страницам. Это особенно актуально для SPA.

# Fetch
Современный метод для выполнения AJAX запросов. Именно с помощью fetch происходит общение с сервером и другими сайтами.
*/


>>>>> Что такое DOM? <<<<<

/*
С высоты птичьего полета процесс отображения страницы можно представить следующим образом:

1. Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью DNS)

  GET /courses HTTP/1.1
  HOST: ru.hexlet.io

2. Пришедший в ответ html парсится, и на его основе строится DOM дерево

3. Браузер рисует страницу, используя DOM дерево (упрощенно).

Чтобы понять, что такое DOM и, в частности, DOM дерево, рассмотрим следующий пример.
*/

const json = '{ "key": "value" }';
const obj = JSON.parse(json);

console.log(obj.key); // value

/*
Как мы помним, json — это текстовый формат, используемый для взаимодействия между разными программами, которые, возможно, написаны на совершенно разных языках. Одна программа сериализует данные в json, а другая десереализует их во внутренние структуры своего языка.

Думаю, достаточно очевидно, что программа, получившая какие-то данные в виде json, не сможет работать с ним, если он останется в текстовом представлении, ведь по сути это строчка текста.

Теперь, попробуем понять смысл DOM дерева:
*/

// Гипотетический пример, так как модуля HTML не существует в природе

const html = `
  <body>
    <p>hello, <b>world</b>!</p>
  </body>
`;

const document = HTML.parse(html);
console.log(document.firstChild.name); // html

/*
Грубо говоря, html можно сравнить с json. Другими словами, html — это текстовое представление DOM дерева, не зависящее от языка программирования. То, что оно является деревом, видно невооруженным взглядом, так как теги вкладываются в теги.

Каждый html-тег становится узлом этого дерева, а теги, вложенные в него, становятся дочерними узлами. Для представления текста создаются специальные текстовые узлы.

Важно то, что в DOM дерево попадают все элементы, представленные в html, включая пробелы и переводы строк.

С DOM tree разобрались, теперь попробуем разобраться с тем, что же, собственно, такое DOM.

Объектная модель документа (Document Object Model) - это не зависящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

На практике, во фронтенд разработке это сводится к тому, что браузер предоставляет специальный объект document, который содержит внутри себя DOM tree и который наполнен большим количеством методов (согласно спецификации DOM) для манипулирования этим деревом. Любые изменения, которые производятся с ним, сразу же отображаются браузером на странице.

Подавляющее число возможностей, связанных с DOM, описаны в спецификациях раз https://dom.spec.whatwg.org/ и два https://html.spec.whatwg.org/ и, по идее, должны работать одинаково во всех браузерах. К сожалению, это не так. DOM развивается, но браузеры двигаются медленнее. Кроме того, существует множество исторических решений, которые приводят к проблемам.

# Восстановление
Те, кто сталкивались с html в реальной жизни, прекрасно знают, что если подать на вход браузеру невалидный html с незакрытыми тегами, нарушенной вложенностью и другими проблемами, то мы не получим сообщений об ошибках. Браузер переварит этот html и что-то отобразит на экране. Возможно, вам не понравится то, что вы увидите, но, по крайней мере, оно будет работать.

Браузер действительно восстанавливает структуру и делает это по очень хитрым правилам. И это логично, иначе было бы невозможно произвести парсинг в принципе. Но есть и другая причина: даже если сам html будет валидным, браузер при создании DOM tree добавляет в него узлы (представленные тегами в html), которые вы, возможно, пропустили, но стандарт требует их наличия. Например, в таблицы добавляется tbody.


Именно DOM открывает практически безграничные возможности по изменению страниц. Все библиотеки (jquery и другие) и фреймворки (angular, react) внутри себя манипулируют DOM. Это та база, вокруг которой построено всё во фронтенд разработке.
*/


>>>>> DOM Дерево <<<<<

/*
Корневым элементом в DOM дереве считается элемент html. Доступ к нему можно получить так: document.documentElement.

Навигация по дереву достаточно интуитивная, поэтому можно смело экспериментировать в браузере:
*/

const html = document.documentElement;
// Read-only
html.childNodes; // [head, text, body]
html.firstChild; // <head>...</head>
html.lastChild; // <body>...</body>
html.childNodes[1]; // #text

// Из-за того, что body и head всегда присутствуют внутри документа, их вынесли на уровень объекта document для более простого доступа:

document.head;
document.body;

// Кроме того, что можно идти вглубь дерева, так же можно идти и наружу:

document.documentElement === document.body.parentNode;
document.body === document.body.childNodes[2].parentNode;

/*
# childNodes

В работе с childNodes есть несколько интересных моментов.

1. Это свойство доступно только для чтения. Попытка что то записать в конкретный элемент не приведет к успеху:
*/

document.body.childNodes[0] = 'hey';

/*
Изменение DOM дерева осуществляется специальным набором методов.

Хотя childNodes и является коллекцией, это все же не массив. В нем отсутствует привычные методы, такие как map, filter и другие. Для перебора элементов можно воспользоваться итератором или сделать так:
*/

const elements = document.documentElement.childNodes;

elements.toString()
"[object NodeList]"

[...elements]; // теперь это массив

// либо так
elements.forEach(el => console.log(el));

/*
# Иерархия

Хотя каждый узел дерева и представлен типом Node, но в реальности это базовый тип. А каждый конкретный элемент имеет свой. Другими словами, у нас есть определенная иерархия типов.

Ноды с типами Text и Comment являются листовыми, то есть они не могут иметь детей. А вот элементы — это то, с чем приходится иметь дело чаще всего. Как видите, в DOM HTMLElement — это отдельное направление, потому что DOM также может представлять и xml документы.

На практике чаще всего нас интересуют не ноды, а элементы. Именно ими мы манипулируем, перемещаемся сквозь них. Это настолько важно, что в DOM есть альтернативный способ обхода дерева, который построен только на элементах

# Специальная навигация

Некоторые элементы обладают специальными свойствами для навигации по ним, к таким элементам относятся, например, формы и таблицы.

<table>
  <tr>
    <td>1.1</td>
    <td>1.2</td>
    <td>1.3</td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>2.2</td>
    <td>2.3</td>
  </tr>
</table>

*/

const table = document.body.firstElementChild
table.rows[0].cells[2];

// Этот способ навигации не заменяет основные. Он сделан исключительно для удобства в тех местах где это имеет смысл.