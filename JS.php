<?

############## JS ##############


>>>>> Guard Expression <<<<<<<

/*
Одни функции устроены сложнее других. Иногда так происходит в силу объективных причин (необходимая сложность). Иногда — в силу особенностей писавшего её программиста (случайная сложность). И хотя нельзя однозначно описать эту сложность, существуют способы, позволяющие хотя бы частично её оценить.

# Цикломатическая сложность
Цикломатическая сложность — это структурная, или топологическая, мера сложности компьютерной программы, разработанная Томасом Дж. Маккейбом в 1976 году.

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только один маршрут через код.

Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один, если условие оператора if имеет значение true, и один — если false.

Такую оценку можно применять как в целом к программе, так и к отдельным функциям.
*/

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);

abs(10); // => 10
abs(-3); // => 3

/*
В примере выше у функции sum цикломатическая сложность равна единице, а у функции abs — двойке, так как она содержит ветвление, а значит два независимых пути выполнения.

Чем больше возможных путей выполнения, тем сложнее функцию понять, отладить и модифицировать. Очевидно, что, с одной стороны, функции нужно дробить, а с другой — описывать логику программы так, чтобы не появлялись лишние пути. Даже опытные разработчики часто сталкиваются с этой проблемой.

Линтеры многих языков измеряют показатель сложности и сигнализируют, если он, скажем, больше 5 для одной функции.

# Guard Expression
Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:
*/

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

/*
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.
*/

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

/*
Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.

/**
Реализуйте и экспортируйте по умолчанию функцию isPalindrome с использованием рекурсии.

Примеры использования:
import isPalindrome from './isPalindrome';

isPalindrome('radar'); // => true
isPalindrome('a');     // => true
isPalindrome('abs');   // => false
**/

// file: App/isPalindrome.js: 

#1:
const isPalindrome = (string) => {
  if (string.length <= 1) {
    return true;
  }

  const firstSymbol = string[0];
  const lastSymbol = string[string.length - 1];

  if (firstSymbol !== lastSymbol) {
    return false;
  }

  const stringWithoutFirstAndLastSymbols = string.substr(1, string.length - 2);

  return isPalindrome(stringWithoutFirstAndLastSymbols);
};

export default isPalindrome;

# 2:

const isPalindrome = (str) => {
  let length = str.length,
    center = length % 2 == 0 ? length / 2 : Math.ceil(length / 2) - 1;  

  if (length <= 1) {
    return true;
  } else {
    for (let i = 0; i < center; i++) {
      if (str[i] !== str[length - 1 - i]) {
        return false;
      }
    }   
  }
  return true;
}

export default isPalindrome;

// file: __tests__/isPalindrome.test.js:

import isPalindrome from '../isPalindrome';

test('isPalindrome', () => {
  expect(isPalindrome('a')).toBe(true);
  expect(isPalindrome('aa')).toBe(true);
  expect(isPalindrome('404')).toBe(true);
  expect(isPalindrome('abba')).toBe(true);
  expect(isPalindrome('radar')).toBe(true);
  expect(isPalindrome('absba')).toBe(true);
  expect(isPalindrome('aibohphobia')).toBe(true);

  expect(isPalindrome('abaoba')).toBe(false);
  expect(isPalindrome('aashgkhdj')).toBe(false);
  expect(isPalindrome('palindrome')).toBe(false);
  expect(isPalindrome('aibohapohobia')).toBe(false);
});



>>>>> Параметры по умолчанию <<<<<<< 

// Опишем функцию greeting, которая печатает на экран приветствие:

const greeting = name => console.log(`Hi, ${name}!`);

greeting('John');
// => Hi, John!

// Но что произойдёт, если при вызове функции передать ей меньшее число аргументов, чем у неё установлено параметров? Давайте посмотрим:

greeting();
// => Hi, undefined!

// Правило здесь простое: параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined. Проиллюстрируем это подробнее на примере функции, которая принимает на вход три параметра и распечатывает их значения:

const foo = (a, b, c) => {
  const output = `a - ${a}; b - ${b}, c - ${c}`;
  console.log(output);
};

foo('I', 'am', 'here');
// a - I; b - am, c - here

foo('I', 'am');
// a - I; b - am, c - undefined

foo('I');
// a - I; b - undefined, c - undefined

foo();
// a - undefined; b - undefined, c - undefined

/* 
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.

Допустим, мы хотим, чтобы при вызове функции greeting без параметров, она выводила сообщение Hi, anonymous!.

Тогда мы можем реализовать её следующим образом:
*/

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

// Однако, JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:

const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);

greeting();
// => Hi, anonymous!

//Работает он следующим образом. Если параметр не передан, то подставляется значение по умолчанию (то, что справа от оператора =). Если параметр передан, то переприсваивания не происходит. Параметр будет равен тому значению, которое было фактически передано в функцию.

const pow = (base, exp = 2) => base ** exp;

pow(5); // => 25
pow(5, 2); // => 25
pow(5, 1); // => 5

// Кроме того, в значениях по умолчанию можно использовать идентификаторы:

const f = (x = Math.PI) => {};

// И даже вызовы функций:

const f = (x, y = Math.sqrt(x)) => {};


const getSum = (a = 10, b = 2 * a, c = 3 * b) => a + b + c;
const result = getSum(); // <-> 10 + 20 + 60 => 90
const result = getSum(2); // <-> 2 + 4 + 12 => 18
const result = getSum(2, 3); // <-> 2 + 3 + 9 => 14
const result = getSum(2, 3, 4); // <-> 2 + 3 + 4 => 9


const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`); // интерполяция - работает только со строками в бэктиках.
/*
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования.

Примечание
В этом уроке мы рассмотрели случай, когда в функцию передаётся меньше параметров, чем она ожидает. У вас может возникнуть вопрос, что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?

Ответ: ничего не произойдёт они будут просто проигнорированы.

Дополнительные материалы
Default function parameters https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters


/**
Реализуйте и экспортируйте по умолчанию функцию substr, которая возвращает подстроку из переданной строки. Подстрокой называется любая выбранная часть строки. Например для строки hello можно выделить следующие подстроки: ello, llo, o, el и множество других. Функция принимает на вход три параметра:

Строка.
Начальный индекс. Значение по умолчанию: 0.
Длина подстроки. Значение по умолчанию: длина всей строки.
substr('abba', 0, 1);    // => a
substr('abba', 1, 2);    // => bb
substr('abba', -10, 2);  // => ab
substr('abba', -1, 100); // => abba
substr('abba', -1, -1);  // => a
substr('abba', 1, -10);  // => b
substr('abba', 1, 10);   // => bba
substr('abba', 1, 0);    // => ''
substr('abba', 100, 3);  // => ''
По умолчанию, то есть если не переданы дополнительные параметры, возвращается сама строка:

substr('');     // => ''
substr('abba'); // => abba
У этой функции множество вариантов поведения:

Если переданная длина отрицательная, то внутри она становится единицей
Если переданная длина равна нулю, то возвращается пустая строка
Если конечный индекс (переданная длина + начальный индекс - 1) выходит за границу строки, то берется подстрока от начального индекса до конца строки.

substr('abba', 1, 10);   // => bba
Конечный индекс 1 + 10. Он выходит за границу строки, так как длина строки 4 символа. Поэтому возвращается подстрока, от начального индекса 1 и до конца строки.

Если начальный индекс отрицательный, то внутри он становится нулем

Если начальный индекс выходит за границу слова справа, то всегда возвращается пустая строка

Для реализации этой функции, используйте подход, который называется "нормализация". Он заключается в том, что перед тем как делать вычисления, данные приводятся к виду, с которым удобно работать. Например, длина строки для substr может иметь следующие неудобные значения:

Отрицательное число
Число, выходящее за границу строки
Индекс + Длина выходят за границу строки
В каждой из этих ситуаций длину строки можно изменить на такое значение, которое будет удобно для обработки сразу всех возможных случаев. Если число отрицательное, то длина становится равной единице (из условия), если оно выходит за границу строки, то его нужно сделать равным длине строки. В последнем случае длина должна стать числом Длина Строки - Индекс. После этих манипуляций процесс взятия подстроки становится универсальным и не содержащим условия.
**/


//////// решение !



// __tests__/substr.test.js:

import substr from '../substr';

test('substr', () => {
  expect(substr('')).toEqual('');
  expect(substr('abba', 4, -10)).toEqual('');
  expect(substr('abba')).toEqual('abba');
  expect(substr('abba', 1, 0)).toEqual('');
  expect(substr('abba', 0, 1)).toEqual('a');
  expect(substr('abba', 1, 2)).toEqual('bb');
  expect(substr('abba', -10, 2)).toEqual('ab');
  expect(substr('abba', -1, 100)).toEqual('abba');
  expect(substr('abba', -1, -1)).toEqual('a');
  expect(substr('abba', 1, -10)).toEqual('b');
  expect(substr('abba', 1, 10)).toEqual('bba');
});